/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/howler/dist/howler.js
var require_howler = __commonJS({
  "node_modules/howler/dist/howler.js"(exports) {
    (function() {
      "use strict";
      var HowlerGlobal2 = function() {
        this.init();
      };
      HowlerGlobal2.prototype = {
        /**
         * Initialize the global Howler object.
         * @return {Howler}
         */
        init: function() {
          var self = this || Howler2;
          self._counter = 1e3;
          self._html5AudioPool = [];
          self.html5PoolSize = 10;
          self._codecs = {};
          self._howls = [];
          self._muted = false;
          self._volume = 1;
          self._canPlayEvent = "canplaythrough";
          self._navigator = typeof window !== "undefined" && window.navigator ? window.navigator : null;
          self.masterGain = null;
          self.noAudio = false;
          self.usingWebAudio = true;
          self.autoSuspend = true;
          self.ctx = null;
          self.autoUnlock = true;
          self._setup();
          return self;
        },
        /**
         * Get/set the global volume for all sounds.
         * @param  {Float} vol Volume from 0.0 to 1.0.
         * @return {Howler/Float}     Returns self or current volume.
         */
        volume: function(vol) {
          var self = this || Howler2;
          vol = parseFloat(vol);
          if (!self.ctx) {
            setupAudioContext();
          }
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            self._volume = vol;
            if (self._muted) {
              return self;
            }
            if (self.usingWebAudio) {
              self.masterGain.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
            }
            for (var i = 0; i < self._howls.length; i++) {
              if (!self._howls[i]._webAudio) {
                var ids = self._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self._howls[i]._soundById(ids[j]);
                  if (sound && sound._node) {
                    sound._node.volume = sound._volume * vol;
                  }
                }
              }
            }
            return self;
          }
          return self._volume;
        },
        /**
         * Handle muting and unmuting globally.
         * @param  {Boolean} muted Is muted or not.
         */
        mute: function(muted) {
          var self = this || Howler2;
          if (!self.ctx) {
            setupAudioContext();
          }
          self._muted = muted;
          if (self.usingWebAudio) {
            self.masterGain.gain.setValueAtTime(muted ? 0 : self._volume, Howler2.ctx.currentTime);
          }
          for (var i = 0; i < self._howls.length; i++) {
            if (!self._howls[i]._webAudio) {
              var ids = self._howls[i]._getSoundIds();
              for (var j = 0; j < ids.length; j++) {
                var sound = self._howls[i]._soundById(ids[j]);
                if (sound && sound._node) {
                  sound._node.muted = muted ? true : sound._muted;
                }
              }
            }
          }
          return self;
        },
        /**
         * Handle stopping all sounds globally.
         */
        stop: function() {
          var self = this || Howler2;
          for (var i = 0; i < self._howls.length; i++) {
            self._howls[i].stop();
          }
          return self;
        },
        /**
         * Unload and destroy all currently loaded Howl objects.
         * @return {Howler}
         */
        unload: function() {
          var self = this || Howler2;
          for (var i = self._howls.length - 1; i >= 0; i--) {
            self._howls[i].unload();
          }
          if (self.usingWebAudio && self.ctx && typeof self.ctx.close !== "undefined") {
            self.ctx.close();
            self.ctx = null;
            setupAudioContext();
          }
          return self;
        },
        /**
         * Check for codec support of specific extension.
         * @param  {String} ext Audio file extention.
         * @return {Boolean}
         */
        codecs: function(ext) {
          return (this || Howler2)._codecs[ext.replace(/^x-/, "")];
        },
        /**
         * Setup various state values for global tracking.
         * @return {Howler}
         */
        _setup: function() {
          var self = this || Howler2;
          self.state = self.ctx ? self.ctx.state || "suspended" : "suspended";
          self._autoSuspend();
          if (!self.usingWebAudio) {
            if (typeof Audio !== "undefined") {
              try {
                var test = new Audio();
                if (typeof test.oncanplaythrough === "undefined") {
                  self._canPlayEvent = "canplay";
                }
              } catch (e2) {
                self.noAudio = true;
              }
            } else {
              self.noAudio = true;
            }
          }
          try {
            var test = new Audio();
            if (test.muted) {
              self.noAudio = true;
            }
          } catch (e2) {
          }
          if (!self.noAudio) {
            self._setupCodecs();
          }
          return self;
        },
        /**
         * Check for browser support for various codecs and cache the results.
         * @return {Howler}
         */
        _setupCodecs: function() {
          var self = this || Howler2;
          var audioTest = null;
          try {
            audioTest = typeof Audio !== "undefined" ? new Audio() : null;
          } catch (err) {
            return self;
          }
          if (!audioTest || typeof audioTest.canPlayType !== "function") {
            return self;
          }
          var mpegTest = audioTest.canPlayType("audio/mpeg;").replace(/^no$/, "");
          var ua = self._navigator ? self._navigator.userAgent : "";
          var checkOpera = ua.match(/OPR\/([0-6].)/g);
          var isOldOpera = checkOpera && parseInt(checkOpera[0].split("/")[1], 10) < 33;
          var checkSafari = ua.indexOf("Safari") !== -1 && ua.indexOf("Chrome") === -1;
          var safariVersion = ua.match(/Version\/(.*?) /);
          var isOldSafari = checkSafari && safariVersion && parseInt(safariVersion[1], 10) < 15;
          self._codecs = {
            mp3: !!(!isOldOpera && (mpegTest || audioTest.canPlayType("audio/mp3;").replace(/^no$/, ""))),
            mpeg: !!mpegTest,
            opus: !!audioTest.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, ""),
            ogg: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            oga: !!audioTest.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ""),
            wav: !!(audioTest.canPlayType('audio/wav; codecs="1"') || audioTest.canPlayType("audio/wav")).replace(/^no$/, ""),
            aac: !!audioTest.canPlayType("audio/aac;").replace(/^no$/, ""),
            caf: !!audioTest.canPlayType("audio/x-caf;").replace(/^no$/, ""),
            m4a: !!(audioTest.canPlayType("audio/x-m4a;") || audioTest.canPlayType("audio/m4a;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            m4b: !!(audioTest.canPlayType("audio/x-m4b;") || audioTest.canPlayType("audio/m4b;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            mp4: !!(audioTest.canPlayType("audio/x-mp4;") || audioTest.canPlayType("audio/mp4;") || audioTest.canPlayType("audio/aac;")).replace(/^no$/, ""),
            weba: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            webm: !!(!isOldSafari && audioTest.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, "")),
            dolby: !!audioTest.canPlayType('audio/mp4; codecs="ec-3"').replace(/^no$/, ""),
            flac: !!(audioTest.canPlayType("audio/x-flac;") || audioTest.canPlayType("audio/flac;")).replace(/^no$/, "")
          };
          return self;
        },
        /**
         * Some browsers/devices will only allow audio to be played after a user interaction.
         * Attempt to automatically unlock audio on the first user interaction.
         * Concept from: http://paulbakaus.com/tutorials/html5/web-audio-on-ios/
         * @return {Howler}
         */
        _unlockAudio: function() {
          var self = this || Howler2;
          if (self._audioUnlocked || !self.ctx) {
            return;
          }
          self._audioUnlocked = false;
          self.autoUnlock = false;
          if (!self._mobileUnloaded && self.ctx.sampleRate !== 44100) {
            self._mobileUnloaded = true;
            self.unload();
          }
          self._scratchBuffer = self.ctx.createBuffer(1, 1, 22050);
          var unlock = function(e2) {
            while (self._html5AudioPool.length < self.html5PoolSize) {
              try {
                var audioNode = new Audio();
                audioNode._unlocked = true;
                self._releaseHtml5Audio(audioNode);
              } catch (e3) {
                self.noAudio = true;
                break;
              }
            }
            for (var i = 0; i < self._howls.length; i++) {
              if (!self._howls[i]._webAudio) {
                var ids = self._howls[i]._getSoundIds();
                for (var j = 0; j < ids.length; j++) {
                  var sound = self._howls[i]._soundById(ids[j]);
                  if (sound && sound._node && !sound._node._unlocked) {
                    sound._node._unlocked = true;
                    sound._node.load();
                  }
                }
              }
            }
            self._autoResume();
            var source = self.ctx.createBufferSource();
            source.buffer = self._scratchBuffer;
            source.connect(self.ctx.destination);
            if (typeof source.start === "undefined") {
              source.noteOn(0);
            } else {
              source.start(0);
            }
            if (typeof self.ctx.resume === "function") {
              self.ctx.resume();
            }
            source.onended = function() {
              source.disconnect(0);
              self._audioUnlocked = true;
              document.removeEventListener("touchstart", unlock, true);
              document.removeEventListener("touchend", unlock, true);
              document.removeEventListener("click", unlock, true);
              document.removeEventListener("keydown", unlock, true);
              for (var i2 = 0; i2 < self._howls.length; i2++) {
                self._howls[i2]._emit("unlock");
              }
            };
          };
          document.addEventListener("touchstart", unlock, true);
          document.addEventListener("touchend", unlock, true);
          document.addEventListener("click", unlock, true);
          document.addEventListener("keydown", unlock, true);
          return self;
        },
        /**
         * Get an unlocked HTML5 Audio object from the pool. If none are left,
         * return a new Audio object and throw a warning.
         * @return {Audio} HTML5 Audio object.
         */
        _obtainHtml5Audio: function() {
          var self = this || Howler2;
          if (self._html5AudioPool.length) {
            return self._html5AudioPool.pop();
          }
          var testPlay = new Audio().play();
          if (testPlay && typeof Promise !== "undefined" && (testPlay instanceof Promise || typeof testPlay.then === "function")) {
            testPlay.catch(function() {
              console.warn("HTML5 Audio pool exhausted, returning potentially locked audio object.");
            });
          }
          return new Audio();
        },
        /**
         * Return an activated HTML5 Audio object to the pool.
         * @return {Howler}
         */
        _releaseHtml5Audio: function(audio) {
          var self = this || Howler2;
          if (audio._unlocked) {
            self._html5AudioPool.push(audio);
          }
          return self;
        },
        /**
         * Automatically suspend the Web Audio AudioContext after no sound has played for 30 seconds.
         * This saves processing/energy and fixes various browser-specific bugs with audio getting stuck.
         * @return {Howler}
         */
        _autoSuspend: function() {
          var self = this;
          if (!self.autoSuspend || !self.ctx || typeof self.ctx.suspend === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          for (var i = 0; i < self._howls.length; i++) {
            if (self._howls[i]._webAudio) {
              for (var j = 0; j < self._howls[i]._sounds.length; j++) {
                if (!self._howls[i]._sounds[j]._paused) {
                  return self;
                }
              }
            }
          }
          if (self._suspendTimer) {
            clearTimeout(self._suspendTimer);
          }
          self._suspendTimer = setTimeout(function() {
            if (!self.autoSuspend) {
              return;
            }
            self._suspendTimer = null;
            self.state = "suspending";
            var handleSuspension = function() {
              self.state = "suspended";
              if (self._resumeAfterSuspend) {
                delete self._resumeAfterSuspend;
                self._autoResume();
              }
            };
            self.ctx.suspend().then(handleSuspension, handleSuspension);
          }, 3e4);
          return self;
        },
        /**
         * Automatically resume the Web Audio AudioContext when a new sound is played.
         * @return {Howler}
         */
        _autoResume: function() {
          var self = this;
          if (!self.ctx || typeof self.ctx.resume === "undefined" || !Howler2.usingWebAudio) {
            return;
          }
          if (self.state === "running" && self.ctx.state !== "interrupted" && self._suspendTimer) {
            clearTimeout(self._suspendTimer);
            self._suspendTimer = null;
          } else if (self.state === "suspended" || self.state === "running" && self.ctx.state === "interrupted") {
            self.ctx.resume().then(function() {
              self.state = "running";
              for (var i = 0; i < self._howls.length; i++) {
                self._howls[i]._emit("resume");
              }
            });
            if (self._suspendTimer) {
              clearTimeout(self._suspendTimer);
              self._suspendTimer = null;
            }
          } else if (self.state === "suspending") {
            self._resumeAfterSuspend = true;
          }
          return self;
        }
      };
      var Howler2 = new HowlerGlobal2();
      var Howl4 = function(o) {
        var self = this;
        if (!o.src || o.src.length === 0) {
          console.error("An array of source files must be passed with any new Howl.");
          return;
        }
        self.init(o);
      };
      Howl4.prototype = {
        /**
         * Initialize a new Howl group object.
         * @param  {Object} o Passed in properties for this group.
         * @return {Howl}
         */
        init: function(o) {
          var self = this;
          if (!Howler2.ctx) {
            setupAudioContext();
          }
          self._autoplay = o.autoplay || false;
          self._format = typeof o.format !== "string" ? o.format : [o.format];
          self._html5 = o.html5 || false;
          self._muted = o.mute || false;
          self._loop = o.loop || false;
          self._pool = o.pool || 5;
          self._preload = typeof o.preload === "boolean" || o.preload === "metadata" ? o.preload : true;
          self._rate = o.rate || 1;
          self._sprite = o.sprite || {};
          self._src = typeof o.src !== "string" ? o.src : [o.src];
          self._volume = o.volume !== void 0 ? o.volume : 1;
          self._xhr = {
            method: o.xhr && o.xhr.method ? o.xhr.method : "GET",
            headers: o.xhr && o.xhr.headers ? o.xhr.headers : null,
            withCredentials: o.xhr && o.xhr.withCredentials ? o.xhr.withCredentials : false
          };
          self._duration = 0;
          self._state = "unloaded";
          self._sounds = [];
          self._endTimers = {};
          self._queue = [];
          self._playLock = false;
          self._onend = o.onend ? [{ fn: o.onend }] : [];
          self._onfade = o.onfade ? [{ fn: o.onfade }] : [];
          self._onload = o.onload ? [{ fn: o.onload }] : [];
          self._onloaderror = o.onloaderror ? [{ fn: o.onloaderror }] : [];
          self._onplayerror = o.onplayerror ? [{ fn: o.onplayerror }] : [];
          self._onpause = o.onpause ? [{ fn: o.onpause }] : [];
          self._onplay = o.onplay ? [{ fn: o.onplay }] : [];
          self._onstop = o.onstop ? [{ fn: o.onstop }] : [];
          self._onmute = o.onmute ? [{ fn: o.onmute }] : [];
          self._onvolume = o.onvolume ? [{ fn: o.onvolume }] : [];
          self._onrate = o.onrate ? [{ fn: o.onrate }] : [];
          self._onseek = o.onseek ? [{ fn: o.onseek }] : [];
          self._onunlock = o.onunlock ? [{ fn: o.onunlock }] : [];
          self._onresume = [];
          self._webAudio = Howler2.usingWebAudio && !self._html5;
          if (typeof Howler2.ctx !== "undefined" && Howler2.ctx && Howler2.autoUnlock) {
            Howler2._unlockAudio();
          }
          Howler2._howls.push(self);
          if (self._autoplay) {
            self._queue.push({
              event: "play",
              action: function() {
                self.play();
              }
            });
          }
          if (self._preload && self._preload !== "none") {
            self.load();
          }
          return self;
        },
        /**
         * Load the audio file.
         * @return {Howler}
         */
        load: function() {
          var self = this;
          var url = null;
          if (Howler2.noAudio) {
            self._emit("loaderror", null, "No audio support.");
            return;
          }
          if (typeof self._src === "string") {
            self._src = [self._src];
          }
          for (var i = 0; i < self._src.length; i++) {
            var ext, str;
            if (self._format && self._format[i]) {
              ext = self._format[i];
            } else {
              str = self._src[i];
              if (typeof str !== "string") {
                self._emit("loaderror", null, "Non-string found in selected audio sources - ignoring.");
                continue;
              }
              ext = /^data:audio\/([^;,]+);/i.exec(str);
              if (!ext) {
                ext = /\.([^.]+)$/.exec(str.split("?", 1)[0]);
              }
              if (ext) {
                ext = ext[1].toLowerCase();
              }
            }
            if (!ext) {
              console.warn('No file extension was found. Consider using the "format" property or specify an extension.');
            }
            if (ext && Howler2.codecs(ext)) {
              url = self._src[i];
              break;
            }
          }
          if (!url) {
            self._emit("loaderror", null, "No codec support for selected audio sources.");
            return;
          }
          self._src = url;
          self._state = "loading";
          if (window.location.protocol === "https:" && url.slice(0, 5) === "http:") {
            self._html5 = true;
            self._webAudio = false;
          }
          new Sound2(self);
          if (self._webAudio) {
            loadBuffer(self);
          }
          return self;
        },
        /**
         * Play a sound or resume previous playback.
         * @param  {String/Number} sprite   Sprite name for sprite playback or sound id to continue previous.
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Number}          Sound ID.
         */
        play: function(sprite, internal) {
          var self = this;
          var id = null;
          if (typeof sprite === "number") {
            id = sprite;
            sprite = null;
          } else if (typeof sprite === "string" && self._state === "loaded" && !self._sprite[sprite]) {
            return null;
          } else if (typeof sprite === "undefined") {
            sprite = "__default";
            if (!self._playLock) {
              var num = 0;
              for (var i = 0; i < self._sounds.length; i++) {
                if (self._sounds[i]._paused && !self._sounds[i]._ended) {
                  num++;
                  id = self._sounds[i]._id;
                }
              }
              if (num === 1) {
                sprite = null;
              } else {
                id = null;
              }
            }
          }
          var sound = id ? self._soundById(id) : self._inactiveSound();
          if (!sound) {
            return null;
          }
          if (id && !sprite) {
            sprite = sound._sprite || "__default";
          }
          if (self._state !== "loaded") {
            sound._sprite = sprite;
            sound._ended = false;
            var soundId = sound._id;
            self._queue.push({
              event: "play",
              action: function() {
                self.play(soundId);
              }
            });
            return soundId;
          }
          if (id && !sound._paused) {
            if (!internal) {
              self._loadQueue("play");
            }
            return sound._id;
          }
          if (self._webAudio) {
            Howler2._autoResume();
          }
          var seek = Math.max(0, sound._seek > 0 ? sound._seek : self._sprite[sprite][0] / 1e3);
          var duration = Math.max(0, (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3 - seek);
          var timeout = duration * 1e3 / Math.abs(sound._rate);
          var start = self._sprite[sprite][0] / 1e3;
          var stop = (self._sprite[sprite][0] + self._sprite[sprite][1]) / 1e3;
          sound._sprite = sprite;
          sound._ended = false;
          var setParams = function() {
            sound._paused = false;
            sound._seek = seek;
            sound._start = start;
            sound._stop = stop;
            sound._loop = !!(sound._loop || self._sprite[sprite][2]);
          };
          if (seek >= stop) {
            self._ended(sound);
            return;
          }
          var node = sound._node;
          if (self._webAudio) {
            var playWebAudio = function() {
              self._playLock = false;
              setParams();
              self._refreshBuffer(sound);
              var vol = sound._muted || self._muted ? 0 : sound._volume;
              node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
              sound._playStart = Howler2.ctx.currentTime;
              if (typeof node.bufferSource.start === "undefined") {
                sound._loop ? node.bufferSource.noteGrainOn(0, seek, 86400) : node.bufferSource.noteGrainOn(0, seek, duration);
              } else {
                sound._loop ? node.bufferSource.start(0, seek, 86400) : node.bufferSource.start(0, seek, duration);
              }
              if (timeout !== Infinity) {
                self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
              }
              if (!internal) {
                setTimeout(function() {
                  self._emit("play", sound._id);
                  self._loadQueue();
                }, 0);
              }
            };
            if (Howler2.state === "running" && Howler2.ctx.state !== "interrupted") {
              playWebAudio();
            } else {
              self._playLock = true;
              self.once("resume", playWebAudio);
              self._clearTimer(sound._id);
            }
          } else {
            var playHtml5 = function() {
              node.currentTime = seek;
              node.muted = sound._muted || self._muted || Howler2._muted || node.muted;
              node.volume = sound._volume * Howler2.volume();
              node.playbackRate = sound._rate;
              try {
                var play = node.play();
                if (play && typeof Promise !== "undefined" && (play instanceof Promise || typeof play.then === "function")) {
                  self._playLock = true;
                  setParams();
                  play.then(function() {
                    self._playLock = false;
                    node._unlocked = true;
                    if (!internal) {
                      self._emit("play", sound._id);
                    } else {
                      self._loadQueue();
                    }
                  }).catch(function() {
                    self._playLock = false;
                    self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                    sound._ended = true;
                    sound._paused = true;
                  });
                } else if (!internal) {
                  self._playLock = false;
                  setParams();
                  self._emit("play", sound._id);
                }
                node.playbackRate = sound._rate;
                if (node.paused) {
                  self._emit("playerror", sound._id, "Playback was unable to start. This is most commonly an issue on mobile devices and Chrome where playback was not within a user interaction.");
                  return;
                }
                if (sprite !== "__default" || sound._loop) {
                  self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
                } else {
                  self._endTimers[sound._id] = function() {
                    self._ended(sound);
                    node.removeEventListener("ended", self._endTimers[sound._id], false);
                  };
                  node.addEventListener("ended", self._endTimers[sound._id], false);
                }
              } catch (err) {
                self._emit("playerror", sound._id, err);
              }
            };
            if (node.src === "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA") {
              node.src = self._src;
              node.load();
            }
            var loadedNoReadyState = window && window.ejecta || !node.readyState && Howler2._navigator.isCocoonJS;
            if (node.readyState >= 3 || loadedNoReadyState) {
              playHtml5();
            } else {
              self._playLock = true;
              self._state = "loading";
              var listener = function() {
                self._state = "loaded";
                playHtml5();
                node.removeEventListener(Howler2._canPlayEvent, listener, false);
              };
              node.addEventListener(Howler2._canPlayEvent, listener, false);
              self._clearTimer(sound._id);
            }
          }
          return sound._id;
        },
        /**
         * Pause playback and save current position.
         * @param  {Number} id The sound ID (empty to pause all in group).
         * @return {Howl}
         */
        pause: function(id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "pause",
              action: function() {
                self.pause(id);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self._clearTimer(ids[i]);
            var sound = self._soundById(ids[i]);
            if (sound && !sound._paused) {
              sound._seek = self.seek(ids[i]);
              sound._rateSeek = 0;
              sound._paused = true;
              self._stopFade(ids[i]);
              if (sound._node) {
                if (self._webAudio) {
                  if (!sound._node.bufferSource) {
                    continue;
                  }
                  if (typeof sound._node.bufferSource.stop === "undefined") {
                    sound._node.bufferSource.noteOff(0);
                  } else {
                    sound._node.bufferSource.stop(0);
                  }
                  self._cleanBuffer(sound._node);
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.pause();
                }
              }
            }
            if (!arguments[1]) {
              self._emit("pause", sound ? sound._id : null);
            }
          }
          return self;
        },
        /**
         * Stop playback and reset to start.
         * @param  {Number} id The sound ID (empty to stop all in group).
         * @param  {Boolean} internal Internal Use: true prevents event firing.
         * @return {Howl}
         */
        stop: function(id, internal) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "stop",
              action: function() {
                self.stop(id);
              }
            });
            return self;
          }
          var ids = self._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            self._clearTimer(ids[i]);
            var sound = self._soundById(ids[i]);
            if (sound) {
              sound._seek = sound._start || 0;
              sound._rateSeek = 0;
              sound._paused = true;
              sound._ended = true;
              self._stopFade(ids[i]);
              if (sound._node) {
                if (self._webAudio) {
                  if (sound._node.bufferSource) {
                    if (typeof sound._node.bufferSource.stop === "undefined") {
                      sound._node.bufferSource.noteOff(0);
                    } else {
                      sound._node.bufferSource.stop(0);
                    }
                    self._cleanBuffer(sound._node);
                  }
                } else if (!isNaN(sound._node.duration) || sound._node.duration === Infinity) {
                  sound._node.currentTime = sound._start || 0;
                  sound._node.pause();
                  if (sound._node.duration === Infinity) {
                    self._clearSound(sound._node);
                  }
                }
              }
              if (!internal) {
                self._emit("stop", sound._id);
              }
            }
          }
          return self;
        },
        /**
         * Mute/unmute a single sound or all sounds in this Howl group.
         * @param  {Boolean} muted Set to true to mute and false to unmute.
         * @param  {Number} id    The sound ID to update (omit to mute/unmute all).
         * @return {Howl}
         */
        mute: function(muted, id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "mute",
              action: function() {
                self.mute(muted, id);
              }
            });
            return self;
          }
          if (typeof id === "undefined") {
            if (typeof muted === "boolean") {
              self._muted = muted;
            } else {
              return self._muted;
            }
          }
          var ids = self._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self._soundById(ids[i]);
            if (sound) {
              sound._muted = muted;
              if (sound._interval) {
                self._stopFade(sound._id);
              }
              if (self._webAudio && sound._node) {
                sound._node.gain.setValueAtTime(muted ? 0 : sound._volume, Howler2.ctx.currentTime);
              } else if (sound._node) {
                sound._node.muted = Howler2._muted ? true : muted;
              }
              self._emit("mute", sound._id);
            }
          }
          return self;
        },
        /**
         * Get/set the volume of this sound or of the Howl group. This method can optionally take 0, 1 or 2 arguments.
         *   volume() -> Returns the group's volume value.
         *   volume(id) -> Returns the sound id's current volume.
         *   volume(vol) -> Sets the volume of all sounds in this Howl group.
         *   volume(vol, id) -> Sets the volume of passed sound id.
         * @return {Howl/Number} Returns self or current volume.
         */
        volume: function() {
          var self = this;
          var args = arguments;
          var vol, id;
          if (args.length === 0) {
            return self._volume;
          } else if (args.length === 1 || args.length === 2 && typeof args[1] === "undefined") {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              vol = parseFloat(args[0]);
            }
          } else if (args.length >= 2) {
            vol = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof vol !== "undefined" && vol >= 0 && vol <= 1) {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "volume",
                action: function() {
                  self.volume.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id === "undefined") {
              self._volume = vol;
            }
            id = self._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self._soundById(id[i]);
              if (sound) {
                sound._volume = vol;
                if (!args[2]) {
                  self._stopFade(id[i]);
                }
                if (self._webAudio && sound._node && !sound._muted) {
                  sound._node.gain.setValueAtTime(vol, Howler2.ctx.currentTime);
                } else if (sound._node && !sound._muted) {
                  sound._node.volume = vol * Howler2.volume();
                }
                self._emit("volume", sound._id);
              }
            }
          } else {
            sound = id ? self._soundById(id) : self._sounds[0];
            return sound ? sound._volume : 0;
          }
          return self;
        },
        /**
         * Fade a currently playing sound between two volumes (if no id is passed, all sounds will fade).
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id (omit to fade all sounds).
         * @return {Howl}
         */
        fade: function(from, to, len, id) {
          var self = this;
          if (self._state !== "loaded" || self._playLock) {
            self._queue.push({
              event: "fade",
              action: function() {
                self.fade(from, to, len, id);
              }
            });
            return self;
          }
          from = Math.min(Math.max(0, parseFloat(from)), 1);
          to = Math.min(Math.max(0, parseFloat(to)), 1);
          len = parseFloat(len);
          self.volume(from, id);
          var ids = self._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            var sound = self._soundById(ids[i]);
            if (sound) {
              if (!id) {
                self._stopFade(ids[i]);
              }
              if (self._webAudio && !sound._muted) {
                var currentTime = Howler2.ctx.currentTime;
                var end = currentTime + len / 1e3;
                sound._volume = from;
                sound._node.gain.setValueAtTime(from, currentTime);
                sound._node.gain.linearRampToValueAtTime(to, end);
              }
              self._startFadeInterval(sound, from, to, len, ids[i], typeof id === "undefined");
            }
          }
          return self;
        },
        /**
         * Starts the internal interval to fade a sound.
         * @param  {Object} sound Reference to sound to fade.
         * @param  {Number} from The value to fade from (0.0 to 1.0).
         * @param  {Number} to   The volume to fade to (0.0 to 1.0).
         * @param  {Number} len  Time in milliseconds to fade.
         * @param  {Number} id   The sound id to fade.
         * @param  {Boolean} isGroup   If true, set the volume on the group.
         */
        _startFadeInterval: function(sound, from, to, len, id, isGroup) {
          var self = this;
          var vol = from;
          var diff = to - from;
          var steps = Math.abs(diff / 0.01);
          var stepLen = Math.max(4, steps > 0 ? len / steps : len);
          var lastTick = Date.now();
          sound._fadeTo = to;
          sound._interval = setInterval(function() {
            var tick = (Date.now() - lastTick) / len;
            lastTick = Date.now();
            vol += diff * tick;
            vol = Math.round(vol * 100) / 100;
            if (diff < 0) {
              vol = Math.max(to, vol);
            } else {
              vol = Math.min(to, vol);
            }
            if (self._webAudio) {
              sound._volume = vol;
            } else {
              self.volume(vol, sound._id, true);
            }
            if (isGroup) {
              self._volume = vol;
            }
            if (to < from && vol <= to || to > from && vol >= to) {
              clearInterval(sound._interval);
              sound._interval = null;
              sound._fadeTo = null;
              self.volume(to, sound._id);
              self._emit("fade", sound._id);
            }
          }, stepLen);
        },
        /**
         * Internal method that stops the currently playing fade when
         * a new fade starts, volume is changed or the sound is stopped.
         * @param  {Number} id The sound id.
         * @return {Howl}
         */
        _stopFade: function(id) {
          var self = this;
          var sound = self._soundById(id);
          if (sound && sound._interval) {
            if (self._webAudio) {
              sound._node.gain.cancelScheduledValues(Howler2.ctx.currentTime);
            }
            clearInterval(sound._interval);
            sound._interval = null;
            self.volume(sound._fadeTo, id);
            sound._fadeTo = null;
            self._emit("fade", id);
          }
          return self;
        },
        /**
         * Get/set the loop parameter on a sound. This method can optionally take 0, 1 or 2 arguments.
         *   loop() -> Returns the group's loop value.
         *   loop(id) -> Returns the sound id's loop value.
         *   loop(loop) -> Sets the loop value for all sounds in this Howl group.
         *   loop(loop, id) -> Sets the loop value of passed sound id.
         * @return {Howl/Boolean} Returns self or current loop value.
         */
        loop: function() {
          var self = this;
          var args = arguments;
          var loop, id, sound;
          if (args.length === 0) {
            return self._loop;
          } else if (args.length === 1) {
            if (typeof args[0] === "boolean") {
              loop = args[0];
              self._loop = loop;
            } else {
              sound = self._soundById(parseInt(args[0], 10));
              return sound ? sound._loop : false;
            }
          } else if (args.length === 2) {
            loop = args[0];
            id = parseInt(args[1], 10);
          }
          var ids = self._getSoundIds(id);
          for (var i = 0; i < ids.length; i++) {
            sound = self._soundById(ids[i]);
            if (sound) {
              sound._loop = loop;
              if (self._webAudio && sound._node && sound._node.bufferSource) {
                sound._node.bufferSource.loop = loop;
                if (loop) {
                  sound._node.bufferSource.loopStart = sound._start || 0;
                  sound._node.bufferSource.loopEnd = sound._stop;
                  if (self.playing(ids[i])) {
                    self.pause(ids[i], true);
                    self.play(ids[i], true);
                  }
                }
              }
            }
          }
          return self;
        },
        /**
         * Get/set the playback rate of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   rate() -> Returns the first sound node's current playback rate.
         *   rate(id) -> Returns the sound id's current playback rate.
         *   rate(rate) -> Sets the playback rate of all sounds in this Howl group.
         *   rate(rate, id) -> Sets the playback rate of passed sound id.
         * @return {Howl/Number} Returns self or the current playback rate.
         */
        rate: function() {
          var self = this;
          var args = arguments;
          var rate, id;
          if (args.length === 0) {
            id = self._sounds[0]._id;
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else {
              rate = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            rate = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          var sound;
          if (typeof rate === "number") {
            if (self._state !== "loaded" || self._playLock) {
              self._queue.push({
                event: "rate",
                action: function() {
                  self.rate.apply(self, args);
                }
              });
              return self;
            }
            if (typeof id === "undefined") {
              self._rate = rate;
            }
            id = self._getSoundIds(id);
            for (var i = 0; i < id.length; i++) {
              sound = self._soundById(id[i]);
              if (sound) {
                if (self.playing(id[i])) {
                  sound._rateSeek = self.seek(id[i]);
                  sound._playStart = self._webAudio ? Howler2.ctx.currentTime : sound._playStart;
                }
                sound._rate = rate;
                if (self._webAudio && sound._node && sound._node.bufferSource) {
                  sound._node.bufferSource.playbackRate.setValueAtTime(rate, Howler2.ctx.currentTime);
                } else if (sound._node) {
                  sound._node.playbackRate = rate;
                }
                var seek = self.seek(id[i]);
                var duration = (self._sprite[sound._sprite][0] + self._sprite[sound._sprite][1]) / 1e3 - seek;
                var timeout = duration * 1e3 / Math.abs(sound._rate);
                if (self._endTimers[id[i]] || !sound._paused) {
                  self._clearTimer(id[i]);
                  self._endTimers[id[i]] = setTimeout(self._ended.bind(self, sound), timeout);
                }
                self._emit("rate", sound._id);
              }
            }
          } else {
            sound = self._soundById(id);
            return sound ? sound._rate : self._rate;
          }
          return self;
        },
        /**
         * Get/set the seek position of a sound. This method can optionally take 0, 1 or 2 arguments.
         *   seek() -> Returns the first sound node's current seek position.
         *   seek(id) -> Returns the sound id's current seek position.
         *   seek(seek) -> Sets the seek position of the first sound node.
         *   seek(seek, id) -> Sets the seek position of passed sound id.
         * @return {Howl/Number} Returns self or the current seek position.
         */
        seek: function() {
          var self = this;
          var args = arguments;
          var seek, id;
          if (args.length === 0) {
            if (self._sounds.length) {
              id = self._sounds[0]._id;
            }
          } else if (args.length === 1) {
            var ids = self._getSoundIds();
            var index = ids.indexOf(args[0]);
            if (index >= 0) {
              id = parseInt(args[0], 10);
            } else if (self._sounds.length) {
              id = self._sounds[0]._id;
              seek = parseFloat(args[0]);
            }
          } else if (args.length === 2) {
            seek = parseFloat(args[0]);
            id = parseInt(args[1], 10);
          }
          if (typeof id === "undefined") {
            return 0;
          }
          if (typeof seek === "number" && (self._state !== "loaded" || self._playLock)) {
            self._queue.push({
              event: "seek",
              action: function() {
                self.seek.apply(self, args);
              }
            });
            return self;
          }
          var sound = self._soundById(id);
          if (sound) {
            if (typeof seek === "number" && seek >= 0) {
              var playing = self.playing(id);
              if (playing) {
                self.pause(id, true);
              }
              sound._seek = seek;
              sound._ended = false;
              self._clearTimer(id);
              if (!self._webAudio && sound._node && !isNaN(sound._node.duration)) {
                sound._node.currentTime = seek;
              }
              var seekAndEmit = function() {
                if (playing) {
                  self.play(id, true);
                }
                self._emit("seek", id);
              };
              if (playing && !self._webAudio) {
                var emitSeek = function() {
                  if (!self._playLock) {
                    seekAndEmit();
                  } else {
                    setTimeout(emitSeek, 0);
                  }
                };
                setTimeout(emitSeek, 0);
              } else {
                seekAndEmit();
              }
            } else {
              if (self._webAudio) {
                var realTime = self.playing(id) ? Howler2.ctx.currentTime - sound._playStart : 0;
                var rateSeek = sound._rateSeek ? sound._rateSeek - sound._seek : 0;
                return sound._seek + (rateSeek + realTime * Math.abs(sound._rate));
              } else {
                return sound._node.currentTime;
              }
            }
          }
          return self;
        },
        /**
         * Check if a specific sound is currently playing or not (if id is provided), or check if at least one of the sounds in the group is playing or not.
         * @param  {Number}  id The sound id to check. If none is passed, the whole sound group is checked.
         * @return {Boolean} True if playing and false if not.
         */
        playing: function(id) {
          var self = this;
          if (typeof id === "number") {
            var sound = self._soundById(id);
            return sound ? !sound._paused : false;
          }
          for (var i = 0; i < self._sounds.length; i++) {
            if (!self._sounds[i]._paused) {
              return true;
            }
          }
          return false;
        },
        /**
         * Get the duration of this sound. Passing a sound id will return the sprite duration.
         * @param  {Number} id The sound id to check. If none is passed, return full source duration.
         * @return {Number} Audio duration in seconds.
         */
        duration: function(id) {
          var self = this;
          var duration = self._duration;
          var sound = self._soundById(id);
          if (sound) {
            duration = self._sprite[sound._sprite][1] / 1e3;
          }
          return duration;
        },
        /**
         * Returns the current loaded state of this Howl.
         * @return {String} 'unloaded', 'loading', 'loaded'
         */
        state: function() {
          return this._state;
        },
        /**
         * Unload and destroy the current Howl object.
         * This will immediately stop all sound instances attached to this group.
         */
        unload: function() {
          var self = this;
          var sounds = self._sounds;
          for (var i = 0; i < sounds.length; i++) {
            if (!sounds[i]._paused) {
              self.stop(sounds[i]._id);
            }
            if (!self._webAudio) {
              self._clearSound(sounds[i]._node);
              sounds[i]._node.removeEventListener("error", sounds[i]._errorFn, false);
              sounds[i]._node.removeEventListener(Howler2._canPlayEvent, sounds[i]._loadFn, false);
              sounds[i]._node.removeEventListener("ended", sounds[i]._endFn, false);
              Howler2._releaseHtml5Audio(sounds[i]._node);
            }
            delete sounds[i]._node;
            self._clearTimer(sounds[i]._id);
          }
          var index = Howler2._howls.indexOf(self);
          if (index >= 0) {
            Howler2._howls.splice(index, 1);
          }
          var remCache = true;
          for (i = 0; i < Howler2._howls.length; i++) {
            if (Howler2._howls[i]._src === self._src || self._src.indexOf(Howler2._howls[i]._src) >= 0) {
              remCache = false;
              break;
            }
          }
          if (cache && remCache) {
            delete cache[self._src];
          }
          Howler2.noAudio = false;
          self._state = "unloaded";
          self._sounds = [];
          self = null;
          return null;
        },
        /**
         * Listen to a custom event.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @param  {Number}   once  (INTERNAL) Marks event to fire only once.
         * @return {Howl}
         */
        on: function(event, fn, id, once) {
          var self = this;
          var events = self["_on" + event];
          if (typeof fn === "function") {
            events.push(once ? { id, fn, once } : { id, fn });
          }
          return self;
        },
        /**
         * Remove a custom event. Call without parameters to remove all events.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to remove. Leave empty to remove all.
         * @param  {Number}   id    (optional) Only remove events for this sound.
         * @return {Howl}
         */
        off: function(event, fn, id) {
          var self = this;
          var events = self["_on" + event];
          var i = 0;
          if (typeof fn === "number") {
            id = fn;
            fn = null;
          }
          if (fn || id) {
            for (i = 0; i < events.length; i++) {
              var isId = id === events[i].id;
              if (fn === events[i].fn && isId || !fn && isId) {
                events.splice(i, 1);
                break;
              }
            }
          } else if (event) {
            self["_on" + event] = [];
          } else {
            var keys = Object.keys(self);
            for (i = 0; i < keys.length; i++) {
              if (keys[i].indexOf("_on") === 0 && Array.isArray(self[keys[i]])) {
                self[keys[i]] = [];
              }
            }
          }
          return self;
        },
        /**
         * Listen to a custom event and remove it once fired.
         * @param  {String}   event Event name.
         * @param  {Function} fn    Listener to call.
         * @param  {Number}   id    (optional) Only listen to events for this sound.
         * @return {Howl}
         */
        once: function(event, fn, id) {
          var self = this;
          self.on(event, fn, id, 1);
          return self;
        },
        /**
         * Emit all events of a specific type and pass the sound id.
         * @param  {String} event Event name.
         * @param  {Number} id    Sound ID.
         * @param  {Number} msg   Message to go with event.
         * @return {Howl}
         */
        _emit: function(event, id, msg) {
          var self = this;
          var events = self["_on" + event];
          for (var i = events.length - 1; i >= 0; i--) {
            if (!events[i].id || events[i].id === id || event === "load") {
              setTimeout(function(fn) {
                fn.call(this, id, msg);
              }.bind(self, events[i].fn), 0);
              if (events[i].once) {
                self.off(event, events[i].fn, events[i].id);
              }
            }
          }
          self._loadQueue(event);
          return self;
        },
        /**
         * Queue of actions initiated before the sound has loaded.
         * These will be called in sequence, with the next only firing
         * after the previous has finished executing (even if async like play).
         * @return {Howl}
         */
        _loadQueue: function(event) {
          var self = this;
          if (self._queue.length > 0) {
            var task = self._queue[0];
            if (task.event === event) {
              self._queue.shift();
              self._loadQueue();
            }
            if (!event) {
              task.action();
            }
          }
          return self;
        },
        /**
         * Fired when playback ends at the end of the duration.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _ended: function(sound) {
          var self = this;
          var sprite = sound._sprite;
          if (!self._webAudio && sound._node && !sound._node.paused && !sound._node.ended && sound._node.currentTime < sound._stop) {
            setTimeout(self._ended.bind(self, sound), 100);
            return self;
          }
          var loop = !!(sound._loop || self._sprite[sprite][2]);
          self._emit("end", sound._id);
          if (!self._webAudio && loop) {
            self.stop(sound._id, true).play(sound._id);
          }
          if (self._webAudio && loop) {
            self._emit("play", sound._id);
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            sound._playStart = Howler2.ctx.currentTime;
            var timeout = (sound._stop - sound._start) * 1e3 / Math.abs(sound._rate);
            self._endTimers[sound._id] = setTimeout(self._ended.bind(self, sound), timeout);
          }
          if (self._webAudio && !loop) {
            sound._paused = true;
            sound._ended = true;
            sound._seek = sound._start || 0;
            sound._rateSeek = 0;
            self._clearTimer(sound._id);
            self._cleanBuffer(sound._node);
            Howler2._autoSuspend();
          }
          if (!self._webAudio && !loop) {
            self.stop(sound._id, true);
          }
          return self;
        },
        /**
         * Clear the end timer for a sound playback.
         * @param  {Number} id The sound ID.
         * @return {Howl}
         */
        _clearTimer: function(id) {
          var self = this;
          if (self._endTimers[id]) {
            if (typeof self._endTimers[id] !== "function") {
              clearTimeout(self._endTimers[id]);
            } else {
              var sound = self._soundById(id);
              if (sound && sound._node) {
                sound._node.removeEventListener("ended", self._endTimers[id], false);
              }
            }
            delete self._endTimers[id];
          }
          return self;
        },
        /**
         * Return the sound identified by this ID, or return null.
         * @param  {Number} id Sound ID
         * @return {Object}    Sound object or null.
         */
        _soundById: function(id) {
          var self = this;
          for (var i = 0; i < self._sounds.length; i++) {
            if (id === self._sounds[i]._id) {
              return self._sounds[i];
            }
          }
          return null;
        },
        /**
         * Return an inactive sound from the pool or create a new one.
         * @return {Sound} Sound playback object.
         */
        _inactiveSound: function() {
          var self = this;
          self._drain();
          for (var i = 0; i < self._sounds.length; i++) {
            if (self._sounds[i]._ended) {
              return self._sounds[i].reset();
            }
          }
          return new Sound2(self);
        },
        /**
         * Drain excess inactive sounds from the pool.
         */
        _drain: function() {
          var self = this;
          var limit = self._pool;
          var cnt = 0;
          var i = 0;
          if (self._sounds.length < limit) {
            return;
          }
          for (i = 0; i < self._sounds.length; i++) {
            if (self._sounds[i]._ended) {
              cnt++;
            }
          }
          for (i = self._sounds.length - 1; i >= 0; i--) {
            if (cnt <= limit) {
              return;
            }
            if (self._sounds[i]._ended) {
              if (self._webAudio && self._sounds[i]._node) {
                self._sounds[i]._node.disconnect(0);
              }
              self._sounds.splice(i, 1);
              cnt--;
            }
          }
        },
        /**
         * Get all ID's from the sounds pool.
         * @param  {Number} id Only return one ID if one is passed.
         * @return {Array}    Array of IDs.
         */
        _getSoundIds: function(id) {
          var self = this;
          if (typeof id === "undefined") {
            var ids = [];
            for (var i = 0; i < self._sounds.length; i++) {
              ids.push(self._sounds[i]._id);
            }
            return ids;
          } else {
            return [id];
          }
        },
        /**
         * Load the sound back into the buffer source.
         * @param  {Sound} sound The sound object to work with.
         * @return {Howl}
         */
        _refreshBuffer: function(sound) {
          var self = this;
          sound._node.bufferSource = Howler2.ctx.createBufferSource();
          sound._node.bufferSource.buffer = cache[self._src];
          if (sound._panner) {
            sound._node.bufferSource.connect(sound._panner);
          } else {
            sound._node.bufferSource.connect(sound._node);
          }
          sound._node.bufferSource.loop = sound._loop;
          if (sound._loop) {
            sound._node.bufferSource.loopStart = sound._start || 0;
            sound._node.bufferSource.loopEnd = sound._stop || 0;
          }
          sound._node.bufferSource.playbackRate.setValueAtTime(sound._rate, Howler2.ctx.currentTime);
          return self;
        },
        /**
         * Prevent memory leaks by cleaning up the buffer source after playback.
         * @param  {Object} node Sound's audio node containing the buffer source.
         * @return {Howl}
         */
        _cleanBuffer: function(node) {
          var self = this;
          var isIOS = Howler2._navigator && Howler2._navigator.vendor.indexOf("Apple") >= 0;
          if (Howler2._scratchBuffer && node.bufferSource) {
            node.bufferSource.onended = null;
            node.bufferSource.disconnect(0);
            if (isIOS) {
              try {
                node.bufferSource.buffer = Howler2._scratchBuffer;
              } catch (e2) {
              }
            }
          }
          node.bufferSource = null;
          return self;
        },
        /**
         * Set the source to a 0-second silence to stop any downloading (except in IE).
         * @param  {Object} node Audio node to clear.
         */
        _clearSound: function(node) {
          var checkIE = /MSIE |Trident\//.test(Howler2._navigator && Howler2._navigator.userAgent);
          if (!checkIE) {
            node.src = "data:audio/wav;base64,UklGRigAAABXQVZFZm10IBIAAAABAAEARKwAAIhYAQACABAAAABkYXRhAgAAAAEA";
          }
        }
      };
      var Sound2 = function(howl) {
        this._parent = howl;
        this.init();
      };
      Sound2.prototype = {
        /**
         * Initialize a new Sound object.
         * @return {Sound}
         */
        init: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          parent._sounds.push(self);
          self.create();
          return self;
        },
        /**
         * Create and setup a new sound object, whether HTML5 Audio or Web Audio.
         * @return {Sound}
         */
        create: function() {
          var self = this;
          var parent = self._parent;
          var volume = Howler2._muted || self._muted || self._parent._muted ? 0 : self._volume;
          if (parent._webAudio) {
            self._node = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
            self._node.gain.setValueAtTime(volume, Howler2.ctx.currentTime);
            self._node.paused = true;
            self._node.connect(Howler2.masterGain);
          } else if (!Howler2.noAudio) {
            self._node = Howler2._obtainHtml5Audio();
            self._errorFn = self._errorListener.bind(self);
            self._node.addEventListener("error", self._errorFn, false);
            self._loadFn = self._loadListener.bind(self);
            self._node.addEventListener(Howler2._canPlayEvent, self._loadFn, false);
            self._endFn = self._endListener.bind(self);
            self._node.addEventListener("ended", self._endFn, false);
            self._node.src = parent._src;
            self._node.preload = parent._preload === true ? "auto" : parent._preload;
            self._node.volume = volume * Howler2.volume();
            self._node.load();
          }
          return self;
        },
        /**
         * Reset the parameters of this sound to the original state (for recycle).
         * @return {Sound}
         */
        reset: function() {
          var self = this;
          var parent = self._parent;
          self._muted = parent._muted;
          self._loop = parent._loop;
          self._volume = parent._volume;
          self._rate = parent._rate;
          self._seek = 0;
          self._rateSeek = 0;
          self._paused = true;
          self._ended = true;
          self._sprite = "__default";
          self._id = ++Howler2._counter;
          return self;
        },
        /**
         * HTML5 Audio error listener callback.
         */
        _errorListener: function() {
          var self = this;
          self._parent._emit("loaderror", self._id, self._node.error ? self._node.error.code : 0);
          self._node.removeEventListener("error", self._errorFn, false);
        },
        /**
         * HTML5 Audio canplaythrough listener callback.
         */
        _loadListener: function() {
          var self = this;
          var parent = self._parent;
          parent._duration = Math.ceil(self._node.duration * 10) / 10;
          if (Object.keys(parent._sprite).length === 0) {
            parent._sprite = { __default: [0, parent._duration * 1e3] };
          }
          if (parent._state !== "loaded") {
            parent._state = "loaded";
            parent._emit("load");
            parent._loadQueue();
          }
          self._node.removeEventListener(Howler2._canPlayEvent, self._loadFn, false);
        },
        /**
         * HTML5 Audio ended listener callback.
         */
        _endListener: function() {
          var self = this;
          var parent = self._parent;
          if (parent._duration === Infinity) {
            parent._duration = Math.ceil(self._node.duration * 10) / 10;
            if (parent._sprite.__default[1] === Infinity) {
              parent._sprite.__default[1] = parent._duration * 1e3;
            }
            parent._ended(self);
          }
          self._node.removeEventListener("ended", self._endFn, false);
        }
      };
      var cache = {};
      var loadBuffer = function(self) {
        var url = self._src;
        if (cache[url]) {
          self._duration = cache[url].duration;
          loadSound(self);
          return;
        }
        if (/^data:[^;]+;base64,/.test(url)) {
          var data = atob(url.split(",")[1]);
          var dataView = new Uint8Array(data.length);
          for (var i = 0; i < data.length; ++i) {
            dataView[i] = data.charCodeAt(i);
          }
          decodeAudioData(dataView.buffer, self);
        } else {
          var xhr = new XMLHttpRequest();
          xhr.open(self._xhr.method, url, true);
          xhr.withCredentials = self._xhr.withCredentials;
          xhr.responseType = "arraybuffer";
          if (self._xhr.headers) {
            Object.keys(self._xhr.headers).forEach(function(key) {
              xhr.setRequestHeader(key, self._xhr.headers[key]);
            });
          }
          xhr.onload = function() {
            var code = (xhr.status + "")[0];
            if (code !== "0" && code !== "2" && code !== "3") {
              self._emit("loaderror", null, "Failed loading audio file with status: " + xhr.status + ".");
              return;
            }
            decodeAudioData(xhr.response, self);
          };
          xhr.onerror = function() {
            if (self._webAudio) {
              self._html5 = true;
              self._webAudio = false;
              self._sounds = [];
              delete cache[url];
              self.load();
            }
          };
          safeXhrSend(xhr);
        }
      };
      var safeXhrSend = function(xhr) {
        try {
          xhr.send();
        } catch (e2) {
          xhr.onerror();
        }
      };
      var decodeAudioData = function(arraybuffer, self) {
        var error = function() {
          self._emit("loaderror", null, "Decoding audio data failed.");
        };
        var success = function(buffer) {
          if (buffer && self._sounds.length > 0) {
            cache[self._src] = buffer;
            loadSound(self, buffer);
          } else {
            error();
          }
        };
        if (typeof Promise !== "undefined" && Howler2.ctx.decodeAudioData.length === 1) {
          Howler2.ctx.decodeAudioData(arraybuffer).then(success).catch(error);
        } else {
          Howler2.ctx.decodeAudioData(arraybuffer, success, error);
        }
      };
      var loadSound = function(self, buffer) {
        if (buffer && !self._duration) {
          self._duration = buffer.duration;
        }
        if (Object.keys(self._sprite).length === 0) {
          self._sprite = { __default: [0, self._duration * 1e3] };
        }
        if (self._state !== "loaded") {
          self._state = "loaded";
          self._emit("load");
          self._loadQueue();
        }
      };
      var setupAudioContext = function() {
        if (!Howler2.usingWebAudio) {
          return;
        }
        try {
          if (typeof AudioContext !== "undefined") {
            Howler2.ctx = new AudioContext();
          } else if (typeof webkitAudioContext !== "undefined") {
            Howler2.ctx = new webkitAudioContext();
          } else {
            Howler2.usingWebAudio = false;
          }
        } catch (e2) {
          Howler2.usingWebAudio = false;
        }
        if (!Howler2.ctx) {
          Howler2.usingWebAudio = false;
        }
        var iOS = /iP(hone|od|ad)/.test(Howler2._navigator && Howler2._navigator.platform);
        var appVersion = Howler2._navigator && Howler2._navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
        var version = appVersion ? parseInt(appVersion[1], 10) : null;
        if (iOS && version && version < 9) {
          var safari = /safari/.test(Howler2._navigator && Howler2._navigator.userAgent.toLowerCase());
          if (Howler2._navigator && !safari) {
            Howler2.usingWebAudio = false;
          }
        }
        if (Howler2.usingWebAudio) {
          Howler2.masterGain = typeof Howler2.ctx.createGain === "undefined" ? Howler2.ctx.createGainNode() : Howler2.ctx.createGain();
          Howler2.masterGain.gain.setValueAtTime(Howler2._muted ? 0 : Howler2._volume, Howler2.ctx.currentTime);
          Howler2.masterGain.connect(Howler2.ctx.destination);
        }
        Howler2._setup();
      };
      if (typeof define === "function" && define.amd) {
        define([], function() {
          return {
            Howler: Howler2,
            Howl: Howl4
          };
        });
      }
      if (typeof exports !== "undefined") {
        exports.Howler = Howler2;
        exports.Howl = Howl4;
      }
      if (typeof global !== "undefined") {
        global.HowlerGlobal = HowlerGlobal2;
        global.Howler = Howler2;
        global.Howl = Howl4;
        global.Sound = Sound2;
      } else if (typeof window !== "undefined") {
        window.HowlerGlobal = HowlerGlobal2;
        window.Howler = Howler2;
        window.Howl = Howl4;
        window.Sound = Sound2;
      }
    })();
    (function() {
      "use strict";
      HowlerGlobal.prototype._pos = [0, 0, 0];
      HowlerGlobal.prototype._orientation = [0, 0, -1, 0, 1, 0];
      HowlerGlobal.prototype.stereo = function(pan) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        for (var i = self._howls.length - 1; i >= 0; i--) {
          self._howls[i].stereo(pan);
        }
        return self;
      };
      HowlerGlobal.prototype.pos = function(x, y, z) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        y = typeof y !== "number" ? self._pos[1] : y;
        z = typeof z !== "number" ? self._pos[2] : z;
        if (typeof x === "number") {
          self._pos = [x, y, z];
          if (typeof self.ctx.listener.positionX !== "undefined") {
            self.ctx.listener.positionX.setTargetAtTime(self._pos[0], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionY.setTargetAtTime(self._pos[1], Howler.ctx.currentTime, 0.1);
            self.ctx.listener.positionZ.setTargetAtTime(self._pos[2], Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setPosition(self._pos[0], self._pos[1], self._pos[2]);
          }
        } else {
          return self._pos;
        }
        return self;
      };
      HowlerGlobal.prototype.orientation = function(x, y, z, xUp, yUp, zUp) {
        var self = this;
        if (!self.ctx || !self.ctx.listener) {
          return self;
        }
        var or = self._orientation;
        y = typeof y !== "number" ? or[1] : y;
        z = typeof z !== "number" ? or[2] : z;
        xUp = typeof xUp !== "number" ? or[3] : xUp;
        yUp = typeof yUp !== "number" ? or[4] : yUp;
        zUp = typeof zUp !== "number" ? or[5] : zUp;
        if (typeof x === "number") {
          self._orientation = [x, y, z, xUp, yUp, zUp];
          if (typeof self.ctx.listener.forwardX !== "undefined") {
            self.ctx.listener.forwardX.setTargetAtTime(x, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardY.setTargetAtTime(y, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.forwardZ.setTargetAtTime(z, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upX.setTargetAtTime(xUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upY.setTargetAtTime(yUp, Howler.ctx.currentTime, 0.1);
            self.ctx.listener.upZ.setTargetAtTime(zUp, Howler.ctx.currentTime, 0.1);
          } else {
            self.ctx.listener.setOrientation(x, y, z, xUp, yUp, zUp);
          }
        } else {
          return or;
        }
        return self;
      };
      Howl.prototype.init = function(_super) {
        return function(o) {
          var self = this;
          self._orientation = o.orientation || [1, 0, 0];
          self._stereo = o.stereo || null;
          self._pos = o.pos || null;
          self._pannerAttr = {
            coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : 360,
            coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : 360,
            coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : 0,
            distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : "inverse",
            maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : 1e4,
            panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : "HRTF",
            refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : 1,
            rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : 1
          };
          self._onstereo = o.onstereo ? [{ fn: o.onstereo }] : [];
          self._onpos = o.onpos ? [{ fn: o.onpos }] : [];
          self._onorientation = o.onorientation ? [{ fn: o.onorientation }] : [];
          return _super.call(this, o);
        };
      }(Howl.prototype.init);
      Howl.prototype.stereo = function(pan, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "stereo",
            action: function() {
              self.stereo(pan, id);
            }
          });
          return self;
        }
        var pannerType = typeof Howler.ctx.createStereoPanner === "undefined" ? "spatial" : "stereo";
        if (typeof id === "undefined") {
          if (typeof pan === "number") {
            self._stereo = pan;
            self._pos = [pan, 0, 0];
          } else {
            return self._stereo;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self._soundById(ids[i]);
          if (sound) {
            if (typeof pan === "number") {
              sound._stereo = pan;
              sound._pos = [pan, 0, 0];
              if (sound._node) {
                sound._pannerAttr.panningModel = "equalpower";
                if (!sound._panner || !sound._panner.pan) {
                  setupPanner(sound, pannerType);
                }
                if (pannerType === "spatial") {
                  if (typeof sound._panner.positionX !== "undefined") {
                    sound._panner.positionX.setValueAtTime(pan, Howler.ctx.currentTime);
                    sound._panner.positionY.setValueAtTime(0, Howler.ctx.currentTime);
                    sound._panner.positionZ.setValueAtTime(0, Howler.ctx.currentTime);
                  } else {
                    sound._panner.setPosition(pan, 0, 0);
                  }
                } else {
                  sound._panner.pan.setValueAtTime(pan, Howler.ctx.currentTime);
                }
              }
              self._emit("stereo", sound._id);
            } else {
              return sound._stereo;
            }
          }
        }
        return self;
      };
      Howl.prototype.pos = function(x, y, z, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "pos",
            action: function() {
              self.pos(x, y, z, id);
            }
          });
          return self;
        }
        y = typeof y !== "number" ? 0 : y;
        z = typeof z !== "number" ? -0.5 : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self._pos = [x, y, z];
          } else {
            return self._pos;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._pos = [x, y, z];
              if (sound._node) {
                if (!sound._panner || sound._panner.pan) {
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.positionX !== "undefined") {
                  sound._panner.positionX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.positionY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.positionZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setPosition(x, y, z);
                }
              }
              self._emit("pos", sound._id);
            } else {
              return sound._pos;
            }
          }
        }
        return self;
      };
      Howl.prototype.orientation = function(x, y, z, id) {
        var self = this;
        if (!self._webAudio) {
          return self;
        }
        if (self._state !== "loaded") {
          self._queue.push({
            event: "orientation",
            action: function() {
              self.orientation(x, y, z, id);
            }
          });
          return self;
        }
        y = typeof y !== "number" ? self._orientation[1] : y;
        z = typeof z !== "number" ? self._orientation[2] : z;
        if (typeof id === "undefined") {
          if (typeof x === "number") {
            self._orientation = [x, y, z];
          } else {
            return self._orientation;
          }
        }
        var ids = self._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          var sound = self._soundById(ids[i]);
          if (sound) {
            if (typeof x === "number") {
              sound._orientation = [x, y, z];
              if (sound._node) {
                if (!sound._panner) {
                  if (!sound._pos) {
                    sound._pos = self._pos || [0, 0, -0.5];
                  }
                  setupPanner(sound, "spatial");
                }
                if (typeof sound._panner.orientationX !== "undefined") {
                  sound._panner.orientationX.setValueAtTime(x, Howler.ctx.currentTime);
                  sound._panner.orientationY.setValueAtTime(y, Howler.ctx.currentTime);
                  sound._panner.orientationZ.setValueAtTime(z, Howler.ctx.currentTime);
                } else {
                  sound._panner.setOrientation(x, y, z);
                }
              }
              self._emit("orientation", sound._id);
            } else {
              return sound._orientation;
            }
          }
        }
        return self;
      };
      Howl.prototype.pannerAttr = function() {
        var self = this;
        var args = arguments;
        var o, id, sound;
        if (!self._webAudio) {
          return self;
        }
        if (args.length === 0) {
          return self._pannerAttr;
        } else if (args.length === 1) {
          if (typeof args[0] === "object") {
            o = args[0];
            if (typeof id === "undefined") {
              if (!o.pannerAttr) {
                o.pannerAttr = {
                  coneInnerAngle: o.coneInnerAngle,
                  coneOuterAngle: o.coneOuterAngle,
                  coneOuterGain: o.coneOuterGain,
                  distanceModel: o.distanceModel,
                  maxDistance: o.maxDistance,
                  refDistance: o.refDistance,
                  rolloffFactor: o.rolloffFactor,
                  panningModel: o.panningModel
                };
              }
              self._pannerAttr = {
                coneInnerAngle: typeof o.pannerAttr.coneInnerAngle !== "undefined" ? o.pannerAttr.coneInnerAngle : self._coneInnerAngle,
                coneOuterAngle: typeof o.pannerAttr.coneOuterAngle !== "undefined" ? o.pannerAttr.coneOuterAngle : self._coneOuterAngle,
                coneOuterGain: typeof o.pannerAttr.coneOuterGain !== "undefined" ? o.pannerAttr.coneOuterGain : self._coneOuterGain,
                distanceModel: typeof o.pannerAttr.distanceModel !== "undefined" ? o.pannerAttr.distanceModel : self._distanceModel,
                maxDistance: typeof o.pannerAttr.maxDistance !== "undefined" ? o.pannerAttr.maxDistance : self._maxDistance,
                refDistance: typeof o.pannerAttr.refDistance !== "undefined" ? o.pannerAttr.refDistance : self._refDistance,
                rolloffFactor: typeof o.pannerAttr.rolloffFactor !== "undefined" ? o.pannerAttr.rolloffFactor : self._rolloffFactor,
                panningModel: typeof o.pannerAttr.panningModel !== "undefined" ? o.pannerAttr.panningModel : self._panningModel
              };
            }
          } else {
            sound = self._soundById(parseInt(args[0], 10));
            return sound ? sound._pannerAttr : self._pannerAttr;
          }
        } else if (args.length === 2) {
          o = args[0];
          id = parseInt(args[1], 10);
        }
        var ids = self._getSoundIds(id);
        for (var i = 0; i < ids.length; i++) {
          sound = self._soundById(ids[i]);
          if (sound) {
            var pa = sound._pannerAttr;
            pa = {
              coneInnerAngle: typeof o.coneInnerAngle !== "undefined" ? o.coneInnerAngle : pa.coneInnerAngle,
              coneOuterAngle: typeof o.coneOuterAngle !== "undefined" ? o.coneOuterAngle : pa.coneOuterAngle,
              coneOuterGain: typeof o.coneOuterGain !== "undefined" ? o.coneOuterGain : pa.coneOuterGain,
              distanceModel: typeof o.distanceModel !== "undefined" ? o.distanceModel : pa.distanceModel,
              maxDistance: typeof o.maxDistance !== "undefined" ? o.maxDistance : pa.maxDistance,
              refDistance: typeof o.refDistance !== "undefined" ? o.refDistance : pa.refDistance,
              rolloffFactor: typeof o.rolloffFactor !== "undefined" ? o.rolloffFactor : pa.rolloffFactor,
              panningModel: typeof o.panningModel !== "undefined" ? o.panningModel : pa.panningModel
            };
            var panner = sound._panner;
            if (panner) {
              panner.coneInnerAngle = pa.coneInnerAngle;
              panner.coneOuterAngle = pa.coneOuterAngle;
              panner.coneOuterGain = pa.coneOuterGain;
              panner.distanceModel = pa.distanceModel;
              panner.maxDistance = pa.maxDistance;
              panner.refDistance = pa.refDistance;
              panner.rolloffFactor = pa.rolloffFactor;
              panner.panningModel = pa.panningModel;
            } else {
              if (!sound._pos) {
                sound._pos = self._pos || [0, 0, -0.5];
              }
              setupPanner(sound, "spatial");
            }
          }
        }
        return self;
      };
      Sound.prototype.init = function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          _super.call(this);
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          }
        };
      }(Sound.prototype.init);
      Sound.prototype.reset = function(_super) {
        return function() {
          var self = this;
          var parent = self._parent;
          self._orientation = parent._orientation;
          self._stereo = parent._stereo;
          self._pos = parent._pos;
          self._pannerAttr = parent._pannerAttr;
          if (self._stereo) {
            parent.stereo(self._stereo);
          } else if (self._pos) {
            parent.pos(self._pos[0], self._pos[1], self._pos[2], self._id);
          } else if (self._panner) {
            self._panner.disconnect(0);
            self._panner = void 0;
            parent._refreshBuffer(self);
          }
          return _super.call(this);
        };
      }(Sound.prototype.reset);
      var setupPanner = function(sound, type) {
        type = type || "spatial";
        if (type === "spatial") {
          sound._panner = Howler.ctx.createPanner();
          sound._panner.coneInnerAngle = sound._pannerAttr.coneInnerAngle;
          sound._panner.coneOuterAngle = sound._pannerAttr.coneOuterAngle;
          sound._panner.coneOuterGain = sound._pannerAttr.coneOuterGain;
          sound._panner.distanceModel = sound._pannerAttr.distanceModel;
          sound._panner.maxDistance = sound._pannerAttr.maxDistance;
          sound._panner.refDistance = sound._pannerAttr.refDistance;
          sound._panner.rolloffFactor = sound._pannerAttr.rolloffFactor;
          sound._panner.panningModel = sound._pannerAttr.panningModel;
          if (typeof sound._panner.positionX !== "undefined") {
            sound._panner.positionX.setValueAtTime(sound._pos[0], Howler.ctx.currentTime);
            sound._panner.positionY.setValueAtTime(sound._pos[1], Howler.ctx.currentTime);
            sound._panner.positionZ.setValueAtTime(sound._pos[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setPosition(sound._pos[0], sound._pos[1], sound._pos[2]);
          }
          if (typeof sound._panner.orientationX !== "undefined") {
            sound._panner.orientationX.setValueAtTime(sound._orientation[0], Howler.ctx.currentTime);
            sound._panner.orientationY.setValueAtTime(sound._orientation[1], Howler.ctx.currentTime);
            sound._panner.orientationZ.setValueAtTime(sound._orientation[2], Howler.ctx.currentTime);
          } else {
            sound._panner.setOrientation(sound._orientation[0], sound._orientation[1], sound._orientation[2]);
          }
        } else {
          sound._panner = Howler.ctx.createStereoPanner();
          sound._panner.pan.setValueAtTime(sound._stereo, Howler.ctx.currentTime);
        }
        sound._panner.connect(sound._node);
        if (!sound._paused) {
          sound._parent.pause(sound._id, true).play(sound._id, true);
        }
      };
    })();
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ClickClackPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/keySoundMap.ts
var DEFAULT_MAP = {
  // writing system keys
  KeyA: "key",
  KeyB: "key",
  KeyC: "key",
  KeyD: "key2",
  KeyE: "key2",
  KeyF: "key",
  KeyG: "key2",
  KeyH: "key",
  KeyI: "key",
  KeyJ: "key2",
  KeyK: "key",
  KeyL: "key2",
  KeyM: "key2",
  KeyN: "key2",
  KeyO: "key2",
  KeyP: "key",
  KeyQ: "key2",
  KeyR: "key",
  KeyS: "key2",
  KeyT: "key2",
  KeyU: "key2",
  KeyV: "key2",
  KeyW: "key",
  KeyX: "key2",
  KeyY: "key",
  KeyZ: "key",
  Digit1: "key",
  Digit2: "key",
  Digit3: "key",
  Digit4: "key",
  Digit5: "key",
  Digit6: "key",
  Digit7: "key",
  Digit8: "key",
  Digit9: "key",
  Digit0: "key",
  Backquote: "key",
  Minus: "key",
  Equal: "key",
  BracketLeft: "key",
  BracketRight: "key",
  Quote: "key",
  Semicolon: "key",
  Comma: "key",
  Period: "key",
  Slash: "key",
  IntlYen: "key",
  Backslash: "key",
  IntlBackslash: "key",
  IntlRo: "key",
  // functioanl keys
  Backspace: "delete",
  Tab: "key",
  Capslock: "",
  // 打字机专用声音
  Enter: "enter",
  ShiftLeft: "",
  // 需要加逻辑判断了
  ShiftRight: "",
  ControlLeft: "",
  ControlRight: "",
  MetaLeft: "",
  MetaRight: "",
  AltLeft: "",
  AltRight: "",
  Space: "space",
  ContextMenu: "",
  // code 93, right cmd
  Convert: "",
  NonConvert: "",
  KanaMode: "",
  Lang1: "",
  Lang2: "",
  Lang3: "",
  Lang4: "",
  Lang5: "",
  // control pad
  Insert: "",
  Delete: "delete",
  Help: "",
  Home: "",
  End: "",
  PageUp: "",
  PageDown: "",
  // arrow pad
  ArrowLeft: "",
  ArrowRight: "",
  ArrowUp: "",
  ArrowDown: "",
  // numpad
  // TODO: 回校后用大键盘和 MacOS 键盘调试这个
  Numpad0: "key",
  Numpad1: "key",
  Numpad2: "key",
  Numpad3: "key",
  Numpad4: "key",
  Numpad5: "key",
  Numpad6: "key",
  Numpad7: "key",
  Numpad8: "key",
  Numpad9: "key",
  // check numlock logic
  NumLock: "",
  // something like shift in typewriter
  NumpadDivide: "key",
  NumpadMultiply: "key",
  NumpadSubstract: "key",
  NumpadAdd: "key",
  NumpadComma: "key",
  NumpadEnter: "enter",
  NumpadDecimal: "key",
  NumpadEqual: "key",
  NumpadBackspace: "backspace",
  // function section
  Escape: "",
  F1: "",
  F2: "",
  F3: "",
  F4: "",
  F5: "",
  F6: "",
  F7: "",
  F8: "",
  F9: "",
  F10: "",
  F11: "",
  F12: "",
  Fn: "",
  FnLock: "",
  PrintScreen: "",
  ScrollLock: "",
  Pause: "",
  // media keys
  AudioVolumeUp: "",
  AudioVolumeDown: "",
  AudioVolumnMute: ""
};

// src/settings.ts
var DEFAULT_SETTINGS_V1 = {
  version: "version1",
  enabled: true,
  activeScheme: {
    id: "default",
    caption: "Default",
    sounds: {
      key: "",
      key2: "",
      space: "",
      enter: "",
      delete: ""
    }
  },
  volumn: 100
};

// src/SettingTab.ts
var import_obsidian3 = require("obsidian");

// src/default.ts
var defaultKey = "data:audio/wav;base64,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";
var defaultKey2 = "data:audio/wav;base64,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";
var defaultSpace = "data:audio/wav;base64,UklGRjR3AABXQVZFZm10IBAAAAADAAIARKwAACBiBQAIACAAZmFjdAQAAADEDgAAUEVBSxgAAAABAAAA2aslWlJxij64BgAAUnGKPrgGAABkYXRhIHYAAKD+uDug/rg7wILPO8CCzzvYbqY72G6mO8B2UjrAdlI60M+pu9DPqbugs+G7oLPhu1AnDLtQJwy7YBGFO2ARhTv4dOE7+HThOyAp9DsgKfQ70PQRPND0ETx80QM8fNEDPADNDTsAzQ07gD7WuYA+1rlwCZk7cAmZO8QmCjzEJgo8FJ0DPBSdAzyoZBw8qGQcPDRxXDw0cVw8nDCaPJwwmjzyw9A88sPQPKB+5DygfuQ8GMvAPBjLwDwQ14k8ENeJPKgtMDyoLTA8YO/PO2DvzzuQbIo7kGyKO8DJmTvAyZk7HMYNPBzGDTx4nFU8eJxVPFQRUjxUEVI8JBASPCQQEjzAbZg7wG2YO0C73zpAu986gMq2OoDKtjrwpjI78KYyO8D6eDvA+ng74OKOO+DijjtA6qA7QOqgO/ig6jv4oOo7tOAhPLTgITxAVwg8QFcIPGjyizto8os74EsaO+BLGjtAET66QBE+ujiJ9Ls4ifS71FtOvNRbTrzQ20280NtNvKRWKbykVim8UIwovFCMKLxM4je8TOI3vBSqAbwUqgG8wB3TusAd07ogb/46IG/+OmC64jpguuI6QBXuukAV7rqwo+67sKPuu0zEIrxMxCK8dHgrvHR4K7zkCVq85AlavAYthLwGLYS8iuqFvIrqhbzWvoa81r6GvPTjgLz044C8LPhEvCz4RLyUQxS8lEMUvIjhI7yI4SO8/A9EvPwPRLw0MWO8NDFjvAQ3lrwEN5a8Ek6+vBJOvrymF8q8phfKvLiFxry4hca8qpG3vKqRt7x0rZO8dK2TvEp5gbxKeYG8DCOPvAwjj7wcJoW8HCaFvExMJ7xMTCe8gPRvu4D0b7ugjLE6oIyxOmCBOTtggTk7gAeguYAHoLlwL4i7cC+Iu4ilobuIpaG7QClfu0ApX7twCG+7cAhvu3AU4LtwFOC7WAjzu1gI87uQ2I+7kNiPuwipy7sIqcu7aDJovGgyaLwE0Zq8BNGavJ7Tibye04m85JpUvOSaVLwA1j28ANY9vNzDYLzcw2C82JWLvNiVi7y+BpC8vgaQvJZkkryWZJK8vLfAvLy3wLyIWvm8iFr5vLJvBL2ybwS9JZAFvSWQBb0zFQm9MxUJvZdaA72XWgO9RrT+vEa0/rwVEQi9FREIvd2OC73djgu90O79vNDu/bwuv9y8Lr/cvDgzz7w4M8+8FNjNvBTYzbxsHrK8bB6yvIATebyAE3m8LKw9vCysPbyQRWK8kEVivHKWoLxylqC8trOuvLazrry87zi8vO84vIBktTqAZLU6gDO0OYAztDnkdAi85HQIvHDd+btw3fm7oIy0OqCMtDpcHwk8XB8JPLQKIjy0CiI8+K6jO/iuozuQeG67kHhuu/Dmobvw5qG7uFK0O7hStDsE6Us8BOlLPIBMZDuATGQ7+BEBvPgRAby4UNS7uFDUu8BKCrvASgq72EXbu9hF27voozO86KMzvLBpVbuwaVW7rEYnPKxGJzxkIng8ZCJ4PFCvEDxQrxA84CqmOuAqpjogOBS7IDgUuziDurs4g7q7fMMOvHzDDryIOAa8iDgGvFB46btQeOm7kM33u5DN97toCPK7aAjyuxg8ursYPLq7ANIvuwDSL7swdgG7MHYBu1At6btQLem7VORBvFTkQbwgwxq8IMMavIgenLuIHpy7oM57u6DOe7tYcLO7WHCzu+hh07voYdO7MB+6uzAfursIKo+7CCqPuxC/mrsQv5q7MMb5uzDG+bskayy8JGssvBxEBbwcRAW8AAX2OQAF9jnIT9k7yE/ZO0DcGDtA3Bg7MFPKuzBTyrvof9m76H/ZuwDgnzcA4J830Nh0O9DYdDsgeCU7IHglO4CDvTmAg705oHPMuqBzzLrg/ou64P6LuvBBNjvwQTY7EPkKOxD5CjvYXfu72F37u2S8grxkvIK8NJpbvDSaW7xwXbC7cF2wu4CliTqApYk6GKmeOxipnjswJKU7MCSlOyB0PzsgdD87YGc4O2BnODt4JZY7eCWWOwidrTsIna07WOOjO1jjoztgvqo7YL6qO1hu7TtYbu07UBsWPFAbFjxQJPY7UCT2OzCb6Dswm+g7jKhFPIyoRTxs3mM8bN5jPJxKIzycSiM8+JEkPPiRJDyYW2k8mFtpPARmVjwEZlY8cK27O3CtuzuAZig6gGYoOkDLPTtAyz07ICXEOyAlxDvQNmk70DZpO4Dr0DqA69A6+FiGO/hYhjv4wqo7+MKqO8D1jDvA9Yw78HqxO/B6sTvAcps7wHKbOwA89LoAPPS6wGgIvMBoCLxw9Qa8cPUGvFAgyLtQIMi7tMcUvLTHFLyc42S8nONkvHAtYLxwLWC8jAUrvIwFK7y81BG8vNQRvFxWCbxcVgm8nGYrvJxmK7ygjl68oI5evJhzHryYcx68MPpOuzD6TrtwFnK7cBZyuzjknbs45J27gCeHuoAnh7rgQrE64EKxOgCMH7oAjB+6YMYJvGDGCbxGk6e8RpOnvNjPtLzYz7S8cJAUvHCQFLyAmGu6gJhrunhFjLt4RYy7wP17u8D9e7sw3147MN9eO+DZDDzg2Qw8ePcrPHj3KzzAJ/07wCf9OwBDUDoAQ1A6wOLvusDi77qAtaQ5gLWkOUDZKzpA2Ss6gFhEOoBYRDooy6M7KMujO+AFPTzgBT08yLd+PMi3fjzIBXk8yAV5PKgoMTyoKDE86GmHO+hphzuACok6gAqJOoD/KDuA/yg7IHdHOyB3RztoIpY7aCKWO7g6JDy4OiQ8BElbPARJWzzs71M87O9TPLBAEDywQBA8AA4EuwAOBLsMn0y8DJ9MvNR0TbzUdE28eB63u3get7swNgi7MDYIu9Cc1LvQnNS7MLcmvDC3JrxAOye7QDsnuygbzTsoG807AJRIuACUSLj4lHK8+JRyvFilr7xYpa+83qGJvN6hibzwFUC88BVAvNzpWrzc6Vq8CDhFvAg4RbywItW7sCLVu+CUtrvglLa7AMCjOQDAozncBwQ83AcEPAh4kjsIeJI7MASYOzAEmDsAyEY7AMhGOzz6LLw8+iy8oDs2u6A7NrvcvNY83LzWPKtYbT2rWG09rhyrPa4cqz1aFvU8Whb1PIYmyL2GJsi9Tpcevk6XHr6/0QC+v9EAvuUw6b3lMOm9o8UDvqPFA74twwu+LcMLvgg36b0IN+m9Y5gavWOYGr2mII09piCNPdQULj7UFC4+VVh3PlVYdz5n1H4+Z9R+PqsdLD6rHSw+YvHtPGLx7TwpK2q9KStqvdtdB73bXQe9HOsTvBzrE7yjGFC9oxhQvRt2oL0bdqC9qbFkvamxZL1MKzO8TCszvBv4ED0b+BA9pTJXPaUyVz3a0SU92tElPYXuID2F7iA9KuycPSrsnD2uV+89rlfvPbi8rD24vKw91IvzPNSL8zzeeIA93niAPXDqsz1w6rM9wJfAu8CXwLsQ67O9EOuzvfXuf7317n+9uyodvbsqHb3rupi967qYvYDRs72A0bO9WPX3vFj197wS1Ao9EtQKPQjBbz0IwW89ekypPXpMqT3NCuo9zQrqPerGAD7qxgA+XwISPl8CEj6iYyE+omMhPsgH3z3IB989MtPJPDLTyTwMPUG8DD1BvO5YgrzuWIK8tRqIvbUaiL1G1hu+RtYbvv+qLb7/qi2+RsTKvUbEyr32qDe99qg3vekZWL3pGVi9ubtyvbm7cr33ZwG992cBvXDpobtw6aG7gLWzO4C1sztcj/M8XI/zPIl2kD2JdpA9pvCvPabwrz1rIoQ9ayKEPde0AT3XtAE9QB3pOkAd6TqagJy8moCcvDbLBb02ywW9p9YgvafWIL0oh+q8KIfqvKycDLysnAy8gIZIPICGSDzeKf483in+PN46qjzeOqo8tMwXvLTMF7w0y2G8NMthvBj5GbwY+Rm8jOW6vIzluryQkum8kJLpvNo4s7zaOLO8hIeRvISHkbzMSV68zElevCBehbwgXoW8tiGwvLYhsLyUqii8lKoovBjkijsY5Io7SMDgO0jA4DuAAxg8gAMYPFRHfTxUR308LqKiPC6iojzUusI81LrCPMDf/zzA3/88PYk+PT2JPj3dnYs93Z2LPSLGtD0ixrQ9QLe7PUC3uz0GJII9BiSCPdzIvDzcyLw8UKskO1CrJDu4bsC7uG7Au+6Hlbzuh5W8Et6yvBLesrxwtsq7cLbKu1BGhDxQRoQ8OD3CPDg9wjzoHYQ86B2EPPiEUDz4hFA85KFJPOShSTyoGxU8qBsVPNAccTzQHHE8eNy8PHjcvDwGOrs8Bjq7PCDzmzwg85s8EDXWOxA11jtcyUK8XMlCvMqBirzKgYq8OPNMvDjzTLyoQk28qEJNvAxoJbwMaCW8IFr1OiBa9TpA2U48QNlOPPSRMDz0kTA8AEamuQBGprmecI28nnCNvI5rFb2OaxW99LgsvfS4LL1kbBG9ZGwRvZmyAL2ZsgC9RBnFvEQZxby8oHG8vKBxvByZULwcmVC88OVbu/DlW7vouTs86Lk7PAijaTwIo2k8QFmjPEBZozzfOA093zgNPZRxGj2UcRo9PTEGPT0xBj2UH+o8lB/qPCCClDwggpQ8KG76Oyhu+jvw8vk78PL5OwwcODwMHDg8HL8nPBy/Jzz4YfE7+GHxO4Cv9DuAr/Q7EFrYOxBa2DsgzZw6IM2cOpBaPLuQWjy7+FHru/hR67t4Iny8eCJ8vNyqdLzcqnS8AKveuQCr3rnuC4887guPPD7+AT0+/gE9PjoYPT46GD0u+BY9LvgWPbDQKj2w0Co9+cM2PfnDNj0+rxk9Pq8ZPThZ5zw4Wec8fOiRPHzokTwoKjo8KCo6PJYxoDyWMaA89tvePPbb3jy0q688tKuvPCYRjjwmEY48brqkPG66pDxYSLg8WEi4PNyp2Dzcqdg8YBbhPGAW4TwUf5U8FH+VPExIDzxMSA88wArjO8AK4zugLo87oC6PO0D5dbtA+XW74Cl4vOApeLySIOm8kiDpvAreEr0K3hK9z7cJvc+3Cb1iR/W8Ykf1vPxoqrz8aKq84Ca0uuAmtLqsRRw8rEUcPHBdfztwXX870KsHu9CrB7ugGPS6oBj0uqB5ljqgeZY6wG6iO8BuojvAkrs7wJK7O2jgtDto4LQ7OF/uOzhf7jsQKLA7ECiwO6At/LqgLfy6eIb+u3iG/rsYD/67GA/+u8AvtbvAL7W7iPCcu4jwnLsQiwC7EIsAuwCJPDsAiTw76AaLO+gGizsoG607KButOxBVJzwQVSc8hPxuPIT8bjwWmos8FpqLPPo9tTz6PbU8RkL7PEZC+zxjKxc9YysXPU73ED1O9xA93q32PN6t9jxq++o8avvqPCpVAT0qVQE9Iu0UPSLtFD3URiQ91EYkPaYhFj2mIRY9nuXWPJ7l1jw68Jo8OvCaPOo1pzzqNac8FP3TPBT90zzgDtw84A7cPP7apDz+2qQ80JdKPNCXSjy4oSg8uKEoPJzJNDycyTQ8bH0rPGx9Kzz02Ac89NgHPBitozsYraM7gADaOoAA2jqABpC6gAaQugBVUrkAVVK5aEfgO2hH4DsgAEw8IABMPNiEODzYhDg8FColPBQqJTxwKGk8cChpPLRHvDy0R7w8giz/PIIs/zx40PU8eND1PL44ozy+OKM8EGItPBBiLTzIHcI7yB3CO8Aq5jrAKuY6MA2VuzANlbvIzhe8yM4XvKATKLygEyi86OEpvOjhKbw04yW8NOMlvIzOGLyMzhi8kD/Wu5A/1ruwIjw7sCI8O1SkZzxUpGc8cK2WPHCtljy0OZ08tDmdPMqprzzKqa88TELHPExCxzwE+uc8BPrnPLLt9zyy7fc8aPnoPGj56DyUdPc8lHT3PK2VGD2tlRg99yczPfcnMz3zLkQ98y5EPeaMST3mjEk94DxSPeA8Uj1ImnE9SJpxPWjKgT1oyoE9xat1PcWrdT3WC3M91gtzPTAYdz0wGHc91z1fPdc9Xz0q4Tw9KuE8PX3ZKD192Sg9kgInPZICJz1qNSg9ajUoPaU2Gz2lNhs9yf0OPcn9Dj3Wkfs81pH7PLoAnzy6AJ88CM3oOwjN6DsATZS5AE2UuUATOLpAEzi6wKfmO8Cn5jtMBxw8TAccPHCPWbtwj1m7sgGrvLIBq7wMtAW9DLQFvTF9Br0xfQa9GjadvBo2nby4bda7uG3Wu+TKULzkylC86jr1vOo69bw63RO9Ot0TvXDj8Lxw4/C8BBCDvAQQg7wciTk8HIk5PFJGJD1SRiQ93mMwPd5jMD3S49Y80uPWPJhkGzyYZBs8ME9SOzBPUjsUTWw8FE1sPNRvzjzUb848gHCXPIBwlzzoM1M86DNTPPa9gzz2vYM85OudPOTrnTzA6ug8wOroPPpEFz36RBc961QKPetUCj3WMfY81jH2PGSX4jxkl+I8jGa9PIxmvTxoj9w8aI/cPGJbFj1iWxY9rh4qPa4eKj2m7xc9pu8XPeaTjzzmk488IM+ruyDPq7uY0Nm7mNDZuxx4JTwceCU8jAy1PIwMtTxInXY8SJ12PFho8rtYaPK76prAvOqawLyGmaq8hpmqvMgNbbzIDW28Mn2mvDJ9pryo9v28qPb9vCQX77wkF++8tMV+vLTFfrxwzki7cM5Iu3BMGDxwTBg8aN3IPGjdyDyAGgs9gBoLPfamDz32pg89yQMCPckDAj0Iz+w8CM/sPGiZFD1omRQ9FEFbPRRBWz1lmIU9ZZiFPX3UcT191HE9UPsfPVD7Hz1oWL48aFi+PJQVqTyUFak8rCDEPKwgxDyC3e88gt3vPCOSCz0jkgs9ZUwBPWVMAT0uito8LoraPKoL2jyqC9o8kMrDPJDKwzxMpkg8TKZIPIAf1TmAH9U5gDExOoAxMTpo4w08aOMNPGDceztg3Hs7IHmCvCB5grx2htS8dobUvCZFoLwmRaC8TAiSvEwIkrzqWr+86lq/vLLpi7yy6Yu8QBClOkAQpTpiJ4Q8YieEPNocvzzaHL88VqW3PFaltzz0NjE89DYxPCCgmbogoJm6wLo5usC6ObqQocA7kKHAO0CkwDtApMA7AJJROgCSUTqAsWO6gLFjuoBD9DqAQ/Q6AD2uOwA9rjsgTSo8IE0qPKpomTyqaJk8ghXOPIIVzjz2osE89qLBPHz1eDx89Xg8UD/mO1A/5jsYDsA7GA7AO+SLCTzkiwk8WF+8O1hfvDsAmyA5AJsgOYDGvbmAxr25oEnoOqBJ6DqgXw87oF8POwh7wDsIe8A71iCGPNYghjyyU9w8slPcPKBT5zygU+c8VpyYPFacmDwwnZ07MJ2dOzh8kLs4fJC7wNLnu8DS57tkui28ZLotvEZMo7xGTKO8OhvdvDob3byqM8q8qjPKvIgjnbyII5286IdTvOiHU7wARkK6AEZCupj9MzyY/TM86ERyPOhEcjwc0Ik8HNCJPDiOljw4jpY80J5+PNCefjwEtoE8BLaBPLrGtDy6xrQ8xsG7PMbBuzzckHk83JB5PPxsCDz8bAg8dK8BPHSvATxkOi08ZDotPLA/GDywPxg8oEeQO6BHkDsY7JE7GOyROzDKMjwwyjI8BEuMPARLjDyk9bc8pPW3PILZ6DyC2eg8vED+PLxA/jwAovs8AKL7PPl7BT35ewU9szoPPbM6Dz2UDgk9lA4JPVj26TxY9uk8Eq+xPBKvsTyksFM8pLBTPKDOhDugzoQ7gCiVOYAolTl4pqI7eKaiO4gJRzyICUc8UD9SPFA/UjyYnus7mJ7rO0CtGDtArRg7QM8KO0DPCjtAhoA7QIaAOyDdYTsg3WE7gNcDOoDXAzpAWhW7QFoVu2C3Wrtgt1q78NQcu/DUHLtgr8i6YK/Iuji7hbs4u4W7cOn9u3Dp/btAbs+7QG7Pu6AE3LqgBNy6UDEtu1AxLbtQZB+8UGQfvJSlXbyUpV28CN8rvAjfK7zA6t67wOreu2iCk7togpO7AAxqOgAMajqcfQg8nH0IPBg9VTwYPVU8qJ9+PKiffjy005A8tNOQPABBmzwAQZs8HEmfPBxJnzzkUJg85FCYPAoDiTwKA4k8JOJ+PCTifjzo7WI86O1iPAznOjwM5zo8PKEvPDyhLzyQXhg8kF4YPFCYgztQmIM7AKuWugCrlrpwByi7cAcou0DADbtAwA27UEY3u1BGN7toXr67aF6+u1gAIrxYACK8fIVPvHyFT7xyGIC8chiAvLiLory4i6K8FqusvBarrLzUYZy81GGcvBSvobwUr6G8jDKzvIwys7xAj468QI+OvGiGzbtohs27oBrqOqAa6jrwth078LYdO3DsJDtw7CQ74JmpO+CZqTtYMoY7WDKGO+BZoTrgWaE6gISgO4CEoDv4bBo8+GwaPMBWvjvAVr47gAYkuoAGJLro+Jq76Piau0AsHLxALBy8QEZXvEBGV7x4Fzy8eBc8vEgTGLxIExi8cFBUvHBQVLzG1Zy8xtWcvB6Gnbwehp28cJtlvHCbZbysb1K8rG9SvBD5dbwQ+XW8JEdCvCRHQrzQWAa80FgGvGwDWrxsA1q8zu6cvM7unLwgf5W8IH+VvNBUoLzQVKC8xv24vMb9uLy09Gy8tPRsvFDQJLtQ0CS7AFp1ugBadboAv3a5AL92ubB2xTuwdsU7gBupO4AbqTsAQfe5AEH3uTAQFDswEBQ7kPPjO5Dz4ztYFM07WBTNOxBpyjsQaco7mAOyO5gDsjuAMTu6gDE7ukis6btIrOm78NsavPDbGrzMvga8zL4GvEgxuLtIMbi76POku+jzpLtAxJ67QMSeu/BAj7vwQI+7EOgPvBDoD7yAoka8gKJGvEBlqrtAZaq7YIe2OmCHtjqAF6q5gBequUADfjpAA3460F7wO9Be8DsUFCQ8FBQkPBQKVTwUClU8HFaqPBxWqjxSUs48UlLOPJqWuTyalrk8tJSfPLSUnzzGNJY8xjSWPAr8iDwK/Ig8RNRZPETUWTxIjQs8SI0LPJBqUjuQalI7wPbzusD287roGcK76BnCu2yxALxssQC8hCkGvIQpBrzUaim81GopvKRteLykbXi8HP2WvBz9lrxsjpm8bI6ZvBj1pLwY9aS8PkzCvD5Mwrx8cc28fHHNvDS6rLw0uqy8cHV3vHB1d7ygdGK8oHRivK4ij7yuIo+89P+XvPT/l7z4gmq8+IJqvKxoKrysaCq8vBsPvLwbD7zASqS7wEqku4DYiDmA2Ig5gOriOoDq4joAcG+6AHBvurBAbbuwQG27yDSbu8g0m7tI4Z+7SOGfu0Dok7tA6JO7ALIvuwCyL7vgliI74JYiO5D7EjyQ+xI8EPc2PBD3NjwIEfU7CBH1O0DN5jpAzeY6oO0pu6DtKbuot8e7qLfHu4CRHLyAkRy8FIIlvBSCJbzAJwi8wCcIvHz1Ibx89SG8sOk+vLDpPrwQVuq7EFbqu8AxEbvAMRG7AMpiuQDKYrlQx4E7UMeBOyBrvDsga7w7wMZiOsDGYjqArMS6gKzEunAzTTtwM007gD4OPIA+DjxogRg8aIEYPJBfeDuQX3g7QAL1ukAC9brA2pW7wNqVu3jlB7x45Qe8BA4MvAQODLywTya7sE8mu0BxjLpAcYy6cHaTu3B2k7tgJJK7YCSSu6h7sLuoe7C7kCsUvJArFLxo8Q28aPENvPgIzbv4CM27QKvXu0Cr17ug6h68oOoevGAfbrxgH268JHyGvCR8hrwUpma8FKZmvCzWSbws1km8tPkqvLT5KryI0tu7iNLbu2jwi7to8Iu7IK9MuyCvTLvA/mS7wP5kuyjW/bso1v27jHFDvIxxQ7yMeEq8jHhKvPQoRrz0KEa8uA5OvLgOTrxIzFK8SMxSvBBoUrwQaFK8vPs7vLz7O7ys0S+8rNEvvMwxWrzMMVq83HVlvNx1Zbz0LRa89C0WvLDyp7uw8qe7oFFSu6BRUruQEgM7kBIDOxig1TsYoNU7mMqWO5jKljtA9Go6QPRqOoBU2rqAVNq6cGqKu3Bqirvw85i78POYu4gUtbuIFLW7TIkNvEyJDbwIabK7CGmyuxCsdTsQrHU7nG8LPJxvCzx8f0Q8fH9EPACdmDwAnZg8sj6YPLI+mDxM+Rg8TPkYPAAYg7cAGIO3+NzTu/jc07skITO8JCEzvBz4XLwc+Fy8Bk+FvAZPhbyaRJ+8mkSfvB5Jr7weSa+8eBW4vHgVuLySHaq8kh2qvKQvZrykL2a8qJH6u6iR+rvoJ/276Cf9u7iUJ7y4lCe8VKsgvFSrILyU8iC8lPIgvKj4PLyo+Dy8TC4rvEwuK7yUegG8lHoBvPiKA7z4igO82BcgvNgXILycFDW8nBQ1vIjZObyI2Tm8iLs+vIi7Prz8a0q8/GtKvIytMLyMrTC83FkCvNxZArx47t27eO7duyjalbso2pW7QL0bu0C9G7uAq227gKttu9BIpLvQSKS7kHDVu5Bw1bssoAW8LKAFvJCFeLuQhXi7YMXGOmDFxjogjIs6IIyLOmBKSDtgSkg7OHfbOzh32zugfj87oH4/O4ALOLqACzi6oMT5OqDE+Tqg6Kw6oOisOohRpLuIUaS7LJ8PvCyfD7zoSt+76ErfuwAwnbsAMJ27eH4MvHh+DLySJpC8kiaQvArP67wKz+u8VkQivVZEIr1rOj29azo9vQW1Qb0FtUG9EeY4vRHmOL1xEyS9cRMkvXaD+Lx2g/i8hM6MvITOjLyUgQm8lIEJvNgBALzYAQC8UIvQu1CL0Lvg5wm74OcJu3h9sLt4fbC7PEhNvDxITbywC1u8sAtbvGgcXLxoHFy8DrCRvA6wkbzAA7S8wAO0vPTd07z03dO8SnMCvUpzAr1sbxy9bG8cvYByKr2Aciq9yHwpvch8Kb0H8yG9B/MhvYNwDL2DcAy9Cu/LvArvy7xgoqO8YKKjvJg4pLyYOKS8YE5ivGBOYryAgoW7gIKFu3C8L7twvC+7IDfeuyA33rtk9Q28ZPUNvFCqGrxQqhq8OJ00vDidNLzIUjW8yFI1vGCtzLtgrcy78FgnO/BYJztkwgY8ZMIGPLh0Czy4dAs8AIExPACBMTzK9oE8yvaBPBoehzwaHoc8XKR0PFykdDxYTGM8WExjPJAg8zuQIPM7wPANOsDwDToggSo7IIEqO9BonzvQaJ87AKucOQCrnDkAPSi7AD0ouwDpjLoA6Yy6ALVfugC1X7owMqu7MDKru4gKeryICnq8pgXavKYF2rwJDwm9CQ8JvfBPDr3wTw69x1kAvcdZAL323e+89t3vvGRfB71kXwe9E6YMvROmDL2Qve+8kL3vvCSL3Lwki9y8hqD5vIag+bzEYgu9xGILvQxjBr0MYwa9epngvHqZ4Lwmx8O8JsfDvAjI0rwIyNK89n31vPZ99bwcy/y8HMv8vCAWybwgFsm8WuyZvFrsmbxMPsW8TD7FvNE2Cr3RNgq9eQwVvXkMFb3CzAO9wswDvZbB2byWwdm81gjZvNYI2bx4hQW9eIUFvSIGF70iBhe9s+cevbPnHr1mQi29ZkItvXRELL10RCy9mZ8JvZmfCb0uhbi8LoW4vIiShbyIkoW8yHlOvMh5TrwIBJy7CAScu4DYx7mA2Me56Nm9u+jZvbsQwMy7EMDMuyBq4jogauI6wF/SOsBf0jqojoS7qI6Eu4DI2DmAyNg5COVSPAjlUjyUt6w8lLesPND6pDzQ+qQ8fDCHPHwwhzzwXoA88F6APMDHLjzAxy48gG4hOoBuITogCVe7IAlXu8DvGrvA7xq70J2tu9CdrbtAlN+7QJTfu4ACxbmAAsW5UOO6O1DjujuA65M6gOuTOmTHALxkxwC8RAAYvEQAGLzYhwq82IcKvFDTdbxQ03W8XnmpvF55qby6ZI68umSOvFSxVbxUsVW88C9svPAvbLyERJW8hESVvPwPsLz8D7C87DTKvOw0yrya4eC8muHgvD5w7Lw+cOy8EtnwvBLZ8LwyufS8Mrn0vEyr97xMq/e8QN30vEDd9LyGXfC8hl3wvFx4/rxceP681acMvdWnDL3akg292pINvQRRAr0EUQK9Qi7svEIu7LyeU868nlPOvAavubwGr7m8KmnHvCppx7xCk/G8QpPxvOaTEb3mkxG9ALYevQC2Hr2e1Ry9ntUcvRx+E70cfhO9GknvvBpJ77yUC6S8lAukvMTlf7zE5X+8hJ80vISfNLygYPq6oGD6uhAHZjsQB2Y7oOgiO6DoIjsQTQ+7EE0Pu8go97vIKPe7qIfru6iH67sI+767CPu+u1S8NrxUvDa8rEU3vKxFN7xgXvU6YF71OqDPYDygz2A8gIVaPICFWjxAZsk7QGbJO1B3MDtQdzA70FZNO9BWTTsADlK6AA5SugjdorsI3aK7YEi0umBItLqANz47gDc+OyC2nTsgtp07BDUvPAQ1LzzMfno8zH56PDyfKjw8nyo8QDHVOkAx1TqAy5K6gMuSukAkOTtAJDk7aFXnO2hV5zuQezw8kHs8PMoJljzKCZY8+jmbPPo5mzxwxxY8cMcWPAC4nboAuJ26lBcFvJQXBbzskIK87JCCvH4qvrx+Kr68/lO6vP5Turyo21u8qNtbvGh8xrtofMa7HNQAvBzUALzUEkS81BJEvESFfLxEhXy8mKi2vJiotrzQNu+80DbvvHm0BL15tAS9S0QLvUtEC70QwQi9EMEIvQaT6bwGk+m8wuOrvMLjq7xGdIO8RnSDvCxNkrwsTZK8yFC6vMhQurwwkc28MJHNvB7IyLweyMi8VMK1vFTCtbyk8K28pPCtvN7/xLze/8S8qB/XvKgf17zM3Mu8zNzLvKoQw7yqEMO8jm3MvI5tzLzeFc683hXOvHaht7x2obe88iGVvPIhlbzgb1i84G9YvOgYErzoGBK8TJZBvEyWQbxMfLG8THyxvCif4bwon+G8ErLivBKy4ry4Fe28uBXtvCKD5bwig+W8Bs2gvAbNoLwAGTG8ABkxvCiOHrwojh682IR4vNiEeLz2N8a89jfGvLgVBb24FQW9QEjxvEBI8bx0q2K8dKtivMB51rrAeda6gB/TOoAf0zoYHeI7GB3iOySfiTwkn4k8TJzPPEyczzzsxNc87MTXPAZKhTwGSoU8SAOjO0gDoztgH5o6YB+aOoAr3LqAK9y6aAy6u2gMurs41RW8ONUVvGwnd7xsJ3e8wBuMvMAbjLxMB1O8TAdTvCTfb7wk32+8UG+tvFBvrbz+jZy8/o2cvCDrALwg6wC8sLcnO7C3JzsQfpg7EH6YO6Du/Dqg7vw6AAlbOgAJWzqwNya7sDcmu2xZJLxsWSS8OI2UvDiNlLw+VfO8PlXzvBwsL70cLC+9mFtFvZhbRb043Sy9ON0svXiy27x4stu86Lp6vOi6erwemaO8HpmjvOix6Lzosei8LCjgvCwo4Lyu2r28rtq9vNIpr7zSKa+8PES+vDxEvrzi/9W84v/VvO6nobzup6G8GHPvuxhz77sQo227EKNtuzCmCrwwpgq8lLlwvJS5cLzqE6686hOuvHCU07xwlNO8pmrivKZq4rw5AgK9OQICvcMZH73DGR+9ZtgfvWbYH73k49W85OPVvDRAKLw0QCi8QHNoukBzaLqwf7c7sH+3O1ApLzxQKS88rCQnPKwkJzyAWKU6gFilOgQrfrwEK368tn/5vLZ/+bwx+Am9MfgJvXx42rx8eNq8GBJuvBgSbrxwNK67cDSuu7CNp7uwjae78P12u/D9drtIGtA7SBrQO0Q6YDxEOmA8gIMrPICDKzyg54k7oOeJOyAKfTsgCn07OEMOPDhDDjxskyU8bJMlPKyHBDyshwQ83Ps1PNz7NTy4cYc8uHGHPMSPbzzEj288aAWUO2gFlDtQk8m7UJPJu+j6Ibzo+iG8AI8PvACPD7y8yg68vMoOvADn47sA5+O7QJwKukCcCroAneA7AJ3gO0AUMjxAFDI8IK37OyCt+zsAMB06ADAdOkAMr7pADK+6ANzCOQDcwjkAM6S5ADOkuYDosbqA6LG6gN5BuoDeQboA5JC4AOSQuADI5bkAyOW5oE8Su6BPErvoztG76M7Ru4gEb7yIBG+8nOyuvJzsrrwIgJm8CICZvMg7XLzIO1y8UNdNvFDXTbyQYxa8kGMWvPDSi7vw0ou7oCzBu6Aswbs86hC8POoQvGDyArxg8gK8SN0JvEjdCbyo6yq8qOsqvFCkGLxQpBi86JH1u+iR9bvUFEG81BRBvMo6mrzKOpq8xEmGvMRJhryAXn67gF5+u9gZ+zvYGfs7kGZuPJBmbjwiqJg8IqiYPPjMnzz4zJ885B+UPOQflDw0XlY8NF5WPEDJgTtAyYE7wKNDusCjQ7qAliS6gJYkuqx3BbysdwW8sDydvLA8nbySNaK8kjWivEjVb7xI1W+8tCwAvLQsALxgxuA7YMbgO4bWtjyG1rY8kycCPZMnAj0N9yE9DfchPU2+HD1Nvhw9VhPPPFYTzzwaR448GkeOPE70kTxO9JE8xPyKPMT8ijwYCnk8GAp5PBgbbzwYG288OJyQPDickDy4eMU8uHjFPLKJrzyyia88SJQOPEiUDjygZNI6oGTSOtDVbTvQ1W07IMDwOyDA8DuYmdg7mJnYO4BcKjqAXCo6QNE7ukDRO7rosqE76LKhO7g9wDu4PcA7oOyCuqDsgrp8Zge8fGYHvABXALwAVwC8gExBOoBMQTrQIWc70CFnOxD0QrsQ9EK74IaUu+CGlLvAED26wBA9ukBUgbpAVIG6oDTpu6A06buS85e8kvOXvBLr2rwS69q8MrfCvDK3wrz0np289J6dvFz3q7xc96u8wjzPvMI8z7wI5Oy8COTsvMzp6bzM6em8ile8vIpXvLzin4O84p+DvKhGTryoRk68oOl3vKDpd7xCSY68QkmOvOQkarzkJGq8XNBgvFzQYLxOdpC8TnaQvMybpLzMm6S82qWtvNqlrbw8xZi8PMWYvDyRN7w8kTe8oO94u6DveLvI+6E7yPuhO6y9bjysvW488sSfPPLEnzysUaQ8rFGkPMACbTzAAm08kB6YO5AemDtgEJk6YBCZOkCDADtAgwA7wO0zOsDtMzqAxdI5gMXSOYAdPTqAHT062GSVO9hklTsIBWc8CAVnPEbrhzxG64c8AOU7PADlOzwohTs8KIU7PGCOTTxgjk08cE02PHBNNjzou3U86Lt1PHapuTx2qbk8oGDePKBg3jxc/8E8XP/BPBhfPTwYXz08gKSVuYCklbmIIv27iCL9u0h8cbxIfHG8bFmnvGxZp7yys8q8srPKvNx8xLzcfMS8cAg0vHAINLzgTl874E5fO2jT6zto0+s7KEvJOyhLyTvImZI7yJmSO8CClzvAgpc70NLWO9DS1jugFJm6oBSZugCNibwAjYm8Ii/OvCIvzrxcd8e8XHfHvH7Bnbx+wZ28XAODvFwDg7xksZq8ZLGavGoSqrxqEqq8XoacvF6GnLyaSZi8mkmYvKZzjbymc428AOiCvADogrwkVm+8JFZvvCh5FbwoeRW86Fb2u+hW9rv4E268+BNuvPo9rrz6Pa68OsHNvDrBzbxwcNm8cHDZvF6ly7xepcu8rGHYvKxh2LycX/m8nF/5vHor0Lx6K9C8EH0uvBB9LrzAoQm6wKEJuvA9g7vwPYO7RDMgvEQzILwQgJ+7EICfu5ALQzuQC0M70AByO9AAcjsAbzo6AG86OsAddrvAHXa78MYXvPDGF7yo6j68qOo+vDigQrw4oEK8/MY+vPzGPrwwNwu8MDcLvFCPmrtQj5q7YPjIumD4yLrIjc47yI3OOxodiTwaHYk8Kui6PCroujzKz+Q8ys/kPMWLFz3Fixc9y8YwPcvGMD2ZEB49mRAePX5x4Tx+ceE8fEGSPHxBkjyExh48hMYePAAdJjsAHSY7QAONukADjbq4xqe7uManu3wGHLx8Bhy8MDsEuzA7BLvk4WQ85OFkPKLtkjyi7ZI8RGoqPERqKjx41wk8eNcJPJAGRTyQBkU8hFYXPIRWFzwgkiK7IJIiu9SYbrzUmG68AMqUvADKlLwsMly8LDJcvLCSFrywkha8zOFUvMzhVLyW76C8lu+gvDzgiLw84Ii8oFu6u6BbursAEbM6ABGzOiDXATsg1wE7wLpsusC6bLpIKYe7SCmHu+Byjrrgco660Ix8O9CMfDvAdTS6wHU0ugBq4rsAauK7AM0luwDNJbuQo0k7kKNJOwDvbboA7226rIAPvKyAD7ywVk+8sFZPvIzHLbyMxy28OIqRuziKkbsAd1w5AHdcOcD6GLrA+hi6UKaFu1Cmhbuwck67sHJOuzA1fjswNX47EGr8OxBq/DsQZEM7EGRDO+AtFLvgLRS7AFkFugBZBbro49E76OPRO6RoJjykaCY8iMzHO4jMxzuQL0c7kC9HO5gYCzyYGAs8aACFPGgAhTy6BKA8ugSgPJCthzyQrYc8iCBEPIggRDxY/oE8WP6BPBYAvzwWAL88OFiyPDhYsjxIYo88SGKPPF5vlTxeb5U8xgyaPMYMmjxGyYk8RsmJPBg2PzwYNj88yBDPO8gQzzv8iR88/IkfPIAygzyAMoM8UPt1PFD7dTzE0lY8xNJWPKwTSTysE0k89CYaPPQmGjyI8gY8iPIGPOD6gDvg+oA7yJ+Lu8ifi7vQOIS70DiEu/B0BDvwdAQ7oHBUO6BwVDsAW+c5AFvnOYCxf7qAsX+6ECRJOxAkSTtgw6Y7YMOmOzDVAbsw1QG7WJDmu1iQ5rsA0hq8ANIavEzjjbxM4428HgOgvB4DoLxkakq8ZGpKvFDT3rtQ0967oFA8u6BQPLtgWes6YFnrOhgcwDsYHMA7eMYhPHjGITxYMCI8WDAiPAARGzoAERs6EAw0vBAMNLzYTBq82EwavPDZAbvw2QG7bMANvGzADby6nZC8up2QvBTqfbwU6n28+FZfvPhWX7wg8Da8IPA2vBBoBLwQaAS8HGVivBxlYrxKD4C8Sg+AvEQOCrxEDgq8uPwKvLj8Crw6eoK8OnqCvExDj7xMQ4+8QDfbu0A327twk7o7cJO6O0jeujtI3ro7MEJyOzBCcjvMmi08zJotPLjEmzy4xJs8bvCmPG7wpjxsbQc8bG0HPPCbx7vwm8e7YGoMu2BqDLscPyQ8HD8kPBCFLzwQhS88IBukOyAbpDvYh+s72IfrO/psnTz6bJ081lLmPNZS5jxER8Y8REfGPBBbbzwQW2884IxXPOCMVzyq66M8quujPNAamDzQGpg8yNonPMjaJzzk8Ck85PApPJTBQTyUwUE8EM1cPBDNXDx+/aU8fv2lPLysbDy8rGw8QGyvukBsr7oM6xS8DOsUvIy/SryMv0q8ZJ8gvGSfILzgZVm74GVZu0AMRLtADES7gKjquYCo6rlAYaE7QGGhO6APVDugD1Q7wHwgu8B8ILvwQxu88EMbvJp1gbyadYG8uFWLvLhVi7zkUka85FJGvCg+pLsoPqS7QN5Gu0DeRrvgFhk74BYZO/hdiTz4XYk80BWuPNAVrjzgTFM84ExTPDBALjswQC47QKpBvECqQbyqPru8qj67vD5cqLw+XKi8POBhvDzgYbxY/R28WP0dvED9eLtA/Xi7sIFCO7CBQjugHHc7oBx3OziFjTs4hY074I7/O+CO/zuIM4M7iDODOwAUiboAFIm6wNtAusDbQLpASqU6QEqlOnCq9ztwqvc7oG3vO6Bt7zvILpI7yC6SO4CxgDyAsYA8aM66PGjOujwSWeM8ElnjPMbHEj3GxxI9siatPLImrTxIwvU7SML1O4iQ4zuIkOM7YHzyumB88rooe9c7KHvXO6S0RjyktEY8oBOoOqATqDrS3Yc80t2HPLh2jLy4doy8LlPqvS5T6r1c2+29XNvtvTQXubw0F7m801AyPdNQMj2e5zs9nuc7PbgSEry4EhK8Jvr9vCb6/bzgHuM84B7jPOg+gz3oPoM9Zi2wPWYtsD1CBDI+QgQyPqufdz6rn3c+oR9TPqEfUz4Q4RA+EOEQPrDSDD6w0gw+rWcMPq1nDD5YVNA8WFTQPGYNCL5mDQi+yQFOvskBTr6EFUO+hBVDvkrSAL5K0gC+GFoBPBhaATxuVxY+blcWPgM3Xz4DN18+OBBVPjgQVT5j/Qg+Y/0IPuDkDj3g5A49qm4uvapuLr32Pnu99j57vQlOEb0JThG9pBKJvKQSibzgD8s64A/LOnn7CD15+wg9PI6HPTyOhz2t2PQ9rdj0PWzHED5sxxA+tLt6PbS7ej1Ct9G8QrfRvBBcQb0QXEG9KLRovSi0aL3EpYK9xKWCvZQup72ULqe9Ave+vQL3vr1QiWE7UIlhO3SSDT50kg0+jjkfPo45Hz5KhMc9SoTHPdbXJz3W1yc90IxNvNCMTbza3qS92t6kvQ6sRb4OrEW+UnGKvlJxir4iAXm+IgF5vs1mX77NZl++dnxgvnZ8YL6Agye+gIMnvm5idr1uYna9p+qOPafqjj2gIzY+oCM2Po+8Tj6PvE4+Dbo9Pg26PT5YkA4+WJAOPkVgTz1FYE89BCC1vAQgtbyWCJ+9lgifvWBj0r1gY9K94LObveCzm70wbce9MG3HvaQbC76kGwu+ppiDvaaYg72ib4w8om+MPGhQQjxoUEI8RBsbvEQbG7wSi8q8EovKvAnJC70JyQu96B9zvOgfc7wIots8CKLbPDoqxj06KsY9djwlPnY8JT67My4+uzMuPrwjJz68Iyc+gCUmPoAlJj6wKAA+sCgAPrKHkz2yh5M99qphPfaqYT04b4Y9OG+GPfbajj322o49ZKuSPWSrkj1kVMY9ZFTGPcFcBj7BXAY+yLgIPsi4CD4yg8k9MoPJPb7Maj2+zGo9QsAxPULAMT1z02M9c9NjPdTAaT3UwGk96U43PelONz1ne1Y9Z3tWPbpEaD26RGg9SBGpO0gRqTvnTqq9506qvctmEb7LZhG+JBgKviQYCr5GodC9RqHQvWj+7b1o/u29/1gXvv9YF75q9/u9avf7veINnL3iDZy9MRMcvTETHL1UsBQ8VLAUPAzdtTwM3bU8AB7POQAezzmgY/c6oGP3OgAAdzcAAHc3duHYvHbh2LxwlD69cJQ+vZ2Xnr2dl5695cjvveXI772ZKfy9mSn8vcRE2L3ERNi9/inHvf4px72D38i9g9/IvXJWkb1yVpG9ICvRuyAr0bv0yaE89MmhPKBaD7ygWg+8jD1uPIw9bjzUNeU91DXlPRXVOT4V1Tk+3BA2PtwQNj7ccBo+3HAaPrjaDj642g4+1PgBPtT4AT5GXMw9RlzMPQqbiT0Km4k91lnWPNZZ1jxAXmW7QF5lu0hg7jtIYO474aYQPeGmED1kwYU9ZMGFPYIvyj2CL8o9EqbAPRKmwD2gBmU9oAZlPWbHZj1mx2Y9w2u7PcNruz1m5bQ9ZuW0PWVBGD1lQRg9wK0mO8CtJjsqipI8KoqSPAz+Ej0M/hI9ng/CPJ4PwjwmV4I8JleCPHYArjx2AK48uKVCPLilQjzoOOS76Djku2rd9rxq3fa8cpGJvXKRib2U0bu9lNG7vSBOnb0gTp29smU1vbJlNb2yAZ68sgGevCTcMjwk3DI8vQmAPb0JgD3DPNY9wzzWPYgmtT2IJrU9iZkYPYmZGD2ECqU8hAqlPGx0BT1sdAU9dMnePHTJ3jxqKYo8aimKPGRz8zxkc/M8QD1fPUA9Xz2oP4s9qD+LPff0Tj339E49LgwOPS4MDj2vJag9ryWoPYIiFz6CIhc+Q34aPkN+Gj4DfPA9A3zwPb+Lkz2/i5M9ZMIOPGTCDjz8u+m8/LvpvPRvGL30bxi9arY3vWq2N73IOzS8yDs0vMISRz3CEkc9CMZuPQjGbj3z20s989tLPSbLnD0my5w9qB3GPagdxj2g9aA9oPWgPXK4XD1yuFw99QVJPfUFST3IVmo9yFZqPdSVlj3UlZY9Hr/SPR6/0j2CdPM9gnTzPSpe0j0qXtI9sqOxPbKjsT3MNqE9zDahPZBoij2QaIo9FL2XPRS9lz29Cqg9vQqoPSRKgj0kSoI9XFJIPVxSSD0qKk89KipPPaKsbT2irG090YakPdGGpD0ulNg9LpTYPbkdBD65HQQ+sEAcPrBAHD7+Qg0+/kINPmkesz1pHrM9/IxVPfyMVT2L+Rk9i/kZPdxfJz3cXyc9pGOAPaRjgD2CPqg9gj6oPUpy3D1Kctw9npP9PZ6T/T3aYaA92mGgPfS1pzz0tac8VoQIPVaECD3BWao9wVmqPRBR5z0QUec9X1/3PV9f9z2XDt89lw7fPRR2pz0Udqc98M43PfDONz20Xwa8tF8GvLidcb24nXG9yBeHvcgXh71WUb28VlG9vHrG7jx6xu48HexbPR3sWz2kYDs9pGA7PfZT0Dz2U9A8xFazPMRWszyW9wA9lvcAPZQKuzyUCrs8BKYfPASmHzzYTYo82E2KPARLRTwES0U8kgyjvJIMo7z+CUq9/glKvTTahr002oa9h92IvYfdiL1gAly9YAJcvTO6JL0zuiS9ECtyvBArcryCD648gg+uPC8wID0vMCA9gaI/PYGiPz3ulEI97pRCPcaZ0TzGmdE8wKw9PMCsPTxwNfw7cDX8O54l7ryeJe68jZaKvY2Wir2cvIy9nLyMvYcai72HGou9/giXvf4Il73AK3i9wCt4vVc0BL1XNAS9UGIIPFBiCDwUoTU9FKE1PfmpHj35qR49qIamO6iGpjukrWO8pK1jvMQdMbzEHTG8cNiVu3DYlbsgmXe8IJl3vIqVF72KlRe9PEBEvTxARL29SVG9vUlRvSMuZ70jLme9OCxtvTgsbb0NCGO9DQhjvenJVL3pyVS9d3tYvXd7WL0cIIC9HCCAvV17gr1de4K9WqpBvVqqQb1CoL+8QqC/vBBPADwQTwA86jj2POo49jwwAdc8MAHXPBwBzjwcAc4834MYPd+DGD1StBs9UrQbPRm8Mz0ZvDM9+jyYPfo8mD3VlcM91ZXDPcaloD3GpaA9LU8YPS1PGD0A8Cq4APAquPQWuLz0Fri8+y8RvfsvEb3rnhy9654cvWScMr1knDK9pE+LvaRPi71oW7C9aFuwvTp2z706ds+9sgskvrILJL5jtVu+Y7VbvkMTNb5DEzW+jGGZvYxhmb1qLIw8aiyMPEiWaD1Ilmg9DbsaPQ27Gj1UB448VAeOPF4HuTxeB7k8UE3KO1BNyjvqqv286qr9vCETir0hE4q9xOf+vcTn/r3F/Cq+xfwqvooIAb6KCAG+3nevvN53r7yW23M9lttzPdIiiz3SIos9DWc5PQ1nOT2y9gA9svYAPUADpLpAA6S6dUgDvXVIA72AnMI5gJzCOZ/Uhj2f1IY9NnLfPTZy3z2KfwQ+in8EPg+OCz4Pjgs++usCPvrrAj5g/qU9YP6lPXAIXztwCF87jak5vY2pOb1j04e9Y9OHvQLqu70C6ru9khHAvZIRwL3FYom9xWKJvWhLAb1oSwG9uEAgPLhAIDwgncg8IJ3IPADb7zsA2+87UA2IvFANiLxeNo+9XjaPvU7PDr5Ozw6+s14xvrNeMb4pNDS+KTQ0vtSBGr7UgRq+MoHXvTKB171obre9aG63vWidvb1onb291jiPvdY4j70Coja9AqI2vcn0D73J9A+94uuTvOLrk7yUo4s8lKOLPCprVz0qa1c9+Ol3Pfjpdz0IBUc9CAVHPVNbVT1TW1U9YSmBPWEpgT2kX4M9pF+DPcAeoD3AHqA9gDPBPYAzwT29E3M9vRNzPXADCrxwAwq8zIUEvcyFBL1Y0sa7WNLGu7MCAj2zAgI9qu+jParvoz2YKPc9mCj3PfYO9T32DvU9mm/HPZpvxz1Aup49QLqePe3/iT3t/4k95OSoPeTkqD3Gy649xsuuPbDhJz2w4Sc9UFRRO1BUUTsAbOo5AGzqOZCkPTuQpD07XL+yPFy/sjzw4GI98OBiPWozMz1qMzM9kAgVu5AIFbvsnX487J1+POzwtD3s8LQ95geUPeYHlD1LnDi9S5w4vbKlwr2ypcK9tL3svLS97LwgqGc8IKhnPPUNKr31DSq9CXW+vQl1vr1akaO8WpGjvKu0wz2rtMM9dMCvPXTArz0wmrA8MJqwPLbSgT220oE99kEMPvZBDD7sDQY+7A0GPg5a0T0OWtE9vJu+Pbybvj0qpZc9KqWXPWLiOT1i4jk9lJuAPJSbgDy4TOq7uEzqu4CN2zqAjds68NHQPPDR0Dzo5V086OVdPAANZ7wADWe8UPr0O1D69DstqEU9LahFPbXXAj211wI9iNA0vIjQNLyQW467kFuOu5v5Pj2b+T49tD+uPbQ/rj3aSKc92kinPUxrgD1Ma4A9Vyh/PVcofz0xr309Ma99PT5yED0+chA9AMiMugDIjLp63JC8etyQvIiyGbyIshm8+Mzdu/jM3bt4ZdG8eGXRvNRdBL3UXQS9AD9tvAA/bbyUdl48lHZePGgCUz1oAlM9LFiXPSxYlz1sS4I9bEuCPQVaXj0FWl49MkZXPTJGVz3j7Ss94+0rPfLE/DzyxPw82MVaPNjFWjz6t4i8+reIvKeYHb2nmB29un4gvbp+IL22odW8tqHVvPjfzbz43828L2wpvS9sKb3jHRi94x0YvZwUlbycFJW80p2KvNKdiry4T7q7uE+6u9KctjzSnLY8GvnZPBr52Tz20I089tCNPALOiTwCzok8IAr3OyAK9ztkd0+8ZHdPvJRFz7yURc+8AIPhvACD4bxPGgO9TxoDvVXcJ71V3Ce9TqoavU6qGr0mvNy8JrzcvAxdtbwMXbW8YPw0u2D8NLvajvM82o7zPEXNLj1FzS49j3Y3PY92Nz3RoE890aBPPR6IQz0eiEM9oRhEPaEYRD3Zo4E92aOBPdL0kj3S9JI93op4Pd6KeD0aRig9GkYoPXDi9Dxw4vQ84xMEPeMTBD0OM688DjOvPKD6i7yg+ou8oXs/vaF7P71Y8Uy9WPFMvdmNfL3ZjXy9JFi6vSRYur0eh9O9HofTvbY2tL22NrS9ZOqLvWTqi73gsGO94LBjvQPrLL0D6yy9/hndvP4Z3bwk5M+8JOTPvF2wPL1dsDy9mlOOvZpTjr2Qg5i9kIOYvZ5igb2eYoG9zaRDvc2kQ71kJyO9ZCcjveB7E73gexO9GEiTvBhIk7yAyYo7gMmKO0AAeTpAAHk6HvSgvB70oLzYK/O82CvzvMjV9rzI1fa8RWwevUVsHr3PAGG9zwBhvXkzZL15M2S9Hs3/vB7N/7wgppK7IKaSu9gtsjvYLbI7EAgVOxAIFTuQ89G7kPPRu/5Lj7z+S4+8UXUDvVF1A70askG9GrJBvTUQW701EFu9jnpGvY56Rr2Tlgu9k5YLvc7lgLzO5YC82P2Pu9j9j7sQmwQ8EJsEPBqv9Twar/U8IDINPSAyDT2wTA48sEwOPKgKebyoCnm8QKVsvEClbLwoYpO7KGKTu6RNHbykTR28ovbnvKL257wrkiK9K5IivfFvML3xbzC9WzlbvVs5W73W04i91tOIvQhci70IXIu9kgtmvZILZr3ipTO94qUzvaq2EL2qthC9uKWFvLilhbwoP2o8KD9qPE7kFj1O5BY93jg0Pd44ND1ujjI9bo4yPUIhNz1CITc9sK80PbCvND1wfMM8cHzDPMhCzbvIQs27MByEvDAchLwM7VS8DO1UvBDuK7wQ7iu8YCxTO2AsUzsEgME8BIDBPHUBFD11ARQ9M50hPTOdIT0xJhE9MSYRPX0rET19KxE9V7kiPVe5Ij0kGvk8JBr5PLR7vTy0e708kX0sPZF9LD0zpXs9M6V7PZyDYj2cg2I9pGg7PaRoOz2NQ3E9jUNxPfYfqz32H6s93wW+Pd8Fvj1sz7M9bM+zPQqlsT0KpbE9WJqxPViasT0Ynag9GJ2oPWtJsD1rSbA9mFvXPZhb1z2IJAQ+iCQEPtlNDj7ZTQ4+a4QHPmuEBz7mXwQ+5l8EPuCWBj7glgY+dpn5PXaZ+T3uyNw97sjcPSI+zD0iPsw9So20PUqNtD0DSZo9A0maPVrDkD1aw5A9KGaHPShmhz1vZWU9b2VlPSG5Qz0huUM9aus1PWrrNT1njzM9Z48zPb3eND293jQ93u4iPd7uIj3wgu088ILtPMCSnDzAkpw8fGBuPHxgbjzGZ5U8xmeVPARaCj0EWgo9qLlFPai5RT2VJk49lSZOPalyYz2pcmM9BpyJPQaciT0GnIE9BpyBPfXeOz313js9rq4LPa6uCz0mxNA8JsTQPLBMODywTDg8+GqLu/hqi7tobB+8aGwfvKDK27qgytu6wFxsO8BcbDvoK6G76Cuhu1QdbbxUHW28eJ6ivHieoryo+Ne8qPjXvACQ6rwAkOq8zF8GvcxfBr3VBlK91QZSvXocgr16HIK9p7dZvae3Wb0DiUi9A4lIvabOhr2mzoa9VKiWvVSolr1JKm69SSpuvZLYKL2S2Ci95n0lveZ9Jb2BRVG9gUVRvTCJV70wiVe9p34jvad+I71Grxa9Rq8WvQzDMb0MwzG90XQKvdF0Cr3+ipG8/oqRvLh5jLy4eYy8sNPFvLDTxbx4yhK9eMoSvSdSVb0nUlW9PPdjvTz3Y70nyke9J8pHvet/QL3rf0C99lsyvfZbMr3aAw+92gMPvYL5Ar2C+QK94hHpvOIR6bzAlSm8wJUpvBDeXjwQ3l48xJXVPMSV1Tw2pOk8NqTpPGg75jxoO+Y8pHigPKR4oDz454o7+OeKOxDvnbsQ7527AF1huwBdYbugA6w7oAOsO+ihazzooWs8oE9HPKBPRzxAiaY6QImmOmAJi7tgCYu74Ekdu+BJHbsA1Jk4ANSZOCirg7soq4O78Dh+vPA4frw88MK8PPDCvEiH1bxIh9W8Ii/cvCIv3LwM0Ja8DNCWvACadTkAmnU5rIhBPKyIQTx4Uv07eFL9OyBTLbsgUy27YIZwu2CGcLvgHec74B3nO6xvOjysbzo8uBefO7gXnzsITew7CE3sO5YarTyWGq08kMP1PJDD9Tz+SwQ9/ksEPTe+FT03vhU92nwfPdp8Hz1daQc9XWkHPWYb4DxmG+A8SB/yPEgf8jyy2AA9stgAPYSo6zyEqOs8+uvVPPrr1TwQrbA8EK2wPLoshDy6LIQ8sKR4PLCkeDywR4A8sEeAPPS7gjz0u4I84LiLPOC4izzer4g83q+IPELqhzxC6oc8NNpRPDTaUTwgBtq6IAbauuTIiLzkyIi83Ma5vNzGubxuu728bru9vA4jnbwOI528PNZHvDzWR7zA6lS7wOpUuxDPDzwQzw88ZNVvPGTVbzykcjg8pHI4PPBhCjzwYQo8sMHCO7DBwjuAD0E7gA9BO1AtAztQLQM7SIKBu0iCgbucByu8nAcrvMi9+LvIvfi74AbAu+AGwLsoN+W7KDflu+AZPTvgGT07BMuVPATLlTyg8sY8oPLGPFourzxaLq88uLyfPLi8nzzuvrw87r68PAo/1DwKP9Q8fsPqPH7D6jx2RSQ9dkUkPUugXz1LoF890uOFPdLjhT0G8p09BvKdPeySrT3skq09hgSuPYYErj2KVLE9ilSxPVDaqz1Q2qs9PhmQPT4ZkD1im3w9Ypt8PSGwhj0hsIY9OnCNPTpwjT2IAH49iAB+PeLXTT3i1009Nyg7PTcoOz0T9kU9E/ZFPcYZMz3GGTM9dnoCPXZ6Aj2sV/Q8rFf0PO+YCz3vmAs95JvDPOSbwzyoXIM7qFyDO0hSk7tIUpO7gAZWu4AGVrsgzg+7IM4Pu/C4aDvwuGg7wDJUPMAyVDyeUIo8nlCKPAwTpzwME6c8Ng/1PDYP9TwYgxg9GIMYPSUxFD0lMRQ9yof4PMqH+DxWacY8VmnGPH4Yszx+GLM8PivJPD4ryTwaaek8GmnpPDL4AD0y+AA9HRINPR0SDT0zWhU9M1oVPTdIHT03SB09OJQ3PTiUNz3TfGM903xjPbh8gj24fII9bMuDPWzLgz05aXQ9OWl0PfYxZj32MWY9iLhjPYi4Yz1nE1w9ZxNcPYjYUD2I2FA9cTxMPXE8TD0KN0g9CjdIPQj0Tz0I9E89otdrPaLXaz2MzXk9jM15PWuybT1rsm09JKdlPSSnZT0Sbl89Em5fPa7IQT2uyEE9KyQZPSskGT3pmQE96ZkBPSCW6Twgluk8PpG5PD6RuTxAx448QMeOPP6jkTz+o5E88qOKPPKjijycyCI8nMgiPJAqbjuQKm47QJLkukCS5LrgIV284CFdvKoSzryqEs68GAW/vBgFv7yg+zy8oPs8vHA/LrtwPy67UHEYO1BxGDs4rek7OK3pOwRkCzwEZAs8gFTPO4BUzztgO647YDuuO1D9eztQ/Xs7UBFtu1ARbbt4XI+8eFyPvD6F/bw+hf287yMUve8jFL0czwy9HM8MveiC/bzogv28jsnTvI7J07yEa528hGudvMjTfLzI03y8QA+cvEAPnLygZu68oGbuvEYwEb1GMBG9r/gCva/4Ar2KnOi8ipzovPUYC731GAu9lIwqvZSMKr2Ojx+9jo8fvfTQ9bz00PW8xCX6vMQl+rxHjAq9R4wKvR6Ltbwei7W8MFkvvDBZL7zEGJC8xBiQvLDFxLywxcS8gMaFvIDGhbw4qvC7OKrwu4BemrqAXpq6cEMhPHBDITwiQMo8IkDKPIz+7TyM/u08PNAzPDzQMzy4Dl68uA5evHwSrbx8Eq28nkGnvJ5Bp7yE6NK8hOjSvKby6bym8um8ImzTvCJs07zEmOW8xJjlvHCEFL1whBS92kMxvdpDMb3Xwjy918I8vfWzOr31szq9k6QlvZOkJb00CO+8NAjvvDyWobw8lqG8aE+jvGhPo7yi8K68ovCuvGjJdbxoyXW8yFgHvMhYB7wwgvO7MILzuyh+wbsofsG7oALIuqACyLqQozO7kKMzu3jvDrx47w68QGX4u0Bl+LsAkSy5AJEsuXCBfztwgX87yNYXPMjWFzwogaE8KIGhPI4uqDyOLqg82KnuO9ip7jsAvuC5AL7guRiL3TsYi907vDmJPLw5iTwSA8U8EgPFPLEKDD2xCgw9j/80PY//ND0PuDo9D7g6Pb/oID2/6CA94ywDPeMsAz3qjtE86o7RPDiklTw4pJU8aHhaPGh4WjxY8GA8WPBgPHAqTTxwKk08kAcCPJAHAjxItjo8SLY6PEwtszxMLbM8CrTMPAq0zDzu7qo87u6qPNKFnDzShZw89nCxPPZwsTyGcss8hnLLPMKhwjzCocI8/ja0PP42tDyI+dk8iPnZPMAh7DzAIew8Dli5PA5YuTwId6E8CHehPBiQpTwYkKU8ZgGBPGYBgTwUP1s8FD9bPIicgjyInII8oHR5PKB0eTxYHDg8WBw4PBB5wDsQecA7IFuIOiBbiDrw6Y878OmPO3SlRjx0pUY83MZSPNzGUjxYkyE8WJMhPBTBCTwUwQk8wIUWO8CFFjs8Eki8PBJIvBZx+LwWcfi8VJQyvVSUMr3obzy96G88vSHIJr0hyCa9TPT+vEz0/rwECXW8BAl1vGDOtDpgzrQ6iNHnO4jR5zugWJU7oFiVO0DWdzpA1nc6cF8du3BfHbtwC5W7cAuVu7BCx7uwQse7vEIivLxCIry2ZYC8tmWAvBT/m7wU/5u85CFvvOQhb7wgc0q7IHNKu3TaGTx02hk8bOTDPGzkwzwQeyc9EHsnPbubRz27m0c9qzoyPas6Mj2MVhU9jFYVPbwxBT28MQU9diXfPHYl3zyiZKc8omSnPHxNlTx8TZU8ziy8PM4svDzk+tA85PrQPDxppzw8aac8QvyOPEL8jjzII4s8yCOLPEScBzxEnAc8wImNOsCJjTr4zQc8+M0HPDjpYTw46WE8KGTKOyhkyjsQ5ks7EOZLO3A7ODxwOzg8YA9OPGAPTjwQ6Ec7EOhHOwCQy7gAkMu4EPDdOxDw3TtYVN87WFTfO8hdrLvIXay7EEF5vBBBebyOLI28jiyNvKbqorym6qK87mbNvO5mzbxgANC8YADQvETCk7xEwpO8HMMYvBzDGLzwU8278FPNu6iIBryoiAa8JD5VvCQ+Vbzs5Ka87OSmvOz0wrzs9MK8MHysvDB8rLz6t7C8+rewvLauzby2rs28Tha5vE4Wubz4B4e8+AeHvKgGTryoBk68BHZGvAR2RrzUTnO81E5zvNT/YLzU/2C82Mbvu9jG77tQz7K7UM+yu6DIdbugyHW7IEnmOyBJ5jtgik48YIpOPLDxBjuw8QY7VIgMvFSIDLx4fdO7eH3TuwC8rzkAvK85AB4WOgAeFjogqoS7IKqEuwClmLkApZi5gmmCPIJpgjw6Tec8Ok3nPPqMzzz6jM887qSRPO6kkTw4mIA8OJiAPNSjejzUo3o8oBlPPKAZTzw4Ghw8OBocPBDf2DsQ39g7IIsROyCLETuQCUW7kAlFu2iFmLtohZi7gLHduYCx3bkQY7c7EGO3O6hX/DuoV/w7OIyHOziMhzugjBi7oIwYu7yrAry8qwK8IBlRvCAZUbzw6pW88OqVvHyZwrx8mcK8bqfdvG6n3byosNG8qLDRvLA/nLywP5y8QKdmvECnZrxyP4y8cj+MvLpFzLy6Rcy8wOTovMDk6LxyLb+8ci2/vOz9Xrzs/V68oFCHu6BQh7uwpWE7sKVhO6iOyTuojsk7YF4eO2BeHjuwTG67sExuu5hzCLyYcwi8dP85vHT/ObxQwFa8UMBWvGR4Q7xkeEO8GO6UuxjulLswbUU7MG1FOwAgjjkAII452Omyu9jpsrvgute64LrXutj6qjvY+qo7KCSROygkkTuwSTe7sEk3u4DhGryA4Rq8PKBPvDygT7wcCpu8HAqbvHDV3Lxw1dy8ivG4vIrxuLxkpT68ZKU+vLwSTby8Ek28qJeUvKiXlLyWE5a8lhOWvCqGvbwqhr28N9gMvTfYDL2mBh+9pgYfvUDo77xA6O+8xB1OvMQdTrzwS2u78Etru+CEe7vghHu7gPkRuoD5EbogomU7IKJlO1C5DrtQuQ67EFYuvBBWLrzeZ4O83meDvJjtt7yY7be8rKDAvKygwLwod2q8KHdqvCR5BbwkeQW8DBRFvAwURbzUyIG81MiBvKzQlLys0JS8CFvVvAhb1bzYqwC92KsAvfZzvrz2c768YCMPvGAjD7wgOYg6IDmIOiihjzsooY87IDJiOyAyYjvQqQw70KkMO0CKZDpAimQ6QLOUu0CzlLsAVjG8AFYxvDADP7wwAz+8rMorvKzKK7wAPUW8AD1FvGxJO7xsSTu8gN7OuYDezrkmL5Y8Ji+WPMxo+jzMaPo81K4GPdSuBj2ZAhM9mQITPWJfIj1iXyI9SbcVPUm3FT2A8u08gPLtPHazojx2s6I8vPYkPLz2JDzEwxw8xMMcPJTvrDyU76w8GnfyPBp38jwExuQ8BMbkPDCF8jwwhfI8PJohPTyaIT26zyM9us8jPRr+1Dwa/tQ8/DCBPPwwgTxg6U08YOlNPNDZXzvQ2V876Kmqu+ipqrsAYA83AGAPNxSgOjwUoDo8qhWHPKoVhzyEOXY8hDl2PHgNJjx4DSY8wLJnOsCyZzog6Ea8IOhGvFxYqLxcWKi8mlWqvJpVqrwC2b+8Atm/vEyAAr1MgAK9nf4SvZ3+Er2brgS9m64EvdLb0LzS29C8Fk+VvBZPlbzkU2285FNtvFTMcLxUzHC8sAyZvLAMmbxG2tO8RtrTvLSv0by0r9G8VNCKvFTQiryo+JK8qPiSvO6f6rzun+q8xP4AvcT+AL3Is9+8yLPfvDA0y7wwNMu8MuSovDLkqLwQuTW8ELk1vMB3yDrAd8g6BIRXPASEVzywGqI8sBqiPNZknzzWZJ887LlRPOy5UTwYvtc7GL7XO6Bqzjugas478Ha2O/B2tjtQ/3g7UP94Oxy/NDwcvzQ8jFS2PIxUtjwQPto8ED7aPBge8DwYHvA8+kAKPfpACj0XmQ49F5kOPXKyBz1ysgc9xur+PMbq/jxWc+c8VnPnPNCmwjzQpsI8kqeRPJKnkTzI3Yg8yN2IPKCFuDyghbg8+IW7PPiFuzy0dn48tHZ+PLC7Wzywu1s87t6DPO7egzxcJWw8XCVsPLgUKDy4FCg8YIPWO2CD1jsA1xY6ANcWOjx7C7w8ewu8nBqQvJwakLzUdaa81HWmvKT3i7yk94u8bNGRvGzRkbwMaa+8DGmvvH49j7x+PY+84DMivOAzIrzQN/u70Df7u3SMDrx0jA682KM6vNijOrwI14y8CNeMvHQ8uLx0PLi8eNfFvHjXxbwuXa68Ll2uvFjCTLxYwky8gPjnuoD457pwPow7cD6MO4Ci7TuAou07cOtUPHDrVDzYYJ482GCePIo6kjyKOpI86L3vO+i97ztwFFe7cBRXuyhE5rsoROa7aCrJu2gqybvQJEG70CRBuwhpxjsIacY7qH2OPKh9jjyKs5E8irORPPiBGTz4gRk8IIkgPCCJIDycdo48nHaOPNKViDzSlYg8hDgzPIQ4MzycmC08nJgtPAzfXzwM3188WpWIPFqViDx8VKA8fFSgPOylvzzspb882sr6PNrK+jyKQRE9ikERPSD/4jwg/+I85IJaPOSCWjwIfuE7CH7hO5C2jjuQto47mHrhu5h64bv+mZK8/pmSvOQ1b7zkNW+8xO4KvMTuCrzwciW88HIlvKim6Luopui7YCLhOmAi4TqAsIw6gLCMOpTkFryU5Ba8Ek+dvBJPnbzyoMa88qDGvCZQvrwmUL68SFW4vEhVuLwqQuK8KkLivBX8BL0V/AS9QVEIvUFRCL0N1Qq9DdUKvVCbEb1QmxG9lEcZvZRHGb38lhe9/JYXvXUVBL11FQS9BCXrvAQl67w+Yfa8PmH2vOZX/7zmV/+8F9MAvRfTAL0DSBC9A0gQvW+XIb1vlyG9SbskvUm7JL0PTyO9D08jvSQqH70kKh+9ifASvYnwEr3xlQy98ZUMvac/Fb2nPxW9fHsfvXx7H70FNiC9BTYgve8TFb3vExW9uI7tvLiO7bwso3y8LKN8vADfNjkA3zY5bOYUPGzmFDz4FTE8+BUxPEhlaTxIZWk8JqqaPCaqmjy413o8uNd6PPQbAjz0GwI80PEyPNDxMjxQnK88UJyvPMLDsTzCw7E8YAkvPGAJLzxs7wI8bO8CPNiVhjzYlYY8ri6DPK4ugzzAXWU7wF1lOzhJrrs4Sa67gC3ku4At5LugSOm7oEjpuzhJvrs4Sb67wOJSu8DiUrtA5zi7QOc4u/Bb97vwW/e7RBt+vEQbfrzi3Z284t2dvLKIgryyiIK8TNUsvEzVLLw0yQq8NMkKvKAFPbygBT28IFNqvCBTarwM5Sq8DOUqvKjczbuo3M27+O0JvPjtCbwA9S+8APUvvAhDPLwIQzy8AKSCvACkgrx89qS8fPakvNzqjbzc6o28xHcRvMR3EbxgH506YB+dOsgq9zvIKvc7GJ+2OxiftjsAx0g5AMdIOVAMGLtQDBi7eKm7u3ipu7tolkS8aJZEvIxvd7yMb3e8wMRivMDEYrx8WC28fFgtvPA2nbvwNp27gMfxOYDH8Tngykw74MpMO2i31jtot9Y7pKwUPKSsFDxQMxc8UDMXPGgfPDxoHzw8bM1RPGzNUTyYpBo8mKQaPKCiEDygohA8tJBSPLSQUjwIhmc8CIZnPLgBTzy4AU88xDtxPMQ7cTxEeLo8RHi6PBrx6zwa8es8HFCsPBxQrDzQfK470HyuO0A2sbpANrG6QLo6ukC6OrpgHEi7YBxIuxCeH7sQnh+7mPfXO5j31zsMnlI8DJ5SPCx7IjwseyI8wGPLO8BjyzsQuKY7ELimOzC6Cjswugo7wO80usDvNLoAXdi6AF3Yunh0jrt4dI67SECiu0hAoruAkc45gJHOObDKYjuwymI7YPC+umDwvrqE5ha8hOYWvKCIRbygiEW8yOLXu8ji17uABoO6gAaDutC1arvQtWq7aLC5u2iwubuARRS7gEUUu3D/oLtw/6C77MFwvOzBcLzk5aa85OWmvEpIorxKSKK83JZpvNyWabxYNI+7WDSPu5CdMzuQnTM7mPK+O5jyvju8jDg8vIw4PGA2cjxgNnI8bCEuPGwhLjxgRAk8YEQJPJgUazyYFGs8eMmePHjJnjy+OZo8vjmaPByWkzwclpM8LsmePC7Jnjw2Obo8Njm6PAKE2TwChNk8LtndPC7Z3TwWm9k8FpvZPFJL7DxSS+w8YPXnPGD15zy+qqk8vqqpPJjuOTyY7jk8OE2rOzhNqzvQ3nY70N52O7hfwDu4X8A7SFICPEhSAjxoOzU8aDs1PHg2mjx4Npo8iKXZPIil2TxgGeA8YBngPI63xjyOt8Y8Mqm/PDKpvzykLaw8pC2sPERoOTxEaDk84KnOOuCpzjoAY0o6AGNKOoBmEDuAZhA7gArruoAK67pA7567QO+eu8D8xrrA/Ma6EK9IOxCvSDuY+pg7mPqYOxjn1jsY59Y7QMA8PEDAPDz4p1Q8+KdUPECJRztAiUc7BAs3vAQLN7weYoC8HmKAvNBbObzQWzm8XL8QvFy/ELyUGBy8lBgcvPAs8LvwLPC7QBT6ukAU+rqApO46gKTuOqAbgTqgG4E60Dohu9A6Ibtw4kK7cOJCu8DBFzrAwRc6gJmPOoCZjzrw+G678PhuuwDPzrsAz867CDLDuwgyw7s4zDG8OMwxvFwAuLxcALi8FIH0vBSB9Lws58S8LOfEvLRSZ7y0Ume8wC9svMAvbLwSoZy8EqGcvCj2hrwo9oa8eFNGvHhTRrwkTzW8JE81vDjSqrs40qq7AB/vOwAf7zsABX48AAV+PDidOTw4nTk8cNwTO3DcEzuA2Pw6gNj8OrgO4ju4DuI7WLmFO1i5hTuw01+7sNNfu2j8zbto/M27cFbHu3BWx7ugB7C7oAewu4BclruAXJa7QJHgu0CR4LuArzq8gK86vNhNSrzYTUq8wI/ou8CP6LsA5ha5AOYWucA/NjvAPzY7YIZGO2CGRjtwPHI7cDxyO1CvIztQryM7ANrAuQDawLmATUO6gE1DugCPczoAj3M6QBE7OkAROzrg1HW74NR1uwR3I7wEdyO8HDJOvBwyTrxMC1S8TAtUvBwNebwcDXm8nJ6BvJyegbyMIUC8jCFAvOgAxLvoAMS7INPquiDT6roAAOK1AADitaB1jDugdYw7CIhXPAiIVzycOH48nDh+PJzOJDycziQ8aJg8PGiYPDwInIg8CJyIPMSKMjzEijI8ANS9uQDUvbmgMMO7oDDDu3j9r7t4/a+7ANVLOQDVSzlgfs47YH7OOzib9Ds4m/Q7eDbKO3g2yjsQf8U7EH/FO+Dw1jvg8NY7eATSO3gE0jvgQLk74EC5O6TCDzykwg886geKPOoHijyuirI8roqyPFpcqzxaXKs8qpqoPKqaqDxcELg8XBC4PFSSujxUkro8WiaaPFommjx4wjQ8eMI0PMA9TDvAPUw70FApu9BQKbtI9+C7SPfguxiiELwYohC8aHvCu2h7wruAivs5gIr7ORB4pzsQeKc7qAnrO6gJ6ztwrC48cKwuPOCrTTzgq008wFj8O8BY/DsAcpY5AHKWOUiQ77tIkO+7Uh2UvFIdlLxYvey8WL3svMjeFb3I3hW9aScqvWknKr3eQSG93kEhveAj6bzgI+m81sqMvNbKjLyEYF68hGBevHy4cbx8uHG8OBwpvDgcKbwAIcG6ACHBunAVCLtwFQi70F84vNBfOLyKFoO8ihaDvOhOirzoToq8UtWkvFLVpLz2zca89s3GvNj11bzY9dW8TFu1vExbtbzcK1O83CtTvEC3vrtAt7678PxJu/D8SbuAona6gKJ2ugAjtLkAI7S5kG2Ru5BtkbuQXD+8kFw/vEZei7xGXou8orecvKK3nLyMXK68jFyuvMYWwLzGFsC8ztXNvM7VzbwCI+S8AiPkvFBT27xQU9u8GPCjvBjwo7zycYm88nGJvLxemby8Xpm8uGGivLhhorzkKLu85Ci7vAxX77wMV++8RU4EvUVOBL0ekv+8HpL/vLZS+Ly2Uvi8JNj2vCTY9ry6aui8umrovIyU0LyMlNC8OGfbvDhn27x0Cg29dAoNvZDkK72Q5Cu9dR07vXUdO71G5EG9RuRBvfgVO734FTu9TaIqvU2iKr0gAyW9IAMlvYnwI72J8CO96IYcveiGHL1IjSW9SI0lvaaPSb2mj0m9/CJsvfwibL0TKne9Eyp3vTUeb701Hm+9BuZgvQbmYL0mM1e9JjNXvZHiVL2R4lS9N6FUvTehVL2MAU69jAFOvSeLOb0nizm9oxccvaMXHL2yhwW9socFvXye9Lx8nvS8JtPovCbT6LzSaey80mnsvN6UAL3elAC9GsoJvRrKCb3sxhO97MYTvag5Kb2oOSm9SKs8vUirPL3c7Tu93O07vWlcNL1pXDS9mzIwvZsyML2F7yC9he8gvWkyBb1pMgW9HK3EvBytxLw8U1O8PFNTvCCwRLsgsES7kEgIO5BICDvgSVo74ElaO2BS17pgUte6PJQkvDyUJLwME0G8DBNBvNxgSbzcYEm89Bq7vPQau7ygcge9oHIHvWj7+rxo+/q8SrS/vEq0v7yG7qe8hu6nvMbfqrzG36q8Aou4vAKLuLzeosS83qLEvHAPv7xwD7+8yPOwvMjzsLwEiLG8BIixvOBwzbzgcM28Q+8AvUPvAL3ohBq96IQavZfKJL2XyiS9yNAgvcjQIL26vBC9urwQvZCW2LyQlti8EvmFvBL5hbyQLlm8kC5ZvBB+b7wQfm+8RGUyvERlMrwQzEy7EMxMuwAQSLkAEEi5MD9uuzA/brvAmvC7wJrwu4DeALyA3gC8EIbtuxCG7bvADv67wA7+u1zrEbxc6xG8SBn1u0gZ9bvAa4C6wGuAuqC11DugtdQ7ULAnPFCwJzyIVlU8iFZVPJoHhDyaB4Q8PgaCPD4Ggjw0y088NMtPPARnBzwEZwc84ERJO+BESTvAwBI6wMASOmCuoTpgrqE6gLh+OoC4fjqgXfa6oF32ughV1bsIVdW7yG8HvMhvB7wQyQK7EMkCu4Aw2zuAMNs7cKQrPHCkKzxQhkk8UIZJPLRqWzy0als8KFg4PChYODzkvCU85LwlPAxnPjwMZz48WHUWPFh1FjzwcFU78HBVOyBY+jogWPo6MOGmOzDhpjsYZM07GGTNO/AhmDvwIZg7iN6BO4jegTtABMc7QATHO9yCJDzcgiQ8sD9VPLA/VTzcxGA83MRgPCxVYDwsVWA8gCZNPIAmTTzwgw888IMPPMAshzvALIc7gO2GOoDthjoAXty4AF7cuKC6pbqguqW6oAWCu6AFgrv4Bpy7+Aacu8Dvs7rA77O60NcpO9DXKTvYNaY72DWmO5ho0DuYaNA78Jf5O/CX+TvgSTw84Ek8PJyQVDyckFQ80HarO9B2qzuA+mK7gPpiu7DEdLuwxHS7ALGvugCxr7rA5Vm7wOVZu9Dh+rvQ4fq7SDMbvEgzG7zs4hK87OISvAwiJ7wMIie8wMQsvMDELLzox6676MeuuwCBNzkAgTc5AHSNOQB0jTmA+Fa7gPhWuyDUqrsg1Kq7QAoNukAKDbpI5J87SOSfO4DCqDqAwqg6MEqwuzBKsLvUjAi81IwIvABfOrwAXzq8uClHvLgpR7ygdxO8oHcTvPTEBrz0xAa8eDXwu3g18LtgTDq7YEw6u6BqB7ugage7KBbEuygWxLsYf/O7GH/zu3Db1Ltw29S7lPIEvJTyBLwMJUi8DCVIvHROZrx0Tma8oARIvKAESLzQaDy80Gg8vFy6f7xcun+84M63vODOt7zu19287tfdvJxi5LycYuS8UsrovFLK6Lxmbu28Zm7tvFgP2rxYD9q8pqvOvKarzrwwLOa8MCzmvMqg97zKoPe8zHfsvMx37LywG9W8sBvVvN6KwbzeisG8JN+8vCTfvLyckLi8nJC4vIS7tryEu7a8DPTlvAz05byImx69iJsevSflPL0n5Ty9Ks9EvSrPRL1KWEG9SlhBvQ+XNb0PlzW9kEMgvZBDIL0DHwu9Ax8LvQJ/B70Cfwe9ZicPvWYnD73y8Aq98vAKvWz8/7xs/P+80rwAvdK8AL2QYgW9kGIFvdrf/bza3/28hFjhvIRY4bx8qcS8fKnEvHjXpLx416S85hyIvOYciLw2BoO8NgaDvOC8grzgvIK8OGxQvDhsULxkjym8ZI8pvJx8TbycfE28vBhevLwYXryE0h+8hNIfvDA0BrwwNAa8zJ1tvMydbbwCVau8AlWrvG7fkrxu35K8uMFHvLjBR7yYqnW8mKp1vC4TsrwuE7K8fE+uvHxPrryIRWe8iEVnvDTmIrw05iK87LtYvOy7WLxOfou8Tn6LvJCGgbyQhoG8DPF8vAzxfLyk/Ki8pPyovCSG2bwkhtm8LlLjvC5S47wW1sy8FtbMvC6ywrwussK8xlLUvMZS1Ly2Ttq8tk7avEKRxbxCkcW8FI+0vBSPtLweq728Hqu9vCwZ2LwsGdi8fOvVvHzr1bwgRau8IEWrvNjFk7zYxZO8mtGPvJrRj7xIfVu8SH1bvDj7J7w4+ye8zHpIvMx6SLyoVlS8qFZUvMxLK7zMSyu8SPYBvEj2AbxIK5W7SCuVuwAI37kACN+5AALwOAAC8DjoRIq76ESKuygZ37soGd+7oCZCu6AmQruARCa6gEQmurCPxbuwj8W7uP80vLj/NLxoIDS8aCA0vCiWSrwolkq8DHGDvAxxg7ykDIa8pAyGvBD9bLwQ/Wy8fCJ3vHwid7z4z4S8+M+EvICiabyAomm84A07vOANO7w0tha8NLYWvAgE6LsIBOi72LoLvNi6C7zMhlK8zIZSvNCqSbzQqkm8UEL6u1BC+rsY+dC7GPnQu7gP6Lu4D+i7cDaau3A2mruQXDW7kFw1uxgQz7sYEM+70F0ovNBdKLzQcsG70HLBu5BJUzuQSVM7AGqmOwBqpjuAXM66gFzOurjZ2Lu42di7EAqquxAKqruAPSW7gD0luwB+ZrsAfma7qDC+u6gwvrtY9667WPeuu+B9G7vgfRu7AJNlOgCTZTpgsfo6YLH6OoAFULqABVC6oHdxu6B3cbtg5Sy7YOUsuwCFNboAhTW6MJUKuzCVCrsIBL+7CAS/u/wHKrz8Byq8UMJ1vFDCdbwwm4u8MJuLvCyBjrwsgY68EhadvBIWnbx0n5y8dJ+cvNB3c7zQd3O8jKVAvIylQLyQaD+8kGg/vPDGQrzwxkK85K9SvOSvUrwsN1+8LDdfvNhPWLzYT1i81Fx9vNRcfbyujp+8ro6fvMYipLzGIqS8LGuQvCxrkLzYnma82J5mvNReLLzUXiy87OMfvOzjH7wISSu8CEkrvChTJLwoUyS8BE8jvARPI7wAmh28AJodvJDv7buQ7+27oEqpu6BKqbuISa67iEmuuxgqBrwYKga84JxbvOCcW7w+aY+8PmmPvGizlbxos5W8QEqPvEBKj7wabIK8GmyCvEjNXrxIzV68NNpPvDTaT7w4Z2C8OGdgvPSSebz0knm8MsGTvDLBk7wU76i8FO+ovFz3mLxc95i8eKOFvHijhby4kqm8uJKpvLY81by2PNW80tDNvNLQzbze4cG83uHBvDz/1bw8/9W86i7gvOou4LyYv8C8mL/AvJSQkryUkJK8cgKNvHICjbyMq7q8jKu6vPx+5Lz8fuS8jv7lvI7+5bzIM868yDPOvAbevLwG3ry8PAHJvDwBybxQ7+C8UO/gvBKy8rwSsvK8H+MHvR/jB72/khC9v5IQvcHBBL3BwQS9RB3zvEQd87wi7eq8Iu3qvBrd0rwa3dK85p3CvOadwrzwhsu88IbLvFzn1bxc59W81uPgvNbj4Lyiuem8ornpvLx+57y8fue8cu7mvHLu5rwKpde8CqXXvKJ+o7yifqO8yB90vMgfdLxYrIy8WKyMvLR7t7y0e7e8eBTDvHgUw7w4rri8OK64vKSssLykrLC8il6evIpenrzkbYu85G2LvFhVmrxYVZq84tq+vOLavrxcbd+8XG3fvOZWAL3mVgC9iscNvYrHDb0LdRC9C3UQvTe5DL03uQy9FcsHvRXLB72gMvm8oDL5vO7EyrzuxMq8/NGZvPzRmbyQA4W8kAOFvCofgLwqH4C8jL5rvIy+a7zsRVS87EVUvPTGPrz0xj68bHdIvGx3SLxkLoq8ZC6KvL4CuLy+Ari8ymTTvMpk07wOw+G8DsPhvJYu5byWLuW86nPavOpz2rx8rbi8fK24vDiJdrw4iXa8IP4QvCD+ELyYUuW7mFLlu/B2j7vwdo+7QFJmOkBSZjoAgEQ7AIBEO2CDkjpgg5I6ALxFOAC8RTgAvti5AL7YuSBwQLsgcEC72Lu6u9i7urs4nsy7OJ7MuxDkdLsQ5HS74NmSOuDZkjrQamY70GpmOwAKDTsACg07wJYsO8CWLDvwfJY78HyWO5DWczuQ1nM7ABnqOgAZ6joA+Fe6APhXuiDikrsg4pK7+Numu/jbprvAxJi7wMSYu1go67tYKOu7oMHMu6DBzLswCkI7MApCO8i4bDzIuGw8igupPIoLqTxsFKg8bBSoPLzsnDy87Jw83veQPN73kDzk20U85NtFPPjMrDv4zKw7QPVjO0D1YztgQMg7YEDIOzh1Gzw4dRs89OQTPPTkEzyYsJk7mLCZO5ATWTuQE1k7gLGXO4CxlzsYlZA7GJWQOxA4wjsQOMI7QEr+O0BK/juQUJI7kFCSOwBQlrkAUJa50Ahtu9AIbbsAGty7ABrcu5hm3ruYZt67sIWlu7CFpbuQv9W7kL/Vu4THE7yExxO8KFkQvChZELzskRC87JEQvODEX7zgxF+8YiuqvGIrqrzwfLq88Hy6vND/pLzQ/6S8GneWvBp3lrzUWoO81FqDvJisR7yYrEe8OLYpvDi2KbxsmCq8bJgqvBDbRrwQ20a83vuCvN77grxQTo+8UE6PvEh6f7xIen+8kCR8vJAkfLxMjo28TI6NvGSHiLxkh4i8sP5BvLD+QbzIl+q7yJfqu1BQDLxQUAy8fOppvHzqabzQUYa80FGGvHCoT7xwqE+8zJsQvMybELzghBy84IQcvIjgPbyI4D28FB4ivBQeIrxAI/W7QCP1u6wpDrysKQ68yPMhvMjzIbyw6+i7sOvou1AgRLtQIES7gOciu4DnIruYv9C7mL/Qu0TYGrxE2Bq87OULvOzlC7zMRAa8zEQGvAyNQLwMjUC8csuAvHLLgLzIqYW8yKmFvLhQXry4UF68fA0zvHwNM7zE4ka8xOJGvDwNe7w8DXu8NAh1vDQIdbwkZzi8JGc4vLDVHbyw1R28BOY0vATmNLwQtlS8ELZUvHZFh7x2RYe8rIOnvKyDp7zOXqC8zl6gvMz0i7zM9Iu8qLGgvKixoLzM2rO8zNqzvBhkkLwYZJC8FJxFvBScRbwMI0W8DCNFvC6jh7wuo4e8mPGsvJjxrLzYPsK82D7CvI6K27yOitu8UnkAvVJ5AL1VMwq9VTMKvY/UBb2P1AW9PucCvT7nAr02mAu9NpgLva59Fr2ufRa9gp0XvYKdF72E6RS9hOkUvXGwGL1xsBi9/aAgvf2gIL2IdCm9iHQpvXg/K714Pyu9bvMYvW7zGL3WQ/281kP9vLrr6ry66+q8mjr8vJo6/LwbIAi9GyAIvaylAr2spQK9LnvYvC572LweSba8Hkm2vHSbrLx0m6y8St+TvErfk7z0vVG89L1RvJAjF7yQIxe8KH/9uyh//bugtdG7oLXRu/i2nrv4tp67wOuou8DrqLtcsgG8XLIBvJhpILyYaSC8pOssvKTrLLwEG1O8BBtTvEhCXLxIQly82CYNvNgmDbyQ80S7kPNEuyBql7ogape6AMeLugDHi7oAhmA5AIZgOVANSjtQDUo7wGzOO8Bszjt4N9s7eDfbO/BnATvwZwE7MO96uzDvertYaaq7WGmqu6B4h7ugeIe7yO2Fu8jthbvwrRK78K0Su4BpFTuAaRU7EAiGOxAIhjsAr+w6AK/sOkDJ7jpAye46yJvyO8ib8jt4XUU8eF1FPFjpLjxY6S48zFoDPMxaAzyAXv07gF79O5BH5zuQR+c7qACZO6gAmTugnp06oJ6dOkAM/LpADPy6QIDRukCA0boAl5A6AJeQOsB/yzrAf8s6wKdsusCnbLrQcmS70HJku9AEfLvQBHy7oHVLu6B1S7twmIa7cJiGu0iOnrtIjp670AZRu9AGUbsATLG6AEyxunDzAztw8wM74JUBPOCVATxElzo8RJc6PGiqPzxoqj88GE5BPBhOQTy0Lzc8tC83PBRXJTwUVyU8MAsNPDALDTxgmKQ7YJikO8C6VjrAulY6kDAdu5AwHbvYf6S72H+ku2gI67toCOu7dCEvvHQhL7zoaGq86GhqvExJU1QuAAAASU5GT0lTRlQiAAAATGF2ZjU2LjI1LjEwMSAobGlic25kZmlsZS0xLjAuMjQpAGlkMyCGAAAASUQzAwAAAAAAe1RYWFgAAAARAAAAbWFqb3JfYnJhbmQAZGFzaFRYWFgAAAAXAAAAU29mdHdhcmUATGF2ZjU2LjI1LjEwMVRYWFgAAAAbAAAAY29tcGF0aWJsZV9icmFuZHMAaXNvNm1wNDFUWFhYAAAAEAAAAG1pbm9yX3ZlcnNpb24AMAA=";
var defaultEnter = "data:audio/wav;base64,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";
var defaultDelete = "data:audio/wav;base64,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";

// src/defaultSound.ts
var import_howler = __toESM(require_howler());
var defaultSounds = {
  key: new import_howler.Howl({ src: defaultKey, preload: true }),
  key2: new import_howler.Howl({ src: defaultKey2, preload: true }),
  space: new import_howler.Howl({ src: defaultSpace, preload: true }),
  enter: new import_howler.Howl({ src: defaultEnter, preload: true }),
  delete: new import_howler.Howl({ src: defaultDelete, preload: true })
};
var defaultScheme = {
  id: "default",
  caption: "Default",
  sounds: { key: "", key2: "", enter: "", space: "", delete: "" }
};

// node_modules/i18next/dist/esm/i18next.js
var consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    if (console && console[type])
      console[type].apply(console, args);
  }
};
var Logger = class {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix, debugOnly) {
    if (debugOnly && !this.debug)
      return null;
    if (typeof args[0] === "string")
      args[0] = `${prefix}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
};
var baseLogger = new Logger();
var EventEmitter = class {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event])
        this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event])
      return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i = 0; i < numTimesAdded; i++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i = 0; i < numTimesAdded; i++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
};
function defer() {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
}
function makeString(object) {
  if (object == null)
    return "";
  return "" + object;
}
function copy(a, s, t2) {
  a.forEach((m) => {
    if (s[m])
      t2[m] = s[m];
  });
}
var lastOfPathSeparatorRegExp = /###/g;
function getLastOfPath(object, path, Empty) {
  function cleanKey(key) {
    return key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
  }
  function canNotTraverseDeeper() {
    return !object || typeof object === "string";
  }
  const stack = typeof path !== "string" ? path : path.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper())
      return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty)
      object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper())
    return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
}
function setPath(object, path, newValue) {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  if (obj !== void 0 || path.length === 1) {
    obj[k] = newValue;
    return;
  }
  let e2 = path[path.length - 1];
  let p = path.slice(0, path.length - 1);
  let last = getLastOfPath(object, p, Object);
  while (last.obj === void 0 && p.length) {
    e2 = `${p[p.length - 1]}.${e2}`;
    p = p.slice(0, p.length - 1);
    last = getLastOfPath(object, p, Object);
    if (last && last.obj && typeof last.obj[`${last.k}.${e2}`] !== "undefined") {
      last.obj = void 0;
    }
  }
  last.obj[`${last.k}.${e2}`] = newValue;
}
function pushPath(object, path, newValue, concat2) {
  const {
    obj,
    k
  } = getLastOfPath(object, path, Object);
  obj[k] = obj[k] || [];
  if (concat2)
    obj[k] = obj[k].concat(newValue);
  if (!concat2)
    obj[k].push(newValue);
}
function getPath(object, path) {
  const {
    obj,
    k
  } = getLastOfPath(object, path);
  if (!obj)
    return void 0;
  return obj[k];
}
function getPathWithDefaults(data, defaultData, key) {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
}
function deepExtend(target, source, overwrite) {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (typeof target[prop] === "string" || target[prop] instanceof String || typeof source[prop] === "string" || source[prop] instanceof String) {
          if (overwrite)
            target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
}
function regexEscape(str) {
  return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
}
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
function escape(data) {
  if (typeof data === "string") {
    return data.replace(/[&<>"'\/]/g, (s) => _entityMap[s]);
  }
  return data;
}
var RegExpCache = class {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
};
var chars = [" ", ",", "?", "!", ";"];
var looksLikeObjectPathRegExpCache = new RegExpCache(20);
function looksLikeObjectPath(key, nsSeparator, keySeparator) {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c) => nsSeparator.indexOf(c) < 0 && keySeparator.indexOf(c) < 0);
  if (possibleChars.length === 0)
    return true;
  const r = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c) => c === "?" ? "\\?" : c).join("|")})`);
  let matched = !r.test(key);
  if (!matched) {
    const ki = key.indexOf(keySeparator);
    if (ki > 0 && !r.test(key.substring(0, ki))) {
      matched = true;
    }
  }
  return matched;
}
function deepFind(obj, path) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj)
    return void 0;
  if (obj[path])
    return obj[path];
  const tokens = path.split(keySeparator);
  let current = obj;
  for (let i = 0; i < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i; j < tokens.length; ++j) {
      if (j !== i) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i += j - i + 1;
        break;
      }
    }
    current = next;
  }
  return current;
}
function getCleanedCode(code) {
  if (code && code.indexOf("_") > 0)
    return code.replace("_", "-");
  return code;
}
var ResourceStore = class extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index = this.options.ns.indexOf(ns);
    if (index > -1) {
      this.options.ns.splice(index, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path;
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
    } else {
      path = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path.push(...key);
        } else if (typeof key === "string" && keySeparator) {
          path.push(...key.split(keySeparator));
        } else {
          path.push(key);
        }
      }
    }
    const result = getPath(this.data, path);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path[0];
      ns = path[1];
      key = path.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || typeof key !== "string")
      return result;
    return deepFind(this.data && this.data[lng] && this.data[lng][ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path = [lng, ns];
    if (key)
      path = path.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      value = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path, value);
    if (!options.silent)
      this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m in resources) {
      if (typeof resources[m] === "string" || Object.prototype.toString.apply(resources[m]) === "[object Array]")
        this.addResource(lng, ns, m, resources[m], {
          silent: true
        });
    }
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path) || {};
    if (!options.skipCopy)
      resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path, pack);
    if (!options.silent)
      this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns)
      ns = this.options.defaultNS;
    if (this.options.compatibilityAPI === "v1")
      return {
        ...{},
        ...this.getResource(lng, ns)
      };
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n = data && Object.keys(data) || [];
    return !!n.find((v) => data[v] && Object.keys(data[v]).length > 0);
  }
  toJSON() {
    return this.data;
  }
};
var postProcessor = {
  processors: {},
  addPostProcessor(module2) {
    this.processors[module2.name] = module2;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      if (this.processors[processor])
        value = this.processors[processor].process(value, key, options, translator);
    });
    return value;
  }
};
var checkedLoadedFor = {};
var Translator = class extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng)
      this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved && resolved.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0)
      nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m = key.match(this.interpolator.nestingRegexp);
      if (m && m.length > 0) {
        return {
          key,
          namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1)
        namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    return {
      key,
      namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object")
      options = {
        ...options
      };
    if (!options)
      options = {};
    if (keys === void 0 || keys === null)
      return "";
    if (!Array.isArray(keys))
      keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng && lng.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved && resolved.res;
    const resUsedKey = resolved && resolved.usedKey || key;
    const resExactUsedKey = resolved && resolved.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = typeof res !== "string" && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(typeof joinArrays === "string" && resType === "[object Array]")) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r;
      }
      if (keySeparator) {
        const resTypeIsArray = resType === "[object Array]";
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m in res) {
          if (Object.prototype.hasOwnProperty.call(res, m)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m}`;
            copy2[m] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m] === deepKey)
              copy2[m] = res[m];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && typeof joinArrays === "string" && resType === "[object Array]") {
      res = res.join(joinArrays);
      if (res)
        res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk && fk.res)
            this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i = 0; i < fallbackLngs.length; i++) {
            lngs.push(fallbackLngs[i]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l, k, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l, namespace, k, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector && this.backendConnector.saveMissing) {
            this.backendConnector.saveMissing(l, namespace, k, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l, namespace, k, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey)
        res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        if (this.options.compatibilityAPI !== "v1") {
          res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
        } else {
          res = this.options.parseMissingKeyHandler(res);
        }
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat && this.i18nFormat.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation)
        this.interpolator.init({
          ...options,
          ...{
            interpolation: {
              ...this.options.interpolation,
              ...options.interpolation
            }
          }
        });
      const skipOnVariables = typeof res === "string" && (options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb = res.match(this.interpolator.nestingRegexp);
        nestBef = nb && nb.length;
      }
      let data = options.replace && typeof options.replace !== "string" ? options.replace : options;
      if (this.options.interpolation.defaultVariables)
        data = {
          ...this.options.interpolation.defaultVariables,
          ...data
        };
      res = this.interpolator.interpolate(res, data, options.lng || this.language, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft)
          options.nest = false;
      }
      if (!options.lng && this.options.compatibilityAPI !== "v1" && resolved && resolved.res)
        options.lng = resolved.usedLng;
      if (options.nest !== false)
        res = this.interpolator.nest(res, function() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (lastKey && lastKey[0] === args[0] && !options.context) {
            _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
            return null;
          }
          return _this.translate(...args, key);
        }, options);
      if (options.interpolation)
        this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = typeof postProcess === "string" ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames && postProcessorNames.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (typeof keys === "string")
      keys = [keys];
    keys.forEach((k) => {
      if (this.isValidLookup(found))
        return;
      const extracted = this.extractFromKey(k, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS)
        namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && typeof options.count !== "string";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0 && this.pluralResolver.shouldUseIntlApi();
      const needsContextHandling = options.context !== void 0 && (typeof options.context === "string" || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found))
          return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils && this.utils.hasLoadedNamespace && !this.utils.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found))
            return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat && this.i18nFormat.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling)
              pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat && this.i18nFormat.getResource)
      return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && typeof options.replace !== "string";
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix === option.substring(0, prefix.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
};
function capitalize(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
var LanguageUtil = class {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return null;
    const p = code.split("-");
    if (p.length === 2)
      return null;
    p.pop();
    if (p[p.length - 1].toLowerCase() === "x")
      return null;
    return this.formatLanguageCode(p.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0)
      return code;
    const p = code.split("-");
    return this.formatLanguageCode(p[0]);
  }
  formatLanguageCode(code) {
    if (typeof code === "string" && code.indexOf("-") > -1) {
      const specialCases = ["hans", "hant", "latn", "cyrl", "cans", "mong", "arab"];
      let p = code.split("-");
      if (this.options.lowerCaseLng) {
        p = p.map((part) => part.toLowerCase());
      } else if (p.length === 2) {
        p[0] = p[0].toLowerCase();
        p[1] = p[1].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize(p[1].toLowerCase());
      } else if (p.length === 3) {
        p[0] = p[0].toLowerCase();
        if (p[1].length === 2)
          p[1] = p[1].toUpperCase();
        if (p[0] !== "sgn" && p[2].length === 2)
          p[2] = p[2].toUpperCase();
        if (specialCases.indexOf(p[1].toLowerCase()) > -1)
          p[1] = capitalize(p[1].toLowerCase());
        if (specialCases.indexOf(p[2].toLowerCase()) > -1)
          p[2] = capitalize(p[2].toLowerCase());
      }
      return p.join("-");
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes)
      return null;
    let found;
    codes.forEach((code) => {
      if (found)
        return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng))
        found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found)
          return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly))
          return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0)
            return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly)
            return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1)
            return supportedLng;
        });
      });
    }
    if (!found)
      found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks)
      return [];
    if (typeof fallbacks === "function")
      fallbacks = fallbacks(code);
    if (typeof fallbacks === "string")
      fallbacks = [fallbacks];
    if (Object.prototype.toString.apply(fallbacks) === "[object Array]")
      return fallbacks;
    if (!code)
      return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found)
      found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found)
      found = fallbacks[this.formatLanguageCode(code)];
    if (!found)
      found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found)
      found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c) => {
      if (!c)
        return;
      if (this.isSupportedCode(c)) {
        codes.push(c);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c}`);
      }
    };
    if (typeof code === "string" && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly")
        addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly")
        addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly")
        addCode(this.getLanguagePartFromCode(code));
    } else if (typeof code === "string") {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc) => {
      if (codes.indexOf(fc) < 0)
        addCode(this.formatLanguageCode(fc));
    });
    return codes;
  }
};
var sets = [{
  lngs: ["ach", "ak", "am", "arn", "br", "fil", "gun", "ln", "mfe", "mg", "mi", "oc", "pt", "pt-BR", "tg", "tl", "ti", "tr", "uz", "wa"],
  nr: [1, 2],
  fc: 1
}, {
  lngs: ["af", "an", "ast", "az", "bg", "bn", "ca", "da", "de", "dev", "el", "en", "eo", "es", "et", "eu", "fi", "fo", "fur", "fy", "gl", "gu", "ha", "hi", "hu", "hy", "ia", "it", "kk", "kn", "ku", "lb", "mai", "ml", "mn", "mr", "nah", "nap", "nb", "ne", "nl", "nn", "no", "nso", "pa", "pap", "pms", "ps", "pt-PT", "rm", "sco", "se", "si", "so", "son", "sq", "sv", "sw", "ta", "te", "tk", "ur", "yo"],
  nr: [1, 2],
  fc: 2
}, {
  lngs: ["ay", "bo", "cgg", "fa", "ht", "id", "ja", "jbo", "ka", "km", "ko", "ky", "lo", "ms", "sah", "su", "th", "tt", "ug", "vi", "wo", "zh"],
  nr: [1],
  fc: 3
}, {
  lngs: ["be", "bs", "cnr", "dz", "hr", "ru", "sr", "uk"],
  nr: [1, 2, 5],
  fc: 4
}, {
  lngs: ["ar"],
  nr: [0, 1, 2, 3, 11, 100],
  fc: 5
}, {
  lngs: ["cs", "sk"],
  nr: [1, 2, 5],
  fc: 6
}, {
  lngs: ["csb", "pl"],
  nr: [1, 2, 5],
  fc: 7
}, {
  lngs: ["cy"],
  nr: [1, 2, 3, 8],
  fc: 8
}, {
  lngs: ["fr"],
  nr: [1, 2],
  fc: 9
}, {
  lngs: ["ga"],
  nr: [1, 2, 3, 7, 11],
  fc: 10
}, {
  lngs: ["gd"],
  nr: [1, 2, 3, 20],
  fc: 11
}, {
  lngs: ["is"],
  nr: [1, 2],
  fc: 12
}, {
  lngs: ["jv"],
  nr: [0, 1],
  fc: 13
}, {
  lngs: ["kw"],
  nr: [1, 2, 3, 4],
  fc: 14
}, {
  lngs: ["lt"],
  nr: [1, 2, 10],
  fc: 15
}, {
  lngs: ["lv"],
  nr: [1, 2, 0],
  fc: 16
}, {
  lngs: ["mk"],
  nr: [1, 2],
  fc: 17
}, {
  lngs: ["mnk"],
  nr: [0, 1, 2],
  fc: 18
}, {
  lngs: ["mt"],
  nr: [1, 2, 11, 20],
  fc: 19
}, {
  lngs: ["or"],
  nr: [2, 1],
  fc: 2
}, {
  lngs: ["ro"],
  nr: [1, 2, 20],
  fc: 20
}, {
  lngs: ["sl"],
  nr: [5, 1, 2, 3],
  fc: 21
}, {
  lngs: ["he", "iw"],
  nr: [1, 2, 20, 21],
  fc: 22
}];
var _rulesPluralsTypes = {
  1: function(n) {
    return Number(n > 1);
  },
  2: function(n) {
    return Number(n != 1);
  },
  3: function(n) {
    return 0;
  },
  4: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  5: function(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : n == 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5);
  },
  6: function(n) {
    return Number(n == 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2);
  },
  7: function(n) {
    return Number(n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  8: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n != 8 && n != 11 ? 2 : 3);
  },
  9: function(n) {
    return Number(n >= 2);
  },
  10: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n < 7 ? 2 : n < 11 ? 3 : 4);
  },
  11: function(n) {
    return Number(n == 1 || n == 11 ? 0 : n == 2 || n == 12 ? 1 : n > 2 && n < 20 ? 2 : 3);
  },
  12: function(n) {
    return Number(n % 10 != 1 || n % 100 == 11);
  },
  13: function(n) {
    return Number(n !== 0);
  },
  14: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : n == 3 ? 2 : 3);
  },
  15: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2);
  },
  16: function(n) {
    return Number(n % 10 == 1 && n % 100 != 11 ? 0 : n !== 0 ? 1 : 2);
  },
  17: function(n) {
    return Number(n == 1 || n % 10 == 1 && n % 100 != 11 ? 0 : 1);
  },
  18: function(n) {
    return Number(n == 0 ? 0 : n == 1 ? 1 : 2);
  },
  19: function(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3);
  },
  20: function(n) {
    return Number(n == 1 ? 0 : n == 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2);
  },
  21: function(n) {
    return Number(n % 100 == 1 ? 1 : n % 100 == 2 ? 2 : n % 100 == 3 || n % 100 == 4 ? 3 : 0);
  },
  22: function(n) {
    return Number(n == 1 ? 0 : n == 2 ? 1 : (n < 0 || n > 10) && n % 10 == 0 ? 2 : 3);
  }
};
var nonIntlVersions = ["v1", "v2", "v3"];
var intlVersions = ["v4"];
var suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
function createRules() {
  const rules = {};
  sets.forEach((set) => {
    set.lngs.forEach((l) => {
      rules[l] = {
        numbers: set.nr,
        plurals: _rulesPluralsTypes[set.fc]
      };
    });
  });
  return rules;
}
var PluralResolver = class {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    if ((!this.options.compatibilityJSON || intlVersions.includes(this.options.compatibilityJSON)) && (typeof Intl === "undefined" || !Intl.PluralRules)) {
      this.options.compatibilityJSON = "v3";
      this.logger.error("Your environment seems not to be Intl API compatible, use an Intl.PluralRules polyfill. Will fallback to the compatibilityJSON v3 format handling.");
    }
    this.rules = createRules();
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (this.shouldUseIntlApi()) {
      try {
        return new Intl.PluralRules(getCleanedCode(code === "dev" ? "en" : code), {
          type: options.ordinal ? "ordinal" : "cardinal"
        });
      } catch (err) {
        return;
      }
    }
    return this.rules[code] || this.rules[this.languageUtils.getLanguagePartFromCode(code)];
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (this.shouldUseIntlApi()) {
      return rule && rule.resolvedOptions().pluralCategories.length > 1;
    }
    return rule && rule.numbers.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const rule = this.getRule(code, options);
    if (!rule) {
      return [];
    }
    if (this.shouldUseIntlApi()) {
      return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
    }
    return rule.numbers.map((number) => this.getSuffix(code, number, options));
  }
  getSuffix(code, count) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      if (this.shouldUseIntlApi()) {
        return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count)}`;
      }
      return this.getSuffixRetroCompatible(rule, count);
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return "";
  }
  getSuffixRetroCompatible(rule, count) {
    const idx = rule.noAbs ? rule.plurals(count) : rule.plurals(Math.abs(count));
    let suffix = rule.numbers[idx];
    if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      if (suffix === 2) {
        suffix = "plural";
      } else if (suffix === 1) {
        suffix = "";
      }
    }
    const returnSuffix = () => this.options.prepend && suffix.toString() ? this.options.prepend + suffix.toString() : suffix.toString();
    if (this.options.compatibilityJSON === "v1") {
      if (suffix === 1)
        return "";
      if (typeof suffix === "number")
        return `_plural_${suffix.toString()}`;
      return returnSuffix();
    } else if (this.options.compatibilityJSON === "v2") {
      return returnSuffix();
    } else if (this.options.simplifyPluralSuffix && rule.numbers.length === 2 && rule.numbers[0] === 1) {
      return returnSuffix();
    }
    return this.options.prepend && idx.toString() ? this.options.prepend + idx.toString() : idx.toString();
  }
  shouldUseIntlApi() {
    return !nonIntlVersions.includes(this.options.compatibilityJSON);
  }
};
function deepFindWithDefaults(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path = getPathWithDefaults(data, defaultData, key);
  if (!path && ignoreJSONStructure && typeof key === "string") {
    path = deepFind(data, key, keySeparator);
    if (path === void 0)
      path = deepFind(defaultData, key, keySeparator);
  }
  return path;
}
var Interpolator = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options.interpolation && options.interpolation.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation)
      options.interpolation = {
        escapeValue: true
      };
    const iOpts = options.interpolation;
    this.escape = iOpts.escape !== void 0 ? iOpts.escape : escape;
    this.escapeValue = iOpts.escapeValue !== void 0 ? iOpts.escapeValue : true;
    this.useRawValueToEscape = iOpts.useRawValueToEscape !== void 0 ? iOpts.useRawValueToEscape : false;
    this.prefix = iOpts.prefix ? regexEscape(iOpts.prefix) : iOpts.prefixEscaped || "{{";
    this.suffix = iOpts.suffix ? regexEscape(iOpts.suffix) : iOpts.suffixEscaped || "}}";
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
    this.unescapePrefix = iOpts.unescapeSuffix ? "" : iOpts.unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : iOpts.unescapeSuffix || "";
    this.nestingPrefix = iOpts.nestingPrefix ? regexEscape(iOpts.nestingPrefix) : iOpts.nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = iOpts.nestingSuffix ? regexEscape(iOpts.nestingSuffix) : iOpts.nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = iOpts.nestingOptionsSeparator ? iOpts.nestingOptionsSeparator : iOpts.nestingOptionsSeparator || ",";
    this.maxReplaces = iOpts.maxReplaces ? iOpts.maxReplaces : 1e3;
    this.alwaysFormat = iOpts.alwaysFormat !== void 0 ? iOpts.alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options)
      this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp && existingRegExp.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    function regexSafe(val) {
      return val.replace(/\$/g, "$$$$");
    }
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path;
      }
      const p = key.split(this.formatSeparator);
      const k = p.shift().trim();
      const f = p.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k, this.options.keySeparator, this.options.ignoreJSONStructure), f, lng, {
        ...options,
        ...data,
        interpolationkey: k
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options && options.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options && options.interpolation && options.interpolation.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = typeof temp === "string" ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (typeof value !== "string" && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    function handleHasOptions(key, inheritedOptions) {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0)
        return key;
      const c = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c[1]}`;
      key = c[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if (matchedSingleQuotes && matchedSingleQuotes.length % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions)
          clonedOptions = {
            ...inheritedOptions,
            ...clonedOptions
          };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      delete clonedOptions.defaultValue;
      return key;
    }
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && typeof clonedOptions.replace !== "string" ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r.shift();
        formatters = r;
        doReduce = true;
      }
      value = fc(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && typeof value !== "string")
        return value;
      if (typeof value !== "string")
        value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v, f) => this.format(v, f, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
};
function parseFormatStr(formatStr) {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p = formatStr.split("(");
    formatName = p[0].toLowerCase().trim();
    const optStr = p[1].substring(0, p[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency)
        formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range)
        formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (!opt)
          return;
        const [key, ...rest] = opt.split(":");
        const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
        if (!formatOptions[key.trim()])
          formatOptions[key.trim()] = val;
        if (val === "false")
          formatOptions[key.trim()] = false;
        if (val === "true")
          formatOptions[key.trim()] = true;
        if (!isNaN(val))
          formatOptions[key.trim()] = parseInt(val, 10);
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
}
function createCachedFormatter(fn) {
  const cache = {};
  return function invokeFormatter(val, lng, options) {
    const key = lng + JSON.stringify(options);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
}
var Formatter = class {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    const iOpts = options.interpolation;
    this.formatSeparator = iOpts.formatSeparator ? iOpts.formatSeparator : iOpts.formatSeparator || ",";
  }
  add(name, fc) {
    this.formats[name.toLowerCase().trim()] = fc;
  }
  addCached(name, fc) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc);
  }
  format(value, format, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format.split(this.formatSeparator);
    const result = formats.reduce((mem, f) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options && options.formatParams && options.formatParams[options.interpolationkey] || {};
          const l = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
};
function removePending(q, name) {
  if (q.pending[name] !== void 0) {
    delete q.pending[name];
    q.pendingCount--;
  }
}
var Connector = class extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    if (this.backend && this.backend.init) {
      this.backend.init(services, options.backend, options);
    }
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0)
          ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0)
            pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0)
            pending[name] = true;
          if (toLoad[name] === void 0)
            toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0)
            toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces)
        toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    if (err)
      this.emit("failedLoading", lng, ns, err);
    if (data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    const loaded = {};
    this.queue.forEach((q) => {
      pushPath(q.loaded, [lng], ns);
      removePending(q, name);
      if (err)
        q.errors.push(err);
      if (q.pendingCount === 0 && !q.done) {
        Object.keys(q.loaded).forEach((l) => {
          if (!loaded[l])
            loaded[l] = {};
          const loadedKeys = q.loaded[l];
          if (loadedKeys.length) {
            loadedKeys.forEach((n) => {
              if (loaded[l][n] === void 0)
                loaded[l][n] = true;
            });
          }
        });
        q.done = true;
        if (q.errors.length) {
          q.callback(q.errors);
        } else {
          q.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q) => !q.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length)
      return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc = this.backend[fcName].bind(this.backend);
    if (fc.length === 2) {
      try {
        const r = fc(lng, ns);
        if (r && typeof r.then === "function") {
          r.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (typeof languages === "string")
      languages = this.languageUtils.toResolveHierarchy(languages);
    if (typeof namespaces === "string")
      namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length)
        callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s = name.split("|");
    const lng = s[0];
    const ns = s[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err)
        this.logger.warn(`${prefix}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data)
        this.logger.log(`${prefix}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services.utils && this.services.utils.hasLoadedNamespace && !this.services.utils.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "")
      return;
    if (this.backend && this.backend.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc = this.backend.create.bind(this.backend);
      if (fc.length < 6) {
        try {
          let r;
          if (fc.length === 5) {
            r = fc(languages, namespace, key, fallbackValue, opts);
          } else {
            r = fc(languages, namespace, key, fallbackValue);
          }
          if (r && typeof r.then === "function") {
            r.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0])
      return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
};
function get() {
  return {
    debug: false,
    initImmediate: true,
    ns: ["translation"],
    defaultNS: ["translation"],
    fallbackLng: ["dev"],
    fallbackNS: false,
    supportedLngs: false,
    nonExplicitSupportedLngs: false,
    load: "all",
    preload: false,
    simplifyPluralSuffix: true,
    keySeparator: ".",
    nsSeparator: ":",
    pluralSeparator: "_",
    contextSeparator: "_",
    partialBundledLanguages: false,
    saveMissing: false,
    updateMissing: false,
    saveMissingTo: "fallback",
    saveMissingPlurals: true,
    missingKeyHandler: false,
    missingInterpolationHandler: false,
    postProcess: false,
    postProcessPassResolved: false,
    returnNull: false,
    returnEmptyString: true,
    returnObjects: false,
    joinArrays: false,
    returnedObjectHandler: false,
    parseMissingKeyHandler: false,
    appendNamespaceToMissingKey: false,
    appendNamespaceToCIMode: false,
    overloadTranslationOptionHandler: function handle(args) {
      let ret = {};
      if (typeof args[1] === "object")
        ret = args[1];
      if (typeof args[1] === "string")
        ret.defaultValue = args[1];
      if (typeof args[2] === "string")
        ret.tDescription = args[2];
      if (typeof args[2] === "object" || typeof args[3] === "object") {
        const options = args[3] || args[2];
        Object.keys(options).forEach((key) => {
          ret[key] = options[key];
        });
      }
      return ret;
    },
    interpolation: {
      escapeValue: true,
      format: (value) => value,
      prefix: "{{",
      suffix: "}}",
      formatSeparator: ",",
      unescapePrefix: "-",
      nestingPrefix: "$t(",
      nestingSuffix: ")",
      nestingOptionsSeparator: ",",
      maxReplaces: 1e3,
      skipOnVariables: true
    }
  };
}
function transformOptions(options) {
  if (typeof options.ns === "string")
    options.ns = [options.ns];
  if (typeof options.fallbackLng === "string")
    options.fallbackLng = [options.fallbackLng];
  if (typeof options.fallbackNS === "string")
    options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs && options.supportedLngs.indexOf("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  return options;
}
function noop() {
}
function bindMemberFunctions(inst) {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
}
var I18n = class extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initImmediate) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (typeof options.ns === "string") {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    if (this.options.compatibilityAPI !== "v1") {
      this.options.interpolation = {
        ...defOpts.interpolation,
        ...this.options.interpolation
      };
    }
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    function createClassOnDemand(ClassOrObject) {
      if (!ClassOrObject)
        return null;
      if (typeof ClassOrObject === "function")
        return new ClassOrObject();
      return ClassOrObject;
    }
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else if (typeof Intl !== "undefined") {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s = this.services;
      s.logger = baseLogger;
      s.resourceStore = this.store;
      s.languageUtils = lu;
      s.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        compatibilityJSON: this.options.compatibilityJSON,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s.formatter = createClassOnDemand(formatter);
        s.formatter.init(s, this.options);
        this.options.interpolation.format = s.formatter.format.bind(s.formatter);
      }
      s.interpolator = new Interpolator(this.options);
      s.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s.resourceStore, s, this.options);
      s.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s.languageDetector.init)
          s.languageDetector.init(s, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s.i18nFormat.init)
          s.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m) => {
        if (m.init)
          m.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback)
      callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev")
        this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce)
          this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone)
          this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && this.options.compatibilityAPI !== "v1" && !this.isInitialized)
        return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initImmediate) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = typeof language === "string" ? language : this.language;
    if (typeof language === "function")
      usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng && usedLng.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0))
        return usedCallback();
      const toLoad = [];
      const append2 = (lng) => {
        if (!lng)
          return;
        if (lng === "cimode")
          return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l) => {
          if (l === "cimode")
            return;
          if (toLoad.indexOf(l) < 0)
            toLoad.push(l);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l) => append2(l));
      } else {
        append2(usedLng);
      }
      if (this.options.preload) {
        this.options.preload.forEach((l) => append2(l));
      }
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language)
          this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (!lngs)
      lngs = this.languages;
    if (!ns)
      ns = this.options.ns;
    if (!callback)
      callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module2) {
    if (!module2)
      throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module2.type)
      throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module2.type === "backend") {
      this.modules.backend = module2;
    }
    if (module2.type === "logger" || module2.log && module2.warn && module2.error) {
      this.modules.logger = module2;
    }
    if (module2.type === "languageDetector") {
      this.modules.languageDetector = module2;
    }
    if (module2.type === "i18nFormat") {
      this.modules.i18nFormat = module2;
    }
    if (module2.type === "postProcessor") {
      postProcessor.addPostProcessor(module2);
    }
    if (module2.type === "formatter") {
      this.modules.formatter = module2;
    }
    if (module2.type === "3rdParty") {
      this.modules.external.push(module2);
    }
    return this;
  }
  setResolvedLanguage(l) {
    if (!l || !this.languages)
      return;
    if (["cimode", "dev"].indexOf(l) > -1)
      return;
    for (let li = 0; li < this.languages.length; li++) {
      const lngInLngs = this.languages[li];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1)
        continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l) => {
      this.language = l;
      this.languages = this.services.languageUtils.toResolveHierarchy(l);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l);
    };
    const done = (err, l) => {
      if (l) {
        setLngProps(l);
        this.translator.changeLanguage(l);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l);
        this.logger.log("languageChanged", l);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback)
        callback(err, function() {
          return _this2.t(...arguments);
        });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector)
        lngs = [];
      const l = typeof lngs === "string" ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l) {
        if (!this.language) {
          setLngProps(l);
        }
        if (!this.translator.language)
          this.translator.changeLanguage(l);
        if (this.services.languageDetector && this.services.languageDetector.cacheUserLanguage)
          this.services.languageDetector.cacheUserLanguage(l);
      }
      this.loadResources(l, (err) => {
        done(err, l);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k) => `${options.keyPrefix}${keySeparator}${k}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (typeof lng === "string") {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    return this.translator && this.translator.translate(...arguments);
  }
  exists() {
    return this.translator && this.translator.exists(...arguments);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode")
      return true;
    const loadNotPending = (l, n) => {
      const loadState = this.services.backendConnector.state[`${l}|${n}`];
      return loadState === -1 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0)
        return preResult;
    }
    if (this.hasResourceBundle(lng, ns))
      return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages)
      return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns)))
      return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    if (typeof ns === "string")
      ns = [ns];
    ns.forEach((n) => {
      if (this.options.ns.indexOf(n) < 0)
        this.options.ns.push(n);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (typeof lngs === "string")
      lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0);
    if (!newLngs.length) {
      if (callback)
        callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback)
        callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng)
      lng = this.resolvedLanguage || (this.languages && this.languages.length > 0 ? this.languages[0] : this.language);
    if (!lng)
      return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services && this.services.languageUtils || new LanguageUtil(get());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore)
      delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m) => {
      clone[m] = this[m];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
};
var instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
var createInstance = instance.createInstance;
var dir = instance.dir;
var init = instance.init;
var loadResources = instance.loadResources;
var reloadResources = instance.reloadResources;
var use = instance.use;
var changeLanguage = instance.changeLanguage;
var getFixedT = instance.getFixedT;
var t = instance.t;
var exists = instance.exists;
var setDefaultNamespace = instance.setDefaultNamespace;
var hasLoadedNamespace = instance.hasLoadedNamespace;
var loadNamespaces = instance.loadNamespaces;
var loadLanguages = instance.loadLanguages;

// src/libs/translations/en.json
var en_exports = {};
__export(en_exports, {
  default: () => en_default,
  translation: () => translation
});
var translation = {
  settings: {
    "toggle-sound": {
      name: "Toggle sound"
    },
    volume: {
      name: "Volume",
      desc: "Adjust key sound volume."
    },
    resource: "Sound resource",
    scheme: {
      name: "Sound scheme",
      default: "Default"
    },
    download: {
      name: "Download resources",
      desc: "Download resources from GitHub release. Please refresh the scheme list after downloaded.",
      button: "Download"
    }
  }
};
var en_default = {
  translation
};

// src/libs/translations/zh-CN.json
var zh_CN_exports = {};
__export(zh_CN_exports, {
  default: () => zh_CN_default,
  translation: () => translation2
});
var translation2 = {
  settings: {
    "toggle-sound": {
      name: "\u5F00\u542F/\u5173\u95ED\u58F0\u97F3"
    },
    volume: {
      name: "\u97F3\u91CF",
      desc: "\u8C03\u6574\u6309\u952E\u97F3\u6548\u97F3\u91CF\u3002"
    },
    resource: "\u58F0\u97F3\u8D44\u6E90",
    scheme: {
      name: "\u97F3\u6548\u4E3B\u9898",
      default: "\u9ED8\u8BA4"
    },
    download: {
      name: "\u4E0B\u8F7D\u58F0\u97F3\u8D44\u6E90",
      desc: "\u4ECE GitHub release \u4E0B\u8F7D\u97F3\u6548\u8D44\u6E90\u3002\u4E0B\u8F7D\u5B8C\u6210\u540E\u8BF7\u5237\u65B0\u97F3\u6548\u4E3B\u9898\u5217\u8868\u3002",
      button: "\u4E0B\u8F7D"
    }
  }
};
var zh_CN_default = {
  translation: translation2
};

// src/libs/i18n.ts
var import_obsidian = require("obsidian");
instance.init({
  lng: import_obsidian.moment.locale(),
  fallbackLng: {
    "zh-TW": ["zh-CN", "en"],
    default: ["en"]
  },
  resources: {
    en: en_exports,
    "zh-CN": zh_CN_exports
  }
});
var i18n = instance;

// src/fetchHelper.ts
var import_obsidian2 = require("obsidian");

// node_modules/@zip.js/zip.js/lib/core/streams/codecs/deflate.js
var MAX_BITS = 15;
var D_CODES = 30;
var BL_CODES = 19;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var HEAP_SIZE = 2 * L_CODES + 1;
var END_BLOCK = 256;
var MAX_BL_BITS = 7;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var Buf_size = 8 * 2;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_DEFAULT_STRATEGY = 0;
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_BUF_ERROR = -5;
function extractArray(array) {
  return flatArray(array.map(([length, value]) => new Array(length).fill(value, 0, length)));
}
function flatArray(array) {
  return array.reduce((a, b) => a.concat(Array.isArray(b) ? flatArray(b) : b), []);
}
var _dist_code = [0, 1, 2, 3].concat(...extractArray([
  [2, 4],
  [2, 5],
  [4, 6],
  [4, 7],
  [8, 8],
  [8, 9],
  [16, 10],
  [16, 11],
  [32, 12],
  [32, 13],
  [64, 14],
  [64, 15],
  [2, 0],
  [1, 16],
  [1, 17],
  [2, 18],
  [2, 19],
  [4, 20],
  [4, 21],
  [8, 22],
  [8, 23],
  [16, 24],
  [16, 25],
  [32, 26],
  [32, 27],
  [64, 28],
  [64, 29]
]));
function Tree() {
  const that = this;
  function gen_bitlen(s) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const extra = that.stat_desc.extra_bits;
    const base = that.stat_desc.extra_base;
    const max_length = that.stat_desc.max_length;
    let h;
    let n, m;
    let bits;
    let xbits;
    let f;
    let overflow = 0;
    for (bits = 0; bits <= MAX_BITS; bits++)
      s.bl_count[bits] = 0;
    tree[s.heap[s.heap_max] * 2 + 1] = 0;
    for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
      n = s.heap[h];
      bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
      if (bits > max_length) {
        bits = max_length;
        overflow++;
      }
      tree[n * 2 + 1] = bits;
      if (n > that.max_code)
        continue;
      s.bl_count[bits]++;
      xbits = 0;
      if (n >= base)
        xbits = extra[n - base];
      f = tree[n * 2];
      s.opt_len += f * (bits + xbits);
      if (stree)
        s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
    if (overflow === 0)
      return;
    do {
      bits = max_length - 1;
      while (s.bl_count[bits] === 0)
        bits--;
      s.bl_count[bits]--;
      s.bl_count[bits + 1] += 2;
      s.bl_count[max_length]--;
      overflow -= 2;
    } while (overflow > 0);
    for (bits = max_length; bits !== 0; bits--) {
      n = s.bl_count[bits];
      while (n !== 0) {
        m = s.heap[--h];
        if (m > that.max_code)
          continue;
        if (tree[m * 2 + 1] != bits) {
          s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
          tree[m * 2 + 1] = bits;
        }
        n--;
      }
    }
  }
  function bi_reverse(code, len) {
    let res = 0;
    do {
      res |= code & 1;
      code >>>= 1;
      res <<= 1;
    } while (--len > 0);
    return res >>> 1;
  }
  function gen_codes(tree, max_code, bl_count) {
    const next_code = [];
    let code = 0;
    let bits;
    let n;
    let len;
    for (bits = 1; bits <= MAX_BITS; bits++) {
      next_code[bits] = code = code + bl_count[bits - 1] << 1;
    }
    for (n = 0; n <= max_code; n++) {
      len = tree[n * 2 + 1];
      if (len === 0)
        continue;
      tree[n * 2] = bi_reverse(next_code[len]++, len);
    }
  }
  that.build_tree = function(s) {
    const tree = that.dyn_tree;
    const stree = that.stat_desc.static_tree;
    const elems = that.stat_desc.elems;
    let n, m;
    let max_code = -1;
    let node;
    s.heap_len = 0;
    s.heap_max = HEAP_SIZE;
    for (n = 0; n < elems; n++) {
      if (tree[n * 2] !== 0) {
        s.heap[++s.heap_len] = max_code = n;
        s.depth[n] = 0;
      } else {
        tree[n * 2 + 1] = 0;
      }
    }
    while (s.heap_len < 2) {
      node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
      tree[node * 2] = 1;
      s.depth[node] = 0;
      s.opt_len--;
      if (stree)
        s.static_len -= stree[node * 2 + 1];
    }
    that.max_code = max_code;
    for (n = Math.floor(s.heap_len / 2); n >= 1; n--)
      s.pqdownheap(tree, n);
    node = elems;
    do {
      n = s.heap[1];
      s.heap[1] = s.heap[s.heap_len--];
      s.pqdownheap(tree, 1);
      m = s.heap[1];
      s.heap[--s.heap_max] = n;
      s.heap[--s.heap_max] = m;
      tree[node * 2] = tree[n * 2] + tree[m * 2];
      s.depth[node] = Math.max(s.depth[n], s.depth[m]) + 1;
      tree[n * 2 + 1] = tree[m * 2 + 1] = node;
      s.heap[1] = node++;
      s.pqdownheap(tree, 1);
    } while (s.heap_len >= 2);
    s.heap[--s.heap_max] = s.heap[1];
    gen_bitlen(s);
    gen_codes(tree, that.max_code, s.bl_count);
  };
}
Tree._length_code = [0, 1, 2, 3, 4, 5, 6, 7].concat(...extractArray([
  [2, 8],
  [2, 9],
  [2, 10],
  [2, 11],
  [4, 12],
  [4, 13],
  [4, 14],
  [4, 15],
  [8, 16],
  [8, 17],
  [8, 18],
  [8, 19],
  [16, 20],
  [16, 21],
  [16, 22],
  [16, 23],
  [32, 24],
  [32, 25],
  [32, 26],
  [31, 27],
  [1, 28]
]));
Tree.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0];
Tree.base_dist = [
  0,
  1,
  2,
  3,
  4,
  6,
  8,
  12,
  16,
  24,
  32,
  48,
  64,
  96,
  128,
  192,
  256,
  384,
  512,
  768,
  1024,
  1536,
  2048,
  3072,
  4096,
  6144,
  8192,
  12288,
  16384,
  24576
];
Tree.d_code = function(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
};
Tree.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
Tree.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
Tree.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
Tree.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
function StaticTree(static_tree, extra_bits, extra_base, elems, max_length) {
  const that = this;
  that.static_tree = static_tree;
  that.extra_bits = extra_bits;
  that.extra_base = extra_base;
  that.elems = elems;
  that.max_length = max_length;
}
var static_ltree2_first_part = [
  12,
  140,
  76,
  204,
  44,
  172,
  108,
  236,
  28,
  156,
  92,
  220,
  60,
  188,
  124,
  252,
  2,
  130,
  66,
  194,
  34,
  162,
  98,
  226,
  18,
  146,
  82,
  210,
  50,
  178,
  114,
  242,
  10,
  138,
  74,
  202,
  42,
  170,
  106,
  234,
  26,
  154,
  90,
  218,
  58,
  186,
  122,
  250,
  6,
  134,
  70,
  198,
  38,
  166,
  102,
  230,
  22,
  150,
  86,
  214,
  54,
  182,
  118,
  246,
  14,
  142,
  78,
  206,
  46,
  174,
  110,
  238,
  30,
  158,
  94,
  222,
  62,
  190,
  126,
  254,
  1,
  129,
  65,
  193,
  33,
  161,
  97,
  225,
  17,
  145,
  81,
  209,
  49,
  177,
  113,
  241,
  9,
  137,
  73,
  201,
  41,
  169,
  105,
  233,
  25,
  153,
  89,
  217,
  57,
  185,
  121,
  249,
  5,
  133,
  69,
  197,
  37,
  165,
  101,
  229,
  21,
  149,
  85,
  213,
  53,
  181,
  117,
  245,
  13,
  141,
  77,
  205,
  45,
  173,
  109,
  237,
  29,
  157,
  93,
  221,
  61,
  189,
  125,
  253,
  19,
  275,
  147,
  403,
  83,
  339,
  211,
  467,
  51,
  307,
  179,
  435,
  115,
  371,
  243,
  499,
  11,
  267,
  139,
  395,
  75,
  331,
  203,
  459,
  43,
  299,
  171,
  427,
  107,
  363,
  235,
  491,
  27,
  283,
  155,
  411,
  91,
  347,
  219,
  475,
  59,
  315,
  187,
  443,
  123,
  379,
  251,
  507,
  7,
  263,
  135,
  391,
  71,
  327,
  199,
  455,
  39,
  295,
  167,
  423,
  103,
  359,
  231,
  487,
  23,
  279,
  151,
  407,
  87,
  343,
  215,
  471,
  55,
  311,
  183,
  439,
  119,
  375,
  247,
  503,
  15,
  271,
  143,
  399,
  79,
  335,
  207,
  463,
  47,
  303,
  175,
  431,
  111,
  367,
  239,
  495,
  31,
  287,
  159,
  415,
  95,
  351,
  223,
  479,
  63,
  319,
  191,
  447,
  127,
  383,
  255,
  511,
  0,
  64,
  32,
  96,
  16,
  80,
  48,
  112,
  8,
  72,
  40,
  104,
  24,
  88,
  56,
  120,
  4,
  68,
  36,
  100,
  20,
  84,
  52,
  116,
  3,
  131,
  67,
  195,
  35,
  163,
  99,
  227
];
var static_ltree2_second_part = extractArray([[144, 8], [112, 9], [24, 7], [8, 8]]);
StaticTree.static_ltree = flatArray(static_ltree2_first_part.map((value, index) => [value, static_ltree2_second_part[index]]));
var static_dtree_first_part = [0, 16, 8, 24, 4, 20, 12, 28, 2, 18, 10, 26, 6, 22, 14, 30, 1, 17, 9, 25, 5, 21, 13, 29, 3, 19, 11, 27, 7, 23];
var static_dtree_second_part = extractArray([[30, 5]]);
StaticTree.static_dtree = flatArray(static_dtree_first_part.map((value, index) => [value, static_dtree_second_part[index]]));
StaticTree.static_l_desc = new StaticTree(StaticTree.static_ltree, Tree.extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
StaticTree.static_d_desc = new StaticTree(StaticTree.static_dtree, Tree.extra_dbits, 0, D_CODES, MAX_BITS);
StaticTree.static_bl_desc = new StaticTree(null, Tree.extra_blbits, 0, BL_CODES, MAX_BL_BITS);
var MAX_MEM_LEVEL = 9;
var DEF_MEM_LEVEL = 8;
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  const that = this;
  that.good_length = good_length;
  that.max_lazy = max_lazy;
  that.nice_length = nice_length;
  that.max_chain = max_chain;
  that.func = func;
}
var STORED = 0;
var FAST = 1;
var SLOW = 2;
var config_table = [
  new Config(0, 0, 0, 0, STORED),
  new Config(4, 4, 8, 4, FAST),
  new Config(4, 5, 16, 8, FAST),
  new Config(4, 6, 32, 32, FAST),
  new Config(4, 4, 16, 16, SLOW),
  new Config(8, 16, 32, 32, SLOW),
  new Config(8, 16, 128, 128, SLOW),
  new Config(8, 32, 128, 256, SLOW),
  new Config(32, 128, 258, 1024, SLOW),
  new Config(32, 258, 258, 4096, SLOW)
];
var z_errmsg = [
  "need dictionary",
  // Z_NEED_DICT
  // 2
  "stream end",
  // Z_STREAM_END 1
  "",
  // Z_OK 0
  "",
  // Z_ERRNO (-1)
  "stream error",
  // Z_STREAM_ERROR (-2)
  "data error",
  // Z_DATA_ERROR (-3)
  "",
  // Z_MEM_ERROR (-4)
  "buffer error",
  // Z_BUF_ERROR (-5)
  "",
  // Z_VERSION_ERROR (-6)
  ""
];
var NeedMore = 0;
var BlockDone = 1;
var FinishStarted = 2;
var FinishDone = 3;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var Z_DEFLATED = 8;
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
function smaller(tree, n, m, depth) {
  const tn2 = tree[n * 2];
  const tm2 = tree[m * 2];
  return tn2 < tm2 || tn2 == tm2 && depth[n] <= depth[m];
}
function Deflate() {
  const that = this;
  let strm;
  let status;
  let pending_buf_size;
  let last_flush;
  let w_size;
  let w_bits;
  let w_mask;
  let win;
  let window_size;
  let prev;
  let head;
  let ins_h;
  let hash_size;
  let hash_bits;
  let hash_mask;
  let hash_shift;
  let block_start;
  let match_length;
  let prev_match;
  let match_available;
  let strstart;
  let match_start;
  let lookahead;
  let prev_length;
  let max_chain_length;
  let max_lazy_match;
  let level;
  let strategy;
  let good_match;
  let nice_match;
  let dyn_ltree;
  let dyn_dtree;
  let bl_tree;
  const l_desc = new Tree();
  const d_desc = new Tree();
  const bl_desc = new Tree();
  that.depth = [];
  let lit_bufsize;
  let last_lit;
  let matches;
  let last_eob_len;
  let bi_buf;
  let bi_valid;
  that.bl_count = [];
  that.heap = [];
  dyn_ltree = [];
  dyn_dtree = [];
  bl_tree = [];
  function lm_init() {
    window_size = 2 * w_size;
    head[hash_size - 1] = 0;
    for (let i = 0; i < hash_size - 1; i++) {
      head[i] = 0;
    }
    max_lazy_match = config_table[level].max_lazy;
    good_match = config_table[level].good_length;
    nice_match = config_table[level].nice_length;
    max_chain_length = config_table[level].max_chain;
    strstart = 0;
    block_start = 0;
    lookahead = 0;
    match_length = prev_length = MIN_MATCH - 1;
    match_available = 0;
    ins_h = 0;
  }
  function init_block() {
    let i;
    for (i = 0; i < L_CODES; i++)
      dyn_ltree[i * 2] = 0;
    for (i = 0; i < D_CODES; i++)
      dyn_dtree[i * 2] = 0;
    for (i = 0; i < BL_CODES; i++)
      bl_tree[i * 2] = 0;
    dyn_ltree[END_BLOCK * 2] = 1;
    that.opt_len = that.static_len = 0;
    last_lit = matches = 0;
  }
  function tr_init() {
    l_desc.dyn_tree = dyn_ltree;
    l_desc.stat_desc = StaticTree.static_l_desc;
    d_desc.dyn_tree = dyn_dtree;
    d_desc.stat_desc = StaticTree.static_d_desc;
    bl_desc.dyn_tree = bl_tree;
    bl_desc.stat_desc = StaticTree.static_bl_desc;
    bi_buf = 0;
    bi_valid = 0;
    last_eob_len = 8;
    init_block();
  }
  that.pqdownheap = function(tree, k) {
    const heap = that.heap;
    const v = heap[k];
    let j = k << 1;
    while (j <= that.heap_len) {
      if (j < that.heap_len && smaller(tree, heap[j + 1], heap[j], that.depth)) {
        j++;
      }
      if (smaller(tree, v, heap[j], that.depth))
        break;
      heap[k] = heap[j];
      k = j;
      j <<= 1;
    }
    heap[k] = v;
  };
  function scan_tree(tree, max_code) {
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    tree[(max_code + 1) * 2 + 1] = 65535;
    for (let n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        bl_tree[curlen * 2] += count;
      } else if (curlen !== 0) {
        if (curlen != prevlen)
          bl_tree[curlen * 2]++;
        bl_tree[REP_3_6 * 2]++;
      } else if (count <= 10) {
        bl_tree[REPZ_3_10 * 2]++;
      } else {
        bl_tree[REPZ_11_138 * 2]++;
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function build_bl_tree() {
    let max_blindex;
    scan_tree(dyn_ltree, l_desc.max_code);
    scan_tree(dyn_dtree, d_desc.max_code);
    bl_desc.build_tree(that);
    for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
      if (bl_tree[Tree.bl_order[max_blindex] * 2 + 1] !== 0)
        break;
    }
    that.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
    return max_blindex;
  }
  function put_byte(p) {
    that.pending_buf[that.pending++] = p;
  }
  function put_short(w) {
    put_byte(w & 255);
    put_byte(w >>> 8 & 255);
  }
  function putShortMSB(b) {
    put_byte(b >> 8 & 255);
    put_byte(b & 255 & 255);
  }
  function send_bits(value, length) {
    let val;
    const len = length;
    if (bi_valid > Buf_size - len) {
      val = value;
      bi_buf |= val << bi_valid & 65535;
      put_short(bi_buf);
      bi_buf = val >>> Buf_size - bi_valid;
      bi_valid += len - Buf_size;
    } else {
      bi_buf |= value << bi_valid & 65535;
      bi_valid += len;
    }
  }
  function send_code(c, tree) {
    const c2 = c * 2;
    send_bits(tree[c2] & 65535, tree[c2 + 1] & 65535);
  }
  function send_tree(tree, max_code) {
    let n;
    let prevlen = -1;
    let curlen;
    let nextlen = tree[0 * 2 + 1];
    let count = 0;
    let max_count = 7;
    let min_count = 4;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    }
    for (n = 0; n <= max_code; n++) {
      curlen = nextlen;
      nextlen = tree[(n + 1) * 2 + 1];
      if (++count < max_count && curlen == nextlen) {
        continue;
      } else if (count < min_count) {
        do {
          send_code(curlen, bl_tree);
        } while (--count !== 0);
      } else if (curlen !== 0) {
        if (curlen != prevlen) {
          send_code(curlen, bl_tree);
          count--;
        }
        send_code(REP_3_6, bl_tree);
        send_bits(count - 3, 2);
      } else if (count <= 10) {
        send_code(REPZ_3_10, bl_tree);
        send_bits(count - 3, 3);
      } else {
        send_code(REPZ_11_138, bl_tree);
        send_bits(count - 11, 7);
      }
      count = 0;
      prevlen = curlen;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      } else if (curlen == nextlen) {
        max_count = 6;
        min_count = 3;
      } else {
        max_count = 7;
        min_count = 4;
      }
    }
  }
  function send_all_trees(lcodes, dcodes, blcodes) {
    let rank;
    send_bits(lcodes - 257, 5);
    send_bits(dcodes - 1, 5);
    send_bits(blcodes - 4, 4);
    for (rank = 0; rank < blcodes; rank++) {
      send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1], 3);
    }
    send_tree(dyn_ltree, lcodes - 1);
    send_tree(dyn_dtree, dcodes - 1);
  }
  function bi_flush() {
    if (bi_valid == 16) {
      put_short(bi_buf);
      bi_buf = 0;
      bi_valid = 0;
    } else if (bi_valid >= 8) {
      put_byte(bi_buf & 255);
      bi_buf >>>= 8;
      bi_valid -= 8;
    }
  }
  function _tr_align() {
    send_bits(STATIC_TREES << 1, 3);
    send_code(END_BLOCK, StaticTree.static_ltree);
    bi_flush();
    if (1 + last_eob_len + 10 - bi_valid < 9) {
      send_bits(STATIC_TREES << 1, 3);
      send_code(END_BLOCK, StaticTree.static_ltree);
      bi_flush();
    }
    last_eob_len = 7;
  }
  function _tr_tally(dist, lc) {
    let out_length, in_length, dcode;
    that.dist_buf[last_lit] = dist;
    that.lc_buf[last_lit] = lc & 255;
    last_lit++;
    if (dist === 0) {
      dyn_ltree[lc * 2]++;
    } else {
      matches++;
      dist--;
      dyn_ltree[(Tree._length_code[lc] + LITERALS + 1) * 2]++;
      dyn_dtree[Tree.d_code(dist) * 2]++;
    }
    if ((last_lit & 8191) === 0 && level > 2) {
      out_length = last_lit * 8;
      in_length = strstart - block_start;
      for (dcode = 0; dcode < D_CODES; dcode++) {
        out_length += dyn_dtree[dcode * 2] * (5 + Tree.extra_dbits[dcode]);
      }
      out_length >>>= 3;
      if (matches < Math.floor(last_lit / 2) && out_length < Math.floor(in_length / 2))
        return true;
    }
    return last_lit == lit_bufsize - 1;
  }
  function compress_block(ltree, dtree) {
    let dist;
    let lc;
    let lx = 0;
    let code;
    let extra;
    if (last_lit !== 0) {
      do {
        dist = that.dist_buf[lx];
        lc = that.lc_buf[lx];
        lx++;
        if (dist === 0) {
          send_code(lc, ltree);
        } else {
          code = Tree._length_code[lc];
          send_code(code + LITERALS + 1, ltree);
          extra = Tree.extra_lbits[code];
          if (extra !== 0) {
            lc -= Tree.base_length[code];
            send_bits(lc, extra);
          }
          dist--;
          code = Tree.d_code(dist);
          send_code(code, dtree);
          extra = Tree.extra_dbits[code];
          if (extra !== 0) {
            dist -= Tree.base_dist[code];
            send_bits(dist, extra);
          }
        }
      } while (lx < last_lit);
    }
    send_code(END_BLOCK, ltree);
    last_eob_len = ltree[END_BLOCK * 2 + 1];
  }
  function bi_windup() {
    if (bi_valid > 8) {
      put_short(bi_buf);
    } else if (bi_valid > 0) {
      put_byte(bi_buf & 255);
    }
    bi_buf = 0;
    bi_valid = 0;
  }
  function copy_block(buf, len, header) {
    bi_windup();
    last_eob_len = 8;
    if (header) {
      put_short(len);
      put_short(~len);
    }
    that.pending_buf.set(win.subarray(buf, buf + len), that.pending);
    that.pending += len;
  }
  function _tr_stored_block(buf, stored_len, eof) {
    send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0), 3);
    copy_block(buf, stored_len, true);
  }
  function _tr_flush_block(buf, stored_len, eof) {
    let opt_lenb, static_lenb;
    let max_blindex = 0;
    if (level > 0) {
      l_desc.build_tree(that);
      d_desc.build_tree(that);
      max_blindex = build_bl_tree();
      opt_lenb = that.opt_len + 3 + 7 >>> 3;
      static_lenb = that.static_len + 3 + 7 >>> 3;
      if (static_lenb <= opt_lenb)
        opt_lenb = static_lenb;
    } else {
      opt_lenb = static_lenb = stored_len + 5;
    }
    if (stored_len + 4 <= opt_lenb && buf != -1) {
      _tr_stored_block(buf, stored_len, eof);
    } else if (static_lenb == opt_lenb) {
      send_bits((STATIC_TREES << 1) + (eof ? 1 : 0), 3);
      compress_block(StaticTree.static_ltree, StaticTree.static_dtree);
    } else {
      send_bits((DYN_TREES << 1) + (eof ? 1 : 0), 3);
      send_all_trees(l_desc.max_code + 1, d_desc.max_code + 1, max_blindex + 1);
      compress_block(dyn_ltree, dyn_dtree);
    }
    init_block();
    if (eof) {
      bi_windup();
    }
  }
  function flush_block_only(eof) {
    _tr_flush_block(block_start >= 0 ? block_start : -1, strstart - block_start, eof);
    block_start = strstart;
    strm.flush_pending();
  }
  function fill_window() {
    let n, m;
    let p;
    let more;
    do {
      more = window_size - lookahead - strstart;
      if (more === 0 && strstart === 0 && lookahead === 0) {
        more = w_size;
      } else if (more == -1) {
        more--;
      } else if (strstart >= w_size + w_size - MIN_LOOKAHEAD) {
        win.set(win.subarray(w_size, w_size + w_size), 0);
        match_start -= w_size;
        strstart -= w_size;
        block_start -= w_size;
        n = hash_size;
        p = n;
        do {
          m = head[--p] & 65535;
          head[p] = m >= w_size ? m - w_size : 0;
        } while (--n !== 0);
        n = w_size;
        p = n;
        do {
          m = prev[--p] & 65535;
          prev[p] = m >= w_size ? m - w_size : 0;
        } while (--n !== 0);
        more += w_size;
      }
      if (strm.avail_in === 0)
        return;
      n = strm.read_buf(win, strstart + lookahead, more);
      lookahead += n;
      if (lookahead >= MIN_MATCH) {
        ins_h = win[strstart] & 255;
        ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
      }
    } while (lookahead < MIN_LOOKAHEAD && strm.avail_in !== 0);
  }
  function deflate_stored(flush) {
    let max_block_size = 65535;
    let max_start;
    if (max_block_size > pending_buf_size - 5) {
      max_block_size = pending_buf_size - 5;
    }
    while (true) {
      if (lookahead <= 1) {
        fill_window();
        if (lookahead === 0 && flush == Z_NO_FLUSH)
          return NeedMore;
        if (lookahead === 0)
          break;
      }
      strstart += lookahead;
      lookahead = 0;
      max_start = block_start + max_block_size;
      if (strstart === 0 || strstart >= max_start) {
        lookahead = strstart - max_start;
        strstart = max_start;
        flush_block_only(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
      if (strstart - block_start >= w_size - MIN_LOOKAHEAD) {
        flush_block_only(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only(flush == Z_FINISH);
    if (strm.avail_out === 0)
      return flush == Z_FINISH ? FinishStarted : NeedMore;
    return flush == Z_FINISH ? FinishDone : BlockDone;
  }
  function longest_match(cur_match) {
    let chain_length = max_chain_length;
    let scan = strstart;
    let match;
    let len;
    let best_len = prev_length;
    const limit = strstart > w_size - MIN_LOOKAHEAD ? strstart - (w_size - MIN_LOOKAHEAD) : 0;
    let _nice_match = nice_match;
    const wmask = w_mask;
    const strend = strstart + MAX_MATCH;
    let scan_end1 = win[scan + best_len - 1];
    let scan_end = win[scan + best_len];
    if (prev_length >= good_match) {
      chain_length >>= 2;
    }
    if (_nice_match > lookahead)
      _nice_match = lookahead;
    do {
      match = cur_match;
      if (win[match + best_len] != scan_end || win[match + best_len - 1] != scan_end1 || win[match] != win[scan] || win[++match] != win[scan + 1])
        continue;
      scan += 2;
      match++;
      do {
      } while (win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && win[++scan] == win[++match] && scan < strend);
      len = MAX_MATCH - (strend - scan);
      scan = strend - MAX_MATCH;
      if (len > best_len) {
        match_start = cur_match;
        best_len = len;
        if (len >= _nice_match)
          break;
        scan_end1 = win[scan + best_len - 1];
        scan_end = win[scan + best_len];
      }
    } while ((cur_match = prev[cur_match & wmask] & 65535) > limit && --chain_length !== 0);
    if (best_len <= lookahead)
      return best_len;
    return lookahead;
  }
  function deflate_fast(flush) {
    let hash_head = 0;
    let bflush;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD) {
        fill_window();
        if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      if (hash_head !== 0 && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
        if (strategy != Z_HUFFMAN_ONLY) {
          match_length = longest_match(hash_head);
        }
      }
      if (match_length >= MIN_MATCH) {
        bflush = _tr_tally(strstart - match_start, match_length - MIN_MATCH);
        lookahead -= match_length;
        if (match_length <= max_lazy_match && lookahead >= MIN_MATCH) {
          match_length--;
          do {
            strstart++;
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          } while (--match_length !== 0);
          strstart++;
        } else {
          strstart += match_length;
          match_length = 0;
          ins_h = win[strstart] & 255;
          ins_h = (ins_h << hash_shift ^ win[strstart + 1] & 255) & hash_mask;
        }
      } else {
        bflush = _tr_tally(0, win[strstart] & 255);
        lookahead--;
        strstart++;
      }
      if (bflush) {
        flush_block_only(false);
        if (strm.avail_out === 0)
          return NeedMore;
      }
    }
    flush_block_only(flush == Z_FINISH);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH ? FinishDone : BlockDone;
  }
  function deflate_slow(flush) {
    let hash_head = 0;
    let bflush;
    let max_insert;
    while (true) {
      if (lookahead < MIN_LOOKAHEAD) {
        fill_window();
        if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
          return NeedMore;
        }
        if (lookahead === 0)
          break;
      }
      if (lookahead >= MIN_MATCH) {
        ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
        hash_head = head[ins_h] & 65535;
        prev[strstart & w_mask] = head[ins_h];
        head[ins_h] = strstart;
      }
      prev_length = match_length;
      prev_match = match_start;
      match_length = MIN_MATCH - 1;
      if (hash_head !== 0 && prev_length < max_lazy_match && (strstart - hash_head & 65535) <= w_size - MIN_LOOKAHEAD) {
        if (strategy != Z_HUFFMAN_ONLY) {
          match_length = longest_match(hash_head);
        }
        if (match_length <= 5 && (strategy == Z_FILTERED || match_length == MIN_MATCH && strstart - match_start > 4096)) {
          match_length = MIN_MATCH - 1;
        }
      }
      if (prev_length >= MIN_MATCH && match_length <= prev_length) {
        max_insert = strstart + lookahead - MIN_MATCH;
        bflush = _tr_tally(strstart - 1 - prev_match, prev_length - MIN_MATCH);
        lookahead -= prev_length - 1;
        prev_length -= 2;
        do {
          if (++strstart <= max_insert) {
            ins_h = (ins_h << hash_shift ^ win[strstart + (MIN_MATCH - 1)] & 255) & hash_mask;
            hash_head = head[ins_h] & 65535;
            prev[strstart & w_mask] = head[ins_h];
            head[ins_h] = strstart;
          }
        } while (--prev_length !== 0);
        match_available = 0;
        match_length = MIN_MATCH - 1;
        strstart++;
        if (bflush) {
          flush_block_only(false);
          if (strm.avail_out === 0)
            return NeedMore;
        }
      } else if (match_available !== 0) {
        bflush = _tr_tally(0, win[strstart - 1] & 255);
        if (bflush) {
          flush_block_only(false);
        }
        strstart++;
        lookahead--;
        if (strm.avail_out === 0)
          return NeedMore;
      } else {
        match_available = 1;
        strstart++;
        lookahead--;
      }
    }
    if (match_available !== 0) {
      bflush = _tr_tally(0, win[strstart - 1] & 255);
      match_available = 0;
    }
    flush_block_only(flush == Z_FINISH);
    if (strm.avail_out === 0) {
      if (flush == Z_FINISH)
        return FinishStarted;
      else
        return NeedMore;
    }
    return flush == Z_FINISH ? FinishDone : BlockDone;
  }
  function deflateReset(strm2) {
    strm2.total_in = strm2.total_out = 0;
    strm2.msg = null;
    that.pending = 0;
    that.pending_out = 0;
    status = BUSY_STATE;
    last_flush = Z_NO_FLUSH;
    tr_init();
    lm_init();
    return Z_OK;
  }
  that.deflateInit = function(strm2, _level, bits, _method, memLevel, _strategy) {
    if (!_method)
      _method = Z_DEFLATED;
    if (!memLevel)
      memLevel = DEF_MEM_LEVEL;
    if (!_strategy)
      _strategy = Z_DEFAULT_STRATEGY;
    strm2.msg = null;
    if (_level == Z_DEFAULT_COMPRESSION)
      _level = 6;
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || _method != Z_DEFLATED || bits < 9 || bits > 15 || _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR;
    }
    strm2.dstate = that;
    w_bits = bits;
    w_size = 1 << w_bits;
    w_mask = w_size - 1;
    hash_bits = memLevel + 7;
    hash_size = 1 << hash_bits;
    hash_mask = hash_size - 1;
    hash_shift = Math.floor((hash_bits + MIN_MATCH - 1) / MIN_MATCH);
    win = new Uint8Array(w_size * 2);
    prev = [];
    head = [];
    lit_bufsize = 1 << memLevel + 6;
    that.pending_buf = new Uint8Array(lit_bufsize * 4);
    pending_buf_size = lit_bufsize * 4;
    that.dist_buf = new Uint16Array(lit_bufsize);
    that.lc_buf = new Uint8Array(lit_bufsize);
    level = _level;
    strategy = _strategy;
    return deflateReset(strm2);
  };
  that.deflateEnd = function() {
    if (status != INIT_STATE && status != BUSY_STATE && status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }
    that.lc_buf = null;
    that.dist_buf = null;
    that.pending_buf = null;
    head = null;
    prev = null;
    win = null;
    that.dstate = null;
    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
  };
  that.deflateParams = function(strm2, _level, _strategy) {
    let err = Z_OK;
    if (_level == Z_DEFAULT_COMPRESSION) {
      _level = 6;
    }
    if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {
      return Z_STREAM_ERROR;
    }
    if (config_table[level].func != config_table[_level].func && strm2.total_in !== 0) {
      err = strm2.deflate(Z_PARTIAL_FLUSH);
    }
    if (level != _level) {
      level = _level;
      max_lazy_match = config_table[level].max_lazy;
      good_match = config_table[level].good_length;
      nice_match = config_table[level].nice_length;
      max_chain_length = config_table[level].max_chain;
    }
    strategy = _strategy;
    return err;
  };
  that.deflateSetDictionary = function(_strm, dictionary, dictLength) {
    let length = dictLength;
    let n, index = 0;
    if (!dictionary || status != INIT_STATE)
      return Z_STREAM_ERROR;
    if (length < MIN_MATCH)
      return Z_OK;
    if (length > w_size - MIN_LOOKAHEAD) {
      length = w_size - MIN_LOOKAHEAD;
      index = dictLength - length;
    }
    win.set(dictionary.subarray(index, index + length), 0);
    strstart = length;
    block_start = length;
    ins_h = win[0] & 255;
    ins_h = (ins_h << hash_shift ^ win[1] & 255) & hash_mask;
    for (n = 0; n <= length - MIN_MATCH; n++) {
      ins_h = (ins_h << hash_shift ^ win[n + (MIN_MATCH - 1)] & 255) & hash_mask;
      prev[n & w_mask] = head[ins_h];
      head[ins_h] = n;
    }
    return Z_OK;
  };
  that.deflate = function(_strm, flush) {
    let i, header, level_flags, old_flush, bstate;
    if (flush > Z_FINISH || flush < 0) {
      return Z_STREAM_ERROR;
    }
    if (!_strm.next_out || !_strm.next_in && _strm.avail_in !== 0 || status == FINISH_STATE && flush != Z_FINISH) {
      _strm.msg = z_errmsg[Z_NEED_DICT - Z_STREAM_ERROR];
      return Z_STREAM_ERROR;
    }
    if (_strm.avail_out === 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
      return Z_BUF_ERROR;
    }
    strm = _strm;
    old_flush = last_flush;
    last_flush = flush;
    if (status == INIT_STATE) {
      header = Z_DEFLATED + (w_bits - 8 << 4) << 8;
      level_flags = (level - 1 & 255) >> 1;
      if (level_flags > 3)
        level_flags = 3;
      header |= level_flags << 6;
      if (strstart !== 0)
        header |= PRESET_DICT;
      header += 31 - header % 31;
      status = BUSY_STATE;
      putShortMSB(header);
    }
    if (that.pending !== 0) {
      strm.flush_pending();
      if (strm.avail_out === 0) {
        last_flush = -1;
        return Z_OK;
      }
    } else if (strm.avail_in === 0 && flush <= old_flush && flush != Z_FINISH) {
      strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
      return Z_BUF_ERROR;
    }
    if (status == FINISH_STATE && strm.avail_in !== 0) {
      _strm.msg = z_errmsg[Z_NEED_DICT - Z_BUF_ERROR];
      return Z_BUF_ERROR;
    }
    if (strm.avail_in !== 0 || lookahead !== 0 || flush != Z_NO_FLUSH && status != FINISH_STATE) {
      bstate = -1;
      switch (config_table[level].func) {
        case STORED:
          bstate = deflate_stored(flush);
          break;
        case FAST:
          bstate = deflate_fast(flush);
          break;
        case SLOW:
          bstate = deflate_slow(flush);
          break;
        default:
      }
      if (bstate == FinishStarted || bstate == FinishDone) {
        status = FINISH_STATE;
      }
      if (bstate == NeedMore || bstate == FinishStarted) {
        if (strm.avail_out === 0) {
          last_flush = -1;
        }
        return Z_OK;
      }
      if (bstate == BlockDone) {
        if (flush == Z_PARTIAL_FLUSH) {
          _tr_align();
        } else {
          _tr_stored_block(0, 0, false);
          if (flush == Z_FULL_FLUSH) {
            for (i = 0; i < hash_size; i++)
              head[i] = 0;
          }
        }
        strm.flush_pending();
        if (strm.avail_out === 0) {
          last_flush = -1;
          return Z_OK;
        }
      }
    }
    if (flush != Z_FINISH)
      return Z_OK;
    return Z_STREAM_END;
  };
}
function ZStream() {
  const that = this;
  that.next_in_index = 0;
  that.next_out_index = 0;
  that.avail_in = 0;
  that.total_in = 0;
  that.avail_out = 0;
  that.total_out = 0;
}
ZStream.prototype = {
  deflateInit(level, bits) {
    const that = this;
    that.dstate = new Deflate();
    if (!bits)
      bits = MAX_BITS;
    return that.dstate.deflateInit(that, level, bits);
  },
  deflate(flush) {
    const that = this;
    if (!that.dstate) {
      return Z_STREAM_ERROR;
    }
    return that.dstate.deflate(that, flush);
  },
  deflateEnd() {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR;
    const ret = that.dstate.deflateEnd();
    that.dstate = null;
    return ret;
  },
  deflateParams(level, strategy) {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR;
    return that.dstate.deflateParams(that, level, strategy);
  },
  deflateSetDictionary(dictionary, dictLength) {
    const that = this;
    if (!that.dstate)
      return Z_STREAM_ERROR;
    return that.dstate.deflateSetDictionary(that, dictionary, dictLength);
  },
  // Read a new buffer from the current input stream, update the
  // total number of bytes read. All deflate() input goes through
  // this function so some applications may wish to modify it to avoid
  // allocating a large strm->next_in buffer and copying from it.
  // (See also flush_pending()).
  read_buf(buf, start, size) {
    const that = this;
    let len = that.avail_in;
    if (len > size)
      len = size;
    if (len === 0)
      return 0;
    that.avail_in -= len;
    buf.set(that.next_in.subarray(that.next_in_index, that.next_in_index + len), start);
    that.next_in_index += len;
    that.total_in += len;
    return len;
  },
  // Flush as much pending output as possible. All deflate() output goes
  // through this function so some applications may wish to modify it
  // to avoid allocating a large strm->next_out buffer and copying into it.
  // (See also read_buf()).
  flush_pending() {
    const that = this;
    let len = that.dstate.pending;
    if (len > that.avail_out)
      len = that.avail_out;
    if (len === 0)
      return;
    that.next_out.set(that.dstate.pending_buf.subarray(that.dstate.pending_out, that.dstate.pending_out + len), that.next_out_index);
    that.next_out_index += len;
    that.dstate.pending_out += len;
    that.total_out += len;
    that.avail_out -= len;
    that.dstate.pending -= len;
    if (that.dstate.pending === 0) {
      that.dstate.pending_out = 0;
    }
  }
};
function ZipDeflate(options) {
  const that = this;
  const z = new ZStream();
  const bufsize = getMaximumCompressedSize(options && options.chunkSize ? options.chunkSize : 64 * 1024);
  const flush = Z_NO_FLUSH;
  const buf = new Uint8Array(bufsize);
  let level = options ? options.level : Z_DEFAULT_COMPRESSION;
  if (typeof level == "undefined")
    level = Z_DEFAULT_COMPRESSION;
  z.deflateInit(level);
  z.next_out = buf;
  that.append = function(data, onprogress) {
    let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    if (!data.length)
      return;
    z.next_in_index = 0;
    z.next_in = data;
    z.avail_in = data.length;
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      err = z.deflate(flush);
      if (err != Z_OK)
        throw new Error("deflating: " + z.msg);
      if (z.next_out_index)
        if (z.next_out_index == bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.subarray(0, z.next_out_index));
      bufferSize += z.next_out_index;
      if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
        onprogress(z.next_in_index);
        lastIndex = z.next_in_index;
      }
    } while (z.avail_in > 0 || z.avail_out === 0);
    if (buffers.length > 1) {
      array = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
    }
    return array;
  };
  that.flush = function() {
    let err, array, bufferIndex = 0, bufferSize = 0;
    const buffers = [];
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      err = z.deflate(Z_FINISH);
      if (err != Z_STREAM_END && err != Z_OK)
        throw new Error("deflating: " + z.msg);
      if (bufsize - z.avail_out > 0)
        buffers.push(buf.slice(0, z.next_out_index));
      bufferSize += z.next_out_index;
    } while (z.avail_in > 0 || z.avail_out === 0);
    z.deflateEnd();
    array = new Uint8Array(bufferSize);
    buffers.forEach(function(chunk) {
      array.set(chunk, bufferIndex);
      bufferIndex += chunk.length;
    });
    return array;
  };
}
function getMaximumCompressedSize(uncompressedSize) {
  return uncompressedSize + 5 * (Math.floor(uncompressedSize / 16383) + 1);
}

// node_modules/@zip.js/zip.js/lib/core/streams/codecs/inflate.js
var MAX_BITS2 = 15;
var Z_OK2 = 0;
var Z_STREAM_END2 = 1;
var Z_NEED_DICT2 = 2;
var Z_STREAM_ERROR2 = -2;
var Z_DATA_ERROR2 = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR2 = -5;
var inflate_mask = [
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535
];
var MANY = 1440;
var Z_NO_FLUSH2 = 0;
var Z_FINISH2 = 4;
var fixed_bl = 9;
var fixed_bd = 5;
var fixed_tl = [
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  192,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  160,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  224,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  144,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  208,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  176,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  240,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  200,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  168,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  232,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  152,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  216,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  184,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  248,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  196,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  164,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  228,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  148,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  212,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  180,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  244,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  204,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  172,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  236,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  156,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  220,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  188,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  252,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  194,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  162,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  226,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  146,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  210,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  178,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  242,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  202,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  170,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  234,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  154,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  218,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  186,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  250,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  198,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  166,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  230,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  150,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  214,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  182,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  246,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  206,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  174,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  238,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  158,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  222,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  190,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  254,
  96,
  7,
  256,
  0,
  8,
  80,
  0,
  8,
  16,
  84,
  8,
  115,
  82,
  7,
  31,
  0,
  8,
  112,
  0,
  8,
  48,
  0,
  9,
  193,
  80,
  7,
  10,
  0,
  8,
  96,
  0,
  8,
  32,
  0,
  9,
  161,
  0,
  8,
  0,
  0,
  8,
  128,
  0,
  8,
  64,
  0,
  9,
  225,
  80,
  7,
  6,
  0,
  8,
  88,
  0,
  8,
  24,
  0,
  9,
  145,
  83,
  7,
  59,
  0,
  8,
  120,
  0,
  8,
  56,
  0,
  9,
  209,
  81,
  7,
  17,
  0,
  8,
  104,
  0,
  8,
  40,
  0,
  9,
  177,
  0,
  8,
  8,
  0,
  8,
  136,
  0,
  8,
  72,
  0,
  9,
  241,
  80,
  7,
  4,
  0,
  8,
  84,
  0,
  8,
  20,
  85,
  8,
  227,
  83,
  7,
  43,
  0,
  8,
  116,
  0,
  8,
  52,
  0,
  9,
  201,
  81,
  7,
  13,
  0,
  8,
  100,
  0,
  8,
  36,
  0,
  9,
  169,
  0,
  8,
  4,
  0,
  8,
  132,
  0,
  8,
  68,
  0,
  9,
  233,
  80,
  7,
  8,
  0,
  8,
  92,
  0,
  8,
  28,
  0,
  9,
  153,
  84,
  7,
  83,
  0,
  8,
  124,
  0,
  8,
  60,
  0,
  9,
  217,
  82,
  7,
  23,
  0,
  8,
  108,
  0,
  8,
  44,
  0,
  9,
  185,
  0,
  8,
  12,
  0,
  8,
  140,
  0,
  8,
  76,
  0,
  9,
  249,
  80,
  7,
  3,
  0,
  8,
  82,
  0,
  8,
  18,
  85,
  8,
  163,
  83,
  7,
  35,
  0,
  8,
  114,
  0,
  8,
  50,
  0,
  9,
  197,
  81,
  7,
  11,
  0,
  8,
  98,
  0,
  8,
  34,
  0,
  9,
  165,
  0,
  8,
  2,
  0,
  8,
  130,
  0,
  8,
  66,
  0,
  9,
  229,
  80,
  7,
  7,
  0,
  8,
  90,
  0,
  8,
  26,
  0,
  9,
  149,
  84,
  7,
  67,
  0,
  8,
  122,
  0,
  8,
  58,
  0,
  9,
  213,
  82,
  7,
  19,
  0,
  8,
  106,
  0,
  8,
  42,
  0,
  9,
  181,
  0,
  8,
  10,
  0,
  8,
  138,
  0,
  8,
  74,
  0,
  9,
  245,
  80,
  7,
  5,
  0,
  8,
  86,
  0,
  8,
  22,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  118,
  0,
  8,
  54,
  0,
  9,
  205,
  81,
  7,
  15,
  0,
  8,
  102,
  0,
  8,
  38,
  0,
  9,
  173,
  0,
  8,
  6,
  0,
  8,
  134,
  0,
  8,
  70,
  0,
  9,
  237,
  80,
  7,
  9,
  0,
  8,
  94,
  0,
  8,
  30,
  0,
  9,
  157,
  84,
  7,
  99,
  0,
  8,
  126,
  0,
  8,
  62,
  0,
  9,
  221,
  82,
  7,
  27,
  0,
  8,
  110,
  0,
  8,
  46,
  0,
  9,
  189,
  0,
  8,
  14,
  0,
  8,
  142,
  0,
  8,
  78,
  0,
  9,
  253,
  96,
  7,
  256,
  0,
  8,
  81,
  0,
  8,
  17,
  85,
  8,
  131,
  82,
  7,
  31,
  0,
  8,
  113,
  0,
  8,
  49,
  0,
  9,
  195,
  80,
  7,
  10,
  0,
  8,
  97,
  0,
  8,
  33,
  0,
  9,
  163,
  0,
  8,
  1,
  0,
  8,
  129,
  0,
  8,
  65,
  0,
  9,
  227,
  80,
  7,
  6,
  0,
  8,
  89,
  0,
  8,
  25,
  0,
  9,
  147,
  83,
  7,
  59,
  0,
  8,
  121,
  0,
  8,
  57,
  0,
  9,
  211,
  81,
  7,
  17,
  0,
  8,
  105,
  0,
  8,
  41,
  0,
  9,
  179,
  0,
  8,
  9,
  0,
  8,
  137,
  0,
  8,
  73,
  0,
  9,
  243,
  80,
  7,
  4,
  0,
  8,
  85,
  0,
  8,
  21,
  80,
  8,
  258,
  83,
  7,
  43,
  0,
  8,
  117,
  0,
  8,
  53,
  0,
  9,
  203,
  81,
  7,
  13,
  0,
  8,
  101,
  0,
  8,
  37,
  0,
  9,
  171,
  0,
  8,
  5,
  0,
  8,
  133,
  0,
  8,
  69,
  0,
  9,
  235,
  80,
  7,
  8,
  0,
  8,
  93,
  0,
  8,
  29,
  0,
  9,
  155,
  84,
  7,
  83,
  0,
  8,
  125,
  0,
  8,
  61,
  0,
  9,
  219,
  82,
  7,
  23,
  0,
  8,
  109,
  0,
  8,
  45,
  0,
  9,
  187,
  0,
  8,
  13,
  0,
  8,
  141,
  0,
  8,
  77,
  0,
  9,
  251,
  80,
  7,
  3,
  0,
  8,
  83,
  0,
  8,
  19,
  85,
  8,
  195,
  83,
  7,
  35,
  0,
  8,
  115,
  0,
  8,
  51,
  0,
  9,
  199,
  81,
  7,
  11,
  0,
  8,
  99,
  0,
  8,
  35,
  0,
  9,
  167,
  0,
  8,
  3,
  0,
  8,
  131,
  0,
  8,
  67,
  0,
  9,
  231,
  80,
  7,
  7,
  0,
  8,
  91,
  0,
  8,
  27,
  0,
  9,
  151,
  84,
  7,
  67,
  0,
  8,
  123,
  0,
  8,
  59,
  0,
  9,
  215,
  82,
  7,
  19,
  0,
  8,
  107,
  0,
  8,
  43,
  0,
  9,
  183,
  0,
  8,
  11,
  0,
  8,
  139,
  0,
  8,
  75,
  0,
  9,
  247,
  80,
  7,
  5,
  0,
  8,
  87,
  0,
  8,
  23,
  192,
  8,
  0,
  83,
  7,
  51,
  0,
  8,
  119,
  0,
  8,
  55,
  0,
  9,
  207,
  81,
  7,
  15,
  0,
  8,
  103,
  0,
  8,
  39,
  0,
  9,
  175,
  0,
  8,
  7,
  0,
  8,
  135,
  0,
  8,
  71,
  0,
  9,
  239,
  80,
  7,
  9,
  0,
  8,
  95,
  0,
  8,
  31,
  0,
  9,
  159,
  84,
  7,
  99,
  0,
  8,
  127,
  0,
  8,
  63,
  0,
  9,
  223,
  82,
  7,
  27,
  0,
  8,
  111,
  0,
  8,
  47,
  0,
  9,
  191,
  0,
  8,
  15,
  0,
  8,
  143,
  0,
  8,
  79,
  0,
  9,
  255
];
var fixed_td = [
  80,
  5,
  1,
  87,
  5,
  257,
  83,
  5,
  17,
  91,
  5,
  4097,
  81,
  5,
  5,
  89,
  5,
  1025,
  85,
  5,
  65,
  93,
  5,
  16385,
  80,
  5,
  3,
  88,
  5,
  513,
  84,
  5,
  33,
  92,
  5,
  8193,
  82,
  5,
  9,
  90,
  5,
  2049,
  86,
  5,
  129,
  192,
  5,
  24577,
  80,
  5,
  2,
  87,
  5,
  385,
  83,
  5,
  25,
  91,
  5,
  6145,
  81,
  5,
  7,
  89,
  5,
  1537,
  85,
  5,
  97,
  93,
  5,
  24577,
  80,
  5,
  4,
  88,
  5,
  769,
  84,
  5,
  49,
  92,
  5,
  12289,
  82,
  5,
  13,
  90,
  5,
  3073,
  86,
  5,
  193,
  192,
  5,
  24577
];
var cplens = [
  // Copy lengths for literal codes 257..285
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var cplext = [
  // Extra bits for literal codes 257..285
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  112,
  112
  // 112==invalid
];
var cpdist = [
  // Copy offsets for distance codes 0..29
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577
];
var cpdext = [
  // Extra bits for distance codes
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13
];
var BMAX = 15;
function InfTree() {
  const that = this;
  let hn;
  let v;
  let c;
  let r;
  let u;
  let x;
  function huft_build(b, bindex, n, s, d, e2, t2, m, hp, hn2, v2) {
    let a;
    let f;
    let g;
    let h;
    let i;
    let j;
    let k;
    let l;
    let mask;
    let p;
    let q;
    let w;
    let xp;
    let y;
    let z;
    p = 0;
    i = n;
    do {
      c[b[bindex + p]]++;
      p++;
      i--;
    } while (i !== 0);
    if (c[0] == n) {
      t2[0] = -1;
      m[0] = 0;
      return Z_OK2;
    }
    l = m[0];
    for (j = 1; j <= BMAX; j++)
      if (c[j] !== 0)
        break;
    k = j;
    if (l < j) {
      l = j;
    }
    for (i = BMAX; i !== 0; i--) {
      if (c[i] !== 0)
        break;
    }
    g = i;
    if (l > i) {
      l = i;
    }
    m[0] = l;
    for (y = 1 << j; j < i; j++, y <<= 1) {
      if ((y -= c[j]) < 0) {
        return Z_DATA_ERROR2;
      }
    }
    if ((y -= c[i]) < 0) {
      return Z_DATA_ERROR2;
    }
    c[i] += y;
    x[1] = j = 0;
    p = 1;
    xp = 2;
    while (--i !== 0) {
      x[xp] = j += c[p];
      xp++;
      p++;
    }
    i = 0;
    p = 0;
    do {
      if ((j = b[bindex + p]) !== 0) {
        v2[x[j]++] = i;
      }
      p++;
    } while (++i < n);
    n = x[g];
    x[0] = i = 0;
    p = 0;
    h = -1;
    w = -l;
    u[0] = 0;
    q = 0;
    z = 0;
    for (; k <= g; k++) {
      a = c[k];
      while (a-- !== 0) {
        while (k > w + l) {
          h++;
          w += l;
          z = g - w;
          z = z > l ? l : z;
          if ((f = 1 << (j = k - w)) > a + 1) {
            f -= a + 1;
            xp = k;
            if (j < z) {
              while (++j < z) {
                if ((f <<= 1) <= c[++xp])
                  break;
                f -= c[xp];
              }
            }
          }
          z = 1 << j;
          if (hn2[0] + z > MANY) {
            return Z_DATA_ERROR2;
          }
          u[h] = q = /* hp+ */
          hn2[0];
          hn2[0] += z;
          if (h !== 0) {
            x[h] = i;
            r[0] = /* (byte) */
            j;
            r[1] = /* (byte) */
            l;
            j = i >>> w - l;
            r[2] = /* (int) */
            q - u[h - 1] - j;
            hp.set(r, (u[h - 1] + j) * 3);
          } else {
            t2[0] = q;
          }
        }
        r[1] = /* (byte) */
        k - w;
        if (p >= n) {
          r[0] = 128 + 64;
        } else if (v2[p] < s) {
          r[0] = /* (byte) */
          v2[p] < 256 ? 0 : 32 + 64;
          r[2] = v2[p++];
        } else {
          r[0] = /* (byte) */
          e2[v2[p] - s] + 16 + 64;
          r[2] = d[v2[p++] - s];
        }
        f = 1 << k - w;
        for (j = i >>> w; j < z; j += f) {
          hp.set(r, (q + j) * 3);
        }
        for (j = 1 << k - 1; (i & j) !== 0; j >>>= 1) {
          i ^= j;
        }
        i ^= j;
        mask = (1 << w) - 1;
        while ((i & mask) != x[h]) {
          h--;
          w -= l;
          mask = (1 << w) - 1;
        }
      }
    }
    return y !== 0 && g != 1 ? Z_BUF_ERROR2 : Z_OK2;
  }
  function initWorkArea(vsize) {
    let i;
    if (!hn) {
      hn = [];
      v = [];
      c = new Int32Array(BMAX + 1);
      r = [];
      u = new Int32Array(BMAX);
      x = new Int32Array(BMAX + 1);
    }
    if (v.length < vsize) {
      v = [];
    }
    for (i = 0; i < vsize; i++) {
      v[i] = 0;
    }
    for (i = 0; i < BMAX + 1; i++) {
      c[i] = 0;
    }
    for (i = 0; i < 3; i++) {
      r[i] = 0;
    }
    u.set(c.subarray(0, BMAX), 0);
    x.set(c.subarray(0, BMAX + 1), 0);
  }
  that.inflate_trees_bits = function(c2, bb, tb, hp, z) {
    let result;
    initWorkArea(19);
    hn[0] = 0;
    result = huft_build(c2, 0, 19, 19, null, null, tb, bb, hp, hn, v);
    if (result == Z_DATA_ERROR2) {
      z.msg = "oversubscribed dynamic bit lengths tree";
    } else if (result == Z_BUF_ERROR2 || bb[0] === 0) {
      z.msg = "incomplete dynamic bit lengths tree";
      result = Z_DATA_ERROR2;
    }
    return result;
  };
  that.inflate_trees_dynamic = function(nl, nd, c2, bl, bd, tl, td, hp, z) {
    let result;
    initWorkArea(288);
    hn[0] = 0;
    result = huft_build(c2, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);
    if (result != Z_OK2 || bl[0] === 0) {
      if (result == Z_DATA_ERROR2) {
        z.msg = "oversubscribed literal/length tree";
      } else if (result != Z_MEM_ERROR) {
        z.msg = "incomplete literal/length tree";
        result = Z_DATA_ERROR2;
      }
      return result;
    }
    initWorkArea(288);
    result = huft_build(c2, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);
    if (result != Z_OK2 || bd[0] === 0 && nl > 257) {
      if (result == Z_DATA_ERROR2) {
        z.msg = "oversubscribed distance tree";
      } else if (result == Z_BUF_ERROR2) {
        z.msg = "incomplete distance tree";
        result = Z_DATA_ERROR2;
      } else if (result != Z_MEM_ERROR) {
        z.msg = "empty distance tree with lengths";
        result = Z_DATA_ERROR2;
      }
      return result;
    }
    return Z_OK2;
  };
}
InfTree.inflate_trees_fixed = function(bl, bd, tl, td) {
  bl[0] = fixed_bl;
  bd[0] = fixed_bd;
  tl[0] = fixed_tl;
  td[0] = fixed_td;
  return Z_OK2;
};
var START = 0;
var LEN = 1;
var LENEXT = 2;
var DIST = 3;
var DISTEXT = 4;
var COPY = 5;
var LIT = 6;
var WASH = 7;
var END = 8;
var BADCODE = 9;
function InfCodes() {
  const that = this;
  let mode2;
  let len = 0;
  let tree;
  let tree_index = 0;
  let need = 0;
  let lit = 0;
  let get2 = 0;
  let dist = 0;
  let lbits = 0;
  let dbits = 0;
  let ltree;
  let ltree_index = 0;
  let dtree;
  let dtree_index = 0;
  function inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {
    let t2;
    let tp;
    let tp_index;
    let e2;
    let b;
    let k;
    let p;
    let n;
    let q;
    let m;
    let ml;
    let md;
    let c;
    let d;
    let r;
    let tp_index_t_3;
    p = z.next_in_index;
    n = z.avail_in;
    b = s.bitb;
    k = s.bitk;
    q = s.write;
    m = q < s.read ? s.read - q - 1 : s.end - q;
    ml = inflate_mask[bl];
    md = inflate_mask[bd];
    do {
      while (k < 20) {
        n--;
        b |= (z.read_byte(p++) & 255) << k;
        k += 8;
      }
      t2 = b & ml;
      tp = tl;
      tp_index = tl_index;
      tp_index_t_3 = (tp_index + t2) * 3;
      if ((e2 = tp[tp_index_t_3]) === 0) {
        b >>= tp[tp_index_t_3 + 1];
        k -= tp[tp_index_t_3 + 1];
        s.win[q++] = /* (byte) */
        tp[tp_index_t_3 + 2];
        m--;
        continue;
      }
      do {
        b >>= tp[tp_index_t_3 + 1];
        k -= tp[tp_index_t_3 + 1];
        if ((e2 & 16) !== 0) {
          e2 &= 15;
          c = tp[tp_index_t_3 + 2] + /* (int) */
          (b & inflate_mask[e2]);
          b >>= e2;
          k -= e2;
          while (k < 15) {
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          t2 = b & md;
          tp = td;
          tp_index = td_index;
          tp_index_t_3 = (tp_index + t2) * 3;
          e2 = tp[tp_index_t_3];
          do {
            b >>= tp[tp_index_t_3 + 1];
            k -= tp[tp_index_t_3 + 1];
            if ((e2 & 16) !== 0) {
              e2 &= 15;
              while (k < e2) {
                n--;
                b |= (z.read_byte(p++) & 255) << k;
                k += 8;
              }
              d = tp[tp_index_t_3 + 2] + (b & inflate_mask[e2]);
              b >>= e2;
              k -= e2;
              m -= c;
              if (q >= d) {
                r = q - d;
                if (q - r > 0 && 2 > q - r) {
                  s.win[q++] = s.win[r++];
                  s.win[q++] = s.win[r++];
                  c -= 2;
                } else {
                  s.win.set(s.win.subarray(r, r + 2), q);
                  q += 2;
                  r += 2;
                  c -= 2;
                }
              } else {
                r = q - d;
                do {
                  r += s.end;
                } while (r < 0);
                e2 = s.end - r;
                if (c > e2) {
                  c -= e2;
                  if (q - r > 0 && e2 > q - r) {
                    do {
                      s.win[q++] = s.win[r++];
                    } while (--e2 !== 0);
                  } else {
                    s.win.set(s.win.subarray(r, r + e2), q);
                    q += e2;
                    r += e2;
                    e2 = 0;
                  }
                  r = 0;
                }
              }
              if (q - r > 0 && c > q - r) {
                do {
                  s.win[q++] = s.win[r++];
                } while (--c !== 0);
              } else {
                s.win.set(s.win.subarray(r, r + c), q);
                q += c;
                r += c;
                c = 0;
              }
              break;
            } else if ((e2 & 64) === 0) {
              t2 += tp[tp_index_t_3 + 2];
              t2 += b & inflate_mask[e2];
              tp_index_t_3 = (tp_index + t2) * 3;
              e2 = tp[tp_index_t_3];
            } else {
              z.msg = "invalid distance code";
              c = z.avail_in - n;
              c = k >> 3 < c ? k >> 3 : c;
              n += c;
              p -= c;
              k -= c << 3;
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return Z_DATA_ERROR2;
            }
          } while (true);
          break;
        }
        if ((e2 & 64) === 0) {
          t2 += tp[tp_index_t_3 + 2];
          t2 += b & inflate_mask[e2];
          tp_index_t_3 = (tp_index + t2) * 3;
          if ((e2 = tp[tp_index_t_3]) === 0) {
            b >>= tp[tp_index_t_3 + 1];
            k -= tp[tp_index_t_3 + 1];
            s.win[q++] = /* (byte) */
            tp[tp_index_t_3 + 2];
            m--;
            break;
          }
        } else if ((e2 & 32) !== 0) {
          c = z.avail_in - n;
          c = k >> 3 < c ? k >> 3 : c;
          n += c;
          p -= c;
          k -= c << 3;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return Z_STREAM_END2;
        } else {
          z.msg = "invalid literal/length code";
          c = z.avail_in - n;
          c = k >> 3 < c ? k >> 3 : c;
          n += c;
          p -= c;
          k -= c << 3;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return Z_DATA_ERROR2;
        }
      } while (true);
    } while (m >= 258 && n >= 10);
    c = z.avail_in - n;
    c = k >> 3 < c ? k >> 3 : c;
    n += c;
    p -= c;
    k -= c << 3;
    s.bitb = b;
    s.bitk = k;
    z.avail_in = n;
    z.total_in += p - z.next_in_index;
    z.next_in_index = p;
    s.write = q;
    return Z_OK2;
  }
  that.init = function(bl, bd, tl, tl_index, td, td_index) {
    mode2 = START;
    lbits = /* (byte) */
    bl;
    dbits = /* (byte) */
    bd;
    ltree = tl;
    ltree_index = tl_index;
    dtree = td;
    dtree_index = td_index;
    tree = null;
  };
  that.proc = function(s, z, r) {
    let j;
    let tindex;
    let e2;
    let b = 0;
    let k = 0;
    let p = 0;
    let n;
    let q;
    let m;
    let f;
    p = z.next_in_index;
    n = z.avail_in;
    b = s.bitb;
    k = s.bitk;
    q = s.write;
    m = q < s.read ? s.read - q - 1 : s.end - q;
    while (true) {
      switch (mode2) {
        case START:
          if (m >= 258 && n >= 10) {
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            r = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);
            p = z.next_in_index;
            n = z.avail_in;
            b = s.bitb;
            k = s.bitk;
            q = s.write;
            m = q < s.read ? s.read - q - 1 : s.end - q;
            if (r != Z_OK2) {
              mode2 = r == Z_STREAM_END2 ? WASH : BADCODE;
              break;
            }
          }
          need = lbits;
          tree = ltree;
          tree_index = ltree_index;
          mode2 = LEN;
        case LEN:
          j = need;
          while (k < j) {
            if (n !== 0)
              r = Z_OK2;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          tindex = (tree_index + (b & inflate_mask[j])) * 3;
          b >>>= tree[tindex + 1];
          k -= tree[tindex + 1];
          e2 = tree[tindex];
          if (e2 === 0) {
            lit = tree[tindex + 2];
            mode2 = LIT;
            break;
          }
          if ((e2 & 16) !== 0) {
            get2 = e2 & 15;
            len = tree[tindex + 2];
            mode2 = LENEXT;
            break;
          }
          if ((e2 & 64) === 0) {
            need = e2;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          if ((e2 & 32) !== 0) {
            mode2 = WASH;
            break;
          }
          mode2 = BADCODE;
          z.msg = "invalid literal/length code";
          r = Z_DATA_ERROR2;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case LENEXT:
          j = get2;
          while (k < j) {
            if (n !== 0)
              r = Z_OK2;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          len += b & inflate_mask[j];
          b >>= j;
          k -= j;
          need = dbits;
          tree = dtree;
          tree_index = dtree_index;
          mode2 = DIST;
        case DIST:
          j = need;
          while (k < j) {
            if (n !== 0)
              r = Z_OK2;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          tindex = (tree_index + (b & inflate_mask[j])) * 3;
          b >>= tree[tindex + 1];
          k -= tree[tindex + 1];
          e2 = tree[tindex];
          if ((e2 & 16) !== 0) {
            get2 = e2 & 15;
            dist = tree[tindex + 2];
            mode2 = DISTEXT;
            break;
          }
          if ((e2 & 64) === 0) {
            need = e2;
            tree_index = tindex / 3 + tree[tindex + 2];
            break;
          }
          mode2 = BADCODE;
          z.msg = "invalid distance code";
          r = Z_DATA_ERROR2;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case DISTEXT:
          j = get2;
          while (k < j) {
            if (n !== 0)
              r = Z_OK2;
            else {
              s.bitb = b;
              s.bitk = k;
              z.avail_in = n;
              z.total_in += p - z.next_in_index;
              z.next_in_index = p;
              s.write = q;
              return s.inflate_flush(z, r);
            }
            n--;
            b |= (z.read_byte(p++) & 255) << k;
            k += 8;
          }
          dist += b & inflate_mask[j];
          b >>= j;
          k -= j;
          mode2 = COPY;
        case COPY:
          f = q - dist;
          while (f < 0) {
            f += s.end;
          }
          while (len !== 0) {
            if (m === 0) {
              if (q == s.end && s.read !== 0) {
                q = 0;
                m = q < s.read ? s.read - q - 1 : s.end - q;
              }
              if (m === 0) {
                s.write = q;
                r = s.inflate_flush(z, r);
                q = s.write;
                m = q < s.read ? s.read - q - 1 : s.end - q;
                if (q == s.end && s.read !== 0) {
                  q = 0;
                  m = q < s.read ? s.read - q - 1 : s.end - q;
                }
                if (m === 0) {
                  s.bitb = b;
                  s.bitk = k;
                  z.avail_in = n;
                  z.total_in += p - z.next_in_index;
                  z.next_in_index = p;
                  s.write = q;
                  return s.inflate_flush(z, r);
                }
              }
            }
            s.win[q++] = s.win[f++];
            m--;
            if (f == s.end)
              f = 0;
            len--;
          }
          mode2 = START;
          break;
        case LIT:
          if (m === 0) {
            if (q == s.end && s.read !== 0) {
              q = 0;
              m = q < s.read ? s.read - q - 1 : s.end - q;
            }
            if (m === 0) {
              s.write = q;
              r = s.inflate_flush(z, r);
              q = s.write;
              m = q < s.read ? s.read - q - 1 : s.end - q;
              if (q == s.end && s.read !== 0) {
                q = 0;
                m = q < s.read ? s.read - q - 1 : s.end - q;
              }
              if (m === 0) {
                s.bitb = b;
                s.bitk = k;
                z.avail_in = n;
                z.total_in += p - z.next_in_index;
                z.next_in_index = p;
                s.write = q;
                return s.inflate_flush(z, r);
              }
            }
          }
          r = Z_OK2;
          s.win[q++] = /* (byte) */
          lit;
          m--;
          mode2 = START;
          break;
        case WASH:
          if (k > 7) {
            k -= 8;
            n++;
            p--;
          }
          s.write = q;
          r = s.inflate_flush(z, r);
          q = s.write;
          m = q < s.read ? s.read - q - 1 : s.end - q;
          if (s.read != s.write) {
            s.bitb = b;
            s.bitk = k;
            z.avail_in = n;
            z.total_in += p - z.next_in_index;
            z.next_in_index = p;
            s.write = q;
            return s.inflate_flush(z, r);
          }
          mode2 = END;
        case END:
          r = Z_STREAM_END2;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        case BADCODE:
          r = Z_DATA_ERROR2;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
        default:
          r = Z_STREAM_ERROR2;
          s.bitb = b;
          s.bitk = k;
          z.avail_in = n;
          z.total_in += p - z.next_in_index;
          z.next_in_index = p;
          s.write = q;
          return s.inflate_flush(z, r);
      }
    }
  };
  that.free = function() {
  };
}
var border = [
  // Order of the bit length code lengths
  16,
  17,
  18,
  0,
  8,
  7,
  9,
  6,
  10,
  5,
  11,
  4,
  12,
  3,
  13,
  2,
  14,
  1,
  15
];
var TYPE = 0;
var LENS = 1;
var STORED2 = 2;
var TABLE = 3;
var BTREE = 4;
var DTREE = 5;
var CODES = 6;
var DRY = 7;
var DONELOCKS = 8;
var BADBLOCKS = 9;
function InfBlocks(z, w) {
  const that = this;
  let mode2 = TYPE;
  let left = 0;
  let table3 = 0;
  let index = 0;
  let blens;
  const bb = [0];
  const tb = [0];
  const codes = new InfCodes();
  let last = 0;
  let hufts = new Int32Array(MANY * 3);
  const check = 0;
  const inftree = new InfTree();
  that.bitk = 0;
  that.bitb = 0;
  that.win = new Uint8Array(w);
  that.end = w;
  that.read = 0;
  that.write = 0;
  that.reset = function(z2, c) {
    if (c)
      c[0] = check;
    if (mode2 == CODES) {
      codes.free(z2);
    }
    mode2 = TYPE;
    that.bitk = 0;
    that.bitb = 0;
    that.read = that.write = 0;
  };
  that.reset(z, null);
  that.inflate_flush = function(z2, r) {
    let n;
    let p;
    let q;
    p = z2.next_out_index;
    q = that.read;
    n = /* (int) */
    (q <= that.write ? that.write : that.end) - q;
    if (n > z2.avail_out)
      n = z2.avail_out;
    if (n !== 0 && r == Z_BUF_ERROR2)
      r = Z_OK2;
    z2.avail_out -= n;
    z2.total_out += n;
    z2.next_out.set(that.win.subarray(q, q + n), p);
    p += n;
    q += n;
    if (q == that.end) {
      q = 0;
      if (that.write == that.end)
        that.write = 0;
      n = that.write - q;
      if (n > z2.avail_out)
        n = z2.avail_out;
      if (n !== 0 && r == Z_BUF_ERROR2)
        r = Z_OK2;
      z2.avail_out -= n;
      z2.total_out += n;
      z2.next_out.set(that.win.subarray(q, q + n), p);
      p += n;
      q += n;
    }
    z2.next_out_index = p;
    that.read = q;
    return r;
  };
  that.proc = function(z2, r) {
    let t2;
    let b;
    let k;
    let p;
    let n;
    let q;
    let m;
    let i;
    p = z2.next_in_index;
    n = z2.avail_in;
    b = that.bitb;
    k = that.bitk;
    q = that.write;
    m = /* (int) */
    q < that.read ? that.read - q - 1 : that.end - q;
    while (true) {
      let bl, bd, tl, td, bl_, bd_, tl_, td_;
      switch (mode2) {
        case TYPE:
          while (k < 3) {
            if (n !== 0) {
              r = Z_OK2;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          t2 = /* (int) */
          b & 7;
          last = t2 & 1;
          switch (t2 >>> 1) {
            case 0:
              b >>>= 3;
              k -= 3;
              t2 = k & 7;
              b >>>= t2;
              k -= t2;
              mode2 = LENS;
              break;
            case 1:
              bl = [];
              bd = [];
              tl = [[]];
              td = [[]];
              InfTree.inflate_trees_fixed(bl, bd, tl, td);
              codes.init(bl[0], bd[0], tl[0], 0, td[0], 0);
              b >>>= 3;
              k -= 3;
              mode2 = CODES;
              break;
            case 2:
              b >>>= 3;
              k -= 3;
              mode2 = TABLE;
              break;
            case 3:
              b >>>= 3;
              k -= 3;
              mode2 = BADBLOCKS;
              z2.msg = "invalid block type";
              r = Z_DATA_ERROR2;
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
          }
          break;
        case LENS:
          while (k < 32) {
            if (n !== 0) {
              r = Z_OK2;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          if ((~b >>> 16 & 65535) != (b & 65535)) {
            mode2 = BADBLOCKS;
            z2.msg = "invalid stored block lengths";
            r = Z_DATA_ERROR2;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          left = b & 65535;
          b = k = 0;
          mode2 = left !== 0 ? STORED2 : last !== 0 ? DRY : TYPE;
          break;
        case STORED2:
          if (n === 0) {
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          if (m === 0) {
            if (q == that.end && that.read !== 0) {
              q = 0;
              m = /* (int) */
              q < that.read ? that.read - q - 1 : that.end - q;
            }
            if (m === 0) {
              that.write = q;
              r = that.inflate_flush(z2, r);
              q = that.write;
              m = /* (int) */
              q < that.read ? that.read - q - 1 : that.end - q;
              if (q == that.end && that.read !== 0) {
                q = 0;
                m = /* (int) */
                q < that.read ? that.read - q - 1 : that.end - q;
              }
              if (m === 0) {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
            }
          }
          r = Z_OK2;
          t2 = left;
          if (t2 > n)
            t2 = n;
          if (t2 > m)
            t2 = m;
          that.win.set(z2.read_buf(p, t2), q);
          p += t2;
          n -= t2;
          q += t2;
          m -= t2;
          if ((left -= t2) !== 0)
            break;
          mode2 = last !== 0 ? DRY : TYPE;
          break;
        case TABLE:
          while (k < 14) {
            if (n !== 0) {
              r = Z_OK2;
            } else {
              that.bitb = b;
              that.bitk = k;
              z2.avail_in = n;
              z2.total_in += p - z2.next_in_index;
              z2.next_in_index = p;
              that.write = q;
              return that.inflate_flush(z2, r);
            }
            n--;
            b |= (z2.read_byte(p++) & 255) << k;
            k += 8;
          }
          table3 = t2 = b & 16383;
          if ((t2 & 31) > 29 || (t2 >> 5 & 31) > 29) {
            mode2 = BADBLOCKS;
            z2.msg = "too many length or distance symbols";
            r = Z_DATA_ERROR2;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          t2 = 258 + (t2 & 31) + (t2 >> 5 & 31);
          if (!blens || blens.length < t2) {
            blens = [];
          } else {
            for (i = 0; i < t2; i++) {
              blens[i] = 0;
            }
          }
          b >>>= 14;
          k -= 14;
          index = 0;
          mode2 = BTREE;
        case BTREE:
          while (index < 4 + (table3 >>> 10)) {
            while (k < 3) {
              if (n !== 0) {
                r = Z_OK2;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            blens[border[index++]] = b & 7;
            b >>>= 3;
            k -= 3;
          }
          while (index < 19) {
            blens[border[index++]] = 0;
          }
          bb[0] = 7;
          t2 = inftree.inflate_trees_bits(blens, bb, tb, hufts, z2);
          if (t2 != Z_OK2) {
            r = t2;
            if (r == Z_DATA_ERROR2) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          index = 0;
          mode2 = DTREE;
        case DTREE:
          while (true) {
            t2 = table3;
            if (index >= 258 + (t2 & 31) + (t2 >> 5 & 31)) {
              break;
            }
            let j, c;
            t2 = bb[0];
            while (k < t2) {
              if (n !== 0) {
                r = Z_OK2;
              } else {
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              n--;
              b |= (z2.read_byte(p++) & 255) << k;
              k += 8;
            }
            t2 = hufts[(tb[0] + (b & inflate_mask[t2])) * 3 + 1];
            c = hufts[(tb[0] + (b & inflate_mask[t2])) * 3 + 2];
            if (c < 16) {
              b >>>= t2;
              k -= t2;
              blens[index++] = c;
            } else {
              i = c == 18 ? 7 : c - 14;
              j = c == 18 ? 11 : 3;
              while (k < t2 + i) {
                if (n !== 0) {
                  r = Z_OK2;
                } else {
                  that.bitb = b;
                  that.bitk = k;
                  z2.avail_in = n;
                  z2.total_in += p - z2.next_in_index;
                  z2.next_in_index = p;
                  that.write = q;
                  return that.inflate_flush(z2, r);
                }
                n--;
                b |= (z2.read_byte(p++) & 255) << k;
                k += 8;
              }
              b >>>= t2;
              k -= t2;
              j += b & inflate_mask[i];
              b >>>= i;
              k -= i;
              i = index;
              t2 = table3;
              if (i + j > 258 + (t2 & 31) + (t2 >> 5 & 31) || c == 16 && i < 1) {
                blens = null;
                mode2 = BADBLOCKS;
                z2.msg = "invalid bit length repeat";
                r = Z_DATA_ERROR2;
                that.bitb = b;
                that.bitk = k;
                z2.avail_in = n;
                z2.total_in += p - z2.next_in_index;
                z2.next_in_index = p;
                that.write = q;
                return that.inflate_flush(z2, r);
              }
              c = c == 16 ? blens[i - 1] : 0;
              do {
                blens[i++] = c;
              } while (--j !== 0);
              index = i;
            }
          }
          tb[0] = -1;
          bl_ = [];
          bd_ = [];
          tl_ = [];
          td_ = [];
          bl_[0] = 9;
          bd_[0] = 6;
          t2 = table3;
          t2 = inftree.inflate_trees_dynamic(257 + (t2 & 31), 1 + (t2 >> 5 & 31), blens, bl_, bd_, tl_, td_, hufts, z2);
          if (t2 != Z_OK2) {
            if (t2 == Z_DATA_ERROR2) {
              blens = null;
              mode2 = BADBLOCKS;
            }
            r = t2;
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          codes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);
          mode2 = CODES;
        case CODES:
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          if ((r = codes.proc(that, z2, r)) != Z_STREAM_END2) {
            return that.inflate_flush(z2, r);
          }
          r = Z_OK2;
          codes.free(z2);
          p = z2.next_in_index;
          n = z2.avail_in;
          b = that.bitb;
          k = that.bitk;
          q = that.write;
          m = /* (int) */
          q < that.read ? that.read - q - 1 : that.end - q;
          if (last === 0) {
            mode2 = TYPE;
            break;
          }
          mode2 = DRY;
        case DRY:
          that.write = q;
          r = that.inflate_flush(z2, r);
          q = that.write;
          m = /* (int) */
          q < that.read ? that.read - q - 1 : that.end - q;
          if (that.read != that.write) {
            that.bitb = b;
            that.bitk = k;
            z2.avail_in = n;
            z2.total_in += p - z2.next_in_index;
            z2.next_in_index = p;
            that.write = q;
            return that.inflate_flush(z2, r);
          }
          mode2 = DONELOCKS;
        case DONELOCKS:
          r = Z_STREAM_END2;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
        case BADBLOCKS:
          r = Z_DATA_ERROR2;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
        default:
          r = Z_STREAM_ERROR2;
          that.bitb = b;
          that.bitk = k;
          z2.avail_in = n;
          z2.total_in += p - z2.next_in_index;
          z2.next_in_index = p;
          that.write = q;
          return that.inflate_flush(z2, r);
      }
    }
  };
  that.free = function(z2) {
    that.reset(z2, null);
    that.win = null;
    hufts = null;
  };
  that.set_dictionary = function(d, start, n) {
    that.win.set(d.subarray(start, start + n), 0);
    that.read = that.write = n;
  };
  that.sync_point = function() {
    return mode2 == LENS ? 1 : 0;
  };
}
var PRESET_DICT2 = 32;
var Z_DEFLATED2 = 8;
var METHOD = 0;
var FLAG = 1;
var DICT4 = 2;
var DICT3 = 3;
var DICT2 = 4;
var DICT1 = 5;
var DICT0 = 6;
var BLOCKS = 7;
var DONE = 12;
var BAD = 13;
var mark = [0, 0, 255, 255];
function Inflate() {
  const that = this;
  that.mode = 0;
  that.method = 0;
  that.was = [0];
  that.need = 0;
  that.marker = 0;
  that.wbits = 0;
  function inflateReset(z) {
    if (!z || !z.istate)
      return Z_STREAM_ERROR2;
    z.total_in = z.total_out = 0;
    z.msg = null;
    z.istate.mode = BLOCKS;
    z.istate.blocks.reset(z, null);
    return Z_OK2;
  }
  that.inflateEnd = function(z) {
    if (that.blocks)
      that.blocks.free(z);
    that.blocks = null;
    return Z_OK2;
  };
  that.inflateInit = function(z, w) {
    z.msg = null;
    that.blocks = null;
    if (w < 8 || w > 15) {
      that.inflateEnd(z);
      return Z_STREAM_ERROR2;
    }
    that.wbits = w;
    z.istate.blocks = new InfBlocks(z, 1 << w);
    inflateReset(z);
    return Z_OK2;
  };
  that.inflate = function(z, f) {
    let r;
    let b;
    if (!z || !z.istate || !z.next_in)
      return Z_STREAM_ERROR2;
    const istate = z.istate;
    f = f == Z_FINISH2 ? Z_BUF_ERROR2 : Z_OK2;
    r = Z_BUF_ERROR2;
    while (true) {
      switch (istate.mode) {
        case METHOD:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          if (((istate.method = z.read_byte(z.next_in_index++)) & 15) != Z_DEFLATED2) {
            istate.mode = BAD;
            z.msg = "unknown compression method";
            istate.marker = 5;
            break;
          }
          if ((istate.method >> 4) + 8 > istate.wbits) {
            istate.mode = BAD;
            z.msg = "invalid win size";
            istate.marker = 5;
            break;
          }
          istate.mode = FLAG;
        case FLAG:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          b = z.read_byte(z.next_in_index++) & 255;
          if (((istate.method << 8) + b) % 31 !== 0) {
            istate.mode = BAD;
            z.msg = "incorrect header check";
            istate.marker = 5;
            break;
          }
          if ((b & PRESET_DICT2) === 0) {
            istate.mode = BLOCKS;
            break;
          }
          istate.mode = DICT4;
        case DICT4:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need = (z.read_byte(z.next_in_index++) & 255) << 24 & 4278190080;
          istate.mode = DICT3;
        case DICT3:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += (z.read_byte(z.next_in_index++) & 255) << 16 & 16711680;
          istate.mode = DICT2;
        case DICT2:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += (z.read_byte(z.next_in_index++) & 255) << 8 & 65280;
          istate.mode = DICT1;
        case DICT1:
          if (z.avail_in === 0)
            return r;
          r = f;
          z.avail_in--;
          z.total_in++;
          istate.need += z.read_byte(z.next_in_index++) & 255;
          istate.mode = DICT0;
          return Z_NEED_DICT2;
        case DICT0:
          istate.mode = BAD;
          z.msg = "need dictionary";
          istate.marker = 0;
          return Z_STREAM_ERROR2;
        case BLOCKS:
          r = istate.blocks.proc(z, r);
          if (r == Z_DATA_ERROR2) {
            istate.mode = BAD;
            istate.marker = 0;
            break;
          }
          if (r == Z_OK2) {
            r = f;
          }
          if (r != Z_STREAM_END2) {
            return r;
          }
          r = f;
          istate.blocks.reset(z, istate.was);
          istate.mode = DONE;
        case DONE:
          z.avail_in = 0;
          return Z_STREAM_END2;
        case BAD:
          return Z_DATA_ERROR2;
        default:
          return Z_STREAM_ERROR2;
      }
    }
  };
  that.inflateSetDictionary = function(z, dictionary, dictLength) {
    let index = 0, length = dictLength;
    if (!z || !z.istate || z.istate.mode != DICT0)
      return Z_STREAM_ERROR2;
    const istate = z.istate;
    if (length >= 1 << istate.wbits) {
      length = (1 << istate.wbits) - 1;
      index = dictLength - length;
    }
    istate.blocks.set_dictionary(dictionary, index, length);
    istate.mode = BLOCKS;
    return Z_OK2;
  };
  that.inflateSync = function(z) {
    let n;
    let p;
    let m;
    let r, w;
    if (!z || !z.istate)
      return Z_STREAM_ERROR2;
    const istate = z.istate;
    if (istate.mode != BAD) {
      istate.mode = BAD;
      istate.marker = 0;
    }
    if ((n = z.avail_in) === 0)
      return Z_BUF_ERROR2;
    p = z.next_in_index;
    m = istate.marker;
    while (n !== 0 && m < 4) {
      if (z.read_byte(p) == mark[m]) {
        m++;
      } else if (z.read_byte(p) !== 0) {
        m = 0;
      } else {
        m = 4 - m;
      }
      p++;
      n--;
    }
    z.total_in += p - z.next_in_index;
    z.next_in_index = p;
    z.avail_in = n;
    istate.marker = m;
    if (m != 4) {
      return Z_DATA_ERROR2;
    }
    r = z.total_in;
    w = z.total_out;
    inflateReset(z);
    z.total_in = r;
    z.total_out = w;
    istate.mode = BLOCKS;
    return Z_OK2;
  };
  that.inflateSyncPoint = function(z) {
    if (!z || !z.istate || !z.istate.blocks)
      return Z_STREAM_ERROR2;
    return z.istate.blocks.sync_point();
  };
}
function ZStream2() {
}
ZStream2.prototype = {
  inflateInit(bits) {
    const that = this;
    that.istate = new Inflate();
    if (!bits)
      bits = MAX_BITS2;
    return that.istate.inflateInit(that, bits);
  },
  inflate(f) {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR2;
    return that.istate.inflate(that, f);
  },
  inflateEnd() {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR2;
    const ret = that.istate.inflateEnd(that);
    that.istate = null;
    return ret;
  },
  inflateSync() {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR2;
    return that.istate.inflateSync(that);
  },
  inflateSetDictionary(dictionary, dictLength) {
    const that = this;
    if (!that.istate)
      return Z_STREAM_ERROR2;
    return that.istate.inflateSetDictionary(that, dictionary, dictLength);
  },
  read_byte(start) {
    const that = this;
    return that.next_in[start];
  },
  read_buf(start, size) {
    const that = this;
    return that.next_in.subarray(start, start + size);
  }
};
function ZipInflate(options) {
  const that = this;
  const z = new ZStream2();
  const bufsize = options && options.chunkSize ? Math.floor(options.chunkSize * 2) : 128 * 1024;
  const flush = Z_NO_FLUSH2;
  const buf = new Uint8Array(bufsize);
  let nomoreinput = false;
  z.inflateInit();
  z.next_out = buf;
  that.append = function(data, onprogress) {
    const buffers = [];
    let err, array, lastIndex = 0, bufferIndex = 0, bufferSize = 0;
    if (data.length === 0)
      return;
    z.next_in_index = 0;
    z.next_in = data;
    z.avail_in = data.length;
    do {
      z.next_out_index = 0;
      z.avail_out = bufsize;
      if (z.avail_in === 0 && !nomoreinput) {
        z.next_in_index = 0;
        nomoreinput = true;
      }
      err = z.inflate(flush);
      if (nomoreinput && err === Z_BUF_ERROR2) {
        if (z.avail_in !== 0)
          throw new Error("inflating: bad input");
      } else if (err !== Z_OK2 && err !== Z_STREAM_END2)
        throw new Error("inflating: " + z.msg);
      if ((nomoreinput || err === Z_STREAM_END2) && z.avail_in === data.length)
        throw new Error("inflating: bad input");
      if (z.next_out_index)
        if (z.next_out_index === bufsize)
          buffers.push(new Uint8Array(buf));
        else
          buffers.push(buf.subarray(0, z.next_out_index));
      bufferSize += z.next_out_index;
      if (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {
        onprogress(z.next_in_index);
        lastIndex = z.next_in_index;
      }
    } while (z.avail_in > 0 || z.avail_out === 0);
    if (buffers.length > 1) {
      array = new Uint8Array(bufferSize);
      buffers.forEach(function(chunk) {
        array.set(chunk, bufferIndex);
        bufferIndex += chunk.length;
      });
    } else {
      array = buffers[0] ? new Uint8Array(buffers[0]) : new Uint8Array();
    }
    return array;
  };
  that.flush = function() {
    z.inflateEnd();
  };
}

// node_modules/@zip.js/zip.js/lib/core/constants.js
var MAX_32_BITS = 4294967295;
var MAX_16_BITS = 65535;
var COMPRESSION_METHOD_DEFLATE = 8;
var COMPRESSION_METHOD_STORE = 0;
var COMPRESSION_METHOD_AES = 99;
var LOCAL_FILE_HEADER_SIGNATURE = 67324752;
var SPLIT_ZIP_FILE_SIGNATURE = 134695760;
var CENTRAL_FILE_HEADER_SIGNATURE = 33639248;
var END_OF_CENTRAL_DIR_SIGNATURE = 101010256;
var ZIP64_END_OF_CENTRAL_DIR_SIGNATURE = 101075792;
var ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE = 117853008;
var END_OF_CENTRAL_DIR_LENGTH = 22;
var ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH = 20;
var ZIP64_END_OF_CENTRAL_DIR_LENGTH = 56;
var ZIP64_END_OF_CENTRAL_DIR_TOTAL_LENGTH = END_OF_CENTRAL_DIR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH + ZIP64_END_OF_CENTRAL_DIR_LENGTH;
var EXTRAFIELD_TYPE_ZIP64 = 1;
var EXTRAFIELD_TYPE_AES = 39169;
var EXTRAFIELD_TYPE_NTFS = 10;
var EXTRAFIELD_TYPE_NTFS_TAG1 = 1;
var EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP = 21589;
var EXTRAFIELD_TYPE_UNICODE_PATH = 28789;
var EXTRAFIELD_TYPE_UNICODE_COMMENT = 25461;
var EXTRAFIELD_TYPE_USDZ = 6534;
var BITFLAG_ENCRYPTED = 1;
var BITFLAG_LEVEL = 6;
var BITFLAG_DATA_DESCRIPTOR = 8;
var BITFLAG_LANG_ENCODING_FLAG = 2048;
var FILE_ATTR_MSDOS_DIR_MASK = 16;
var DIRECTORY_SIGNATURE = "/";
var MAX_DATE = new Date(2107, 11, 31);
var MIN_DATE = new Date(1980, 0, 1);
var UNDEFINED_VALUE = void 0;
var UNDEFINED_TYPE = "undefined";
var FUNCTION_TYPE = "function";

// node_modules/@zip.js/zip.js/lib/core/streams/stream-adapter.js
var StreamAdapter = class {
  constructor(Codec) {
    return class extends TransformStream {
      constructor(_format, options) {
        const codec2 = new Codec(options);
        super({
          transform(chunk, controller) {
            controller.enqueue(codec2.append(chunk));
          },
          flush(controller) {
            const chunk = codec2.flush();
            if (chunk) {
              controller.enqueue(chunk);
            }
          }
        });
      }
    };
  }
};

// node_modules/@zip.js/zip.js/lib/core/configuration.js
var MINIMUM_CHUNK_SIZE = 64;
var maxWorkers = 2;
try {
  if (typeof navigator != UNDEFINED_TYPE && navigator.hardwareConcurrency) {
    maxWorkers = navigator.hardwareConcurrency;
  }
} catch (_error) {
}
var DEFAULT_CONFIGURATION = {
  chunkSize: 512 * 1024,
  maxWorkers,
  terminateWorkerTimeout: 5e3,
  useWebWorkers: true,
  useCompressionStream: true,
  workerScripts: UNDEFINED_VALUE,
  CompressionStreamNative: typeof CompressionStream != UNDEFINED_TYPE && CompressionStream,
  DecompressionStreamNative: typeof DecompressionStream != UNDEFINED_TYPE && DecompressionStream
};
var config = Object.assign({}, DEFAULT_CONFIGURATION);
function getConfiguration() {
  return config;
}
function getChunkSize(config2) {
  return Math.max(config2.chunkSize, MINIMUM_CHUNK_SIZE);
}
function configure(configuration) {
  const {
    baseURL: baseURL2,
    chunkSize,
    maxWorkers: maxWorkers2,
    terminateWorkerTimeout,
    useCompressionStream,
    useWebWorkers,
    Deflate: Deflate2,
    Inflate: Inflate2,
    CompressionStream: CompressionStream2,
    DecompressionStream: DecompressionStream2,
    workerScripts
  } = configuration;
  setIfDefined("baseURL", baseURL2);
  setIfDefined("chunkSize", chunkSize);
  setIfDefined("maxWorkers", maxWorkers2);
  setIfDefined("terminateWorkerTimeout", terminateWorkerTimeout);
  setIfDefined("useCompressionStream", useCompressionStream);
  setIfDefined("useWebWorkers", useWebWorkers);
  if (Deflate2) {
    config.CompressionStream = new StreamAdapter(Deflate2);
  }
  if (Inflate2) {
    config.DecompressionStream = new StreamAdapter(Inflate2);
  }
  setIfDefined("CompressionStream", CompressionStream2);
  setIfDefined("DecompressionStream", DecompressionStream2);
  if (workerScripts !== UNDEFINED_VALUE) {
    const { deflate, inflate } = workerScripts;
    if (deflate || inflate) {
      if (!config.workerScripts) {
        config.workerScripts = {};
      }
    }
    if (deflate) {
      if (!Array.isArray(deflate)) {
        throw new Error("workerScripts.deflate must be an array");
      }
      config.workerScripts.deflate = deflate;
    }
    if (inflate) {
      if (!Array.isArray(inflate)) {
        throw new Error("workerScripts.inflate must be an array");
      }
      config.workerScripts.inflate = inflate;
    }
  }
}
function setIfDefined(propertyName, propertyValue) {
  if (propertyValue !== UNDEFINED_VALUE) {
    config[propertyName] = propertyValue;
  }
}

// node_modules/@zip.js/zip.js/lib/core/util/mime-type.js
var table = {
  "application": {
    "andrew-inset": "ez",
    "annodex": "anx",
    "atom+xml": "atom",
    "atomcat+xml": "atomcat",
    "atomserv+xml": "atomsrv",
    "bbolin": "lin",
    "cu-seeme": "cu",
    "davmount+xml": "davmount",
    "dsptype": "tsp",
    "ecmascript": [
      "es",
      "ecma"
    ],
    "futuresplash": "spl",
    "hta": "hta",
    "java-archive": "jar",
    "java-serialized-object": "ser",
    "java-vm": "class",
    "m3g": "m3g",
    "mac-binhex40": "hqx",
    "mathematica": [
      "nb",
      "ma",
      "mb"
    ],
    "msaccess": "mdb",
    "msword": [
      "doc",
      "dot",
      "wiz"
    ],
    "mxf": "mxf",
    "oda": "oda",
    "ogg": "ogx",
    "pdf": "pdf",
    "pgp-keys": "key",
    "pgp-signature": [
      "asc",
      "sig"
    ],
    "pics-rules": "prf",
    "postscript": [
      "ps",
      "ai",
      "eps",
      "epsi",
      "epsf",
      "eps2",
      "eps3"
    ],
    "rar": "rar",
    "rdf+xml": "rdf",
    "rss+xml": "rss",
    "rtf": "rtf",
    "xhtml+xml": [
      "xhtml",
      "xht"
    ],
    "xml": [
      "xml",
      "xsl",
      "xsd",
      "xpdl"
    ],
    "xspf+xml": "xspf",
    "zip": "zip",
    "vnd.android.package-archive": "apk",
    "vnd.cinderella": "cdy",
    "vnd.google-earth.kml+xml": "kml",
    "vnd.google-earth.kmz": "kmz",
    "vnd.mozilla.xul+xml": "xul",
    "vnd.ms-excel": [
      "xls",
      "xlb",
      "xlt",
      "xlm",
      "xla",
      "xlc",
      "xlw"
    ],
    "vnd.ms-pki.seccat": "cat",
    "vnd.ms-pki.stl": "stl",
    "vnd.ms-powerpoint": [
      "ppt",
      "pps",
      "pot",
      "ppa",
      "pwz"
    ],
    "vnd.oasis.opendocument.chart": "odc",
    "vnd.oasis.opendocument.database": "odb",
    "vnd.oasis.opendocument.formula": "odf",
    "vnd.oasis.opendocument.graphics": "odg",
    "vnd.oasis.opendocument.graphics-template": "otg",
    "vnd.oasis.opendocument.image": "odi",
    "vnd.oasis.opendocument.presentation": "odp",
    "vnd.oasis.opendocument.presentation-template": "otp",
    "vnd.oasis.opendocument.spreadsheet": "ods",
    "vnd.oasis.opendocument.spreadsheet-template": "ots",
    "vnd.oasis.opendocument.text": "odt",
    "vnd.oasis.opendocument.text-master": [
      "odm",
      "otm"
    ],
    "vnd.oasis.opendocument.text-template": "ott",
    "vnd.oasis.opendocument.text-web": "oth",
    "vnd.openxmlformats-officedocument.spreadsheetml.sheet": "xlsx",
    "vnd.openxmlformats-officedocument.spreadsheetml.template": "xltx",
    "vnd.openxmlformats-officedocument.presentationml.presentation": "pptx",
    "vnd.openxmlformats-officedocument.presentationml.slideshow": "ppsx",
    "vnd.openxmlformats-officedocument.presentationml.template": "potx",
    "vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
    "vnd.openxmlformats-officedocument.wordprocessingml.template": "dotx",
    "vnd.smaf": "mmf",
    "vnd.stardivision.calc": "sdc",
    "vnd.stardivision.chart": "sds",
    "vnd.stardivision.draw": "sda",
    "vnd.stardivision.impress": "sdd",
    "vnd.stardivision.math": [
      "sdf",
      "smf"
    ],
    "vnd.stardivision.writer": [
      "sdw",
      "vor"
    ],
    "vnd.stardivision.writer-global": "sgl",
    "vnd.sun.xml.calc": "sxc",
    "vnd.sun.xml.calc.template": "stc",
    "vnd.sun.xml.draw": "sxd",
    "vnd.sun.xml.draw.template": "std",
    "vnd.sun.xml.impress": "sxi",
    "vnd.sun.xml.impress.template": "sti",
    "vnd.sun.xml.math": "sxm",
    "vnd.sun.xml.writer": "sxw",
    "vnd.sun.xml.writer.global": "sxg",
    "vnd.sun.xml.writer.template": "stw",
    "vnd.symbian.install": [
      "sis",
      "sisx"
    ],
    "vnd.visio": [
      "vsd",
      "vst",
      "vss",
      "vsw",
      "vsdx",
      "vssx",
      "vstx",
      "vssm",
      "vstm"
    ],
    "vnd.wap.wbxml": "wbxml",
    "vnd.wap.wmlc": "wmlc",
    "vnd.wap.wmlscriptc": "wmlsc",
    "vnd.wordperfect": "wpd",
    "vnd.wordperfect5.1": "wp5",
    "x-123": "wk",
    "x-7z-compressed": "7z",
    "x-abiword": "abw",
    "x-apple-diskimage": "dmg",
    "x-bcpio": "bcpio",
    "x-bittorrent": "torrent",
    "x-cbr": [
      "cbr",
      "cba",
      "cbt",
      "cb7"
    ],
    "x-cbz": "cbz",
    "x-cdf": [
      "cdf",
      "cda"
    ],
    "x-cdlink": "vcd",
    "x-chess-pgn": "pgn",
    "x-cpio": "cpio",
    "x-csh": "csh",
    "x-director": [
      "dir",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ],
    "x-dms": "dms",
    "x-doom": "wad",
    "x-dvi": "dvi",
    "x-httpd-eruby": "rhtml",
    "x-font": "pcf.Z",
    "x-freemind": "mm",
    "x-gnumeric": "gnumeric",
    "x-go-sgf": "sgf",
    "x-graphing-calculator": "gcf",
    "x-gtar": [
      "gtar",
      "taz"
    ],
    "x-hdf": "hdf",
    "x-httpd-php": [
      "phtml",
      "pht",
      "php"
    ],
    "x-httpd-php-source": "phps",
    "x-httpd-php3": "php3",
    "x-httpd-php3-preprocessed": "php3p",
    "x-httpd-php4": "php4",
    "x-httpd-php5": "php5",
    "x-ica": "ica",
    "x-info": "info",
    "x-internet-signup": [
      "ins",
      "isp"
    ],
    "x-iphone": "iii",
    "x-iso9660-image": "iso",
    "x-java-jnlp-file": "jnlp",
    "x-jmol": "jmz",
    "x-killustrator": "kil",
    "x-latex": "latex",
    "x-lyx": "lyx",
    "x-lzx": "lzx",
    "x-maker": [
      "frm",
      "fb",
      "fbdoc"
    ],
    "x-ms-wmd": "wmd",
    "x-msdos-program": [
      "com",
      "exe",
      "bat",
      "dll"
    ],
    "x-netcdf": [
      "nc"
    ],
    "x-ns-proxy-autoconfig": [
      "pac",
      "dat"
    ],
    "x-nwc": "nwc",
    "x-object": "o",
    "x-oz-application": "oza",
    "x-pkcs7-certreqresp": "p7r",
    "x-python-code": [
      "pyc",
      "pyo"
    ],
    "x-qgis": [
      "qgs",
      "shp",
      "shx"
    ],
    "x-quicktimeplayer": "qtl",
    "x-redhat-package-manager": [
      "rpm",
      "rpa"
    ],
    "x-ruby": "rb",
    "x-sh": "sh",
    "x-shar": "shar",
    "x-shockwave-flash": [
      "swf",
      "swfl"
    ],
    "x-silverlight": "scr",
    "x-stuffit": "sit",
    "x-sv4cpio": "sv4cpio",
    "x-sv4crc": "sv4crc",
    "x-tar": "tar",
    "x-tex-gf": "gf",
    "x-tex-pk": "pk",
    "x-texinfo": [
      "texinfo",
      "texi"
    ],
    "x-trash": [
      "~",
      "%",
      "bak",
      "old",
      "sik"
    ],
    "x-ustar": "ustar",
    "x-wais-source": "src",
    "x-wingz": "wz",
    "x-x509-ca-cert": [
      "crt",
      "der",
      "cer"
    ],
    "x-xcf": "xcf",
    "x-xfig": "fig",
    "x-xpinstall": "xpi",
    "applixware": "aw",
    "atomsvc+xml": "atomsvc",
    "ccxml+xml": "ccxml",
    "cdmi-capability": "cdmia",
    "cdmi-container": "cdmic",
    "cdmi-domain": "cdmid",
    "cdmi-object": "cdmio",
    "cdmi-queue": "cdmiq",
    "docbook+xml": "dbk",
    "dssc+der": "dssc",
    "dssc+xml": "xdssc",
    "emma+xml": "emma",
    "epub+zip": "epub",
    "exi": "exi",
    "font-tdpfr": "pfr",
    "gml+xml": "gml",
    "gpx+xml": "gpx",
    "gxf": "gxf",
    "hyperstudio": "stk",
    "inkml+xml": [
      "ink",
      "inkml"
    ],
    "ipfix": "ipfix",
    "jsonml+json": "jsonml",
    "lost+xml": "lostxml",
    "mads+xml": "mads",
    "marc": "mrc",
    "marcxml+xml": "mrcx",
    "mathml+xml": [
      "mathml",
      "mml"
    ],
    "mbox": "mbox",
    "mediaservercontrol+xml": "mscml",
    "metalink+xml": "metalink",
    "metalink4+xml": "meta4",
    "mets+xml": "mets",
    "mods+xml": "mods",
    "mp21": [
      "m21",
      "mp21"
    ],
    "mp4": "mp4s",
    "oebps-package+xml": "opf",
    "omdoc+xml": "omdoc",
    "onenote": [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ],
    "oxps": "oxps",
    "patch-ops-error+xml": "xer",
    "pgp-encrypted": "pgp",
    "pkcs10": "p10",
    "pkcs7-mime": [
      "p7m",
      "p7c"
    ],
    "pkcs7-signature": "p7s",
    "pkcs8": "p8",
    "pkix-attr-cert": "ac",
    "pkix-crl": "crl",
    "pkix-pkipath": "pkipath",
    "pkixcmp": "pki",
    "pls+xml": "pls",
    "prs.cww": "cww",
    "pskc+xml": "pskcxml",
    "reginfo+xml": "rif",
    "relax-ng-compact-syntax": "rnc",
    "resource-lists+xml": "rl",
    "resource-lists-diff+xml": "rld",
    "rls-services+xml": "rs",
    "rpki-ghostbusters": "gbr",
    "rpki-manifest": "mft",
    "rpki-roa": "roa",
    "rsd+xml": "rsd",
    "sbml+xml": "sbml",
    "scvp-cv-request": "scq",
    "scvp-cv-response": "scs",
    "scvp-vp-request": "spq",
    "scvp-vp-response": "spp",
    "sdp": "sdp",
    "set-payment-initiation": "setpay",
    "set-registration-initiation": "setreg",
    "shf+xml": "shf",
    "sparql-query": "rq",
    "sparql-results+xml": "srx",
    "srgs": "gram",
    "srgs+xml": "grxml",
    "sru+xml": "sru",
    "ssdl+xml": "ssdl",
    "ssml+xml": "ssml",
    "tei+xml": [
      "tei",
      "teicorpus"
    ],
    "thraud+xml": "tfi",
    "timestamped-data": "tsd",
    "vnd.3gpp.pic-bw-large": "plb",
    "vnd.3gpp.pic-bw-small": "psb",
    "vnd.3gpp.pic-bw-var": "pvb",
    "vnd.3gpp2.tcap": "tcap",
    "vnd.3m.post-it-notes": "pwn",
    "vnd.accpac.simply.aso": "aso",
    "vnd.accpac.simply.imp": "imp",
    "vnd.acucobol": "acu",
    "vnd.acucorp": [
      "atc",
      "acutc"
    ],
    "vnd.adobe.air-application-installer-package+zip": "air",
    "vnd.adobe.formscentral.fcdt": "fcdt",
    "vnd.adobe.fxp": [
      "fxp",
      "fxpl"
    ],
    "vnd.adobe.xdp+xml": "xdp",
    "vnd.adobe.xfdf": "xfdf",
    "vnd.ahead.space": "ahead",
    "vnd.airzip.filesecure.azf": "azf",
    "vnd.airzip.filesecure.azs": "azs",
    "vnd.amazon.ebook": "azw",
    "vnd.americandynamics.acc": "acc",
    "vnd.amiga.ami": "ami",
    "vnd.anser-web-certificate-issue-initiation": "cii",
    "vnd.anser-web-funds-transfer-initiation": "fti",
    "vnd.antix.game-component": "atx",
    "vnd.apple.installer+xml": "mpkg",
    "vnd.apple.mpegurl": "m3u8",
    "vnd.aristanetworks.swi": "swi",
    "vnd.astraea-software.iota": "iota",
    "vnd.audiograph": "aep",
    "vnd.blueice.multipass": "mpm",
    "vnd.bmi": "bmi",
    "vnd.businessobjects": "rep",
    "vnd.chemdraw+xml": "cdxml",
    "vnd.chipnuts.karaoke-mmd": "mmd",
    "vnd.claymore": "cla",
    "vnd.cloanto.rp9": "rp9",
    "vnd.clonk.c4group": [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ],
    "vnd.cluetrust.cartomobile-config": "c11amc",
    "vnd.cluetrust.cartomobile-config-pkg": "c11amz",
    "vnd.commonspace": "csp",
    "vnd.contact.cmsg": "cdbcmsg",
    "vnd.cosmocaller": "cmc",
    "vnd.crick.clicker": "clkx",
    "vnd.crick.clicker.keyboard": "clkk",
    "vnd.crick.clicker.palette": "clkp",
    "vnd.crick.clicker.template": "clkt",
    "vnd.crick.clicker.wordbank": "clkw",
    "vnd.criticaltools.wbs+xml": "wbs",
    "vnd.ctc-posml": "pml",
    "vnd.cups-ppd": "ppd",
    "vnd.curl.car": "car",
    "vnd.curl.pcurl": "pcurl",
    "vnd.dart": "dart",
    "vnd.data-vision.rdz": "rdz",
    "vnd.dece.data": [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ],
    "vnd.dece.ttml+xml": [
      "uvt",
      "uvvt"
    ],
    "vnd.dece.unspecified": [
      "uvx",
      "uvvx"
    ],
    "vnd.dece.zip": [
      "uvz",
      "uvvz"
    ],
    "vnd.denovo.fcselayout-link": "fe_launch",
    "vnd.dna": "dna",
    "vnd.dolby.mlp": "mlp",
    "vnd.dpgraph": "dpg",
    "vnd.dreamfactory": "dfac",
    "vnd.ds-keypoint": "kpxx",
    "vnd.dvb.ait": "ait",
    "vnd.dvb.service": "svc",
    "vnd.dynageo": "geo",
    "vnd.ecowin.chart": "mag",
    "vnd.enliven": "nml",
    "vnd.epson.esf": "esf",
    "vnd.epson.msf": "msf",
    "vnd.epson.quickanime": "qam",
    "vnd.epson.salt": "slt",
    "vnd.epson.ssf": "ssf",
    "vnd.eszigno3+xml": [
      "es3",
      "et3"
    ],
    "vnd.ezpix-album": "ez2",
    "vnd.ezpix-package": "ez3",
    "vnd.fdf": "fdf",
    "vnd.fdsn.mseed": "mseed",
    "vnd.fdsn.seed": [
      "seed",
      "dataless"
    ],
    "vnd.flographit": "gph",
    "vnd.fluxtime.clip": "ftc",
    "vnd.framemaker": [
      "fm",
      "frame",
      "maker",
      "book"
    ],
    "vnd.frogans.fnc": "fnc",
    "vnd.frogans.ltf": "ltf",
    "vnd.fsc.weblaunch": "fsc",
    "vnd.fujitsu.oasys": "oas",
    "vnd.fujitsu.oasys2": "oa2",
    "vnd.fujitsu.oasys3": "oa3",
    "vnd.fujitsu.oasysgp": "fg5",
    "vnd.fujitsu.oasysprs": "bh2",
    "vnd.fujixerox.ddd": "ddd",
    "vnd.fujixerox.docuworks": "xdw",
    "vnd.fujixerox.docuworks.binder": "xbd",
    "vnd.fuzzysheet": "fzs",
    "vnd.genomatix.tuxedo": "txd",
    "vnd.geogebra.file": "ggb",
    "vnd.geogebra.tool": "ggt",
    "vnd.geometry-explorer": [
      "gex",
      "gre"
    ],
    "vnd.geonext": "gxt",
    "vnd.geoplan": "g2w",
    "vnd.geospace": "g3w",
    "vnd.gmx": "gmx",
    "vnd.grafeq": [
      "gqf",
      "gqs"
    ],
    "vnd.groove-account": "gac",
    "vnd.groove-help": "ghf",
    "vnd.groove-identity-message": "gim",
    "vnd.groove-injector": "grv",
    "vnd.groove-tool-message": "gtm",
    "vnd.groove-tool-template": "tpl",
    "vnd.groove-vcard": "vcg",
    "vnd.hal+xml": "hal",
    "vnd.handheld-entertainment+xml": "zmm",
    "vnd.hbci": "hbci",
    "vnd.hhe.lesson-player": "les",
    "vnd.hp-hpgl": "hpgl",
    "vnd.hp-hpid": "hpid",
    "vnd.hp-hps": "hps",
    "vnd.hp-jlyt": "jlt",
    "vnd.hp-pcl": "pcl",
    "vnd.hp-pclxl": "pclxl",
    "vnd.hydrostatix.sof-data": "sfd-hdstx",
    "vnd.ibm.minipay": "mpy",
    "vnd.ibm.modcap": [
      "afp",
      "listafp",
      "list3820"
    ],
    "vnd.ibm.rights-management": "irm",
    "vnd.ibm.secure-container": "sc",
    "vnd.iccprofile": [
      "icc",
      "icm"
    ],
    "vnd.igloader": "igl",
    "vnd.immervision-ivp": "ivp",
    "vnd.immervision-ivu": "ivu",
    "vnd.insors.igm": "igm",
    "vnd.intercon.formnet": [
      "xpw",
      "xpx"
    ],
    "vnd.intergeo": "i2g",
    "vnd.intu.qbo": "qbo",
    "vnd.intu.qfx": "qfx",
    "vnd.ipunplugged.rcprofile": "rcprofile",
    "vnd.irepository.package+xml": "irp",
    "vnd.is-xpr": "xpr",
    "vnd.isac.fcs": "fcs",
    "vnd.jam": "jam",
    "vnd.jcp.javame.midlet-rms": "rms",
    "vnd.jisp": "jisp",
    "vnd.joost.joda-archive": "joda",
    "vnd.kahootz": [
      "ktz",
      "ktr"
    ],
    "vnd.kde.karbon": "karbon",
    "vnd.kde.kchart": "chrt",
    "vnd.kde.kformula": "kfo",
    "vnd.kde.kivio": "flw",
    "vnd.kde.kontour": "kon",
    "vnd.kde.kpresenter": [
      "kpr",
      "kpt"
    ],
    "vnd.kde.kspread": "ksp",
    "vnd.kde.kword": [
      "kwd",
      "kwt"
    ],
    "vnd.kenameaapp": "htke",
    "vnd.kidspiration": "kia",
    "vnd.kinar": [
      "kne",
      "knp"
    ],
    "vnd.koan": [
      "skp",
      "skd",
      "skt",
      "skm"
    ],
    "vnd.kodak-descriptor": "sse",
    "vnd.las.las+xml": "lasxml",
    "vnd.llamagraphics.life-balance.desktop": "lbd",
    "vnd.llamagraphics.life-balance.exchange+xml": "lbe",
    "vnd.lotus-1-2-3": "123",
    "vnd.lotus-approach": "apr",
    "vnd.lotus-freelance": "pre",
    "vnd.lotus-notes": "nsf",
    "vnd.lotus-organizer": "org",
    "vnd.lotus-screencam": "scm",
    "vnd.lotus-wordpro": "lwp",
    "vnd.macports.portpkg": "portpkg",
    "vnd.mcd": "mcd",
    "vnd.medcalcdata": "mc1",
    "vnd.mediastation.cdkey": "cdkey",
    "vnd.mfer": "mwf",
    "vnd.mfmp": "mfm",
    "vnd.micrografx.flo": "flo",
    "vnd.micrografx.igx": "igx",
    "vnd.mif": "mif",
    "vnd.mobius.daf": "daf",
    "vnd.mobius.dis": "dis",
    "vnd.mobius.mbk": "mbk",
    "vnd.mobius.mqy": "mqy",
    "vnd.mobius.msl": "msl",
    "vnd.mobius.plc": "plc",
    "vnd.mobius.txf": "txf",
    "vnd.mophun.application": "mpn",
    "vnd.mophun.certificate": "mpc",
    "vnd.ms-artgalry": "cil",
    "vnd.ms-cab-compressed": "cab",
    "vnd.ms-excel.addin.macroenabled.12": "xlam",
    "vnd.ms-excel.sheet.binary.macroenabled.12": "xlsb",
    "vnd.ms-excel.sheet.macroenabled.12": "xlsm",
    "vnd.ms-excel.template.macroenabled.12": "xltm",
    "vnd.ms-fontobject": "eot",
    "vnd.ms-htmlhelp": "chm",
    "vnd.ms-ims": "ims",
    "vnd.ms-lrm": "lrm",
    "vnd.ms-officetheme": "thmx",
    "vnd.ms-powerpoint.addin.macroenabled.12": "ppam",
    "vnd.ms-powerpoint.presentation.macroenabled.12": "pptm",
    "vnd.ms-powerpoint.slide.macroenabled.12": "sldm",
    "vnd.ms-powerpoint.slideshow.macroenabled.12": "ppsm",
    "vnd.ms-powerpoint.template.macroenabled.12": "potm",
    "vnd.ms-project": [
      "mpp",
      "mpt"
    ],
    "vnd.ms-word.document.macroenabled.12": "docm",
    "vnd.ms-word.template.macroenabled.12": "dotm",
    "vnd.ms-works": [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ],
    "vnd.ms-wpl": "wpl",
    "vnd.ms-xpsdocument": "xps",
    "vnd.mseq": "mseq",
    "vnd.musician": "mus",
    "vnd.muvee.style": "msty",
    "vnd.mynfc": "taglet",
    "vnd.neurolanguage.nlu": "nlu",
    "vnd.nitf": [
      "ntf",
      "nitf"
    ],
    "vnd.noblenet-directory": "nnd",
    "vnd.noblenet-sealer": "nns",
    "vnd.noblenet-web": "nnw",
    "vnd.nokia.n-gage.data": "ngdat",
    "vnd.nokia.n-gage.symbian.install": "n-gage",
    "vnd.nokia.radio-preset": "rpst",
    "vnd.nokia.radio-presets": "rpss",
    "vnd.novadigm.edm": "edm",
    "vnd.novadigm.edx": "edx",
    "vnd.novadigm.ext": "ext",
    "vnd.oasis.opendocument.chart-template": "otc",
    "vnd.oasis.opendocument.formula-template": "odft",
    "vnd.oasis.opendocument.image-template": "oti",
    "vnd.olpc-sugar": "xo",
    "vnd.oma.dd2+xml": "dd2",
    "vnd.openofficeorg.extension": "oxt",
    "vnd.openxmlformats-officedocument.presentationml.slide": "sldx",
    "vnd.osgeo.mapguide.package": "mgp",
    "vnd.osgi.dp": "dp",
    "vnd.osgi.subsystem": "esa",
    "vnd.palm": [
      "pdb",
      "pqa",
      "oprc"
    ],
    "vnd.pawaafile": "paw",
    "vnd.pg.format": "str",
    "vnd.pg.osasli": "ei6",
    "vnd.picsel": "efif",
    "vnd.pmi.widget": "wg",
    "vnd.pocketlearn": "plf",
    "vnd.powerbuilder6": "pbd",
    "vnd.previewsystems.box": "box",
    "vnd.proteus.magazine": "mgz",
    "vnd.publishare-delta-tree": "qps",
    "vnd.pvi.ptid1": "ptid",
    "vnd.quark.quarkxpress": [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ],
    "vnd.realvnc.bed": "bed",
    "vnd.recordare.musicxml": "mxl",
    "vnd.recordare.musicxml+xml": "musicxml",
    "vnd.rig.cryptonote": "cryptonote",
    "vnd.rn-realmedia": "rm",
    "vnd.rn-realmedia-vbr": "rmvb",
    "vnd.route66.link66+xml": "link66",
    "vnd.sailingtracker.track": "st",
    "vnd.seemail": "see",
    "vnd.sema": "sema",
    "vnd.semd": "semd",
    "vnd.semf": "semf",
    "vnd.shana.informed.formdata": "ifm",
    "vnd.shana.informed.formtemplate": "itp",
    "vnd.shana.informed.interchange": "iif",
    "vnd.shana.informed.package": "ipk",
    "vnd.simtech-mindmapper": [
      "twd",
      "twds"
    ],
    "vnd.smart.teacher": "teacher",
    "vnd.solent.sdkm+xml": [
      "sdkm",
      "sdkd"
    ],
    "vnd.spotfire.dxp": "dxp",
    "vnd.spotfire.sfs": "sfs",
    "vnd.stepmania.package": "smzip",
    "vnd.stepmania.stepchart": "sm",
    "vnd.sus-calendar": [
      "sus",
      "susp"
    ],
    "vnd.svd": "svd",
    "vnd.syncml+xml": "xsm",
    "vnd.syncml.dm+wbxml": "bdm",
    "vnd.syncml.dm+xml": "xdm",
    "vnd.tao.intent-module-archive": "tao",
    "vnd.tcpdump.pcap": [
      "pcap",
      "cap",
      "dmp"
    ],
    "vnd.tmobile-livetv": "tmo",
    "vnd.trid.tpt": "tpt",
    "vnd.triscape.mxs": "mxs",
    "vnd.trueapp": "tra",
    "vnd.ufdl": [
      "ufd",
      "ufdl"
    ],
    "vnd.uiq.theme": "utz",
    "vnd.umajin": "umj",
    "vnd.unity": "unityweb",
    "vnd.uoml+xml": "uoml",
    "vnd.vcx": "vcx",
    "vnd.visionary": "vis",
    "vnd.vsf": "vsf",
    "vnd.webturbo": "wtb",
    "vnd.wolfram.player": "nbp",
    "vnd.wqd": "wqd",
    "vnd.wt.stf": "stf",
    "vnd.xara": "xar",
    "vnd.xfdl": "xfdl",
    "vnd.yamaha.hv-dic": "hvd",
    "vnd.yamaha.hv-script": "hvs",
    "vnd.yamaha.hv-voice": "hvp",
    "vnd.yamaha.openscoreformat": "osf",
    "vnd.yamaha.openscoreformat.osfpvg+xml": "osfpvg",
    "vnd.yamaha.smaf-audio": "saf",
    "vnd.yamaha.smaf-phrase": "spf",
    "vnd.yellowriver-custom-menu": "cmp",
    "vnd.zul": [
      "zir",
      "zirz"
    ],
    "vnd.zzazz.deck+xml": "zaz",
    "voicexml+xml": "vxml",
    "widget": "wgt",
    "winhlp": "hlp",
    "wsdl+xml": "wsdl",
    "wspolicy+xml": "wspolicy",
    "x-ace-compressed": "ace",
    "x-authorware-bin": [
      "aab",
      "x32",
      "u32",
      "vox"
    ],
    "x-authorware-map": "aam",
    "x-authorware-seg": "aas",
    "x-blorb": [
      "blb",
      "blorb"
    ],
    "x-bzip": "bz",
    "x-bzip2": [
      "bz2",
      "boz"
    ],
    "x-cfs-compressed": "cfs",
    "x-chat": "chat",
    "x-conference": "nsc",
    "x-dgc-compressed": "dgc",
    "x-dtbncx+xml": "ncx",
    "x-dtbook+xml": "dtb",
    "x-dtbresource+xml": "res",
    "x-eva": "eva",
    "x-font-bdf": "bdf",
    "x-font-ghostscript": "gsf",
    "x-font-linux-psf": "psf",
    "x-font-pcf": "pcf",
    "x-font-snf": "snf",
    "x-font-ttf": [
      "ttf",
      "ttc"
    ],
    "x-font-type1": [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ],
    "x-freearc": "arc",
    "x-gca-compressed": "gca",
    "x-glulx": "ulx",
    "x-gramps-xml": "gramps",
    "x-install-instructions": "install",
    "x-lzh-compressed": [
      "lzh",
      "lha"
    ],
    "x-mie": "mie",
    "x-mobipocket-ebook": [
      "prc",
      "mobi"
    ],
    "x-ms-application": "application",
    "x-ms-shortcut": "lnk",
    "x-ms-xbap": "xbap",
    "x-msbinder": "obd",
    "x-mscardfile": "crd",
    "x-msclip": "clp",
    "application/x-ms-installer": "msi",
    "x-msmediaview": [
      "mvb",
      "m13",
      "m14"
    ],
    "x-msmetafile": [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ],
    "x-msmoney": "mny",
    "x-mspublisher": "pub",
    "x-msschedule": "scd",
    "x-msterminal": "trm",
    "x-mswrite": "wri",
    "x-nzb": "nzb",
    "x-pkcs12": [
      "p12",
      "pfx"
    ],
    "x-pkcs7-certificates": [
      "p7b",
      "spc"
    ],
    "x-research-info-systems": "ris",
    "x-silverlight-app": "xap",
    "x-sql": "sql",
    "x-stuffitx": "sitx",
    "x-subrip": "srt",
    "x-t3vm-image": "t3",
    "x-tex-tfm": "tfm",
    "x-tgif": "obj",
    "x-xliff+xml": "xlf",
    "x-xz": "xz",
    "x-zmachine": [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ],
    "xaml+xml": "xaml",
    "xcap-diff+xml": "xdf",
    "xenc+xml": "xenc",
    "xml-dtd": "dtd",
    "xop+xml": "xop",
    "xproc+xml": "xpl",
    "xslt+xml": "xslt",
    "xv+xml": [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ],
    "yang": "yang",
    "yin+xml": "yin",
    "envoy": "evy",
    "fractals": "fif",
    "internet-property-stream": "acx",
    "olescript": "axs",
    "vnd.ms-outlook": "msg",
    "vnd.ms-pkicertstore": "sst",
    "x-compress": "z",
    "x-perfmon": [
      "pma",
      "pmc",
      "pmr",
      "pmw"
    ],
    "ynd.ms-pkipko": "pko",
    "gzip": [
      "gz",
      "tgz"
    ],
    "smil+xml": [
      "smi",
      "smil"
    ],
    "vnd.debian.binary-package": [
      "deb",
      "udeb"
    ],
    "vnd.hzn-3d-crossword": "x3d",
    "vnd.sqlite3": [
      "db",
      "sqlite",
      "sqlite3",
      "db-wal",
      "sqlite-wal",
      "db-shm",
      "sqlite-shm"
    ],
    "vnd.wap.sic": "sic",
    "vnd.wap.slc": "slc",
    "x-krita": [
      "kra",
      "krz"
    ],
    "x-perl": [
      "pm",
      "pl"
    ],
    "yaml": [
      "yaml",
      "yml"
    ]
  },
  "audio": {
    "amr": "amr",
    "amr-wb": "awb",
    "annodex": "axa",
    "basic": [
      "au",
      "snd"
    ],
    "flac": "flac",
    "midi": [
      "mid",
      "midi",
      "kar",
      "rmi"
    ],
    "mpeg": [
      "mpga",
      "mpega",
      "mp3",
      "m4a",
      "mp2a",
      "m2a",
      "m3a"
    ],
    "mpegurl": "m3u",
    "ogg": [
      "oga",
      "ogg",
      "spx"
    ],
    "prs.sid": "sid",
    "x-aiff": "aifc",
    "x-gsm": "gsm",
    "x-ms-wma": "wma",
    "x-ms-wax": "wax",
    "x-pn-realaudio": "ram",
    "x-realaudio": "ra",
    "x-sd2": "sd2",
    "adpcm": "adp",
    "mp4": "mp4a",
    "s3m": "s3m",
    "silk": "sil",
    "vnd.dece.audio": [
      "uva",
      "uvva"
    ],
    "vnd.digital-winds": "eol",
    "vnd.dra": "dra",
    "vnd.dts": "dts",
    "vnd.dts.hd": "dtshd",
    "vnd.lucent.voice": "lvp",
    "vnd.ms-playready.media.pya": "pya",
    "vnd.nuera.ecelp4800": "ecelp4800",
    "vnd.nuera.ecelp7470": "ecelp7470",
    "vnd.nuera.ecelp9600": "ecelp9600",
    "vnd.rip": "rip",
    "webm": "weba",
    "x-caf": "caf",
    "x-matroska": "mka",
    "x-pn-realaudio-plugin": "rmp",
    "xm": "xm",
    "aac": "aac",
    "aiff": [
      "aiff",
      "aif",
      "aff"
    ],
    "opus": "opus",
    "wav": "wav"
  },
  "chemical": {
    "x-alchemy": "alc",
    "x-cache": [
      "cac",
      "cache"
    ],
    "x-cache-csf": "csf",
    "x-cactvs-binary": [
      "cbin",
      "cascii",
      "ctab"
    ],
    "x-cdx": "cdx",
    "x-chem3d": "c3d",
    "x-cif": "cif",
    "x-cmdf": "cmdf",
    "x-cml": "cml",
    "x-compass": "cpa",
    "x-crossfire": "bsd",
    "x-csml": [
      "csml",
      "csm"
    ],
    "x-ctx": "ctx",
    "x-cxf": [
      "cxf",
      "cef"
    ],
    "x-embl-dl-nucleotide": [
      "emb",
      "embl"
    ],
    "x-gamess-input": [
      "inp",
      "gam",
      "gamin"
    ],
    "x-gaussian-checkpoint": [
      "fch",
      "fchk"
    ],
    "x-gaussian-cube": "cub",
    "x-gaussian-input": [
      "gau",
      "gjc",
      "gjf"
    ],
    "x-gaussian-log": "gal",
    "x-gcg8-sequence": "gcg",
    "x-genbank": "gen",
    "x-hin": "hin",
    "x-isostar": [
      "istr",
      "ist"
    ],
    "x-jcamp-dx": [
      "jdx",
      "dx"
    ],
    "x-kinemage": "kin",
    "x-macmolecule": "mcm",
    "x-macromodel-input": "mmod",
    "x-mdl-molfile": "mol",
    "x-mdl-rdfile": "rd",
    "x-mdl-rxnfile": "rxn",
    "x-mdl-sdfile": "sd",
    "x-mdl-tgf": "tgf",
    "x-mmcif": "mcif",
    "x-mol2": "mol2",
    "x-molconn-Z": "b",
    "x-mopac-graph": "gpt",
    "x-mopac-input": [
      "mop",
      "mopcrt",
      "zmt"
    ],
    "x-mopac-out": "moo",
    "x-ncbi-asn1": "asn",
    "x-ncbi-asn1-ascii": [
      "prt",
      "ent"
    ],
    "x-ncbi-asn1-binary": "val",
    "x-rosdal": "ros",
    "x-swissprot": "sw",
    "x-vamas-iso14976": "vms",
    "x-vmd": "vmd",
    "x-xtel": "xtel",
    "x-xyz": "xyz"
  },
  "font": {
    "otf": "otf",
    "woff": "woff",
    "woff2": "woff2"
  },
  "image": {
    "gif": "gif",
    "ief": "ief",
    "jpeg": [
      "jpeg",
      "jpg",
      "jpe",
      "jfif",
      "jfif-tbnl",
      "jif"
    ],
    "pcx": "pcx",
    "png": "png",
    "svg+xml": [
      "svg",
      "svgz"
    ],
    "tiff": [
      "tiff",
      "tif"
    ],
    "vnd.djvu": [
      "djvu",
      "djv"
    ],
    "vnd.wap.wbmp": "wbmp",
    "x-canon-cr2": "cr2",
    "x-canon-crw": "crw",
    "x-cmu-raster": "ras",
    "x-coreldraw": "cdr",
    "x-coreldrawpattern": "pat",
    "x-coreldrawtemplate": "cdt",
    "x-corelphotopaint": "cpt",
    "x-epson-erf": "erf",
    "x-icon": "ico",
    "x-jg": "art",
    "x-jng": "jng",
    "x-nikon-nef": "nef",
    "x-olympus-orf": "orf",
    "x-portable-anymap": "pnm",
    "x-portable-bitmap": "pbm",
    "x-portable-graymap": "pgm",
    "x-portable-pixmap": "ppm",
    "x-rgb": "rgb",
    "x-xbitmap": "xbm",
    "x-xpixmap": "xpm",
    "x-xwindowdump": "xwd",
    "bmp": "bmp",
    "cgm": "cgm",
    "g3fax": "g3",
    "ktx": "ktx",
    "prs.btif": "btif",
    "sgi": "sgi",
    "vnd.dece.graphic": [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ],
    "vnd.dwg": "dwg",
    "vnd.dxf": "dxf",
    "vnd.fastbidsheet": "fbs",
    "vnd.fpx": "fpx",
    "vnd.fst": "fst",
    "vnd.fujixerox.edmics-mmr": "mmr",
    "vnd.fujixerox.edmics-rlc": "rlc",
    "vnd.ms-modi": "mdi",
    "vnd.ms-photo": "wdp",
    "vnd.net-fpx": "npx",
    "vnd.xiff": "xif",
    "webp": "webp",
    "x-3ds": "3ds",
    "x-cmx": "cmx",
    "x-freehand": [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ],
    "x-pict": [
      "pic",
      "pct"
    ],
    "x-tga": "tga",
    "cis-cod": "cod",
    "avif": "avifs",
    "heic": [
      "heif",
      "heic"
    ],
    "pjpeg": [
      "pjpg"
    ],
    "vnd.adobe.photoshop": "psd",
    "x-adobe-dng": "dng",
    "x-fuji-raf": "raf",
    "x-icns": "icns",
    "x-kodak-dcr": "dcr",
    "x-kodak-k25": "k25",
    "x-kodak-kdc": "kdc",
    "x-minolta-mrw": "mrw",
    "x-panasonic-raw": [
      "raw",
      "rw2",
      "rwl"
    ],
    "x-pentax-pef": [
      "pef",
      "ptx"
    ],
    "x-sigma-x3f": "x3f",
    "x-sony-arw": "arw",
    "x-sony-sr2": "sr2",
    "x-sony-srf": "srf"
  },
  "message": {
    "rfc822": [
      "eml",
      "mime",
      "mht",
      "mhtml",
      "nws"
    ]
  },
  "model": {
    "iges": [
      "igs",
      "iges"
    ],
    "mesh": [
      "msh",
      "mesh",
      "silo"
    ],
    "vrml": [
      "wrl",
      "vrml"
    ],
    "x3d+vrml": [
      "x3dv",
      "x3dvz"
    ],
    "x3d+xml": "x3dz",
    "x3d+binary": [
      "x3db",
      "x3dbz"
    ],
    "vnd.collada+xml": "dae",
    "vnd.dwf": "dwf",
    "vnd.gdl": "gdl",
    "vnd.gtw": "gtw",
    "vnd.mts": "mts",
    "vnd.usdz+zip": "usdz",
    "vnd.vtu": "vtu"
  },
  "text": {
    "cache-manifest": [
      "manifest",
      "appcache"
    ],
    "calendar": [
      "ics",
      "icz",
      "ifb"
    ],
    "css": "css",
    "csv": "csv",
    "h323": "323",
    "html": [
      "html",
      "htm",
      "shtml",
      "stm"
    ],
    "iuls": "uls",
    "plain": [
      "txt",
      "text",
      "brf",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "bas",
      "diff",
      "ksh"
    ],
    "richtext": "rtx",
    "scriptlet": [
      "sct",
      "wsc"
    ],
    "texmacs": "tm",
    "tab-separated-values": "tsv",
    "vnd.sun.j2me.app-descriptor": "jad",
    "vnd.wap.wml": "wml",
    "vnd.wap.wmlscript": "wmls",
    "x-bibtex": "bib",
    "x-boo": "boo",
    "x-c++hdr": [
      "h++",
      "hpp",
      "hxx",
      "hh"
    ],
    "x-c++src": [
      "c++",
      "cpp",
      "cxx",
      "cc"
    ],
    "x-component": "htc",
    "x-dsrc": "d",
    "x-diff": "patch",
    "x-haskell": "hs",
    "x-java": "java",
    "x-literate-haskell": "lhs",
    "x-moc": "moc",
    "x-pascal": [
      "p",
      "pas",
      "pp",
      "inc"
    ],
    "x-pcs-gcd": "gcd",
    "x-python": "py",
    "x-scala": "scala",
    "x-setext": "etx",
    "x-tcl": [
      "tcl",
      "tk"
    ],
    "x-tex": [
      "tex",
      "ltx",
      "sty",
      "cls"
    ],
    "x-vcalendar": "vcs",
    "x-vcard": "vcf",
    "n3": "n3",
    "prs.lines.tag": "dsc",
    "sgml": [
      "sgml",
      "sgm"
    ],
    "troff": [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ],
    "turtle": "ttl",
    "uri-list": [
      "uri",
      "uris",
      "urls"
    ],
    "vcard": "vcard",
    "vnd.curl": "curl",
    "vnd.curl.dcurl": "dcurl",
    "vnd.curl.scurl": "scurl",
    "vnd.curl.mcurl": "mcurl",
    "vnd.dvb.subtitle": "sub",
    "vnd.fly": "fly",
    "vnd.fmi.flexstor": "flx",
    "vnd.graphviz": "gv",
    "vnd.in3d.3dml": "3dml",
    "vnd.in3d.spot": "spot",
    "x-asm": [
      "s",
      "asm"
    ],
    "x-c": [
      "c",
      "h",
      "dic"
    ],
    "x-fortran": [
      "f",
      "for",
      "f77",
      "f90"
    ],
    "x-opml": "opml",
    "x-nfo": "nfo",
    "x-sfv": "sfv",
    "x-uuencode": "uu",
    "webviewhtml": "htt",
    "javascript": "js",
    "json": "json",
    "markdown": [
      "md",
      "markdown",
      "mdown",
      "markdn"
    ],
    "vnd.wap.si": "si",
    "vnd.wap.sl": "sl"
  },
  "video": {
    "avif": "avif",
    "3gpp": "3gp",
    "annodex": "axv",
    "dl": "dl",
    "dv": [
      "dif",
      "dv"
    ],
    "fli": "fli",
    "gl": "gl",
    "mpeg": [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v",
      "mp2",
      "mpa",
      "mpv2"
    ],
    "mp4": [
      "mp4",
      "mp4v",
      "mpg4"
    ],
    "quicktime": [
      "qt",
      "mov"
    ],
    "ogg": "ogv",
    "vnd.mpegurl": [
      "mxu",
      "m4u"
    ],
    "x-flv": "flv",
    "x-la-asf": [
      "lsf",
      "lsx"
    ],
    "x-mng": "mng",
    "x-ms-asf": [
      "asf",
      "asx",
      "asr"
    ],
    "x-ms-wm": "wm",
    "x-ms-wmv": "wmv",
    "x-ms-wmx": "wmx",
    "x-ms-wvx": "wvx",
    "x-msvideo": "avi",
    "x-sgi-movie": "movie",
    "x-matroska": [
      "mpv",
      "mkv",
      "mk3d",
      "mks"
    ],
    "3gpp2": "3g2",
    "h261": "h261",
    "h263": "h263",
    "h264": "h264",
    "jpeg": "jpgv",
    "jpm": [
      "jpm",
      "jpgm"
    ],
    "mj2": [
      "mj2",
      "mjp2"
    ],
    "vnd.dece.hd": [
      "uvh",
      "uvvh"
    ],
    "vnd.dece.mobile": [
      "uvm",
      "uvvm"
    ],
    "vnd.dece.pd": [
      "uvp",
      "uvvp"
    ],
    "vnd.dece.sd": [
      "uvs",
      "uvvs"
    ],
    "vnd.dece.video": [
      "uvv",
      "uvvv"
    ],
    "vnd.dvb.file": "dvb",
    "vnd.fvt": "fvt",
    "vnd.ms-playready.media.pyv": "pyv",
    "vnd.uvvu.mp4": [
      "uvu",
      "uvvu"
    ],
    "vnd.vivo": "viv",
    "webm": "webm",
    "x-f4v": "f4v",
    "x-m4v": "m4v",
    "x-ms-vob": "vob",
    "x-smv": "smv",
    "mp2t": "ts"
  },
  "x-conference": {
    "x-cooltalk": "ice"
  },
  "x-world": {
    "x-vrml": [
      "vrm",
      "flr",
      "wrz",
      "xaf",
      "xof"
    ]
  }
};
var mimeTypes = (() => {
  const mimeTypes2 = {};
  for (const type of Object.keys(table)) {
    for (const subtype of Object.keys(table[type])) {
      const value = table[type][subtype];
      if (typeof value == "string") {
        mimeTypes2[value] = type + "/" + subtype;
      } else {
        for (let indexMimeType = 0; indexMimeType < value.length; indexMimeType++) {
          mimeTypes2[value[indexMimeType]] = type + "/" + subtype;
        }
      }
    }
  }
  return mimeTypes2;
})();

// node_modules/@zip.js/zip.js/lib/core/streams/codecs/crc32.js
var table2 = [];
for (let i = 0; i < 256; i++) {
  let t2 = i;
  for (let j = 0; j < 8; j++) {
    if (t2 & 1) {
      t2 = t2 >>> 1 ^ 3988292384;
    } else {
      t2 = t2 >>> 1;
    }
  }
  table2[i] = t2;
}
var Crc32 = class {
  constructor(crc) {
    this.crc = crc || -1;
  }
  append(data) {
    let crc = this.crc | 0;
    for (let offset = 0, length = data.length | 0; offset < length; offset++) {
      crc = crc >>> 8 ^ table2[(crc ^ data[offset]) & 255];
    }
    this.crc = crc;
  }
  get() {
    return ~this.crc;
  }
};

// node_modules/@zip.js/zip.js/lib/core/streams/crc32-stream.js
var Crc32Stream = class extends TransformStream {
  constructor() {
    let stream;
    const crc32 = new Crc32();
    super({
      transform(chunk, controller) {
        crc32.append(chunk);
        controller.enqueue(chunk);
      },
      flush() {
        const value = new Uint8Array(4);
        const dataView = new DataView(value.buffer);
        dataView.setUint32(0, crc32.get());
        stream.value = value;
      }
    });
    stream = this;
  }
};

// node_modules/@zip.js/zip.js/lib/core/util/encode-text.js
function encodeText(value) {
  if (typeof TextEncoder == UNDEFINED_TYPE) {
    value = unescape(encodeURIComponent(value));
    const result = new Uint8Array(value.length);
    for (let i = 0; i < result.length; i++) {
      result[i] = value.charCodeAt(i);
    }
    return result;
  } else {
    return new TextEncoder().encode(value);
  }
}

// node_modules/@zip.js/zip.js/lib/core/streams/codecs/sjcl.js
var bitArray = {
  /**
   * Concatenate two bit arrays.
   * @param {bitArray} a1 The first array.
   * @param {bitArray} a2 The second array.
   * @return {bitArray} The concatenation of a1 and a2.
   */
  concat(a1, a2) {
    if (a1.length === 0 || a2.length === 0) {
      return a1.concat(a2);
    }
    const last = a1[a1.length - 1], shift = bitArray.getPartial(last);
    if (shift === 32) {
      return a1.concat(a2);
    } else {
      return bitArray._shiftRight(a2, shift, last | 0, a1.slice(0, a1.length - 1));
    }
  },
  /**
   * Find the length of an array of bits.
   * @param {bitArray} a The array.
   * @return {Number} The length of a, in bits.
   */
  bitLength(a) {
    const l = a.length;
    if (l === 0) {
      return 0;
    }
    const x = a[l - 1];
    return (l - 1) * 32 + bitArray.getPartial(x);
  },
  /**
   * Truncate an array.
   * @param {bitArray} a The array.
   * @param {Number} len The length to truncate to, in bits.
   * @return {bitArray} A new array, truncated to len bits.
   */
  clamp(a, len) {
    if (a.length * 32 < len) {
      return a;
    }
    a = a.slice(0, Math.ceil(len / 32));
    const l = a.length;
    len = len & 31;
    if (l > 0 && len) {
      a[l - 1] = bitArray.partial(len, a[l - 1] & 2147483648 >> len - 1, 1);
    }
    return a;
  },
  /**
   * Make a partial word for a bit array.
   * @param {Number} len The number of bits in the word.
   * @param {Number} x The bits.
   * @param {Number} [_end=0] Pass 1 if x has already been shifted to the high side.
   * @return {Number} The partial word.
   */
  partial(len, x, _end) {
    if (len === 32) {
      return x;
    }
    return (_end ? x | 0 : x << 32 - len) + len * 1099511627776;
  },
  /**
   * Get the number of bits used by a partial word.
   * @param {Number} x The partial word.
   * @return {Number} The number of bits used by the partial word.
   */
  getPartial(x) {
    return Math.round(x / 1099511627776) || 32;
  },
  /** Shift an array right.
   * @param {bitArray} a The array to shift.
   * @param {Number} shift The number of bits to shift.
   * @param {Number} [carry=0] A byte to carry in
   * @param {bitArray} [out=[]] An array to prepend to the output.
   * @private
   */
  _shiftRight(a, shift, carry, out) {
    if (out === void 0) {
      out = [];
    }
    for (; shift >= 32; shift -= 32) {
      out.push(carry);
      carry = 0;
    }
    if (shift === 0) {
      return out.concat(a);
    }
    for (let i = 0; i < a.length; i++) {
      out.push(carry | a[i] >>> shift);
      carry = a[i] << 32 - shift;
    }
    const last2 = a.length ? a[a.length - 1] : 0;
    const shift2 = bitArray.getPartial(last2);
    out.push(bitArray.partial(shift + shift2 & 31, shift + shift2 > 32 ? carry : out.pop(), 1));
    return out;
  }
};
var codec = {
  bytes: {
    /** Convert from a bitArray to an array of bytes. */
    fromBits(arr) {
      const bl = bitArray.bitLength(arr);
      const byteLength = bl / 8;
      const out = new Uint8Array(byteLength);
      let tmp;
      for (let i = 0; i < byteLength; i++) {
        if ((i & 3) === 0) {
          tmp = arr[i / 4];
        }
        out[i] = tmp >>> 24;
        tmp <<= 8;
      }
      return out;
    },
    /** Convert from an array of bytes to a bitArray. */
    toBits(bytes) {
      const out = [];
      let i;
      let tmp = 0;
      for (i = 0; i < bytes.length; i++) {
        tmp = tmp << 8 | bytes[i];
        if ((i & 3) === 3) {
          out.push(tmp);
          tmp = 0;
        }
      }
      if (i & 3) {
        out.push(bitArray.partial(8 * (i & 3), tmp));
      }
      return out;
    }
  }
};
var hash = {};
hash.sha1 = class {
  constructor(hash2) {
    const sha1 = this;
    sha1.blockSize = 512;
    sha1._init = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    sha1._key = [1518500249, 1859775393, 2400959708, 3395469782];
    if (hash2) {
      sha1._h = hash2._h.slice(0);
      sha1._buffer = hash2._buffer.slice(0);
      sha1._length = hash2._length;
    } else {
      sha1.reset();
    }
  }
  /**
   * Reset the hash state.
   * @return this
   */
  reset() {
    const sha1 = this;
    sha1._h = sha1._init.slice(0);
    sha1._buffer = [];
    sha1._length = 0;
    return sha1;
  }
  /**
   * Input several words to the hash.
   * @param {bitArray|String} data the data to hash.
   * @return this
   */
  update(data) {
    const sha1 = this;
    if (typeof data === "string") {
      data = codec.utf8String.toBits(data);
    }
    const b = sha1._buffer = bitArray.concat(sha1._buffer, data);
    const ol = sha1._length;
    const nl = sha1._length = ol + bitArray.bitLength(data);
    if (nl > 9007199254740991) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }
    const c = new Uint32Array(b);
    let j = 0;
    for (let i = sha1.blockSize + ol - (sha1.blockSize + ol & sha1.blockSize - 1); i <= nl; i += sha1.blockSize) {
      sha1._block(c.subarray(16 * j, 16 * (j + 1)));
      j += 1;
    }
    b.splice(0, 16 * j);
    return sha1;
  }
  /**
   * Complete hashing and output the hash value.
   * @return {bitArray} The hash value, an array of 5 big-endian words. TODO
   */
  finalize() {
    const sha1 = this;
    let b = sha1._buffer;
    const h = sha1._h;
    b = bitArray.concat(b, [bitArray.partial(1, 1)]);
    for (let i = b.length + 2; i & 15; i++) {
      b.push(0);
    }
    b.push(Math.floor(sha1._length / 4294967296));
    b.push(sha1._length | 0);
    while (b.length) {
      sha1._block(b.splice(0, 16));
    }
    sha1.reset();
    return h;
  }
  /**
   * The SHA-1 logical functions f(0), f(1), ..., f(79).
   * @private
   */
  _f(t2, b, c, d) {
    if (t2 <= 19) {
      return b & c | ~b & d;
    } else if (t2 <= 39) {
      return b ^ c ^ d;
    } else if (t2 <= 59) {
      return b & c | b & d | c & d;
    } else if (t2 <= 79) {
      return b ^ c ^ d;
    }
  }
  /**
   * Circular left-shift operator.
   * @private
   */
  _S(n, x) {
    return x << n | x >>> 32 - n;
  }
  /**
   * Perform one cycle of SHA-1.
   * @param {Uint32Array|bitArray} words one block of words.
   * @private
   */
  _block(words) {
    const sha1 = this;
    const h = sha1._h;
    const w = Array(80);
    for (let j = 0; j < 16; j++) {
      w[j] = words[j];
    }
    let a = h[0];
    let b = h[1];
    let c = h[2];
    let d = h[3];
    let e2 = h[4];
    for (let t2 = 0; t2 <= 79; t2++) {
      if (t2 >= 16) {
        w[t2] = sha1._S(1, w[t2 - 3] ^ w[t2 - 8] ^ w[t2 - 14] ^ w[t2 - 16]);
      }
      const tmp = sha1._S(5, a) + sha1._f(t2, b, c, d) + e2 + w[t2] + sha1._key[Math.floor(t2 / 20)] | 0;
      e2 = d;
      d = c;
      c = sha1._S(30, b);
      b = a;
      a = tmp;
    }
    h[0] = h[0] + a | 0;
    h[1] = h[1] + b | 0;
    h[2] = h[2] + c | 0;
    h[3] = h[3] + d | 0;
    h[4] = h[4] + e2 | 0;
  }
};
var cipher = {};
cipher.aes = class {
  constructor(key) {
    const aes = this;
    aes._tables = [[[], [], [], [], []], [[], [], [], [], []]];
    if (!aes._tables[0][0][0]) {
      aes._precompute();
    }
    const sbox = aes._tables[0][4];
    const decTable = aes._tables[1];
    const keyLen = key.length;
    let i, encKey, decKey, rcon = 1;
    if (keyLen !== 4 && keyLen !== 6 && keyLen !== 8) {
      throw new Error("invalid aes key size");
    }
    aes._key = [encKey = key.slice(0), decKey = []];
    for (i = keyLen; i < 4 * keyLen + 28; i++) {
      let tmp = encKey[i - 1];
      if (i % keyLen === 0 || keyLen === 8 && i % keyLen === 4) {
        tmp = sbox[tmp >>> 24] << 24 ^ sbox[tmp >> 16 & 255] << 16 ^ sbox[tmp >> 8 & 255] << 8 ^ sbox[tmp & 255];
        if (i % keyLen === 0) {
          tmp = tmp << 8 ^ tmp >>> 24 ^ rcon << 24;
          rcon = rcon << 1 ^ (rcon >> 7) * 283;
        }
      }
      encKey[i] = encKey[i - keyLen] ^ tmp;
    }
    for (let j = 0; i; j++, i--) {
      const tmp = encKey[j & 3 ? i : i - 4];
      if (i <= 4 || j < 4) {
        decKey[j] = tmp;
      } else {
        decKey[j] = decTable[0][sbox[tmp >>> 24]] ^ decTable[1][sbox[tmp >> 16 & 255]] ^ decTable[2][sbox[tmp >> 8 & 255]] ^ decTable[3][sbox[tmp & 255]];
      }
    }
  }
  // public
  /* Something like this might appear here eventually
  name: "AES",
  blockSize: 4,
  keySizes: [4,6,8],
  */
  /**
   * Encrypt an array of 4 big-endian words.
   * @param {Array} data The plaintext.
   * @return {Array} The ciphertext.
   */
  encrypt(data) {
    return this._crypt(data, 0);
  }
  /**
   * Decrypt an array of 4 big-endian words.
   * @param {Array} data The ciphertext.
   * @return {Array} The plaintext.
   */
  decrypt(data) {
    return this._crypt(data, 1);
  }
  /**
   * Expand the S-box tables.
   *
   * @private
   */
  _precompute() {
    const encTable = this._tables[0];
    const decTable = this._tables[1];
    const sbox = encTable[4];
    const sboxInv = decTable[4];
    const d = [];
    const th = [];
    let xInv, x2, x4, x8;
    for (let i = 0; i < 256; i++) {
      th[(d[i] = i << 1 ^ (i >> 7) * 283) ^ i] = i;
    }
    for (let x = xInv = 0; !sbox[x]; x ^= x2 || 1, xInv = th[xInv] || 1) {
      let s = xInv ^ xInv << 1 ^ xInv << 2 ^ xInv << 3 ^ xInv << 4;
      s = s >> 8 ^ s & 255 ^ 99;
      sbox[x] = s;
      sboxInv[s] = x;
      x8 = d[x4 = d[x2 = d[x]]];
      let tDec = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
      let tEnc = d[s] * 257 ^ s * 16843008;
      for (let i = 0; i < 4; i++) {
        encTable[i][x] = tEnc = tEnc << 24 ^ tEnc >>> 8;
        decTable[i][s] = tDec = tDec << 24 ^ tDec >>> 8;
      }
    }
    for (let i = 0; i < 5; i++) {
      encTable[i] = encTable[i].slice(0);
      decTable[i] = decTable[i].slice(0);
    }
  }
  /**
   * Encryption and decryption core.
   * @param {Array} input Four words to be encrypted or decrypted.
   * @param dir The direction, 0 for encrypt and 1 for decrypt.
   * @return {Array} The four encrypted or decrypted words.
   * @private
   */
  _crypt(input, dir2) {
    if (input.length !== 4) {
      throw new Error("invalid aes block size");
    }
    const key = this._key[dir2];
    const nInnerRounds = key.length / 4 - 2;
    const out = [0, 0, 0, 0];
    const table3 = this._tables[dir2];
    const t0 = table3[0];
    const t1 = table3[1];
    const t2 = table3[2];
    const t3 = table3[3];
    const sbox = table3[4];
    let a = input[0] ^ key[0];
    let b = input[dir2 ? 3 : 1] ^ key[1];
    let c = input[2] ^ key[2];
    let d = input[dir2 ? 1 : 3] ^ key[3];
    let kIndex = 4;
    let a2, b2, c2;
    for (let i = 0; i < nInnerRounds; i++) {
      a2 = t0[a >>> 24] ^ t1[b >> 16 & 255] ^ t2[c >> 8 & 255] ^ t3[d & 255] ^ key[kIndex];
      b2 = t0[b >>> 24] ^ t1[c >> 16 & 255] ^ t2[d >> 8 & 255] ^ t3[a & 255] ^ key[kIndex + 1];
      c2 = t0[c >>> 24] ^ t1[d >> 16 & 255] ^ t2[a >> 8 & 255] ^ t3[b & 255] ^ key[kIndex + 2];
      d = t0[d >>> 24] ^ t1[a >> 16 & 255] ^ t2[b >> 8 & 255] ^ t3[c & 255] ^ key[kIndex + 3];
      kIndex += 4;
      a = a2;
      b = b2;
      c = c2;
    }
    for (let i = 0; i < 4; i++) {
      out[dir2 ? 3 & -i : i] = sbox[a >>> 24] << 24 ^ sbox[b >> 16 & 255] << 16 ^ sbox[c >> 8 & 255] << 8 ^ sbox[d & 255] ^ key[kIndex++];
      a2 = a;
      a = b;
      b = c;
      c = d;
      d = a2;
    }
    return out;
  }
};
var random = {
  /** 
   * Generate random words with pure js, cryptographically not as strong & safe as native implementation.
   * @param {TypedArray} typedArray The array to fill.
   * @return {TypedArray} The random values.
   */
  getRandomValues(typedArray) {
    const words = new Uint32Array(typedArray.buffer);
    const r = (m_w) => {
      let m_z = 987654321;
      const mask = 4294967295;
      return function() {
        m_z = 36969 * (m_z & 65535) + (m_z >> 16) & mask;
        m_w = 18e3 * (m_w & 65535) + (m_w >> 16) & mask;
        const result = ((m_z << 16) + m_w & mask) / 4294967296 + 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let i = 0, rcache; i < typedArray.length; i += 4) {
      const _r = r((rcache || Math.random()) * 4294967296);
      rcache = _r() * 987654071;
      words[i / 4] = _r() * 4294967296 | 0;
    }
    return typedArray;
  }
};
var mode = {};
mode.ctrGladman = class {
  constructor(prf, iv) {
    this._prf = prf;
    this._initIv = iv;
    this._iv = iv;
  }
  reset() {
    this._iv = this._initIv;
  }
  /** Input some data to calculate.
   * @param {bitArray} data the data to process, it must be intergral multiple of 128 bits unless it's the last.
   */
  update(data) {
    return this.calculate(this._prf, data, this._iv);
  }
  incWord(word) {
    if ((word >> 24 & 255) === 255) {
      let b1 = word >> 16 & 255;
      let b2 = word >> 8 & 255;
      let b3 = word & 255;
      if (b1 === 255) {
        b1 = 0;
        if (b2 === 255) {
          b2 = 0;
          if (b3 === 255) {
            b3 = 0;
          } else {
            ++b3;
          }
        } else {
          ++b2;
        }
      } else {
        ++b1;
      }
      word = 0;
      word += b1 << 16;
      word += b2 << 8;
      word += b3;
    } else {
      word += 1 << 24;
    }
    return word;
  }
  incCounter(counter) {
    if ((counter[0] = this.incWord(counter[0])) === 0) {
      counter[1] = this.incWord(counter[1]);
    }
  }
  calculate(prf, data, iv) {
    let l;
    if (!(l = data.length)) {
      return [];
    }
    const bl = bitArray.bitLength(data);
    for (let i = 0; i < l; i += 4) {
      this.incCounter(iv);
      const e2 = prf.encrypt(iv);
      data[i] ^= e2[0];
      data[i + 1] ^= e2[1];
      data[i + 2] ^= e2[2];
      data[i + 3] ^= e2[3];
    }
    return bitArray.clamp(data, bl);
  }
};
var misc = {
  importKey(password) {
    return new misc.hmacSha1(codec.bytes.toBits(password));
  },
  pbkdf2(prf, salt, count, length) {
    count = count || 1e4;
    if (length < 0 || count < 0) {
      throw new Error("invalid params to pbkdf2");
    }
    const byteLength = (length >> 5) + 1 << 2;
    let u, ui, i, j, k;
    const arrayBuffer = new ArrayBuffer(byteLength);
    const out = new DataView(arrayBuffer);
    let outLength = 0;
    const b = bitArray;
    salt = codec.bytes.toBits(salt);
    for (k = 1; outLength < (byteLength || 1); k++) {
      u = ui = prf.encrypt(b.concat(salt, [k]));
      for (i = 1; i < count; i++) {
        ui = prf.encrypt(ui);
        for (j = 0; j < ui.length; j++) {
          u[j] ^= ui[j];
        }
      }
      for (i = 0; outLength < (byteLength || 1) && i < u.length; i++) {
        out.setInt32(outLength, u[i]);
        outLength += 4;
      }
    }
    return arrayBuffer.slice(0, length / 8);
  }
};
misc.hmacSha1 = class {
  constructor(key) {
    const hmac = this;
    const Hash = hmac._hash = hash.sha1;
    const exKey = [[], []];
    hmac._baseHash = [new Hash(), new Hash()];
    const bs = hmac._baseHash[0].blockSize / 32;
    if (key.length > bs) {
      key = new Hash().update(key).finalize();
    }
    for (let i = 0; i < bs; i++) {
      exKey[0][i] = key[i] ^ 909522486;
      exKey[1][i] = key[i] ^ 1549556828;
    }
    hmac._baseHash[0].update(exKey[0]);
    hmac._baseHash[1].update(exKey[1]);
    hmac._resultHash = new Hash(hmac._baseHash[0]);
  }
  reset() {
    const hmac = this;
    hmac._resultHash = new hmac._hash(hmac._baseHash[0]);
    hmac._updated = false;
  }
  update(data) {
    const hmac = this;
    hmac._updated = true;
    hmac._resultHash.update(data);
  }
  digest() {
    const hmac = this;
    const w = hmac._resultHash.finalize();
    const result = new hmac._hash(hmac._baseHash[1]).update(w).finalize();
    hmac.reset();
    return result;
  }
  encrypt(data) {
    if (!this._updated) {
      this.update(data);
      return this.digest(data);
    } else {
      throw new Error("encrypt on already updated hmac called!");
    }
  }
};

// node_modules/@zip.js/zip.js/lib/core/streams/common-crypto.js
var GET_RANDOM_VALUES_SUPPORTED = typeof crypto != UNDEFINED_TYPE && typeof crypto.getRandomValues == FUNCTION_TYPE;
var ERR_INVALID_PASSWORD = "Invalid password";
var ERR_INVALID_SIGNATURE = "Invalid signature";
var ERR_ABORT_CHECK_PASSWORD = "zipjs-abort-check-password";
function getRandomValues(array) {
  if (GET_RANDOM_VALUES_SUPPORTED) {
    return crypto.getRandomValues(array);
  } else {
    return random.getRandomValues(array);
  }
}

// node_modules/@zip.js/zip.js/lib/core/streams/aes-crypto-stream.js
var BLOCK_LENGTH = 16;
var RAW_FORMAT = "raw";
var PBKDF2_ALGORITHM = { name: "PBKDF2" };
var HASH_ALGORITHM = { name: "HMAC" };
var HASH_FUNCTION = "SHA-1";
var BASE_KEY_ALGORITHM = Object.assign({ hash: HASH_ALGORITHM }, PBKDF2_ALGORITHM);
var DERIVED_BITS_ALGORITHM = Object.assign({ iterations: 1e3, hash: { name: HASH_FUNCTION } }, PBKDF2_ALGORITHM);
var DERIVED_BITS_USAGE = ["deriveBits"];
var SALT_LENGTH = [8, 12, 16];
var KEY_LENGTH = [16, 24, 32];
var SIGNATURE_LENGTH = 10;
var COUNTER_DEFAULT_VALUE = [0, 0, 0, 0];
var CRYPTO_API_SUPPORTED = typeof crypto != UNDEFINED_TYPE;
var subtle = CRYPTO_API_SUPPORTED && crypto.subtle;
var SUBTLE_API_SUPPORTED = CRYPTO_API_SUPPORTED && typeof subtle != UNDEFINED_TYPE;
var codecBytes = codec.bytes;
var Aes = cipher.aes;
var CtrGladman = mode.ctrGladman;
var HmacSha1 = misc.hmacSha1;
var IMPORT_KEY_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.importKey == FUNCTION_TYPE;
var DERIVE_BITS_SUPPORTED = CRYPTO_API_SUPPORTED && SUBTLE_API_SUPPORTED && typeof subtle.deriveBits == FUNCTION_TYPE;
var AESDecryptionStream = class extends TransformStream {
  constructor({ password, rawPassword, signed, encryptionStrength, checkPasswordOnly }) {
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve) => this.resolveReady = resolve),
          password: encodePassword(password, rawPassword),
          signed,
          strength: encryptionStrength - 1,
          pending: new Uint8Array()
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        const {
          password: password2,
          strength,
          resolveReady,
          ready
        } = aesCrypto;
        if (password2) {
          await createDecryptionKeys(aesCrypto, strength, password2, subarray(chunk, 0, SALT_LENGTH[strength] + 2));
          chunk = subarray(chunk, SALT_LENGTH[strength] + 2);
          if (checkPasswordOnly) {
            controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
          } else {
            resolveReady();
          }
        } else {
          await ready;
        }
        const output = new Uint8Array(chunk.length - SIGNATURE_LENGTH - (chunk.length - SIGNATURE_LENGTH) % BLOCK_LENGTH);
        controller.enqueue(append(aesCrypto, chunk, output, 0, SIGNATURE_LENGTH, true));
      },
      async flush(controller) {
        const {
          signed: signed2,
          ctr,
          hmac,
          pending,
          ready
        } = this;
        if (hmac && ctr) {
          await ready;
          const chunkToDecrypt = subarray(pending, 0, pending.length - SIGNATURE_LENGTH);
          const originalSignature = subarray(pending, pending.length - SIGNATURE_LENGTH);
          let decryptedChunkArray = new Uint8Array();
          if (chunkToDecrypt.length) {
            const encryptedChunk = toBits(codecBytes, chunkToDecrypt);
            hmac.update(encryptedChunk);
            const decryptedChunk = ctr.update(encryptedChunk);
            decryptedChunkArray = fromBits(codecBytes, decryptedChunk);
          }
          if (signed2) {
            const signature = subarray(fromBits(codecBytes, hmac.digest()), 0, SIGNATURE_LENGTH);
            for (let indexSignature = 0; indexSignature < SIGNATURE_LENGTH; indexSignature++) {
              if (signature[indexSignature] != originalSignature[indexSignature]) {
                throw new Error(ERR_INVALID_SIGNATURE);
              }
            }
          }
          controller.enqueue(decryptedChunkArray);
        }
      }
    });
  }
};
var AESEncryptionStream = class extends TransformStream {
  constructor({ password, rawPassword, encryptionStrength }) {
    let stream;
    super({
      start() {
        Object.assign(this, {
          ready: new Promise((resolve) => this.resolveReady = resolve),
          password: encodePassword(password, rawPassword),
          strength: encryptionStrength - 1,
          pending: new Uint8Array()
        });
      },
      async transform(chunk, controller) {
        const aesCrypto = this;
        const {
          password: password2,
          strength,
          resolveReady,
          ready
        } = aesCrypto;
        let preamble = new Uint8Array();
        if (password2) {
          preamble = await createEncryptionKeys(aesCrypto, strength, password2);
          resolveReady();
        } else {
          await ready;
        }
        const output = new Uint8Array(preamble.length + chunk.length - chunk.length % BLOCK_LENGTH);
        output.set(preamble, 0);
        controller.enqueue(append(aesCrypto, chunk, output, preamble.length, 0));
      },
      async flush(controller) {
        const {
          ctr,
          hmac,
          pending,
          ready
        } = this;
        if (hmac && ctr) {
          await ready;
          let encryptedChunkArray = new Uint8Array();
          if (pending.length) {
            const encryptedChunk = ctr.update(toBits(codecBytes, pending));
            hmac.update(encryptedChunk);
            encryptedChunkArray = fromBits(codecBytes, encryptedChunk);
          }
          stream.signature = fromBits(codecBytes, hmac.digest()).slice(0, SIGNATURE_LENGTH);
          controller.enqueue(concat(encryptedChunkArray, stream.signature));
        }
      }
    });
    stream = this;
  }
};
function append(aesCrypto, input, output, paddingStart, paddingEnd, verifySignature) {
  const {
    ctr,
    hmac,
    pending
  } = aesCrypto;
  const inputLength = input.length - paddingEnd;
  if (pending.length) {
    input = concat(pending, input);
    output = expand(output, inputLength - inputLength % BLOCK_LENGTH);
  }
  let offset;
  for (offset = 0; offset <= inputLength - BLOCK_LENGTH; offset += BLOCK_LENGTH) {
    const inputChunk = toBits(codecBytes, subarray(input, offset, offset + BLOCK_LENGTH));
    if (verifySignature) {
      hmac.update(inputChunk);
    }
    const outputChunk = ctr.update(inputChunk);
    if (!verifySignature) {
      hmac.update(outputChunk);
    }
    output.set(fromBits(codecBytes, outputChunk), offset + paddingStart);
  }
  aesCrypto.pending = subarray(input, offset);
  return output;
}
async function createDecryptionKeys(decrypt2, strength, password, preamble) {
  const passwordVerificationKey = await createKeys(decrypt2, strength, password, subarray(preamble, 0, SALT_LENGTH[strength]));
  const passwordVerification = subarray(preamble, SALT_LENGTH[strength]);
  if (passwordVerificationKey[0] != passwordVerification[0] || passwordVerificationKey[1] != passwordVerification[1]) {
    throw new Error(ERR_INVALID_PASSWORD);
  }
}
async function createEncryptionKeys(encrypt2, strength, password) {
  const salt = getRandomValues(new Uint8Array(SALT_LENGTH[strength]));
  const passwordVerification = await createKeys(encrypt2, strength, password, salt);
  return concat(salt, passwordVerification);
}
async function createKeys(aesCrypto, strength, password, salt) {
  aesCrypto.password = null;
  const baseKey = await importKey(RAW_FORMAT, password, BASE_KEY_ALGORITHM, false, DERIVED_BITS_USAGE);
  const derivedBits = await deriveBits(Object.assign({ salt }, DERIVED_BITS_ALGORITHM), baseKey, 8 * (KEY_LENGTH[strength] * 2 + 2));
  const compositeKey = new Uint8Array(derivedBits);
  const key = toBits(codecBytes, subarray(compositeKey, 0, KEY_LENGTH[strength]));
  const authentication = toBits(codecBytes, subarray(compositeKey, KEY_LENGTH[strength], KEY_LENGTH[strength] * 2));
  const passwordVerification = subarray(compositeKey, KEY_LENGTH[strength] * 2);
  Object.assign(aesCrypto, {
    keys: {
      key,
      authentication,
      passwordVerification
    },
    ctr: new CtrGladman(new Aes(key), Array.from(COUNTER_DEFAULT_VALUE)),
    hmac: new HmacSha1(authentication)
  });
  return passwordVerification;
}
async function importKey(format, password, algorithm, extractable, keyUsages) {
  if (IMPORT_KEY_SUPPORTED) {
    try {
      return await subtle.importKey(format, password, algorithm, extractable, keyUsages);
    } catch (_error) {
      IMPORT_KEY_SUPPORTED = false;
      return misc.importKey(password);
    }
  } else {
    return misc.importKey(password);
  }
}
async function deriveBits(algorithm, baseKey, length) {
  if (DERIVE_BITS_SUPPORTED) {
    try {
      return await subtle.deriveBits(algorithm, baseKey, length);
    } catch (_error) {
      DERIVE_BITS_SUPPORTED = false;
      return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
    }
  } else {
    return misc.pbkdf2(baseKey, algorithm.salt, DERIVED_BITS_ALGORITHM.iterations, length);
  }
}
function encodePassword(password, rawPassword) {
  if (rawPassword === UNDEFINED_VALUE) {
    return encodeText(password);
  } else {
    return rawPassword;
  }
}
function concat(leftArray, rightArray) {
  let array = leftArray;
  if (leftArray.length + rightArray.length) {
    array = new Uint8Array(leftArray.length + rightArray.length);
    array.set(leftArray, 0);
    array.set(rightArray, leftArray.length);
  }
  return array;
}
function expand(inputArray, length) {
  if (length && length > inputArray.length) {
    const array = inputArray;
    inputArray = new Uint8Array(length);
    inputArray.set(array, 0);
  }
  return inputArray;
}
function subarray(array, begin, end) {
  return array.subarray(begin, end);
}
function fromBits(codecBytes2, chunk) {
  return codecBytes2.fromBits(chunk);
}
function toBits(codecBytes2, chunk) {
  return codecBytes2.toBits(chunk);
}

// node_modules/@zip.js/zip.js/lib/core/streams/zip-crypto-stream.js
var HEADER_LENGTH = 12;
var ZipCryptoDecryptionStream = class extends TransformStream {
  constructor({ password, passwordVerification, checkPasswordOnly }) {
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys2(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        if (zipCrypto.password) {
          const decryptedHeader = decrypt(zipCrypto, chunk.subarray(0, HEADER_LENGTH));
          zipCrypto.password = null;
          if (decryptedHeader[HEADER_LENGTH - 1] != zipCrypto.passwordVerification) {
            throw new Error(ERR_INVALID_PASSWORD);
          }
          chunk = chunk.subarray(HEADER_LENGTH);
        }
        if (checkPasswordOnly) {
          controller.error(new Error(ERR_ABORT_CHECK_PASSWORD));
        } else {
          controller.enqueue(decrypt(zipCrypto, chunk));
        }
      }
    });
  }
};
var ZipCryptoEncryptionStream = class extends TransformStream {
  constructor({ password, passwordVerification }) {
    super({
      start() {
        Object.assign(this, {
          password,
          passwordVerification
        });
        createKeys2(this, password);
      },
      transform(chunk, controller) {
        const zipCrypto = this;
        let output;
        let offset;
        if (zipCrypto.password) {
          zipCrypto.password = null;
          const header = getRandomValues(new Uint8Array(HEADER_LENGTH));
          header[HEADER_LENGTH - 1] = zipCrypto.passwordVerification;
          output = new Uint8Array(chunk.length + header.length);
          output.set(encrypt(zipCrypto, header), 0);
          offset = HEADER_LENGTH;
        } else {
          output = new Uint8Array(chunk.length);
          offset = 0;
        }
        output.set(encrypt(zipCrypto, chunk), offset);
        controller.enqueue(output);
      }
    });
  }
};
function decrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output[index] = getByte(target) ^ input[index];
    updateKeys(target, output[index]);
  }
  return output;
}
function encrypt(target, input) {
  const output = new Uint8Array(input.length);
  for (let index = 0; index < input.length; index++) {
    output[index] = getByte(target) ^ input[index];
    updateKeys(target, input[index]);
  }
  return output;
}
function createKeys2(target, password) {
  const keys = [305419896, 591751049, 878082192];
  Object.assign(target, {
    keys,
    crcKey0: new Crc32(keys[0]),
    crcKey2: new Crc32(keys[2])
  });
  for (let index = 0; index < password.length; index++) {
    updateKeys(target, password.charCodeAt(index));
  }
}
function updateKeys(target, byte) {
  let [key0, key1, key2] = target.keys;
  target.crcKey0.append([byte]);
  key0 = ~target.crcKey0.get();
  key1 = getInt32(Math.imul(getInt32(key1 + getInt8(key0)), 134775813) + 1);
  target.crcKey2.append([key1 >>> 24]);
  key2 = ~target.crcKey2.get();
  target.keys = [key0, key1, key2];
}
function getByte(target) {
  const temp = target.keys[2] | 2;
  return getInt8(Math.imul(temp, temp ^ 1) >>> 8);
}
function getInt8(number) {
  return number & 255;
}
function getInt32(number) {
  return number & 4294967295;
}

// node_modules/@zip.js/zip.js/lib/core/streams/zip-entry-stream.js
var COMPRESSION_FORMAT = "deflate-raw";
var DeflateStream = class extends TransformStream {
  constructor(options, { chunkSize, CompressionStream: CompressionStream2, CompressionStreamNative }) {
    super({});
    const { compressed, encrypted, useCompressionStream, zipCrypto, signed, level } = options;
    const stream = this;
    let crc32Stream, encryptionStream;
    let readable = filterEmptyChunks(super.readable);
    if ((!encrypted || zipCrypto) && signed) {
      crc32Stream = new Crc32Stream();
      readable = pipeThrough(readable, crc32Stream);
    }
    if (compressed) {
      readable = pipeThroughCommpressionStream(readable, useCompressionStream, { level, chunkSize }, CompressionStreamNative, CompressionStream2);
    }
    if (encrypted) {
      if (zipCrypto) {
        readable = pipeThrough(readable, new ZipCryptoEncryptionStream(options));
      } else {
        encryptionStream = new AESEncryptionStream(options);
        readable = pipeThrough(readable, encryptionStream);
      }
    }
    setReadable(stream, readable, () => {
      let signature;
      if (encrypted && !zipCrypto) {
        signature = encryptionStream.signature;
      }
      if ((!encrypted || zipCrypto) && signed) {
        signature = new DataView(crc32Stream.value.buffer).getUint32(0);
      }
      stream.signature = signature;
    });
  }
};
var InflateStream = class extends TransformStream {
  constructor(options, { chunkSize, DecompressionStream: DecompressionStream2, DecompressionStreamNative }) {
    super({});
    const { zipCrypto, encrypted, signed, signature, compressed, useCompressionStream } = options;
    let crc32Stream, decryptionStream;
    let readable = filterEmptyChunks(super.readable);
    if (encrypted) {
      if (zipCrypto) {
        readable = pipeThrough(readable, new ZipCryptoDecryptionStream(options));
      } else {
        decryptionStream = new AESDecryptionStream(options);
        readable = pipeThrough(readable, decryptionStream);
      }
    }
    if (compressed) {
      readable = pipeThroughCommpressionStream(readable, useCompressionStream, { chunkSize }, DecompressionStreamNative, DecompressionStream2);
    }
    if ((!encrypted || zipCrypto) && signed) {
      crc32Stream = new Crc32Stream();
      readable = pipeThrough(readable, crc32Stream);
    }
    setReadable(this, readable, () => {
      if ((!encrypted || zipCrypto) && signed) {
        const dataViewSignature = new DataView(crc32Stream.value.buffer);
        if (signature != dataViewSignature.getUint32(0, false)) {
          throw new Error(ERR_INVALID_SIGNATURE);
        }
      }
    });
  }
};
function filterEmptyChunks(readable) {
  return pipeThrough(readable, new TransformStream({
    transform(chunk, controller) {
      if (chunk && chunk.length) {
        controller.enqueue(chunk);
      }
    }
  }));
}
function setReadable(stream, readable, flush) {
  readable = pipeThrough(readable, new TransformStream({ flush }));
  Object.defineProperty(stream, "readable", {
    get() {
      return readable;
    }
  });
}
function pipeThroughCommpressionStream(readable, useCompressionStream, options, CodecStreamNative, CodecStream2) {
  try {
    const CompressionStream2 = useCompressionStream && CodecStreamNative ? CodecStreamNative : CodecStream2;
    readable = pipeThrough(readable, new CompressionStream2(COMPRESSION_FORMAT, options));
  } catch (error) {
    if (useCompressionStream) {
      try {
        readable = pipeThrough(readable, new CodecStream2(COMPRESSION_FORMAT, options));
      } catch (error2) {
        return readable;
      }
    } else {
      return readable;
    }
  }
  return readable;
}
function pipeThrough(readable, transformStream) {
  return readable.pipeThrough(transformStream);
}

// node_modules/@zip.js/zip.js/lib/core/streams/codec-stream.js
var MESSAGE_EVENT_TYPE = "message";
var MESSAGE_START = "start";
var MESSAGE_PULL = "pull";
var MESSAGE_DATA = "data";
var MESSAGE_ACK_DATA = "ack";
var MESSAGE_CLOSE = "close";
var CODEC_DEFLATE = "deflate";
var CODEC_INFLATE = "inflate";
var CodecStream = class extends TransformStream {
  constructor(options, config2) {
    super({});
    const codec2 = this;
    const { codecType } = options;
    let Stream2;
    if (codecType.startsWith(CODEC_DEFLATE)) {
      Stream2 = DeflateStream;
    } else if (codecType.startsWith(CODEC_INFLATE)) {
      Stream2 = InflateStream;
    }
    let outputSize = 0;
    let inputSize = 0;
    const stream = new Stream2(options, config2);
    const readable = super.readable;
    const inputSizeStream = new TransformStream({
      transform(chunk, controller) {
        if (chunk && chunk.length) {
          inputSize += chunk.length;
          controller.enqueue(chunk);
        }
      },
      flush() {
        Object.assign(codec2, {
          inputSize
        });
      }
    });
    const outputSizeStream = new TransformStream({
      transform(chunk, controller) {
        if (chunk && chunk.length) {
          outputSize += chunk.length;
          controller.enqueue(chunk);
        }
      },
      flush() {
        const { signature } = stream;
        Object.assign(codec2, {
          signature,
          outputSize,
          inputSize
        });
      }
    });
    Object.defineProperty(codec2, "readable", {
      get() {
        return readable.pipeThrough(inputSizeStream).pipeThrough(stream).pipeThrough(outputSizeStream);
      }
    });
  }
};
var ChunkStream = class extends TransformStream {
  constructor(chunkSize) {
    let pendingChunk;
    super({
      transform,
      flush(controller) {
        if (pendingChunk && pendingChunk.length) {
          controller.enqueue(pendingChunk);
        }
      }
    });
    function transform(chunk, controller) {
      if (pendingChunk) {
        const newChunk = new Uint8Array(pendingChunk.length + chunk.length);
        newChunk.set(pendingChunk);
        newChunk.set(chunk, pendingChunk.length);
        chunk = newChunk;
        pendingChunk = null;
      }
      if (chunk.length > chunkSize) {
        controller.enqueue(chunk.slice(0, chunkSize));
        transform(chunk.slice(chunkSize), controller);
      } else {
        pendingChunk = chunk;
      }
    }
  }
};

// node_modules/@zip.js/zip.js/lib/core/codec-worker.js
var WEB_WORKERS_SUPPORTED = typeof Worker != UNDEFINED_TYPE;
var CodecWorker = class {
  constructor(workerData, { readable, writable }, { options, config: config2, streamOptions, useWebWorkers, transferStreams, scripts }, onTaskFinished) {
    const { signal } = streamOptions;
    Object.assign(workerData, {
      busy: true,
      readable: readable.pipeThrough(new ChunkStream(config2.chunkSize)).pipeThrough(new ProgressWatcherStream(readable, streamOptions), { signal }),
      writable,
      options: Object.assign({}, options),
      scripts,
      transferStreams,
      terminate() {
        return new Promise((resolve) => {
          const { worker, busy } = workerData;
          if (worker) {
            if (busy) {
              workerData.resolveTerminated = resolve;
            } else {
              worker.terminate();
              resolve();
            }
            workerData.interface = null;
          } else {
            resolve();
          }
        });
      },
      onTaskFinished() {
        const { resolveTerminated } = workerData;
        if (resolveTerminated) {
          workerData.resolveTerminated = null;
          workerData.terminated = true;
          workerData.worker.terminate();
          resolveTerminated();
        }
        workerData.busy = false;
        onTaskFinished(workerData);
      }
    });
    return (useWebWorkers && WEB_WORKERS_SUPPORTED ? createWebWorkerInterface : createWorkerInterface)(workerData, config2);
  }
};
var ProgressWatcherStream = class extends TransformStream {
  constructor(readableSource, { onstart, onprogress, size, onend }) {
    let chunkOffset = 0;
    super({
      async start() {
        if (onstart) {
          await callHandler(onstart, size);
        }
      },
      async transform(chunk, controller) {
        chunkOffset += chunk.length;
        if (onprogress) {
          await callHandler(onprogress, chunkOffset, size);
        }
        controller.enqueue(chunk);
      },
      async flush() {
        readableSource.size = chunkOffset;
        if (onend) {
          await callHandler(onend, chunkOffset);
        }
      }
    });
  }
};
async function callHandler(handler, ...parameters) {
  try {
    await handler(...parameters);
  } catch (_error) {
  }
}
function createWorkerInterface(workerData, config2) {
  return {
    run: () => runWorker(workerData, config2)
  };
}
function createWebWorkerInterface(workerData, config2) {
  const { baseURL: baseURL2, chunkSize } = config2;
  if (!workerData.interface) {
    let worker;
    try {
      worker = getWebWorker(workerData.scripts[0], baseURL2, workerData);
    } catch (error) {
      WEB_WORKERS_SUPPORTED = false;
      return createWorkerInterface(workerData, config2);
    }
    Object.assign(workerData, {
      worker,
      interface: {
        run: () => runWebWorker(workerData, { chunkSize })
      }
    });
  }
  return workerData.interface;
}
async function runWorker({ options, readable, writable, onTaskFinished }, config2) {
  try {
    const codecStream = new CodecStream(options, config2);
    await readable.pipeThrough(codecStream).pipeTo(writable, { preventClose: true, preventAbort: true });
    const {
      signature,
      inputSize,
      outputSize
    } = codecStream;
    return {
      signature,
      inputSize,
      outputSize
    };
  } finally {
    onTaskFinished();
  }
}
async function runWebWorker(workerData, config2) {
  let resolveResult, rejectResult;
  const result = new Promise((resolve, reject) => {
    resolveResult = resolve;
    rejectResult = reject;
  });
  Object.assign(workerData, {
    reader: null,
    writer: null,
    resolveResult,
    rejectResult,
    result
  });
  const { readable, options, scripts } = workerData;
  const { writable, closed } = watchClosedStream(workerData.writable);
  const streamsTransferred = sendMessage({
    type: MESSAGE_START,
    scripts: scripts.slice(1),
    options,
    config: config2,
    readable,
    writable
  }, workerData);
  if (!streamsTransferred) {
    Object.assign(workerData, {
      reader: readable.getReader(),
      writer: writable.getWriter()
    });
  }
  const resultValue = await result;
  if (!streamsTransferred) {
    await writable.getWriter().close();
  }
  await closed;
  return resultValue;
}
function watchClosedStream(writableSource) {
  let resolveStreamClosed;
  const closed = new Promise((resolve) => resolveStreamClosed = resolve);
  const writable = new WritableStream({
    async write(chunk) {
      const writer = writableSource.getWriter();
      await writer.ready;
      await writer.write(chunk);
      writer.releaseLock();
    },
    close() {
      resolveStreamClosed();
    },
    abort(reason) {
      const writer = writableSource.getWriter();
      return writer.abort(reason);
    }
  });
  return { writable, closed };
}
var classicWorkersSupported = true;
var transferStreamsSupported = true;
function getWebWorker(url, baseURL2, workerData) {
  const workerOptions = { type: "module" };
  let scriptUrl, worker;
  if (typeof url == FUNCTION_TYPE) {
    url = url();
  }
  try {
    scriptUrl = new URL(url, baseURL2);
  } catch (_error) {
    scriptUrl = url;
  }
  if (classicWorkersSupported) {
    try {
      worker = new Worker(scriptUrl);
    } catch (_error) {
      classicWorkersSupported = false;
      worker = new Worker(scriptUrl, workerOptions);
    }
  } else {
    worker = new Worker(scriptUrl, workerOptions);
  }
  worker.addEventListener(MESSAGE_EVENT_TYPE, (event) => onMessage(event, workerData));
  return worker;
}
function sendMessage(message, { worker, writer, onTaskFinished, transferStreams }) {
  try {
    let { value, readable, writable } = message;
    const transferables = [];
    if (value) {
      if (value.byteLength < value.buffer.byteLength) {
        message.value = value.buffer.slice(0, value.byteLength);
      } else {
        message.value = value.buffer;
      }
      transferables.push(message.value);
    }
    if (transferStreams && transferStreamsSupported) {
      if (readable) {
        transferables.push(readable);
      }
      if (writable) {
        transferables.push(writable);
      }
    } else {
      message.readable = message.writable = null;
    }
    if (transferables.length) {
      try {
        worker.postMessage(message, transferables);
        return true;
      } catch (_error) {
        transferStreamsSupported = false;
        message.readable = message.writable = null;
        worker.postMessage(message);
      }
    } else {
      worker.postMessage(message);
    }
  } catch (error) {
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
    throw error;
  }
}
async function onMessage({ data }, workerData) {
  const { type, value, messageId, result, error } = data;
  const { reader, writer, resolveResult, rejectResult, onTaskFinished } = workerData;
  try {
    if (error) {
      const { message, stack, code, name } = error;
      const responseError = new Error(message);
      Object.assign(responseError, { stack, code, name });
      close(responseError);
    } else {
      if (type == MESSAGE_PULL) {
        const { value: value2, done } = await reader.read();
        sendMessage({ type: MESSAGE_DATA, value: value2, done, messageId }, workerData);
      }
      if (type == MESSAGE_DATA) {
        await writer.ready;
        await writer.write(new Uint8Array(value));
        sendMessage({ type: MESSAGE_ACK_DATA, messageId }, workerData);
      }
      if (type == MESSAGE_CLOSE) {
        close(null, result);
      }
    }
  } catch (error2) {
    sendMessage({ type: MESSAGE_CLOSE, messageId }, workerData);
    close(error2);
  }
  function close(error2, result2) {
    if (error2) {
      rejectResult(error2);
    } else {
      resolveResult(result2);
    }
    if (writer) {
      writer.releaseLock();
    }
    onTaskFinished();
  }
}

// node_modules/@zip.js/zip.js/lib/core/codec-pool.js
var pool = [];
var pendingRequests = [];
var indexWorker = 0;
async function runWorker2(stream, workerOptions) {
  const { options, config: config2 } = workerOptions;
  const { transferStreams, useWebWorkers, useCompressionStream, codecType, compressed, signed, encrypted } = options;
  const { workerScripts, maxWorkers: maxWorkers2 } = config2;
  workerOptions.transferStreams = transferStreams || transferStreams === UNDEFINED_VALUE;
  const streamCopy = !compressed && !signed && !encrypted && !workerOptions.transferStreams;
  workerOptions.useWebWorkers = !streamCopy && (useWebWorkers || useWebWorkers === UNDEFINED_VALUE && config2.useWebWorkers);
  workerOptions.scripts = workerOptions.useWebWorkers && workerScripts ? workerScripts[codecType] : [];
  options.useCompressionStream = useCompressionStream || useCompressionStream === UNDEFINED_VALUE && config2.useCompressionStream;
  return (await getWorker()).run();
  async function getWorker() {
    const workerData = pool.find((workerData2) => !workerData2.busy);
    if (workerData) {
      clearTerminateTimeout(workerData);
      return new CodecWorker(workerData, stream, workerOptions, onTaskFinished);
    } else if (pool.length < maxWorkers2) {
      const workerData2 = { indexWorker };
      indexWorker++;
      pool.push(workerData2);
      return new CodecWorker(workerData2, stream, workerOptions, onTaskFinished);
    } else {
      return new Promise((resolve) => pendingRequests.push({ resolve, stream, workerOptions }));
    }
  }
  function onTaskFinished(workerData) {
    if (pendingRequests.length) {
      const [{ resolve, stream: stream2, workerOptions: workerOptions2 }] = pendingRequests.splice(0, 1);
      resolve(new CodecWorker(workerData, stream2, workerOptions2, onTaskFinished));
    } else if (workerData.worker) {
      clearTerminateTimeout(workerData);
      terminateWorker(workerData, workerOptions);
    } else {
      pool = pool.filter((data) => data != workerData);
    }
  }
}
function terminateWorker(workerData, workerOptions) {
  const { config: config2 } = workerOptions;
  const { terminateWorkerTimeout } = config2;
  if (Number.isFinite(terminateWorkerTimeout) && terminateWorkerTimeout >= 0) {
    if (workerData.terminated) {
      workerData.terminated = false;
    } else {
      workerData.terminateTimeout = setTimeout(async () => {
        pool = pool.filter((data) => data != workerData);
        try {
          await workerData.terminate();
        } catch (_error) {
        }
      }, terminateWorkerTimeout);
    }
  }
}
function clearTerminateTimeout(workerData) {
  const { terminateTimeout } = workerData;
  if (terminateTimeout) {
    clearTimeout(terminateTimeout);
    workerData.terminateTimeout = null;
  }
}

// node_modules/@zip.js/zip.js/lib/z-worker-inline.js
function e(e2) {
  const t2 = () => URL.createObjectURL(new Blob(['const{Array:e,Object:t,Number:n,Math:r,Error:s,Uint8Array:i,Uint16Array:o,Uint32Array:c,Int32Array:f,Map:a,DataView:l,Promise:u,TextEncoder:w,crypto:h,postMessage:d,TransformStream:p,ReadableStream:y,WritableStream:m,CompressionStream:b,DecompressionStream:g}=self,k=void 0,v="undefined",S="function";class z{constructor(e){return class extends p{constructor(t,n){const r=new e(n);super({transform(e,t){t.enqueue(r.append(e))},flush(e){const t=r.flush();t&&e.enqueue(t)}})}}}}const C=[];for(let e=0;256>e;e++){let t=e;for(let e=0;8>e;e++)1&t?t=t>>>1^3988292384:t>>>=1;C[e]=t}class x{constructor(e){this.t=e||-1}append(e){let t=0|this.t;for(let n=0,r=0|e.length;r>n;n++)t=t>>>8^C[255&(t^e[n])];this.t=t}get(){return~this.t}}class A extends p{constructor(){let e;const t=new x;super({transform(e,n){t.append(e),n.enqueue(e)},flush(){const n=new i(4);new l(n.buffer).setUint32(0,t.get()),e.value=n}}),e=this}}const _={concat(e,t){if(0===e.length||0===t.length)return e.concat(t);const n=e[e.length-1],r=_.i(n);return 32===r?e.concat(t):_.o(t,r,0|n,e.slice(0,e.length-1))},l(e){const t=e.length;if(0===t)return 0;const n=e[t-1];return 32*(t-1)+_.i(n)},u(e,t){if(32*e.length<t)return e;const n=(e=e.slice(0,r.ceil(t/32))).length;return t&=31,n>0&&t&&(e[n-1]=_.h(t,e[n-1]&2147483648>>t-1,1)),e},h:(e,t,n)=>32===e?t:(n?0|t:t<<32-e)+1099511627776*e,i:e=>r.round(e/1099511627776)||32,o(e,t,n,r){for(void 0===r&&(r=[]);t>=32;t-=32)r.push(n),n=0;if(0===t)return r.concat(e);for(let s=0;s<e.length;s++)r.push(n|e[s]>>>t),n=e[s]<<32-t;const s=e.length?e[e.length-1]:0,i=_.i(s);return r.push(_.h(t+i&31,t+i>32?n:r.pop(),1)),r}},I={p:{m(e){const t=_.l(e)/8,n=new i(t);let r;for(let s=0;t>s;s++)0==(3&s)&&(r=e[s/4]),n[s]=r>>>24,r<<=8;return n},g(e){const t=[];let n,r=0;for(n=0;n<e.length;n++)r=r<<8|e[n],3==(3&n)&&(t.push(r),r=0);return 3&n&&t.push(_.h(8*(3&n),r)),t}}},P=class{constructor(e){const t=this;t.blockSize=512,t.k=[1732584193,4023233417,2562383102,271733878,3285377520],t.v=[1518500249,1859775393,2400959708,3395469782],e?(t.S=e.S.slice(0),t.C=e.C.slice(0),t.A=e.A):t.reset()}reset(){const e=this;return e.S=e.k.slice(0),e.C=[],e.A=0,e}update(e){const t=this;"string"==typeof e&&(e=I._.g(e));const n=t.C=_.concat(t.C,e),r=t.A,i=t.A=r+_.l(e);if(i>9007199254740991)throw new s("Cannot hash more than 2^53 - 1 bits");const o=new c(n);let f=0;for(let e=t.blockSize+r-(t.blockSize+r&t.blockSize-1);i>=e;e+=t.blockSize)t.I(o.subarray(16*f,16*(f+1))),f+=1;return n.splice(0,16*f),t}P(){const e=this;let t=e.C;const n=e.S;t=_.concat(t,[_.h(1,1)]);for(let e=t.length+2;15&e;e++)t.push(0);for(t.push(r.floor(e.A/4294967296)),t.push(0|e.A);t.length;)e.I(t.splice(0,16));return e.reset(),n}D(e,t,n,r){return e>19?e>39?e>59?e>79?void 0:t^n^r:t&n|t&r|n&r:t^n^r:t&n|~t&r}V(e,t){return t<<e|t>>>32-e}I(t){const n=this,s=n.S,i=e(80);for(let e=0;16>e;e++)i[e]=t[e];let o=s[0],c=s[1],f=s[2],a=s[3],l=s[4];for(let e=0;79>=e;e++){16>e||(i[e]=n.V(1,i[e-3]^i[e-8]^i[e-14]^i[e-16]));const t=n.V(5,o)+n.D(e,c,f,a)+l+i[e]+n.v[r.floor(e/20)]|0;l=a,a=f,f=n.V(30,c),c=o,o=t}s[0]=s[0]+o|0,s[1]=s[1]+c|0,s[2]=s[2]+f|0,s[3]=s[3]+a|0,s[4]=s[4]+l|0}},D={getRandomValues(e){const t=new c(e.buffer),n=e=>{let t=987654321;const n=4294967295;return()=>(t=36969*(65535&t)+(t>>16)&n,(((t<<16)+(e=18e3*(65535&e)+(e>>16)&n)&n)/4294967296+.5)*(r.random()>.5?1:-1))};for(let s,i=0;i<e.length;i+=4){const e=n(4294967296*(s||r.random()));s=987654071*e(),t[i/4]=4294967296*e()|0}return e}},V={importKey:e=>new V.R(I.p.g(e)),B(e,t,n,r){if(n=n||1e4,0>r||0>n)throw new s("invalid params to pbkdf2");const i=1+(r>>5)<<2;let o,c,f,a,u;const w=new ArrayBuffer(i),h=new l(w);let d=0;const p=_;for(t=I.p.g(t),u=1;(i||1)>d;u++){for(o=c=e.encrypt(p.concat(t,[u])),f=1;n>f;f++)for(c=e.encrypt(c),a=0;a<c.length;a++)o[a]^=c[a];for(f=0;(i||1)>d&&f<o.length;f++)h.setInt32(d,o[f]),d+=4}return w.slice(0,r/8)},R:class{constructor(e){const t=this,n=t.M=P,r=[[],[]];t.U=[new n,new n];const s=t.U[0].blockSize/32;e.length>s&&(e=(new n).update(e).P());for(let t=0;s>t;t++)r[0][t]=909522486^e[t],r[1][t]=1549556828^e[t];t.U[0].update(r[0]),t.U[1].update(r[1]),t.K=new n(t.U[0])}reset(){const e=this;e.K=new e.M(e.U[0]),e.N=!1}update(e){this.N=!0,this.K.update(e)}digest(){const e=this,t=e.K.P(),n=new e.M(e.U[1]).update(t).P();return e.reset(),n}encrypt(e){if(this.N)throw new s("encrypt on already updated hmac called!");return this.update(e),this.digest(e)}}},R=typeof h!=v&&typeof h.getRandomValues==S,B="Invalid password",E="Invalid signature",M="zipjs-abort-check-password";function U(e){return R?h.getRandomValues(e):D.getRandomValues(e)}const K=16,N={name:"PBKDF2"},O=t.assign({hash:{name:"HMAC"}},N),T=t.assign({iterations:1e3,hash:{name:"SHA-1"}},N),W=["deriveBits"],j=[8,12,16],H=[16,24,32],L=10,F=[0,0,0,0],q=typeof h!=v,G=q&&h.subtle,J=q&&typeof G!=v,Q=I.p,X=class{constructor(e){const t=this;t.O=[[[],[],[],[],[]],[[],[],[],[],[]]],t.O[0][0][0]||t.T();const n=t.O[0][4],r=t.O[1],i=e.length;let o,c,f,a=1;if(4!==i&&6!==i&&8!==i)throw new s("invalid aes key size");for(t.v=[c=e.slice(0),f=[]],o=i;4*i+28>o;o++){let e=c[o-1];(o%i==0||8===i&&o%i==4)&&(e=n[e>>>24]<<24^n[e>>16&255]<<16^n[e>>8&255]<<8^n[255&e],o%i==0&&(e=e<<8^e>>>24^a<<24,a=a<<1^283*(a>>7))),c[o]=c[o-i]^e}for(let e=0;o;e++,o--){const t=c[3&e?o:o-4];f[e]=4>=o||4>e?t:r[0][n[t>>>24]]^r[1][n[t>>16&255]]^r[2][n[t>>8&255]]^r[3][n[255&t]]}}encrypt(e){return this.W(e,0)}decrypt(e){return this.W(e,1)}T(){const e=this.O[0],t=this.O[1],n=e[4],r=t[4],s=[],i=[];let o,c,f,a;for(let e=0;256>e;e++)i[(s[e]=e<<1^283*(e>>7))^e]=e;for(let l=o=0;!n[l];l^=c||1,o=i[o]||1){let i=o^o<<1^o<<2^o<<3^o<<4;i=i>>8^255&i^99,n[l]=i,r[i]=l,a=s[f=s[c=s[l]]];let u=16843009*a^65537*f^257*c^16843008*l,w=257*s[i]^16843008*i;for(let n=0;4>n;n++)e[n][l]=w=w<<24^w>>>8,t[n][i]=u=u<<24^u>>>8}for(let n=0;5>n;n++)e[n]=e[n].slice(0),t[n]=t[n].slice(0)}W(e,t){if(4!==e.length)throw new s("invalid aes block size");const n=this.v[t],r=n.length/4-2,i=[0,0,0,0],o=this.O[t],c=o[0],f=o[1],a=o[2],l=o[3],u=o[4];let w,h,d,p=e[0]^n[0],y=e[t?3:1]^n[1],m=e[2]^n[2],b=e[t?1:3]^n[3],g=4;for(let e=0;r>e;e++)w=c[p>>>24]^f[y>>16&255]^a[m>>8&255]^l[255&b]^n[g],h=c[y>>>24]^f[m>>16&255]^a[b>>8&255]^l[255&p]^n[g+1],d=c[m>>>24]^f[b>>16&255]^a[p>>8&255]^l[255&y]^n[g+2],b=c[b>>>24]^f[p>>16&255]^a[y>>8&255]^l[255&m]^n[g+3],g+=4,p=w,y=h,m=d;for(let e=0;4>e;e++)i[t?3&-e:e]=u[p>>>24]<<24^u[y>>16&255]<<16^u[m>>8&255]<<8^u[255&b]^n[g++],w=p,p=y,y=m,m=b,b=w;return i}},Y=class{constructor(e,t){this.j=e,this.H=t,this.L=t}reset(){this.L=this.H}update(e){return this.F(this.j,e,this.L)}q(e){if(255==(e>>24&255)){let t=e>>16&255,n=e>>8&255,r=255&e;255===t?(t=0,255===n?(n=0,255===r?r=0:++r):++n):++t,e=0,e+=t<<16,e+=n<<8,e+=r}else e+=1<<24;return e}G(e){0===(e[0]=this.q(e[0]))&&(e[1]=this.q(e[1]))}F(e,t,n){let r;if(!(r=t.length))return[];const s=_.l(t);for(let s=0;r>s;s+=4){this.G(n);const r=e.encrypt(n);t[s]^=r[0],t[s+1]^=r[1],t[s+2]^=r[2],t[s+3]^=r[3]}return _.u(t,s)}},Z=V.R;let $=q&&J&&typeof G.importKey==S,ee=q&&J&&typeof G.deriveBits==S;class te extends p{constructor({password:e,rawPassword:n,signed:r,encryptionStrength:o,checkPasswordOnly:c}){super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),signed:r,X:o-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:o,J:f,ready:a}=n;r?(await(async(e,t,n,r)=>{const i=await se(e,t,n,ce(r,0,j[t])),o=ce(r,j[t]);if(i[0]!=o[0]||i[1]!=o[1])throw new s(B)})(n,o,r,ce(e,0,j[o]+2)),e=ce(e,j[o]+2),c?t.error(new s(M)):f()):await a;const l=new i(e.length-L-(e.length-L)%K);t.enqueue(re(n,e,l,0,L,!0))},async flush(e){const{signed:t,Y:n,Z:r,pending:o,ready:c}=this;if(r&&n){await c;const f=ce(o,0,o.length-L),a=ce(o,o.length-L);let l=new i;if(f.length){const e=ae(Q,f);r.update(e);const t=n.update(e);l=fe(Q,t)}if(t){const e=ce(fe(Q,r.digest()),0,L);for(let t=0;L>t;t++)if(e[t]!=a[t])throw new s(E)}e.enqueue(l)}}})}}class ne extends p{constructor({password:e,rawPassword:n,encryptionStrength:r}){let s;super({start(){t.assign(this,{ready:new u((e=>this.J=e)),password:ie(e,n),X:r-1,pending:new i})},async transform(e,t){const n=this,{password:r,X:s,J:o,ready:c}=n;let f=new i;r?(f=await(async(e,t,n)=>{const r=U(new i(j[t]));return oe(r,await se(e,t,n,r))})(n,s,r),o()):await c;const a=new i(f.length+e.length-e.length%K);a.set(f,0),t.enqueue(re(n,e,a,f.length,0))},async flush(e){const{Y:t,Z:n,pending:r,ready:o}=this;if(n&&t){await o;let c=new i;if(r.length){const e=t.update(ae(Q,r));n.update(e),c=fe(Q,e)}s.signature=fe(Q,n.digest()).slice(0,L),e.enqueue(oe(c,s.signature))}}}),s=this}}function re(e,t,n,r,s,o){const{Y:c,Z:f,pending:a}=e,l=t.length-s;let u;for(a.length&&(t=oe(a,t),n=((e,t)=>{if(t&&t>e.length){const n=e;(e=new i(t)).set(n,0)}return e})(n,l-l%K)),u=0;l-K>=u;u+=K){const e=ae(Q,ce(t,u,u+K));o&&f.update(e);const s=c.update(e);o||f.update(s),n.set(fe(Q,s),u+r)}return e.pending=ce(t,u),n}async function se(n,r,s,o){n.password=null;const c=await(async(e,t,n,r,s)=>{if(!$)return V.importKey(t);try{return await G.importKey("raw",t,n,!1,s)}catch(e){return $=!1,V.importKey(t)}})(0,s,O,0,W),f=await(async(e,t,n)=>{if(!ee)return V.B(t,e.salt,T.iterations,n);try{return await G.deriveBits(e,t,n)}catch(r){return ee=!1,V.B(t,e.salt,T.iterations,n)}})(t.assign({salt:o},T),c,8*(2*H[r]+2)),a=new i(f),l=ae(Q,ce(a,0,H[r])),u=ae(Q,ce(a,H[r],2*H[r])),w=ce(a,2*H[r]);return t.assign(n,{keys:{key:l,$:u,passwordVerification:w},Y:new Y(new X(l),e.from(F)),Z:new Z(u)}),w}function ie(e,t){return t===k?(e=>{if(typeof w==v){const t=new i((e=unescape(encodeURIComponent(e))).length);for(let n=0;n<t.length;n++)t[n]=e.charCodeAt(n);return t}return(new w).encode(e)})(e):t}function oe(e,t){let n=e;return e.length+t.length&&(n=new i(e.length+t.length),n.set(e,0),n.set(t,e.length)),n}function ce(e,t,n){return e.subarray(t,n)}function fe(e,t){return e.m(t)}function ae(e,t){return e.g(t)}class le extends p{constructor({password:e,passwordVerification:n,checkPasswordOnly:r}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;if(n.password){const t=we(n,e.subarray(0,12));if(n.password=null,t[11]!=n.passwordVerification)throw new s(B);e=e.subarray(12)}r?t.error(new s(M)):t.enqueue(we(n,e))}})}}class ue extends p{constructor({password:e,passwordVerification:n}){super({start(){t.assign(this,{password:e,passwordVerification:n}),de(this,e)},transform(e,t){const n=this;let r,s;if(n.password){n.password=null;const t=U(new i(12));t[11]=n.passwordVerification,r=new i(e.length+t.length),r.set(he(n,t),0),s=12}else r=new i(e.length),s=0;r.set(he(n,e),s),t.enqueue(r)}})}}function we(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,n[r]);return n}function he(e,t){const n=new i(t.length);for(let r=0;r<t.length;r++)n[r]=ye(e)^t[r],pe(e,t[r]);return n}function de(e,n){const r=[305419896,591751049,878082192];t.assign(e,{keys:r,ee:new x(r[0]),te:new x(r[2])});for(let t=0;t<n.length;t++)pe(e,n.charCodeAt(t))}function pe(e,t){let[n,s,i]=e.keys;e.ee.append([t]),n=~e.ee.get(),s=be(r.imul(be(s+me(n)),134775813)+1),e.te.append([s>>>24]),i=~e.te.get(),e.keys=[n,s,i]}function ye(e){const t=2|e.keys[2];return me(r.imul(t,1^t)>>>8)}function me(e){return 255&e}function be(e){return 4294967295&e}const ge="deflate-raw";class ke extends p{constructor(e,{chunkSize:t,CompressionStream:n,CompressionStreamNative:r}){super({});const{compressed:s,encrypted:i,useCompressionStream:o,zipCrypto:c,signed:f,level:a}=e,u=this;let w,h,d=Se(super.readable);i&&!c||!f||(w=new A,d=xe(d,w)),s&&(d=Ce(d,o,{level:a,chunkSize:t},r,n)),i&&(c?d=xe(d,new ue(e)):(h=new ne(e),d=xe(d,h))),ze(u,d,(()=>{let e;i&&!c&&(e=h.signature),i&&!c||!f||(e=new l(w.value.buffer).getUint32(0)),u.signature=e}))}}class ve extends p{constructor(e,{chunkSize:t,DecompressionStream:n,DecompressionStreamNative:r}){super({});const{zipCrypto:i,encrypted:o,signed:c,signature:f,compressed:a,useCompressionStream:u}=e;let w,h,d=Se(super.readable);o&&(i?d=xe(d,new le(e)):(h=new te(e),d=xe(d,h))),a&&(d=Ce(d,u,{chunkSize:t},r,n)),o&&!i||!c||(w=new A,d=xe(d,w)),ze(this,d,(()=>{if((!o||i)&&c){const e=new l(w.value.buffer);if(f!=e.getUint32(0,!1))throw new s(E)}}))}}function Se(e){return xe(e,new p({transform(e,t){e&&e.length&&t.enqueue(e)}}))}function ze(e,n,r){n=xe(n,new p({flush:r})),t.defineProperty(e,"readable",{get:()=>n})}function Ce(e,t,n,r,s){try{e=xe(e,new(t&&r?r:s)(ge,n))}catch(r){if(!t)return e;try{e=xe(e,new s(ge,n))}catch(t){return e}}return e}function xe(e,t){return e.pipeThrough(t)}const Ae="data",_e="close";class Ie extends p{constructor(e,n){super({});const r=this,{codecType:s}=e;let i;s.startsWith("deflate")?i=ke:s.startsWith("inflate")&&(i=ve);let o=0,c=0;const f=new i(e,n),a=super.readable,l=new p({transform(e,t){e&&e.length&&(c+=e.length,t.enqueue(e))},flush(){t.assign(r,{inputSize:c})}}),u=new p({transform(e,t){e&&e.length&&(o+=e.length,t.enqueue(e))},flush(){const{signature:e}=f;t.assign(r,{signature:e,outputSize:o,inputSize:c})}});t.defineProperty(r,"readable",{get:()=>a.pipeThrough(l).pipeThrough(f).pipeThrough(u)})}}class Pe extends p{constructor(e){let t;super({transform:function n(r,s){if(t){const e=new i(t.length+r.length);e.set(t),e.set(r,t.length),r=e,t=null}r.length>e?(s.enqueue(r.slice(0,e)),n(r.slice(e),s)):t=r},flush(e){t&&t.length&&e.enqueue(t)}})}}const De=new a,Ve=new a;let Re,Be=0,Ee=!0;async function Me(e){try{const{options:t,scripts:r,config:s}=e;if(r&&r.length)try{Ee?importScripts.apply(k,r):await Ue(r)}catch(e){Ee=!1,await Ue(r)}self.initCodec&&self.initCodec(),s.CompressionStreamNative=self.CompressionStream,s.DecompressionStreamNative=self.DecompressionStream,self.Deflate&&(s.CompressionStream=new z(self.Deflate)),self.Inflate&&(s.DecompressionStream=new z(self.Inflate));const i={highWaterMark:1},o=e.readable||new y({async pull(e){const t=new u((e=>De.set(Be,e)));Ke({type:"pull",messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER;const{value:r,done:s}=await t;e.enqueue(r),s&&e.close()}},i),c=e.writable||new m({async write(e){let t;const r=new u((e=>t=e));Ve.set(Be,t),Ke({type:Ae,value:e,messageId:Be}),Be=(Be+1)%n.MAX_SAFE_INTEGER,await r}},i),f=new Ie(t,s);Re=new AbortController;const{signal:a}=Re;await o.pipeThrough(f).pipeThrough(new Pe(s.chunkSize)).pipeTo(c,{signal:a,preventClose:!0,preventAbort:!0}),await c.getWriter().close();const{signature:l,inputSize:w,outputSize:h}=f;Ke({type:_e,result:{signature:l,inputSize:w,outputSize:h}})}catch(e){Ne(e)}}async function Ue(e){for(const t of e)await import(t)}function Ke(e){let{value:t}=e;if(t)if(t.length)try{t=new i(t),e.value=t.buffer,d(e,[e.value])}catch(t){d(e)}else d(e);else d(e)}function Ne(e=new s("Unknown error")){const{message:t,stack:n,code:r,name:i}=e;d({error:{message:t,stack:n,code:r,name:i}})}addEventListener("message",(({data:e})=>{const{type:t,messageId:n,value:r,done:s}=e;try{if("start"==t&&Me(e),t==Ae){const e=De.get(n);De.delete(n),e({value:new i(r),done:s})}if("ack"==t){const e=Ve.get(n);Ve.delete(n),e()}t==_e&&Re.abort()}catch(e){Ne(e)}}));const Oe=-2;function Te(t){return We(t.map((([t,n])=>new e(t).fill(n,0,t))))}function We(t){return t.reduce(((t,n)=>t.concat(e.isArray(n)?We(n):n)),[])}const je=[0,1,2,3].concat(...Te([[2,4],[2,5],[4,6],[4,7],[8,8],[8,9],[16,10],[16,11],[32,12],[32,13],[64,14],[64,15],[2,0],[1,16],[1,17],[2,18],[2,19],[4,20],[4,21],[8,22],[8,23],[16,24],[16,25],[32,26],[32,27],[64,28],[64,29]]));function He(){const e=this;function t(e,t){let n=0;do{n|=1&e,e>>>=1,n<<=1}while(--t>0);return n>>>1}e.ne=n=>{const s=e.re,i=e.ie.se,o=e.ie.oe;let c,f,a,l=-1;for(n.ce=0,n.fe=573,c=0;o>c;c++)0!==s[2*c]?(n.ae[++n.ce]=l=c,n.le[c]=0):s[2*c+1]=0;for(;2>n.ce;)a=n.ae[++n.ce]=2>l?++l:0,s[2*a]=1,n.le[a]=0,n.ue--,i&&(n.we-=i[2*a+1]);for(e.he=l,c=r.floor(n.ce/2);c>=1;c--)n.de(s,c);a=o;do{c=n.ae[1],n.ae[1]=n.ae[n.ce--],n.de(s,1),f=n.ae[1],n.ae[--n.fe]=c,n.ae[--n.fe]=f,s[2*a]=s[2*c]+s[2*f],n.le[a]=r.max(n.le[c],n.le[f])+1,s[2*c+1]=s[2*f+1]=a,n.ae[1]=a++,n.de(s,1)}while(n.ce>=2);n.ae[--n.fe]=n.ae[1],(t=>{const n=e.re,r=e.ie.se,s=e.ie.pe,i=e.ie.ye,o=e.ie.me;let c,f,a,l,u,w,h=0;for(l=0;15>=l;l++)t.be[l]=0;for(n[2*t.ae[t.fe]+1]=0,c=t.fe+1;573>c;c++)f=t.ae[c],l=n[2*n[2*f+1]+1]+1,l>o&&(l=o,h++),n[2*f+1]=l,f>e.he||(t.be[l]++,u=0,i>f||(u=s[f-i]),w=n[2*f],t.ue+=w*(l+u),r&&(t.we+=w*(r[2*f+1]+u)));if(0!==h){do{for(l=o-1;0===t.be[l];)l--;t.be[l]--,t.be[l+1]+=2,t.be[o]--,h-=2}while(h>0);for(l=o;0!==l;l--)for(f=t.be[l];0!==f;)a=t.ae[--c],a>e.he||(n[2*a+1]!=l&&(t.ue+=(l-n[2*a+1])*n[2*a],n[2*a+1]=l),f--)}})(n),((e,n,r)=>{const s=[];let i,o,c,f=0;for(i=1;15>=i;i++)s[i]=f=f+r[i-1]<<1;for(o=0;n>=o;o++)c=e[2*o+1],0!==c&&(e[2*o]=t(s[c]++,c))})(s,e.he,n.be)}}function Le(e,t,n,r,s){const i=this;i.se=e,i.pe=t,i.ye=n,i.oe=r,i.me=s}He.ge=[0,1,2,3,4,5,6,7].concat(...Te([[2,8],[2,9],[2,10],[2,11],[4,12],[4,13],[4,14],[4,15],[8,16],[8,17],[8,18],[8,19],[16,20],[16,21],[16,22],[16,23],[32,24],[32,25],[32,26],[31,27],[1,28]])),He.ke=[0,1,2,3,4,5,6,7,8,10,12,14,16,20,24,28,32,40,48,56,64,80,96,112,128,160,192,224,0],He.ve=[0,1,2,3,4,6,8,12,16,24,32,48,64,96,128,192,256,384,512,768,1024,1536,2048,3072,4096,6144,8192,12288,16384,24576],He.Se=e=>256>e?je[e]:je[256+(e>>>7)],He.ze=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],He.Ce=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],He.xe=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],He.Ae=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];const Fe=Te([[144,8],[112,9],[24,7],[8,8]]);Le._e=We([12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,19,275,147,403,83,339,211,467,51,307,179,435,115,371,243,499,11,267,139,395,75,331,203,459,43,299,171,427,107,363,235,491,27,283,155,411,91,347,219,475,59,315,187,443,123,379,251,507,7,263,135,391,71,327,199,455,39,295,167,423,103,359,231,487,23,279,151,407,87,343,215,471,55,311,183,439,119,375,247,503,15,271,143,399,79,335,207,463,47,303,175,431,111,367,239,495,31,287,159,415,95,351,223,479,63,319,191,447,127,383,255,511,0,64,32,96,16,80,48,112,8,72,40,104,24,88,56,120,4,68,36,100,20,84,52,116,3,131,67,195,35,163,99,227].map(((e,t)=>[e,Fe[t]])));const qe=Te([[30,5]]);function Ge(e,t,n,r,s){const i=this;i.Ie=e,i.Pe=t,i.De=n,i.Ve=r,i.Re=s}Le.Be=We([0,16,8,24,4,20,12,28,2,18,10,26,6,22,14,30,1,17,9,25,5,21,13,29,3,19,11,27,7,23].map(((e,t)=>[e,qe[t]]))),Le.Ee=new Le(Le._e,He.ze,257,286,15),Le.Me=new Le(Le.Be,He.Ce,0,30,15),Le.Ue=new Le(null,He.xe,0,19,7);const Je=[new Ge(0,0,0,0,0),new Ge(4,4,8,4,1),new Ge(4,5,16,8,1),new Ge(4,6,32,32,1),new Ge(4,4,16,16,2),new Ge(8,16,32,32,2),new Ge(8,16,128,128,2),new Ge(8,32,128,256,2),new Ge(32,128,258,1024,2),new Ge(32,258,258,4096,2)],Qe=["need dictionary","stream end","","","stream error","data error","","buffer error","",""],Xe=113,Ye=666,Ze=262;function $e(e,t,n,r){const s=e[2*t],i=e[2*n];return i>s||s==i&&r[t]<=r[n]}function et(){const e=this;let t,n,s,c,f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z,C,x,A,_,I,P,D,V,R,B,E,M,U;const K=new He,N=new He,O=new He;let T,W,j,H,L,F;function q(){let t;for(t=0;286>t;t++)E[2*t]=0;for(t=0;30>t;t++)M[2*t]=0;for(t=0;19>t;t++)U[2*t]=0;E[512]=1,e.ue=e.we=0,W=j=0}function G(e,t){let n,r=-1,s=e[1],i=0,o=7,c=4;0===s&&(o=138,c=3),e[2*(t+1)+1]=65535;for(let f=0;t>=f;f++)n=s,s=e[2*(f+1)+1],++i<o&&n==s||(c>i?U[2*n]+=i:0!==n?(n!=r&&U[2*n]++,U[32]++):i>10?U[36]++:U[34]++,i=0,r=n,0===s?(o=138,c=3):n==s?(o=6,c=3):(o=7,c=4))}function J(t){e.Ke[e.pending++]=t}function Q(e){J(255&e),J(e>>>8&255)}function X(e,t){let n;const r=t;F>16-r?(n=e,L|=n<<F&65535,Q(L),L=n>>>16-F,F+=r-16):(L|=e<<F&65535,F+=r)}function Y(e,t){const n=2*e;X(65535&t[n],65535&t[n+1])}function Z(e,t){let n,r,s=-1,i=e[1],o=0,c=7,f=4;for(0===i&&(c=138,f=3),n=0;t>=n;n++)if(r=i,i=e[2*(n+1)+1],++o>=c||r!=i){if(f>o)do{Y(r,U)}while(0!=--o);else 0!==r?(r!=s&&(Y(r,U),o--),Y(16,U),X(o-3,2)):o>10?(Y(18,U),X(o-11,7)):(Y(17,U),X(o-3,3));o=0,s=r,0===i?(c=138,f=3):r==i?(c=6,f=3):(c=7,f=4)}}function $(){16==F?(Q(L),L=0,F=0):8>F||(J(255&L),L>>>=8,F-=8)}function ee(t,n){let s,i,o;if(e.Ne[W]=t,e.Oe[W]=255&n,W++,0===t?E[2*n]++:(j++,t--,E[2*(He.ge[n]+256+1)]++,M[2*He.Se(t)]++),0==(8191&W)&&D>2){for(s=8*W,i=C-k,o=0;30>o;o++)s+=M[2*o]*(5+He.Ce[o]);if(s>>>=3,j<r.floor(W/2)&&s<r.floor(i/2))return!0}return W==T-1}function te(t,n){let r,s,i,o,c=0;if(0!==W)do{r=e.Ne[c],s=e.Oe[c],c++,0===r?Y(s,t):(i=He.ge[s],Y(i+256+1,t),o=He.ze[i],0!==o&&(s-=He.ke[i],X(s,o)),r--,i=He.Se(r),Y(i,n),o=He.Ce[i],0!==o&&(r-=He.ve[i],X(r,o)))}while(W>c);Y(256,t),H=t[513]}function ne(){F>8?Q(L):F>0&&J(255&L),L=0,F=0}function re(t,n,r){X(0+(r?1:0),3),((t,n)=>{ne(),H=8,Q(n),Q(~n),e.Ke.set(u.subarray(t,t+n),e.pending),e.pending+=n})(t,n)}function se(n){((t,n,r)=>{let s,i,o=0;D>0?(K.ne(e),N.ne(e),o=(()=>{let t;for(G(E,K.he),G(M,N.he),O.ne(e),t=18;t>=3&&0===U[2*He.Ae[t]+1];t--);return e.ue+=14+3*(t+1),t})(),s=e.ue+3+7>>>3,i=e.we+3+7>>>3,i>s||(s=i)):s=i=n+5,n+4>s||-1==t?i==s?(X(2+(r?1:0),3),te(Le._e,Le.Be)):(X(4+(r?1:0),3),((e,t,n)=>{let r;for(X(e-257,5),X(t-1,5),X(n-4,4),r=0;n>r;r++)X(U[2*He.Ae[r]+1],3);Z(E,e-1),Z(M,t-1)})(K.he+1,N.he+1,o+1),te(E,M)):re(t,n,r),q(),r&&ne()})(0>k?-1:k,C-k,n),k=C,t.Te()}function ie(){let e,n,r,s;do{if(s=w-A-C,0===s&&0===C&&0===A)s=f;else if(-1==s)s--;else if(C>=f+f-Ze){u.set(u.subarray(f,f+f),0),x-=f,C-=f,k-=f,e=y,r=e;do{n=65535&d[--r],d[r]=f>n?0:n-f}while(0!=--e);e=f,r=e;do{n=65535&h[--r],h[r]=f>n?0:n-f}while(0!=--e);s+=f}if(0===t.We)return;e=t.je(u,C+A,s),A+=e,3>A||(p=255&u[C],p=(p<<g^255&u[C+1])&b)}while(Ze>A&&0!==t.We)}function oe(e){let t,n,r=I,s=C,i=_;const o=C>f-Ze?C-(f-Ze):0;let c=B;const a=l,w=C+258;let d=u[s+i-1],p=u[s+i];R>_||(r>>=2),c>A&&(c=A);do{if(t=e,u[t+i]==p&&u[t+i-1]==d&&u[t]==u[s]&&u[++t]==u[s+1]){s+=2,t++;do{}while(u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&u[++s]==u[++t]&&w>s);if(n=258-(w-s),s=w-258,n>i){if(x=e,i=n,n>=c)break;d=u[s+i-1],p=u[s+i]}}}while((e=65535&h[e&a])>o&&0!=--r);return i>A?A:i}e.le=[],e.be=[],e.ae=[],E=[],M=[],U=[],e.de=(t,n)=>{const r=e.ae,s=r[n];let i=n<<1;for(;i<=e.ce&&(i<e.ce&&$e(t,r[i+1],r[i],e.le)&&i++,!$e(t,s,r[i],e.le));)r[n]=r[i],n=i,i<<=1;r[n]=s},e.He=(t,S,x,W,j,G)=>(W||(W=8),j||(j=8),G||(G=0),t.Le=null,-1==S&&(S=6),1>j||j>9||8!=W||9>x||x>15||0>S||S>9||0>G||G>2?Oe:(t.Fe=e,a=x,f=1<<a,l=f-1,m=j+7,y=1<<m,b=y-1,g=r.floor((m+3-1)/3),u=new i(2*f),h=[],d=[],T=1<<j+6,e.Ke=new i(4*T),s=4*T,e.Ne=new o(T),e.Oe=new i(T),D=S,V=G,(t=>(t.qe=t.Ge=0,t.Le=null,e.pending=0,e.Je=0,n=Xe,c=0,K.re=E,K.ie=Le.Ee,N.re=M,N.ie=Le.Me,O.re=U,O.ie=Le.Ue,L=0,F=0,H=8,q(),(()=>{w=2*f,d[y-1]=0;for(let e=0;y-1>e;e++)d[e]=0;P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve,C=0,k=0,A=0,v=_=2,z=0,p=0})(),0))(t))),e.Qe=()=>42!=n&&n!=Xe&&n!=Ye?Oe:(e.Oe=null,e.Ne=null,e.Ke=null,d=null,h=null,u=null,e.Fe=null,n==Xe?-3:0),e.Xe=(e,t,n)=>{let r=0;return-1==t&&(t=6),0>t||t>9||0>n||n>2?Oe:(Je[D].Re!=Je[t].Re&&0!==e.qe&&(r=e.Ye(1)),D!=t&&(D=t,P=Je[D].Pe,R=Je[D].Ie,B=Je[D].De,I=Je[D].Ve),V=n,r)},e.Ze=(e,t,r)=>{let s,i=r,o=0;if(!t||42!=n)return Oe;if(3>i)return 0;for(i>f-Ze&&(i=f-Ze,o=r-i),u.set(t.subarray(o,o+i),0),C=i,k=i,p=255&u[0],p=(p<<g^255&u[1])&b,s=0;i-3>=s;s++)p=(p<<g^255&u[s+2])&b,h[s&l]=d[p],d[p]=s;return 0},e.Ye=(r,i)=>{let o,w,m,I,R;if(i>4||0>i)return Oe;if(!r.$e||!r.et&&0!==r.We||n==Ye&&4!=i)return r.Le=Qe[4],Oe;if(0===r.tt)return r.Le=Qe[7],-5;var B;if(t=r,I=c,c=i,42==n&&(w=8+(a-8<<4)<<8,m=(D-1&255)>>1,m>3&&(m=3),w|=m<<6,0!==C&&(w|=32),w+=31-w%31,n=Xe,J((B=w)>>8&255),J(255&B)),0!==e.pending){if(t.Te(),0===t.tt)return c=-1,0}else if(0===t.We&&I>=i&&4!=i)return t.Le=Qe[7],-5;if(n==Ye&&0!==t.We)return r.Le=Qe[7],-5;if(0!==t.We||0!==A||0!=i&&n!=Ye){switch(R=-1,Je[D].Re){case 0:R=(e=>{let n,r=65535;for(r>s-5&&(r=s-5);;){if(1>=A){if(ie(),0===A&&0==e)return 0;if(0===A)break}if(C+=A,A=0,n=k+r,(0===C||C>=n)&&(A=C-n,C=n,se(!1),0===t.tt))return 0;if(C-k>=f-Ze&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 1:R=(e=>{let n,r=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C),0===r||(C-r&65535)>f-Ze||2!=V&&(v=oe(r)),3>v)n=ee(0,255&u[C]),A--,C++;else if(n=ee(C-x,v-3),A-=v,v>P||3>A)C+=v,v=0,p=255&u[C],p=(p<<g^255&u[C+1])&b;else{v--;do{C++,p=(p<<g^255&u[C+2])&b,r=65535&d[p],h[C&l]=d[p],d[p]=C}while(0!=--v);C++}if(n&&(se(!1),0===t.tt))return 0}return se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i);break;case 2:R=(e=>{let n,r,s=0;for(;;){if(Ze>A){if(ie(),Ze>A&&0==e)return 0;if(0===A)break}if(3>A||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C),_=v,S=x,v=2,0!==s&&P>_&&f-Ze>=(C-s&65535)&&(2!=V&&(v=oe(s)),5>=v&&(1==V||3==v&&C-x>4096)&&(v=2)),3>_||v>_)if(0!==z){if(n=ee(0,255&u[C-1]),n&&se(!1),C++,A--,0===t.tt)return 0}else z=1,C++,A--;else{r=C+A-3,n=ee(C-1-S,_-3),A-=_-1,_-=2;do{++C>r||(p=(p<<g^255&u[C+2])&b,s=65535&d[p],h[C&l]=d[p],d[p]=C)}while(0!=--_);if(z=0,v=2,C++,n&&(se(!1),0===t.tt))return 0}}return 0!==z&&(n=ee(0,255&u[C-1]),z=0),se(4==e),0===t.tt?4==e?2:0:4==e?3:1})(i)}if(2!=R&&3!=R||(n=Ye),0==R||2==R)return 0===t.tt&&(c=-1),0;if(1==R){if(1==i)X(2,3),Y(256,Le._e),$(),9>1+H+10-F&&(X(2,3),Y(256,Le._e),$()),H=7;else if(re(0,0,!1),3==i)for(o=0;y>o;o++)d[o]=0;if(t.Te(),0===t.tt)return c=-1,0}}return 4!=i?0:1}}function tt(){const e=this;e.nt=0,e.rt=0,e.We=0,e.qe=0,e.tt=0,e.Ge=0}function nt(e){const t=new tt,n=(o=e&&e.chunkSize?e.chunkSize:65536)+5*(r.floor(o/16383)+1);var o;const c=new i(n);let f=e?e.level:-1;void 0===f&&(f=-1),t.He(f),t.$e=c,this.append=(e,r)=>{let o,f,a=0,l=0,u=0;const w=[];if(e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,o=t.Ye(0),0!=o)throw new s("deflating: "+t.Le);t.rt&&(t.rt==n?w.push(new i(c)):w.push(c.subarray(0,t.rt))),u+=t.rt,r&&t.nt>0&&t.nt!=a&&(r(t.nt),a=t.nt)}while(t.We>0||0===t.tt);return w.length>1?(f=new i(u),w.forEach((e=>{f.set(e,l),l+=e.length}))):f=w[0]?new i(w[0]):new i,f}},this.flush=()=>{let e,r,o=0,f=0;const a=[];do{if(t.rt=0,t.tt=n,e=t.Ye(4),1!=e&&0!=e)throw new s("deflating: "+t.Le);n-t.tt>0&&a.push(c.slice(0,t.rt)),f+=t.rt}while(t.We>0||0===t.tt);return t.Qe(),r=new i(f),a.forEach((e=>{r.set(e,o),o+=e.length})),r}}tt.prototype={He(e,t){const n=this;return n.Fe=new et,t||(t=15),n.Fe.He(n,e,t)},Ye(e){const t=this;return t.Fe?t.Fe.Ye(t,e):Oe},Qe(){const e=this;if(!e.Fe)return Oe;const t=e.Fe.Qe();return e.Fe=null,t},Xe(e,t){const n=this;return n.Fe?n.Fe.Xe(n,e,t):Oe},Ze(e,t){const n=this;return n.Fe?n.Fe.Ze(n,e,t):Oe},je(e,t,n){const r=this;let s=r.We;return s>n&&(s=n),0===s?0:(r.We-=s,e.set(r.et.subarray(r.nt,r.nt+s),t),r.nt+=s,r.qe+=s,s)},Te(){const e=this;let t=e.Fe.pending;t>e.tt&&(t=e.tt),0!==t&&(e.$e.set(e.Fe.Ke.subarray(e.Fe.Je,e.Fe.Je+t),e.rt),e.rt+=t,e.Fe.Je+=t,e.Ge+=t,e.tt-=t,e.Fe.pending-=t,0===e.Fe.pending&&(e.Fe.Je=0))}};const rt=-2,st=-3,it=-5,ot=[0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,32767,65535],ct=[96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,192,80,7,10,0,8,96,0,8,32,0,9,160,0,8,0,0,8,128,0,8,64,0,9,224,80,7,6,0,8,88,0,8,24,0,9,144,83,7,59,0,8,120,0,8,56,0,9,208,81,7,17,0,8,104,0,8,40,0,9,176,0,8,8,0,8,136,0,8,72,0,9,240,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,200,81,7,13,0,8,100,0,8,36,0,9,168,0,8,4,0,8,132,0,8,68,0,9,232,80,7,8,0,8,92,0,8,28,0,9,152,84,7,83,0,8,124,0,8,60,0,9,216,82,7,23,0,8,108,0,8,44,0,9,184,0,8,12,0,8,140,0,8,76,0,9,248,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,196,81,7,11,0,8,98,0,8,34,0,9,164,0,8,2,0,8,130,0,8,66,0,9,228,80,7,7,0,8,90,0,8,26,0,9,148,84,7,67,0,8,122,0,8,58,0,9,212,82,7,19,0,8,106,0,8,42,0,9,180,0,8,10,0,8,138,0,8,74,0,9,244,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,204,81,7,15,0,8,102,0,8,38,0,9,172,0,8,6,0,8,134,0,8,70,0,9,236,80,7,9,0,8,94,0,8,30,0,9,156,84,7,99,0,8,126,0,8,62,0,9,220,82,7,27,0,8,110,0,8,46,0,9,188,0,8,14,0,8,142,0,8,78,0,9,252,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,194,80,7,10,0,8,97,0,8,33,0,9,162,0,8,1,0,8,129,0,8,65,0,9,226,80,7,6,0,8,89,0,8,25,0,9,146,83,7,59,0,8,121,0,8,57,0,9,210,81,7,17,0,8,105,0,8,41,0,9,178,0,8,9,0,8,137,0,8,73,0,9,242,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,202,81,7,13,0,8,101,0,8,37,0,9,170,0,8,5,0,8,133,0,8,69,0,9,234,80,7,8,0,8,93,0,8,29,0,9,154,84,7,83,0,8,125,0,8,61,0,9,218,82,7,23,0,8,109,0,8,45,0,9,186,0,8,13,0,8,141,0,8,77,0,9,250,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,198,81,7,11,0,8,99,0,8,35,0,9,166,0,8,3,0,8,131,0,8,67,0,9,230,80,7,7,0,8,91,0,8,27,0,9,150,84,7,67,0,8,123,0,8,59,0,9,214,82,7,19,0,8,107,0,8,43,0,9,182,0,8,11,0,8,139,0,8,75,0,9,246,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,206,81,7,15,0,8,103,0,8,39,0,9,174,0,8,7,0,8,135,0,8,71,0,9,238,80,7,9,0,8,95,0,8,31,0,9,158,84,7,99,0,8,127,0,8,63,0,9,222,82,7,27,0,8,111,0,8,47,0,9,190,0,8,15,0,8,143,0,8,79,0,9,254,96,7,256,0,8,80,0,8,16,84,8,115,82,7,31,0,8,112,0,8,48,0,9,193,80,7,10,0,8,96,0,8,32,0,9,161,0,8,0,0,8,128,0,8,64,0,9,225,80,7,6,0,8,88,0,8,24,0,9,145,83,7,59,0,8,120,0,8,56,0,9,209,81,7,17,0,8,104,0,8,40,0,9,177,0,8,8,0,8,136,0,8,72,0,9,241,80,7,4,0,8,84,0,8,20,85,8,227,83,7,43,0,8,116,0,8,52,0,9,201,81,7,13,0,8,100,0,8,36,0,9,169,0,8,4,0,8,132,0,8,68,0,9,233,80,7,8,0,8,92,0,8,28,0,9,153,84,7,83,0,8,124,0,8,60,0,9,217,82,7,23,0,8,108,0,8,44,0,9,185,0,8,12,0,8,140,0,8,76,0,9,249,80,7,3,0,8,82,0,8,18,85,8,163,83,7,35,0,8,114,0,8,50,0,9,197,81,7,11,0,8,98,0,8,34,0,9,165,0,8,2,0,8,130,0,8,66,0,9,229,80,7,7,0,8,90,0,8,26,0,9,149,84,7,67,0,8,122,0,8,58,0,9,213,82,7,19,0,8,106,0,8,42,0,9,181,0,8,10,0,8,138,0,8,74,0,9,245,80,7,5,0,8,86,0,8,22,192,8,0,83,7,51,0,8,118,0,8,54,0,9,205,81,7,15,0,8,102,0,8,38,0,9,173,0,8,6,0,8,134,0,8,70,0,9,237,80,7,9,0,8,94,0,8,30,0,9,157,84,7,99,0,8,126,0,8,62,0,9,221,82,7,27,0,8,110,0,8,46,0,9,189,0,8,14,0,8,142,0,8,78,0,9,253,96,7,256,0,8,81,0,8,17,85,8,131,82,7,31,0,8,113,0,8,49,0,9,195,80,7,10,0,8,97,0,8,33,0,9,163,0,8,1,0,8,129,0,8,65,0,9,227,80,7,6,0,8,89,0,8,25,0,9,147,83,7,59,0,8,121,0,8,57,0,9,211,81,7,17,0,8,105,0,8,41,0,9,179,0,8,9,0,8,137,0,8,73,0,9,243,80,7,4,0,8,85,0,8,21,80,8,258,83,7,43,0,8,117,0,8,53,0,9,203,81,7,13,0,8,101,0,8,37,0,9,171,0,8,5,0,8,133,0,8,69,0,9,235,80,7,8,0,8,93,0,8,29,0,9,155,84,7,83,0,8,125,0,8,61,0,9,219,82,7,23,0,8,109,0,8,45,0,9,187,0,8,13,0,8,141,0,8,77,0,9,251,80,7,3,0,8,83,0,8,19,85,8,195,83,7,35,0,8,115,0,8,51,0,9,199,81,7,11,0,8,99,0,8,35,0,9,167,0,8,3,0,8,131,0,8,67,0,9,231,80,7,7,0,8,91,0,8,27,0,9,151,84,7,67,0,8,123,0,8,59,0,9,215,82,7,19,0,8,107,0,8,43,0,9,183,0,8,11,0,8,139,0,8,75,0,9,247,80,7,5,0,8,87,0,8,23,192,8,0,83,7,51,0,8,119,0,8,55,0,9,207,81,7,15,0,8,103,0,8,39,0,9,175,0,8,7,0,8,135,0,8,71,0,9,239,80,7,9,0,8,95,0,8,31,0,9,159,84,7,99,0,8,127,0,8,63,0,9,223,82,7,27,0,8,111,0,8,47,0,9,191,0,8,15,0,8,143,0,8,79,0,9,255],ft=[80,5,1,87,5,257,83,5,17,91,5,4097,81,5,5,89,5,1025,85,5,65,93,5,16385,80,5,3,88,5,513,84,5,33,92,5,8193,82,5,9,90,5,2049,86,5,129,192,5,24577,80,5,2,87,5,385,83,5,25,91,5,6145,81,5,7,89,5,1537,85,5,97,93,5,24577,80,5,4,88,5,769,84,5,49,92,5,12289,82,5,13,90,5,3073,86,5,193,192,5,24577],at=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],lt=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,112,112],ut=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577],wt=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];function ht(){let e,t,n,r,s,i;function o(e,t,o,c,f,a,l,u,w,h,d){let p,y,m,b,g,k,v,S,z,C,x,A,_,I,P;C=0,g=o;do{n[e[t+C]]++,C++,g--}while(0!==g);if(n[0]==o)return l[0]=-1,u[0]=0,0;for(S=u[0],k=1;15>=k&&0===n[k];k++);for(v=k,k>S&&(S=k),g=15;0!==g&&0===n[g];g--);for(m=g,S>g&&(S=g),u[0]=S,I=1<<k;g>k;k++,I<<=1)if(0>(I-=n[k]))return st;if(0>(I-=n[g]))return st;for(n[g]+=I,i[1]=k=0,C=1,_=2;0!=--g;)i[_]=k+=n[C],_++,C++;g=0,C=0;do{0!==(k=e[t+C])&&(d[i[k]++]=g),C++}while(++g<o);for(o=i[m],i[0]=g=0,C=0,b=-1,A=-S,s[0]=0,x=0,P=0;m>=v;v++)for(p=n[v];0!=p--;){for(;v>A+S;){if(b++,A+=S,P=m-A,P=P>S?S:P,(y=1<<(k=v-A))>p+1&&(y-=p+1,_=v,P>k))for(;++k<P&&(y<<=1)>n[++_];)y-=n[_];if(P=1<<k,h[0]+P>1440)return st;s[b]=x=h[0],h[0]+=P,0!==b?(i[b]=g,r[0]=k,r[1]=S,k=g>>>A-S,r[2]=x-s[b-1]-k,w.set(r,3*(s[b-1]+k))):l[0]=x}for(r[1]=v-A,o>C?d[C]<c?(r[0]=256>d[C]?0:96,r[2]=d[C++]):(r[0]=a[d[C]-c]+16+64,r[2]=f[d[C++]-c]):r[0]=192,y=1<<v-A,k=g>>>A;P>k;k+=y)w.set(r,3*(x+k));for(k=1<<v-1;0!=(g&k);k>>>=1)g^=k;for(g^=k,z=(1<<A)-1;(g&z)!=i[b];)b--,A-=S,z=(1<<A)-1}return 0!==I&&1!=m?it:0}function c(o){let c;for(e||(e=[],t=[],n=new f(16),r=[],s=new f(15),i=new f(16)),t.length<o&&(t=[]),c=0;o>c;c++)t[c]=0;for(c=0;16>c;c++)n[c]=0;for(c=0;3>c;c++)r[c]=0;s.set(n.subarray(0,15),0),i.set(n.subarray(0,16),0)}this.st=(n,r,s,i,f)=>{let a;return c(19),e[0]=0,a=o(n,0,19,19,null,null,s,r,i,e,t),a==st?f.Le="oversubscribed dynamic bit lengths tree":a!=it&&0!==r[0]||(f.Le="incomplete dynamic bit lengths tree",a=st),a},this.it=(n,r,s,i,f,a,l,u,w)=>{let h;return c(288),e[0]=0,h=o(s,0,n,257,at,lt,a,i,u,e,t),0!=h||0===i[0]?(h==st?w.Le="oversubscribed literal/length tree":-4!=h&&(w.Le="incomplete literal/length tree",h=st),h):(c(288),h=o(s,n,r,0,ut,wt,l,f,u,e,t),0!=h||0===f[0]&&n>257?(h==st?w.Le="oversubscribed distance tree":h==it?(w.Le="incomplete distance tree",h=st):-4!=h&&(w.Le="empty distance tree with lengths",h=st),h):0)}}function dt(){const e=this;let t,n,r,s,i=0,o=0,c=0,f=0,a=0,l=0,u=0,w=0,h=0,d=0;function p(e,t,n,r,s,i,o,c){let f,a,l,u,w,h,d,p,y,m,b,g,k,v,S,z;d=c.nt,p=c.We,w=o.ot,h=o.ct,y=o.write,m=y<o.read?o.read-y-1:o.end-y,b=ot[e],g=ot[t];do{for(;20>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(f=w&b,a=n,l=r,z=3*(l+f),0!==(u=a[z]))for(;;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15,k=a[z+2]+(w&ot[u]),w>>=u,h-=u;15>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;for(f=w&g,a=s,l=i,z=3*(l+f),u=a[z];;){if(w>>=a[z+1],h-=a[z+1],0!=(16&u)){for(u&=15;u>h;)p--,w|=(255&c.ft(d++))<<h,h+=8;if(v=a[z+2]+(w&ot[u]),w>>=u,h-=u,m-=k,v>y){S=y-v;do{S+=o.end}while(0>S);if(u=o.end-S,k>u){if(k-=u,y-S>0&&u>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--u);else o.lt.set(o.lt.subarray(S,S+u),y),y+=u,S+=u,u=0;S=0}}else S=y-v,y-S>0&&2>y-S?(o.lt[y++]=o.lt[S++],o.lt[y++]=o.lt[S++],k-=2):(o.lt.set(o.lt.subarray(S,S+2),y),y+=2,S+=2,k-=2);if(y-S>0&&k>y-S)do{o.lt[y++]=o.lt[S++]}while(0!=--k);else o.lt.set(o.lt.subarray(S,S+k),y),y+=k,S+=k,k=0;break}if(0!=(64&u))return c.Le="invalid distance code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st;f+=a[z+2],f+=w&ot[u],z=3*(l+f),u=a[z]}break}if(0!=(64&u))return 0!=(32&u)?(k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,1):(c.Le="invalid literal/length code",k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,st);if(f+=a[z+2],f+=w&ot[u],z=3*(l+f),0===(u=a[z])){w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--;break}}else w>>=a[z+1],h-=a[z+1],o.lt[y++]=a[z+2],m--}while(m>=258&&p>=10);return k=c.We-p,k=k>h>>3?h>>3:k,p+=k,d-=k,h-=k<<3,o.ot=w,o.ct=h,c.We=p,c.qe+=d-c.nt,c.nt=d,o.write=y,0}e.init=(e,i,o,c,f,a)=>{t=0,u=e,w=i,r=o,h=c,s=f,d=a,n=null},e.ut=(e,y,m)=>{let b,g,k,v,S,z,C,x=0,A=0,_=0;for(_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S;;)switch(t){case 0:if(z>=258&&v>=10&&(e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,m=p(u,w,r,h,s,d,e,y),_=y.nt,v=y.We,x=e.ot,A=e.ct,S=e.write,z=S<e.read?e.read-S-1:e.end-S,0!=m)){t=1==m?7:9;break}c=u,n=r,o=h,t=1;case 1:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>>=n[g+1],A-=n[g+1],k=n[g],0===k){f=n[g+2],t=6;break}if(0!=(16&k)){a=15&k,i=n[g+2],t=2;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}if(0!=(32&k)){t=7;break}return t=9,y.Le="invalid literal/length code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 2:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}i+=x&ot[b],x>>=b,A-=b,c=w,n=s,o=d,t=3;case 3:for(b=c;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}if(g=3*(o+(x&ot[b])),x>>=n[g+1],A-=n[g+1],k=n[g],0!=(16&k)){a=15&k,l=n[g+2],t=4;break}if(0==(64&k)){c=k,o=g/3+n[g+2];break}return t=9,y.Le="invalid distance code",m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 4:for(b=a;b>A;){if(0===v)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,v--,x|=(255&y.ft(_++))<<A,A+=8}l+=x&ot[b],x>>=b,A-=b,t=5;case 5:for(C=S-l;0>C;)C+=e.end;for(;0!==i;){if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);e.lt[S++]=e.lt[C++],z--,C==e.end&&(C=0),i--}t=0;break;case 6:if(0===z&&(S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z&&(e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,S==e.end&&0!==e.read&&(S=0,z=S<e.read?e.read-S-1:e.end-S),0===z)))return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);m=0,e.lt[S++]=f,z--,t=0;break;case 7:if(A>7&&(A-=8,v++,_--),e.write=S,m=e.wt(y,m),S=e.write,z=S<e.read?e.read-S-1:e.end-S,e.read!=e.write)return e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);t=8;case 8:return m=1,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);case 9:return m=st,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m);default:return m=rt,e.ot=x,e.ct=A,y.We=v,y.qe+=_-y.nt,y.nt=_,e.write=S,e.wt(y,m)}},e.ht=()=>{}}ht.dt=(e,t,n,r)=>(e[0]=9,t[0]=5,n[0]=ct,r[0]=ft,0);const pt=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];function yt(e,t){const n=this;let r,s=0,o=0,c=0,a=0;const l=[0],u=[0],w=new dt;let h=0,d=new f(4320);const p=new ht;n.ct=0,n.ot=0,n.lt=new i(t),n.end=t,n.read=0,n.write=0,n.reset=(e,t)=>{t&&(t[0]=0),6==s&&w.ht(e),s=0,n.ct=0,n.ot=0,n.read=n.write=0},n.reset(e,null),n.wt=(e,t)=>{let r,s,i;return s=e.rt,i=n.read,r=(i>n.write?n.end:n.write)-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r,i==n.end&&(i=0,n.write==n.end&&(n.write=0),r=n.write-i,r>e.tt&&(r=e.tt),0!==r&&t==it&&(t=0),e.tt-=r,e.Ge+=r,e.$e.set(n.lt.subarray(i,i+r),s),s+=r,i+=r),e.rt=s,n.read=i,t},n.ut=(e,t)=>{let i,f,y,m,b,g,k,v;for(m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g;;){let S,z,C,x,A,_,I,P;switch(s){case 0:for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}switch(i=7&f,h=1&i,i>>>1){case 0:f>>>=3,y-=3,i=7&y,f>>>=i,y-=i,s=1;break;case 1:S=[],z=[],C=[[]],x=[[]],ht.dt(S,z,C,x),w.init(S[0],z[0],C[0],0,x[0],0),f>>>=3,y-=3,s=6;break;case 2:f>>>=3,y-=3,s=3;break;case 3:return f>>>=3,y-=3,s=9,e.Le="invalid block type",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}break;case 1:for(;32>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if((~f>>>16&65535)!=(65535&f))return s=9,e.Le="invalid stored block lengths",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);o=65535&f,f=y=0,s=0!==o?2:0!==h?7:0;break;case 2:if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(0===k&&(g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k&&(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,g==n.end&&0!==n.read&&(g=0,k=g<n.read?n.read-g-1:n.end-g),0===k)))return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(t=0,i=o,i>b&&(i=b),i>k&&(i=k),n.lt.set(e.je(m,i),g),m+=i,b-=i,g+=i,k-=i,0!=(o-=i))break;s=0!==h?7:0;break;case 3:for(;14>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(c=i=16383&f,(31&i)>29||(i>>5&31)>29)return s=9,e.Le="too many length or distance symbols",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);if(i=258+(31&i)+(i>>5&31),!r||r.length<i)r=[];else for(v=0;i>v;v++)r[v]=0;f>>>=14,y-=14,a=0,s=4;case 4:for(;4+(c>>>10)>a;){for(;3>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}r[pt[a++]]=7&f,f>>>=3,y-=3}for(;19>a;)r[pt[a++]]=0;if(l[0]=7,i=p.st(r,l,u,d,e),0!=i)return(t=i)==st&&(r=null,s=9),n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);a=0,s=5;case 5:for(;i=c,258+(31&i)+(i>>5&31)>a;){let o,w;for(i=l[0];i>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(i=d[3*(u[0]+(f&ot[i]))+1],w=d[3*(u[0]+(f&ot[i]))+2],16>w)f>>>=i,y-=i,r[a++]=w;else{for(v=18==w?7:w-14,o=18==w?11:3;i+v>y;){if(0===b)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);t=0,b--,f|=(255&e.ft(m++))<<y,y+=8}if(f>>>=i,y-=i,o+=f&ot[v],f>>>=v,y-=v,v=a,i=c,v+o>258+(31&i)+(i>>5&31)||16==w&&1>v)return r=null,s=9,e.Le="invalid bit length repeat",t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w=16==w?r[v-1]:0;do{r[v++]=w}while(0!=--o);a=v}}if(u[0]=-1,A=[],_=[],I=[],P=[],A[0]=9,_[0]=6,i=c,i=p.it(257+(31&i),1+(i>>5&31),r,A,_,I,P,d,e),0!=i)return i==st&&(r=null,s=9),t=i,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);w.init(A[0],_[0],d,I[0],d,P[0]),s=6;case 6:if(n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,1!=(t=w.ut(n,e,t)))return n.wt(e,t);if(t=0,w.ht(e),m=e.nt,b=e.We,f=n.ot,y=n.ct,g=n.write,k=g<n.read?n.read-g-1:n.end-g,0===h){s=0;break}s=7;case 7:if(n.write=g,t=n.wt(e,t),g=n.write,k=g<n.read?n.read-g-1:n.end-g,n.read!=n.write)return n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);s=8;case 8:return t=1,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);case 9:return t=st,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t);default:return t=rt,n.ot=f,n.ct=y,e.We=b,e.qe+=m-e.nt,e.nt=m,n.write=g,n.wt(e,t)}}},n.ht=e=>{n.reset(e,null),n.lt=null,d=null},n.yt=(e,t,r)=>{n.lt.set(e.subarray(t,t+r),0),n.read=n.write=r},n.bt=()=>1==s?1:0}const mt=13,bt=[0,0,255,255];function gt(){const e=this;function t(e){return e&&e.gt?(e.qe=e.Ge=0,e.Le=null,e.gt.mode=7,e.gt.kt.reset(e,null),0):rt}e.mode=0,e.method=0,e.vt=[0],e.St=0,e.marker=0,e.zt=0,e.Ct=t=>(e.kt&&e.kt.ht(t),e.kt=null,0),e.xt=(n,r)=>(n.Le=null,e.kt=null,8>r||r>15?(e.Ct(n),rt):(e.zt=r,n.gt.kt=new yt(n,1<<r),t(n),0)),e.At=(e,t)=>{let n,r;if(!e||!e.gt||!e.et)return rt;const s=e.gt;for(t=4==t?it:0,n=it;;)switch(s.mode){case 0:if(0===e.We)return n;if(n=t,e.We--,e.qe++,8!=(15&(s.method=e.ft(e.nt++)))){s.mode=mt,e.Le="unknown compression method",s.marker=5;break}if(8+(s.method>>4)>s.zt){s.mode=mt,e.Le="invalid win size",s.marker=5;break}s.mode=1;case 1:if(0===e.We)return n;if(n=t,e.We--,e.qe++,r=255&e.ft(e.nt++),((s.method<<8)+r)%31!=0){s.mode=mt,e.Le="incorrect header check",s.marker=5;break}if(0==(32&r)){s.mode=7;break}s.mode=2;case 2:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St=(255&e.ft(e.nt++))<<24&4278190080,s.mode=3;case 3:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<16&16711680,s.mode=4;case 4:if(0===e.We)return n;n=t,e.We--,e.qe++,s.St+=(255&e.ft(e.nt++))<<8&65280,s.mode=5;case 5:return 0===e.We?n:(n=t,e.We--,e.qe++,s.St+=255&e.ft(e.nt++),s.mode=6,2);case 6:return s.mode=mt,e.Le="need dictionary",s.marker=0,rt;case 7:if(n=s.kt.ut(e,n),n==st){s.mode=mt,s.marker=0;break}if(0==n&&(n=t),1!=n)return n;n=t,s.kt.reset(e,s.vt),s.mode=12;case 12:return e.We=0,1;case mt:return st;default:return rt}},e._t=(e,t,n)=>{let r=0,s=n;if(!e||!e.gt||6!=e.gt.mode)return rt;const i=e.gt;return s<1<<i.zt||(s=(1<<i.zt)-1,r=n-s),i.kt.yt(t,r,s),i.mode=7,0},e.It=e=>{let n,r,s,i,o;if(!e||!e.gt)return rt;const c=e.gt;if(c.mode!=mt&&(c.mode=mt,c.marker=0),0===(n=e.We))return it;for(r=e.nt,s=c.marker;0!==n&&4>s;)e.ft(r)==bt[s]?s++:s=0!==e.ft(r)?0:4-s,r++,n--;return e.qe+=r-e.nt,e.nt=r,e.We=n,c.marker=s,4!=s?st:(i=e.qe,o=e.Ge,t(e),e.qe=i,e.Ge=o,c.mode=7,0)},e.Pt=e=>e&&e.gt&&e.gt.kt?e.gt.kt.bt():rt}function kt(){}function vt(e){const t=new kt,n=e&&e.chunkSize?r.floor(2*e.chunkSize):131072,o=new i(n);let c=!1;t.xt(),t.$e=o,this.append=(e,r)=>{const f=[];let a,l,u=0,w=0,h=0;if(0!==e.length){t.nt=0,t.et=e,t.We=e.length;do{if(t.rt=0,t.tt=n,0!==t.We||c||(t.nt=0,c=!0),a=t.At(0),c&&a===it){if(0!==t.We)throw new s("inflating: bad input")}else if(0!==a&&1!==a)throw new s("inflating: "+t.Le);if((c||1===a)&&t.We===e.length)throw new s("inflating: bad input");t.rt&&(t.rt===n?f.push(new i(o)):f.push(o.subarray(0,t.rt))),h+=t.rt,r&&t.nt>0&&t.nt!=u&&(r(t.nt),u=t.nt)}while(t.We>0||0===t.tt);return f.length>1?(l=new i(h),f.forEach((e=>{l.set(e,w),w+=e.length}))):l=f[0]?new i(f[0]):new i,l}},this.flush=()=>{t.Ct()}}kt.prototype={xt(e){const t=this;return t.gt=new gt,e||(e=15),t.gt.xt(t,e)},At(e){const t=this;return t.gt?t.gt.At(t,e):rt},Ct(){const e=this;if(!e.gt)return rt;const t=e.gt.Ct(e);return e.gt=null,t},It(){const e=this;return e.gt?e.gt.It(e):rt},_t(e,t){const n=this;return n.gt?n.gt._t(n,e,t):rt},ft(e){return this.et[e]},je(e,t){return this.et.subarray(e,e+t)}},self.initCodec=()=>{self.Deflate=nt,self.Inflate=vt};\n'], { type: "text/javascript" }));
  e2({ workerScripts: { inflate: [t2], deflate: [t2] } });
}

// node_modules/@zip.js/zip.js/lib/core/io.js
var ERR_ITERATOR_COMPLETED_TOO_SOON = "Writer iterator completed too soon";
var HTTP_HEADER_CONTENT_TYPE = "Content-Type";
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var PROPERTY_NAME_WRITABLE = "writable";
var Stream = class {
  constructor() {
    this.size = 0;
  }
  init() {
    this.initialized = true;
  }
};
var Reader = class extends Stream {
  get readable() {
    const reader = this;
    const { chunkSize = DEFAULT_CHUNK_SIZE } = reader;
    const readable = new ReadableStream({
      start() {
        this.chunkOffset = 0;
      },
      async pull(controller) {
        const { offset = 0, size, diskNumberStart } = readable;
        const { chunkOffset } = this;
        controller.enqueue(await readUint8Array(reader, offset + chunkOffset, Math.min(chunkSize, size - chunkOffset), diskNumberStart));
        if (chunkOffset + chunkSize > size) {
          controller.close();
        } else {
          this.chunkOffset += chunkSize;
        }
      }
    });
    return readable;
  }
};
var BlobReader = class extends Reader {
  constructor(blob) {
    super();
    Object.assign(this, {
      blob,
      size: blob.size
    });
  }
  async readUint8Array(offset, length) {
    const reader = this;
    const offsetEnd = offset + length;
    const blob = offset || offsetEnd < reader.size ? reader.blob.slice(offset, offsetEnd) : reader.blob;
    let arrayBuffer = await blob.arrayBuffer();
    if (arrayBuffer.byteLength > length) {
      arrayBuffer = arrayBuffer.slice(offset, offsetEnd);
    }
    return new Uint8Array(arrayBuffer);
  }
};
var BlobWriter = class extends Stream {
  constructor(contentType) {
    super();
    const writer = this;
    const transformStream = new TransformStream();
    const headers = [];
    if (contentType) {
      headers.push([HTTP_HEADER_CONTENT_TYPE, contentType]);
    }
    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
      get() {
        return transformStream.writable;
      }
    });
    writer.blob = new Response(transformStream.readable, { headers }).blob();
  }
  getData() {
    return this.blob;
  }
};
var SplitDataReader = class extends Reader {
  constructor(readers) {
    super();
    this.readers = readers;
  }
  async init() {
    const reader = this;
    const { readers } = reader;
    reader.lastDiskNumber = 0;
    reader.lastDiskOffset = 0;
    await Promise.all(readers.map(async (diskReader, indexDiskReader) => {
      await diskReader.init();
      if (indexDiskReader != readers.length - 1) {
        reader.lastDiskOffset += diskReader.size;
      }
      reader.size += diskReader.size;
    }));
    super.init();
  }
  async readUint8Array(offset, length, diskNumber = 0) {
    const reader = this;
    const { readers } = this;
    let result;
    let currentDiskNumber = diskNumber;
    if (currentDiskNumber == -1) {
      currentDiskNumber = readers.length - 1;
    }
    let currentReaderOffset = offset;
    while (currentReaderOffset >= readers[currentDiskNumber].size) {
      currentReaderOffset -= readers[currentDiskNumber].size;
      currentDiskNumber++;
    }
    const currentReader = readers[currentDiskNumber];
    const currentReaderSize = currentReader.size;
    if (currentReaderOffset + length <= currentReaderSize) {
      result = await readUint8Array(currentReader, currentReaderOffset, length);
    } else {
      const chunkLength = currentReaderSize - currentReaderOffset;
      result = new Uint8Array(length);
      result.set(await readUint8Array(currentReader, currentReaderOffset, chunkLength));
      result.set(await reader.readUint8Array(offset + chunkLength, length - chunkLength, diskNumber), chunkLength);
    }
    reader.lastDiskNumber = Math.max(currentDiskNumber, reader.lastDiskNumber);
    return result;
  }
};
var SplitDataWriter = class extends Stream {
  constructor(writerGenerator, maxSize = 4294967295) {
    super();
    const writer = this;
    Object.assign(writer, {
      diskNumber: 0,
      diskOffset: 0,
      size: 0,
      maxSize,
      availableSize: maxSize
    });
    let diskSourceWriter, diskWritable, diskWriter;
    const writable = new WritableStream({
      async write(chunk) {
        const { availableSize } = writer;
        if (!diskWriter) {
          const { value, done } = await writerGenerator.next();
          if (done && !value) {
            throw new Error(ERR_ITERATOR_COMPLETED_TOO_SOON);
          } else {
            diskSourceWriter = value;
            diskSourceWriter.size = 0;
            if (diskSourceWriter.maxSize) {
              writer.maxSize = diskSourceWriter.maxSize;
            }
            writer.availableSize = writer.maxSize;
            await initStream(diskSourceWriter);
            diskWritable = value.writable;
            diskWriter = diskWritable.getWriter();
          }
          await this.write(chunk);
        } else if (chunk.length >= availableSize) {
          await writeChunk(chunk.slice(0, availableSize));
          await closeDisk();
          writer.diskOffset += diskSourceWriter.size;
          writer.diskNumber++;
          diskWriter = null;
          await this.write(chunk.slice(availableSize));
        } else {
          await writeChunk(chunk);
        }
      },
      async close() {
        await diskWriter.ready;
        await closeDisk();
      }
    });
    Object.defineProperty(writer, PROPERTY_NAME_WRITABLE, {
      get() {
        return writable;
      }
    });
    async function writeChunk(chunk) {
      const chunkLength = chunk.length;
      if (chunkLength) {
        await diskWriter.ready;
        await diskWriter.write(chunk);
        diskSourceWriter.size += chunkLength;
        writer.size += chunkLength;
        writer.availableSize -= chunkLength;
      }
    }
    async function closeDisk() {
      diskWritable.size = diskSourceWriter.size;
      await diskWriter.close();
    }
  }
};
async function initStream(stream, initSize) {
  if (stream.init && !stream.initialized) {
    await stream.init(initSize);
  } else {
    return Promise.resolve();
  }
}
function initReader(reader) {
  if (Array.isArray(reader)) {
    reader = new SplitDataReader(reader);
  }
  if (reader instanceof ReadableStream) {
    reader = {
      readable: reader
    };
  }
  return reader;
}
function initWriter(writer) {
  if (writer.writable === UNDEFINED_VALUE && typeof writer.next == FUNCTION_TYPE) {
    writer = new SplitDataWriter(writer);
  }
  if (writer instanceof WritableStream) {
    writer = {
      writable: writer
    };
  }
  const { writable } = writer;
  if (writable.size === UNDEFINED_VALUE) {
    writable.size = 0;
  }
  if (!(writer instanceof SplitDataWriter)) {
    Object.assign(writer, {
      diskNumber: 0,
      diskOffset: 0,
      availableSize: Infinity,
      maxSize: Infinity
    });
  }
  return writer;
}
function readUint8Array(reader, offset, size, diskNumber) {
  return reader.readUint8Array(offset, size, diskNumber);
}

// node_modules/@zip.js/zip.js/lib/core/util/cp437-decode.js
var CP437 = "\0\u263A\u263B\u2665\u2666\u2663\u2660\u2022\u25D8\u25CB\u25D9\u2642\u2640\u266A\u266B\u263C\u25BA\u25C4\u2195\u203C\xB6\xA7\u25AC\u21A8\u2191\u2193\u2192\u2190\u221F\u2194\u25B2\u25BC !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u2302\xC7\xFC\xE9\xE2\xE4\xE0\xE5\xE7\xEA\xEB\xE8\xEF\xEE\xEC\xC4\xC5\xC9\xE6\xC6\xF4\xF6\xF2\xFB\xF9\xFF\xD6\xDC\xA2\xA3\xA5\u20A7\u0192\xE1\xED\xF3\xFA\xF1\xD1\xAA\xBA\xBF\u2310\xAC\xBD\xBC\xA1\xAB\xBB\u2591\u2592\u2593\u2502\u2524\u2561\u2562\u2556\u2555\u2563\u2551\u2557\u255D\u255C\u255B\u2510\u2514\u2534\u252C\u251C\u2500\u253C\u255E\u255F\u255A\u2554\u2569\u2566\u2560\u2550\u256C\u2567\u2568\u2564\u2565\u2559\u2558\u2552\u2553\u256B\u256A\u2518\u250C\u2588\u2584\u258C\u2590\u2580\u03B1\xDF\u0393\u03C0\u03A3\u03C3\xB5\u03C4\u03A6\u0398\u03A9\u03B4\u221E\u03C6\u03B5\u2229\u2261\xB1\u2265\u2264\u2320\u2321\xF7\u2248\xB0\u2219\xB7\u221A\u207F\xB2\u25A0 ".split("");
var VALID_CP437 = CP437.length == 256;
function decodeCP437(stringValue) {
  if (VALID_CP437) {
    let result = "";
    for (let indexCharacter = 0; indexCharacter < stringValue.length; indexCharacter++) {
      result += CP437[stringValue[indexCharacter]];
    }
    return result;
  } else {
    return new TextDecoder().decode(stringValue);
  }
}

// node_modules/@zip.js/zip.js/lib/core/util/decode-text.js
function decodeText(value, encoding) {
  if (encoding && encoding.trim().toLowerCase() == "cp437") {
    return decodeCP437(value);
  } else {
    return new TextDecoder(encoding).decode(value);
  }
}

// node_modules/@zip.js/zip.js/lib/core/zip-entry.js
var PROPERTY_NAME_FILENAME = "filename";
var PROPERTY_NAME_RAW_FILENAME = "rawFilename";
var PROPERTY_NAME_COMMENT = "comment";
var PROPERTY_NAME_RAW_COMMENT = "rawComment";
var PROPERTY_NAME_UNCOMPPRESSED_SIZE = "uncompressedSize";
var PROPERTY_NAME_COMPPRESSED_SIZE = "compressedSize";
var PROPERTY_NAME_OFFSET = "offset";
var PROPERTY_NAME_DISK_NUMBER_START = "diskNumberStart";
var PROPERTY_NAME_LAST_MODIFICATION_DATE = "lastModDate";
var PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE = "rawLastModDate";
var PROPERTY_NAME_LAST_ACCESS_DATE = "lastAccessDate";
var PROPERTY_NAME_RAW_LAST_ACCESS_DATE = "rawLastAccessDate";
var PROPERTY_NAME_CREATION_DATE = "creationDate";
var PROPERTY_NAME_RAW_CREATION_DATE = "rawCreationDate";
var PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE = "internalFileAttribute";
var PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE = "externalFileAttribute";
var PROPERTY_NAME_MS_DOS_COMPATIBLE = "msDosCompatible";
var PROPERTY_NAME_ZIP64 = "zip64";
var PROPERTY_NAMES = [
  PROPERTY_NAME_FILENAME,
  PROPERTY_NAME_RAW_FILENAME,
  PROPERTY_NAME_COMPPRESSED_SIZE,
  PROPERTY_NAME_UNCOMPPRESSED_SIZE,
  PROPERTY_NAME_LAST_MODIFICATION_DATE,
  PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE,
  PROPERTY_NAME_COMMENT,
  PROPERTY_NAME_RAW_COMMENT,
  PROPERTY_NAME_LAST_ACCESS_DATE,
  PROPERTY_NAME_CREATION_DATE,
  PROPERTY_NAME_OFFSET,
  PROPERTY_NAME_DISK_NUMBER_START,
  PROPERTY_NAME_DISK_NUMBER_START,
  PROPERTY_NAME_INTERNAL_FILE_ATTRIBUTE,
  PROPERTY_NAME_EXTERNAL_FILE_ATTRIBUTE,
  PROPERTY_NAME_MS_DOS_COMPATIBLE,
  PROPERTY_NAME_ZIP64,
  "directory",
  "bitFlag",
  "encrypted",
  "signature",
  "filenameUTF8",
  "commentUTF8",
  "compressionMethod",
  "version",
  "versionMadeBy",
  "extraField",
  "rawExtraField",
  "extraFieldZip64",
  "extraFieldUnicodePath",
  "extraFieldUnicodeComment",
  "extraFieldAES",
  "extraFieldNTFS",
  "extraFieldExtendedTimestamp"
];
var Entry = class {
  constructor(data) {
    PROPERTY_NAMES.forEach((name) => this[name] = data[name]);
  }
};

// node_modules/@zip.js/zip.js/lib/core/zip-reader.js
var ERR_BAD_FORMAT = "File format is not recognized";
var ERR_EOCDR_NOT_FOUND = "End of central directory not found";
var ERR_EOCDR_ZIP64_NOT_FOUND = "End of Zip64 central directory not found";
var ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND = "End of Zip64 central directory locator not found";
var ERR_CENTRAL_DIRECTORY_NOT_FOUND = "Central directory header not found";
var ERR_LOCAL_FILE_HEADER_NOT_FOUND = "Local file header not found";
var ERR_EXTRAFIELD_ZIP64_NOT_FOUND = "Zip64 extra field not found";
var ERR_ENCRYPTED = "File contains encrypted entry";
var ERR_UNSUPPORTED_ENCRYPTION = "Encryption method not supported";
var ERR_UNSUPPORTED_COMPRESSION = "Compression method not supported";
var ERR_SPLIT_ZIP_FILE = "Split zip file";
var CHARSET_UTF8 = "utf-8";
var CHARSET_CP437 = "cp437";
var ZIP64_PROPERTIES = [
  [PROPERTY_NAME_UNCOMPPRESSED_SIZE, MAX_32_BITS],
  [PROPERTY_NAME_COMPPRESSED_SIZE, MAX_32_BITS],
  [PROPERTY_NAME_OFFSET, MAX_32_BITS],
  [PROPERTY_NAME_DISK_NUMBER_START, MAX_16_BITS]
];
var ZIP64_EXTRACTION = {
  [MAX_16_BITS]: {
    getValue: getUint32,
    bytes: 4
  },
  [MAX_32_BITS]: {
    getValue: getBigUint64,
    bytes: 8
  }
};
var ZipReader = class {
  constructor(reader, options = {}) {
    Object.assign(this, {
      reader: initReader(reader),
      options,
      config: getConfiguration()
    });
  }
  async *getEntriesGenerator(options = {}) {
    const zipReader = this;
    let { reader } = zipReader;
    const { config: config2 } = zipReader;
    await initStream(reader);
    if (reader.size === UNDEFINED_VALUE || !reader.readUint8Array) {
      reader = new BlobReader(await new Response(reader.readable).blob());
      await initStream(reader);
    }
    if (reader.size < END_OF_CENTRAL_DIR_LENGTH) {
      throw new Error(ERR_BAD_FORMAT);
    }
    reader.chunkSize = getChunkSize(config2);
    const endOfDirectoryInfo = await seekSignature(reader, END_OF_CENTRAL_DIR_SIGNATURE, reader.size, END_OF_CENTRAL_DIR_LENGTH, MAX_16_BITS * 16);
    if (!endOfDirectoryInfo) {
      const signatureArray = await readUint8Array(reader, 0, 4);
      const signatureView = getDataView(signatureArray);
      if (getUint32(signatureView) == SPLIT_ZIP_FILE_SIGNATURE) {
        throw new Error(ERR_SPLIT_ZIP_FILE);
      } else {
        throw new Error(ERR_EOCDR_NOT_FOUND);
      }
    }
    const endOfDirectoryView = getDataView(endOfDirectoryInfo);
    let directoryDataLength = getUint32(endOfDirectoryView, 12);
    let directoryDataOffset = getUint32(endOfDirectoryView, 16);
    const commentOffset = endOfDirectoryInfo.offset;
    const commentLength = getUint16(endOfDirectoryView, 20);
    const appendedDataOffset = commentOffset + END_OF_CENTRAL_DIR_LENGTH + commentLength;
    let lastDiskNumber = getUint16(endOfDirectoryView, 4);
    const expectedLastDiskNumber = reader.lastDiskNumber || 0;
    let diskNumber = getUint16(endOfDirectoryView, 6);
    let filesLength = getUint16(endOfDirectoryView, 8);
    let prependedDataLength = 0;
    let startOffset = 0;
    if (directoryDataOffset == MAX_32_BITS || directoryDataLength == MAX_32_BITS || filesLength == MAX_16_BITS || diskNumber == MAX_16_BITS) {
      const endOfDirectoryLocatorArray = await readUint8Array(reader, endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH, ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH);
      const endOfDirectoryLocatorView = getDataView(endOfDirectoryLocatorArray);
      if (getUint32(endOfDirectoryLocatorView, 0) != ZIP64_END_OF_CENTRAL_DIR_LOCATOR_SIGNATURE) {
        throw new Error(ERR_EOCDR_ZIP64_NOT_FOUND);
      }
      directoryDataOffset = getBigUint64(endOfDirectoryLocatorView, 8);
      let endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
      let endOfDirectoryView2 = getDataView(endOfDirectoryArray);
      const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - ZIP64_END_OF_CENTRAL_DIR_LOCATOR_LENGTH - ZIP64_END_OF_CENTRAL_DIR_LENGTH;
      if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
        const originalDirectoryDataOffset = directoryDataOffset;
        directoryDataOffset = expectedDirectoryDataOffset;
        prependedDataLength = directoryDataOffset - originalDirectoryDataOffset;
        endOfDirectoryArray = await readUint8Array(reader, directoryDataOffset, ZIP64_END_OF_CENTRAL_DIR_LENGTH, -1);
        endOfDirectoryView2 = getDataView(endOfDirectoryArray);
      }
      if (getUint32(endOfDirectoryView2, 0) != ZIP64_END_OF_CENTRAL_DIR_SIGNATURE) {
        throw new Error(ERR_EOCDR_LOCATOR_ZIP64_NOT_FOUND);
      }
      if (lastDiskNumber == MAX_16_BITS) {
        lastDiskNumber = getUint32(endOfDirectoryView2, 16);
      }
      if (diskNumber == MAX_16_BITS) {
        diskNumber = getUint32(endOfDirectoryView2, 20);
      }
      if (filesLength == MAX_16_BITS) {
        filesLength = getBigUint64(endOfDirectoryView2, 32);
      }
      if (directoryDataLength == MAX_32_BITS) {
        directoryDataLength = getBigUint64(endOfDirectoryView2, 40);
      }
      directoryDataOffset -= directoryDataLength;
    }
    if (directoryDataOffset >= reader.size) {
      prependedDataLength = reader.size - directoryDataOffset - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
      directoryDataOffset = reader.size - directoryDataLength - END_OF_CENTRAL_DIR_LENGTH;
    }
    if (expectedLastDiskNumber != lastDiskNumber) {
      throw new Error(ERR_SPLIT_ZIP_FILE);
    }
    if (directoryDataOffset < 0) {
      throw new Error(ERR_BAD_FORMAT);
    }
    let offset = 0;
    let directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
    let directoryView = getDataView(directoryArray);
    if (directoryDataLength) {
      const expectedDirectoryDataOffset = endOfDirectoryInfo.offset - directoryDataLength;
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE && directoryDataOffset != expectedDirectoryDataOffset) {
        const originalDirectoryDataOffset = directoryDataOffset;
        directoryDataOffset = expectedDirectoryDataOffset;
        prependedDataLength += directoryDataOffset - originalDirectoryDataOffset;
        directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
        directoryView = getDataView(directoryArray);
      }
    }
    const expectedDirectoryDataLength = endOfDirectoryInfo.offset - directoryDataOffset - (reader.lastDiskOffset || 0);
    if (directoryDataLength != expectedDirectoryDataLength && expectedDirectoryDataLength >= 0) {
      directoryDataLength = expectedDirectoryDataLength;
      directoryArray = await readUint8Array(reader, directoryDataOffset, directoryDataLength, diskNumber);
      directoryView = getDataView(directoryArray);
    }
    if (directoryDataOffset < 0 || directoryDataOffset >= reader.size) {
      throw new Error(ERR_BAD_FORMAT);
    }
    const filenameEncoding = getOptionValue(zipReader, options, "filenameEncoding");
    const commentEncoding = getOptionValue(zipReader, options, "commentEncoding");
    for (let indexFile = 0; indexFile < filesLength; indexFile++) {
      const fileEntry = new ZipEntry(reader, config2, zipReader.options);
      if (getUint32(directoryView, offset) != CENTRAL_FILE_HEADER_SIGNATURE) {
        throw new Error(ERR_CENTRAL_DIRECTORY_NOT_FOUND);
      }
      readCommonHeader(fileEntry, directoryView, offset + 6);
      const languageEncodingFlag = Boolean(fileEntry.bitFlag.languageEncodingFlag);
      const filenameOffset = offset + 46;
      const extraFieldOffset = filenameOffset + fileEntry.filenameLength;
      const commentOffset2 = extraFieldOffset + fileEntry.extraFieldLength;
      const versionMadeBy = getUint16(directoryView, offset + 4);
      const msDosCompatible = (versionMadeBy & 0) == 0;
      const rawFilename = directoryArray.subarray(filenameOffset, extraFieldOffset);
      const commentLength2 = getUint16(directoryView, offset + 32);
      const endOffset = commentOffset2 + commentLength2;
      const rawComment = directoryArray.subarray(commentOffset2, endOffset);
      const filenameUTF8 = languageEncodingFlag;
      const commentUTF8 = languageEncodingFlag;
      const directory = msDosCompatible && (getUint8(directoryView, offset + 38) & FILE_ATTR_MSDOS_DIR_MASK) == FILE_ATTR_MSDOS_DIR_MASK;
      const offsetFileEntry = getUint32(directoryView, offset + 42) + prependedDataLength;
      Object.assign(fileEntry, {
        versionMadeBy,
        msDosCompatible,
        compressedSize: 0,
        uncompressedSize: 0,
        commentLength: commentLength2,
        directory,
        offset: offsetFileEntry,
        diskNumberStart: getUint16(directoryView, offset + 34),
        internalFileAttribute: getUint16(directoryView, offset + 36),
        externalFileAttribute: getUint32(directoryView, offset + 38),
        rawFilename,
        filenameUTF8,
        commentUTF8,
        rawExtraField: directoryArray.subarray(extraFieldOffset, commentOffset2)
      });
      const [filename, comment] = await Promise.all([
        decodeText(rawFilename, filenameUTF8 ? CHARSET_UTF8 : filenameEncoding || CHARSET_CP437),
        decodeText(rawComment, commentUTF8 ? CHARSET_UTF8 : commentEncoding || CHARSET_CP437)
      ]);
      Object.assign(fileEntry, {
        rawComment,
        filename,
        comment,
        directory: directory || filename.endsWith(DIRECTORY_SIGNATURE)
      });
      startOffset = Math.max(offsetFileEntry, startOffset);
      await readCommonFooter(fileEntry, fileEntry, directoryView, offset + 6);
      const entry = new Entry(fileEntry);
      entry.getData = (writer, options2) => fileEntry.getData(writer, entry, options2);
      offset = endOffset;
      const { onprogress } = options;
      if (onprogress) {
        try {
          await onprogress(indexFile + 1, filesLength, new Entry(fileEntry));
        } catch (_error) {
        }
      }
      yield entry;
    }
    const extractPrependedData = getOptionValue(zipReader, options, "extractPrependedData");
    const extractAppendedData = getOptionValue(zipReader, options, "extractAppendedData");
    if (extractPrependedData) {
      zipReader.prependedData = startOffset > 0 ? await readUint8Array(reader, 0, startOffset) : new Uint8Array();
    }
    zipReader.comment = commentLength ? await readUint8Array(reader, commentOffset + END_OF_CENTRAL_DIR_LENGTH, commentLength) : new Uint8Array();
    if (extractAppendedData) {
      zipReader.appendedData = appendedDataOffset < reader.size ? await readUint8Array(reader, appendedDataOffset, reader.size - appendedDataOffset) : new Uint8Array();
    }
    return true;
  }
  async getEntries(options = {}) {
    const entries = [];
    for await (const entry of this.getEntriesGenerator(options)) {
      entries.push(entry);
    }
    return entries;
  }
  async close() {
  }
};
var ZipEntry = class {
  constructor(reader, config2, options) {
    Object.assign(this, {
      reader,
      config: config2,
      options
    });
  }
  async getData(writer, fileEntry, options = {}) {
    const zipEntry = this;
    const {
      reader,
      offset,
      diskNumberStart,
      extraFieldAES,
      compressionMethod,
      config: config2,
      bitFlag,
      signature,
      rawLastModDate,
      uncompressedSize,
      compressedSize
    } = zipEntry;
    const localDirectory = fileEntry.localDirectory = {};
    const dataArray = await readUint8Array(reader, offset, 30, diskNumberStart);
    const dataView = getDataView(dataArray);
    let password = getOptionValue(zipEntry, options, "password");
    let rawPassword = getOptionValue(zipEntry, options, "rawPassword");
    password = password && password.length && password;
    rawPassword = rawPassword && rawPassword.length && rawPassword;
    if (extraFieldAES) {
      if (extraFieldAES.originalCompressionMethod != COMPRESSION_METHOD_AES) {
        throw new Error(ERR_UNSUPPORTED_COMPRESSION);
      }
    }
    if (compressionMethod != COMPRESSION_METHOD_STORE && compressionMethod != COMPRESSION_METHOD_DEFLATE) {
      throw new Error(ERR_UNSUPPORTED_COMPRESSION);
    }
    if (getUint32(dataView, 0) != LOCAL_FILE_HEADER_SIGNATURE) {
      throw new Error(ERR_LOCAL_FILE_HEADER_NOT_FOUND);
    }
    readCommonHeader(localDirectory, dataView, 4);
    localDirectory.rawExtraField = localDirectory.extraFieldLength ? await readUint8Array(reader, offset + 30 + localDirectory.filenameLength, localDirectory.extraFieldLength, diskNumberStart) : new Uint8Array();
    await readCommonFooter(zipEntry, localDirectory, dataView, 4, true);
    Object.assign(fileEntry, {
      lastAccessDate: localDirectory.lastAccessDate,
      creationDate: localDirectory.creationDate
    });
    const encrypted = zipEntry.encrypted && localDirectory.encrypted;
    const zipCrypto = encrypted && !extraFieldAES;
    if (encrypted) {
      if (!zipCrypto && extraFieldAES.strength === UNDEFINED_VALUE) {
        throw new Error(ERR_UNSUPPORTED_ENCRYPTION);
      } else if (!password && !rawPassword) {
        throw new Error(ERR_ENCRYPTED);
      }
    }
    const dataOffset = offset + 30 + localDirectory.filenameLength + localDirectory.extraFieldLength;
    const size = compressedSize;
    const readable = reader.readable;
    Object.assign(readable, {
      diskNumberStart,
      offset: dataOffset,
      size
    });
    const signal = getOptionValue(zipEntry, options, "signal");
    const checkPasswordOnly = getOptionValue(zipEntry, options, "checkPasswordOnly");
    if (checkPasswordOnly) {
      writer = new WritableStream();
    }
    writer = initWriter(writer);
    await initStream(writer, uncompressedSize);
    const { writable } = writer;
    const { onstart, onprogress, onend } = options;
    const workerOptions = {
      options: {
        codecType: CODEC_INFLATE,
        password,
        rawPassword,
        zipCrypto,
        encryptionStrength: extraFieldAES && extraFieldAES.strength,
        signed: getOptionValue(zipEntry, options, "checkSignature"),
        passwordVerification: zipCrypto && (bitFlag.dataDescriptor ? rawLastModDate >>> 8 & 255 : signature >>> 24 & 255),
        signature,
        compressed: compressionMethod != 0,
        encrypted,
        useWebWorkers: getOptionValue(zipEntry, options, "useWebWorkers"),
        useCompressionStream: getOptionValue(zipEntry, options, "useCompressionStream"),
        transferStreams: getOptionValue(zipEntry, options, "transferStreams"),
        checkPasswordOnly
      },
      config: config2,
      streamOptions: { signal, size, onstart, onprogress, onend }
    };
    let outputSize = 0;
    try {
      ({ outputSize } = await runWorker2({ readable, writable }, workerOptions));
    } catch (error) {
      if (!checkPasswordOnly || error.message != ERR_ABORT_CHECK_PASSWORD) {
        throw error;
      }
    } finally {
      const preventClose = getOptionValue(zipEntry, options, "preventClose");
      writable.size += outputSize;
      if (!preventClose && !writable.locked) {
        await writable.getWriter().close();
      }
    }
    return checkPasswordOnly ? UNDEFINED_VALUE : writer.getData ? writer.getData() : writable;
  }
};
function readCommonHeader(directory, dataView, offset) {
  const rawBitFlag = directory.rawBitFlag = getUint16(dataView, offset + 2);
  const encrypted = (rawBitFlag & BITFLAG_ENCRYPTED) == BITFLAG_ENCRYPTED;
  const rawLastModDate = getUint32(dataView, offset + 6);
  Object.assign(directory, {
    encrypted,
    version: getUint16(dataView, offset),
    bitFlag: {
      level: (rawBitFlag & BITFLAG_LEVEL) >> 1,
      dataDescriptor: (rawBitFlag & BITFLAG_DATA_DESCRIPTOR) == BITFLAG_DATA_DESCRIPTOR,
      languageEncodingFlag: (rawBitFlag & BITFLAG_LANG_ENCODING_FLAG) == BITFLAG_LANG_ENCODING_FLAG
    },
    rawLastModDate,
    lastModDate: getDate(rawLastModDate),
    filenameLength: getUint16(dataView, offset + 22),
    extraFieldLength: getUint16(dataView, offset + 24)
  });
}
async function readCommonFooter(fileEntry, directory, dataView, offset, localDirectory) {
  const { rawExtraField } = directory;
  const extraField = directory.extraField = /* @__PURE__ */ new Map();
  const rawExtraFieldView = getDataView(new Uint8Array(rawExtraField));
  let offsetExtraField = 0;
  try {
    while (offsetExtraField < rawExtraField.length) {
      const type = getUint16(rawExtraFieldView, offsetExtraField);
      const size = getUint16(rawExtraFieldView, offsetExtraField + 2);
      extraField.set(type, {
        type,
        data: rawExtraField.slice(offsetExtraField + 4, offsetExtraField + 4 + size)
      });
      offsetExtraField += 4 + size;
    }
  } catch (_error) {
  }
  const compressionMethod = getUint16(dataView, offset + 4);
  Object.assign(directory, {
    signature: getUint32(dataView, offset + 10),
    uncompressedSize: getUint32(dataView, offset + 18),
    compressedSize: getUint32(dataView, offset + 14)
  });
  const extraFieldZip64 = extraField.get(EXTRAFIELD_TYPE_ZIP64);
  if (extraFieldZip64) {
    readExtraFieldZip64(extraFieldZip64, directory);
    directory.extraFieldZip64 = extraFieldZip64;
  }
  const extraFieldUnicodePath = extraField.get(EXTRAFIELD_TYPE_UNICODE_PATH);
  if (extraFieldUnicodePath) {
    await readExtraFieldUnicode(extraFieldUnicodePath, PROPERTY_NAME_FILENAME, PROPERTY_NAME_RAW_FILENAME, directory, fileEntry);
    directory.extraFieldUnicodePath = extraFieldUnicodePath;
  }
  const extraFieldUnicodeComment = extraField.get(EXTRAFIELD_TYPE_UNICODE_COMMENT);
  if (extraFieldUnicodeComment) {
    await readExtraFieldUnicode(extraFieldUnicodeComment, PROPERTY_NAME_COMMENT, PROPERTY_NAME_RAW_COMMENT, directory, fileEntry);
    directory.extraFieldUnicodeComment = extraFieldUnicodeComment;
  }
  const extraFieldAES = extraField.get(EXTRAFIELD_TYPE_AES);
  if (extraFieldAES) {
    readExtraFieldAES(extraFieldAES, directory, compressionMethod);
    directory.extraFieldAES = extraFieldAES;
  } else {
    directory.compressionMethod = compressionMethod;
  }
  const extraFieldNTFS = extraField.get(EXTRAFIELD_TYPE_NTFS);
  if (extraFieldNTFS) {
    readExtraFieldNTFS(extraFieldNTFS, directory);
    directory.extraFieldNTFS = extraFieldNTFS;
  }
  const extraFieldExtendedTimestamp = extraField.get(EXTRAFIELD_TYPE_EXTENDED_TIMESTAMP);
  if (extraFieldExtendedTimestamp) {
    readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory);
    directory.extraFieldExtendedTimestamp = extraFieldExtendedTimestamp;
  }
  const extraFieldUSDZ = extraField.get(EXTRAFIELD_TYPE_USDZ);
  if (extraFieldUSDZ) {
    directory.extraFieldUSDZ = extraFieldUSDZ;
  }
}
function readExtraFieldZip64(extraFieldZip64, directory) {
  directory.zip64 = true;
  const extraFieldView = getDataView(extraFieldZip64.data);
  const missingProperties = ZIP64_PROPERTIES.filter(([propertyName, max]) => directory[propertyName] == max);
  for (let indexMissingProperty = 0, offset = 0; indexMissingProperty < missingProperties.length; indexMissingProperty++) {
    const [propertyName, max] = missingProperties[indexMissingProperty];
    if (directory[propertyName] == max) {
      const extraction = ZIP64_EXTRACTION[max];
      directory[propertyName] = extraFieldZip64[propertyName] = extraction.getValue(extraFieldView, offset);
      offset += extraction.bytes;
    } else if (extraFieldZip64[propertyName]) {
      throw new Error(ERR_EXTRAFIELD_ZIP64_NOT_FOUND);
    }
  }
}
async function readExtraFieldUnicode(extraFieldUnicode, propertyName, rawPropertyName, directory, fileEntry) {
  const extraFieldView = getDataView(extraFieldUnicode.data);
  const crc32 = new Crc32();
  crc32.append(fileEntry[rawPropertyName]);
  const dataViewSignature = getDataView(new Uint8Array(4));
  dataViewSignature.setUint32(0, crc32.get(), true);
  const signature = getUint32(extraFieldView, 1);
  Object.assign(extraFieldUnicode, {
    version: getUint8(extraFieldView, 0),
    [propertyName]: decodeText(extraFieldUnicode.data.subarray(5)),
    valid: !fileEntry.bitFlag.languageEncodingFlag && signature == getUint32(dataViewSignature, 0)
  });
  if (extraFieldUnicode.valid) {
    directory[propertyName] = extraFieldUnicode[propertyName];
    directory[propertyName + "UTF8"] = true;
  }
}
function readExtraFieldAES(extraFieldAES, directory, compressionMethod) {
  const extraFieldView = getDataView(extraFieldAES.data);
  const strength = getUint8(extraFieldView, 4);
  Object.assign(extraFieldAES, {
    vendorVersion: getUint8(extraFieldView, 0),
    vendorId: getUint8(extraFieldView, 2),
    strength,
    originalCompressionMethod: compressionMethod,
    compressionMethod: getUint16(extraFieldView, 5)
  });
  directory.compressionMethod = extraFieldAES.compressionMethod;
}
function readExtraFieldNTFS(extraFieldNTFS, directory) {
  const extraFieldView = getDataView(extraFieldNTFS.data);
  let offsetExtraField = 4;
  let tag1Data;
  try {
    while (offsetExtraField < extraFieldNTFS.data.length && !tag1Data) {
      const tagValue = getUint16(extraFieldView, offsetExtraField);
      const attributeSize = getUint16(extraFieldView, offsetExtraField + 2);
      if (tagValue == EXTRAFIELD_TYPE_NTFS_TAG1) {
        tag1Data = extraFieldNTFS.data.slice(offsetExtraField + 4, offsetExtraField + 4 + attributeSize);
      }
      offsetExtraField += 4 + attributeSize;
    }
  } catch (_error) {
  }
  try {
    if (tag1Data && tag1Data.length == 24) {
      const tag1View = getDataView(tag1Data);
      const rawLastModDate = tag1View.getBigUint64(0, true);
      const rawLastAccessDate = tag1View.getBigUint64(8, true);
      const rawCreationDate = tag1View.getBigUint64(16, true);
      Object.assign(extraFieldNTFS, {
        rawLastModDate,
        rawLastAccessDate,
        rawCreationDate
      });
      const lastModDate = getDateNTFS(rawLastModDate);
      const lastAccessDate = getDateNTFS(rawLastAccessDate);
      const creationDate = getDateNTFS(rawCreationDate);
      const extraFieldData = { lastModDate, lastAccessDate, creationDate };
      Object.assign(extraFieldNTFS, extraFieldData);
      Object.assign(directory, extraFieldData);
    }
  } catch (_error) {
  }
}
function readExtraFieldExtendedTimestamp(extraFieldExtendedTimestamp, directory, localDirectory) {
  const extraFieldView = getDataView(extraFieldExtendedTimestamp.data);
  const flags = getUint8(extraFieldView, 0);
  const timeProperties = [];
  const timeRawProperties = [];
  if (localDirectory) {
    if ((flags & 1) == 1) {
      timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
    }
    if ((flags & 2) == 2) {
      timeProperties.push(PROPERTY_NAME_LAST_ACCESS_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_LAST_ACCESS_DATE);
    }
    if ((flags & 4) == 4) {
      timeProperties.push(PROPERTY_NAME_CREATION_DATE);
      timeRawProperties.push(PROPERTY_NAME_RAW_CREATION_DATE);
    }
  } else if (extraFieldExtendedTimestamp.data.length >= 5) {
    timeProperties.push(PROPERTY_NAME_LAST_MODIFICATION_DATE);
    timeRawProperties.push(PROPERTY_NAME_RAW_LAST_MODIFICATION_DATE);
  }
  let offset = 1;
  timeProperties.forEach((propertyName, indexProperty) => {
    if (extraFieldExtendedTimestamp.data.length >= offset + 4) {
      const time = getUint32(extraFieldView, offset);
      directory[propertyName] = extraFieldExtendedTimestamp[propertyName] = new Date(time * 1e3);
      const rawPropertyName = timeRawProperties[indexProperty];
      extraFieldExtendedTimestamp[rawPropertyName] = time;
    }
    offset += 4;
  });
}
async function seekSignature(reader, signature, startOffset, minimumBytes, maximumLength) {
  const signatureArray = new Uint8Array(4);
  const signatureView = getDataView(signatureArray);
  setUint32(signatureView, 0, signature);
  const maximumBytes = minimumBytes + maximumLength;
  return await seek(minimumBytes) || await seek(Math.min(maximumBytes, startOffset));
  async function seek(length) {
    const offset = startOffset - length;
    const bytes = await readUint8Array(reader, offset, length);
    for (let indexByte = bytes.length - minimumBytes; indexByte >= 0; indexByte--) {
      if (bytes[indexByte] == signatureArray[0] && bytes[indexByte + 1] == signatureArray[1] && bytes[indexByte + 2] == signatureArray[2] && bytes[indexByte + 3] == signatureArray[3]) {
        return {
          offset: offset + indexByte,
          buffer: bytes.slice(indexByte, indexByte + minimumBytes).buffer
        };
      }
    }
  }
}
function getOptionValue(zipReader, options, name) {
  return options[name] === UNDEFINED_VALUE ? zipReader.options[name] : options[name];
}
function getDate(timeRaw) {
  const date = (timeRaw & 4294901760) >> 16, time = timeRaw & 65535;
  try {
    return new Date(1980 + ((date & 65024) >> 9), ((date & 480) >> 5) - 1, date & 31, (time & 63488) >> 11, (time & 2016) >> 5, (time & 31) * 2, 0);
  } catch (_error) {
  }
}
function getDateNTFS(timeRaw) {
  return new Date(Number(timeRaw / BigInt(1e4) - BigInt(116444736e5)));
}
function getUint8(view, offset) {
  return view.getUint8(offset);
}
function getUint16(view, offset) {
  return view.getUint16(offset, true);
}
function getUint32(view, offset) {
  return view.getUint32(offset, true);
}
function getBigUint64(view, offset) {
  return Number(view.getBigUint64(offset, true));
}
function setUint32(view, offset, value) {
  view.setUint32(offset, value, true);
}
function getDataView(array) {
  return new DataView(array.buffer);
}

// node_modules/@zip.js/zip.js/lib/core/zip-writer.js
var EXTRAFIELD_DATA_AES = new Uint8Array([7, 0, 2, 0, 65, 69, 3, 0, 0]);

// node_modules/@zip.js/zip.js/lib/zip-fs.js
var import_meta = {};
var baseURL;
try {
  baseURL = import_meta.url;
} catch (_error) {
}
configure({ baseURL });
e(configure);

// node_modules/@zip.js/zip.js/index.js
configure({ Deflate: ZipDeflate, Inflate: ZipInflate });

// src/fetchHelper.ts
var FetchHelper = class {
  constructor(app) {
    this.unzip = async (zipFile) => {
      const blob = new Blob(
        [await this.app.vault.adapter.readBinary(zipFile)],
        {
          type: "octet/stream"
        }
      );
      const entries = await new ZipReader(
        new BlobReader(blob)
      ).getEntries();
      const basePath = (0, import_obsidian2.normalizePath)(
        [
          this.app.vault.configDir,
          "plugins",
          "click-clack",
          "resources"
        ].join("/")
      );
      this.checkOrCreateFolder(basePath);
      const folders = entries.filter((e2) => e2.directory);
      folders.forEach(
        async (e2) => this.checkOrCreateFolder([basePath, e2.filename].join("/"))
      );
      const files = entries.filter((e2) => !e2.directory);
      files.forEach(async (e2) => {
        if (await this.app.vault.adapter.exists(
          [basePath, e2.filename].join("/")
        ))
          return;
        if (!e2 || !e2.getData)
          return;
        await this.app.vault.adapter.writeBinary(
          [basePath, e2.filename].join("/"),
          await (await e2.getData(new BlobWriter("audio/wav"), {})).arrayBuffer()
        );
      });
    };
    this.checkOrCreateFolder = async (name) => {
      if (await this.app.vault.adapter.exists(name))
        return;
      await this.app.vault.adapter.mkdir(name);
    };
    this.checkOrDownload = async () => {
      const resourcePath = (0, import_obsidian2.normalizePath)(
        [
          this.app.vault.configDir,
          "plugins",
          "click-clack",
          "resources"
        ].join("/")
      );
      const zipPath = (0, import_obsidian2.normalizePath)(
        [
          this.app.vault.configDir,
          "plugins",
          "click-clack",
          "resources.zip"
        ].join("/")
      );
      this.checkOrCreateFolder(resourcePath);
      if (await this.app.vault.adapter.exists(zipPath)) {
        this.unzip(zipPath);
      } else {
        await this.download("resources.zip", zipPath);
        this.unzip(zipPath);
      }
    };
    this.download = async (name, localPath) => {
      new import_obsidian2.Notice(`Click Clack: Downloading ${name}!`, 5e3);
      try {
        await this.fetchAsset(name, localPath);
        new import_obsidian2.Notice(
          `Click Clack: Resource ${name} successfully downloaded! \u2714\uFE0F`,
          5e3
        );
      } catch (error) {
        new import_obsidian2.Notice(`Click Clack: Failed to fetch ${name}: ${error} \u274C`);
        throw Error(
          `Failed to fetch resource ${name} from GitHub release.`
        );
      }
    };
    this.fetchAsset = async (target, localPath) => {
      var _a, _b;
      const assetInfo = await (0, import_obsidian2.requestUrl)(
        `https://api.github.com/repos/acylation/obsidian-click-clack/releases/tags/${(_b = (_a = this.app.plugins.getPlugin("click-clack")) == null ? void 0 : _a.manifest.version) != null ? _b : "0.1.0"}`
      ).json;
      const asset = assetInfo.assets.find(
        (a) => a.name == target
      );
      if (asset === void 0)
        throw Error("Could not find the online asset!");
      const data = await (0, import_obsidian2.requestUrl)({
        url: asset.url,
        headers: { Accept: "application/octet-stream" }
      }).arrayBuffer;
      await this.app.vault.adapter.writeBinary(localPath, data);
    };
    this.app = app;
  }
};

// src/SettingTab.ts
var ClickClackSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
    this.fetchHelper = new FetchHelper(app);
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName(i18n.t("settings.toggle-sound.name")).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.enabled).onChange(async (value) => {
        this.plugin.settings.enabled = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName(i18n.t("settings.volume.name")).setDesc(i18n.t("settings.volume.desc")).addSlider((slider) => {
      var _a;
      slider.setLimits(0, 100, 1).setValue((_a = this.plugin.settings.volumn) != null ? _a : 100).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.volumn = value;
        Object.keys(this.plugin.sounds).forEach(
          (k) => this.plugin.sounds[k].volume(
            value / 100
          )
        );
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian3.Setting(containerEl).setName(i18n.t("settings.resource")).setHeading();
    const schemeSetting = new import_obsidian3.Setting(containerEl).setName(i18n.t("settings.scheme.name")).addExtraButton((button) => {
      button.setIcon("refresh-cw").onClick(async () => {
        dropdown.selectEl.empty();
        dropdown.addOptions({
          default: i18n.t("settings.scheme.default")
        }).addOptions(
          await this.plugin.schemeHelper.getInstalledSchemes()
        ).setValue(this.plugin.settings.activeScheme.id);
      });
    });
    const dropdown = new import_obsidian3.DropdownComponent(schemeSetting.controlEl);
    dropdown.addOptions({ default: i18n.t("settings.scheme.default") }).addOptions(await this.plugin.schemeHelper.getInstalledSchemes()).setValue(this.plugin.settings.activeScheme.id).onChange(async (value) => {
      var _a;
      const scheme = (_a = await this.plugin.schemeHelper.getScheme(value)) != null ? _a : defaultScheme;
      this.plugin.settings.activeScheme = scheme;
      this.plugin.sounds = await this.plugin.schemeHelper.loadScheme(
        scheme
      );
      await this.plugin.saveSettings();
    });
    new import_obsidian3.Setting(containerEl).setName(i18n.t("settings.download.name")).setDesc(i18n.t("settings.download.desc")).addButton(
      (button) => button.setCta().setButtonText(i18n.t("settings.download.button")).setIcon("download").onClick(async () => {
        await this.fetchHelper.checkOrDownload();
      })
    );
  }
};

// src/schemeHelper.ts
var import_obsidian4 = require("obsidian");
var import_howler2 = __toESM(require_howler());
var SchemeHelper = class {
  constructor(app) {
    this.app = app;
  }
  async getBase64URL(path) {
    const data = await new Blob(
      [await this.app.vault.adapter.readBinary(path)],
      {
        type: "audio/wav"
      }
    ).arrayBuffer();
    const b64 = btoa(String.fromCharCode(...new Uint8Array(data)));
    return "data:audio/wav;base64," + b64;
  }
  async loadScheme(scheme) {
    if (scheme.id === "default")
      return defaultSounds;
    const keyStr = await this.getBase64URL(scheme.sounds.key);
    const key2Str = await this.getBase64URL(scheme.sounds.key2);
    const enterStr = await this.getBase64URL(scheme.sounds.enter);
    const spaceStr = await this.getBase64URL(scheme.sounds.space);
    const deleteStr = await this.getBase64URL(scheme.sounds.delete);
    const sounds = {
      key: new import_howler2.Howl({ src: keyStr, preload: true }),
      key2: new import_howler2.Howl({ src: key2Str, preload: true }),
      enter: new import_howler2.Howl({ src: enterStr, preload: true }),
      space: new import_howler2.Howl({ src: spaceStr, preload: true }),
      delete: new import_howler2.Howl({ src: deleteStr, preload: true })
    };
    return sounds;
  }
  async getScheme(name) {
    const schemePath = (0, import_obsidian4.normalizePath)(
      [
        this.app.vault.configDir,
        "plugins",
        "click-clack",
        "resources",
        name
      ].join("/")
    );
    const manifestPath = (0, import_obsidian4.normalizePath)(
      [schemePath, "manifest.json"].join("/")
    );
    if (await this.app.vault.adapter.exists(manifestPath)) {
      const manifest = JSON.parse(
        await this.app.vault.adapter.read(manifestPath)
      );
      return {
        id: manifest["id"],
        caption: manifest["caption"],
        sounds: {
          key: [schemePath, manifest["key"]].join("/"),
          key2: [schemePath, manifest["key2"]].join("/"),
          space: [schemePath, manifest["space"]].join("/"),
          enter: [schemePath, manifest["enter"]].join("/"),
          delete: [schemePath, manifest["delete"]].join(
            "/"
          )
        }
      };
    }
  }
  async getInstalledSchemes() {
    const resourcePath = (0, import_obsidian4.normalizePath)(
      [
        this.app.vault.configDir,
        "plugins",
        "click-clack",
        "resources"
      ].join("/")
    );
    if (!await this.app.vault.adapter.exists(resourcePath))
      return;
    const paths = await this.app.vault.adapter.list(resourcePath);
    const schemes = await Promise.all(
      paths.folders.map(async (f) => {
        const manifestPath = (0, import_obsidian4.normalizePath)(
          [f, "manifest.json"].join("/")
        );
        if (await this.app.vault.adapter.exists(manifestPath)) {
          const manifest = JSON.parse(
            await this.app.vault.adapter.read(manifestPath)
          );
          return [
            manifest["id"],
            manifest["caption"]
          ];
        }
        return [
          f,
          f.split("-").map((s) => s[0].toUpperCase() + s.substring(1)).join(" ")
        ];
      })
    );
    return Object.fromEntries(schemes);
  }
};

// src/main.ts
var ClickClackPlugin = class extends import_obsidian5.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    this.sounds = defaultSounds;
    this.schemeHelper = new SchemeHelper(app);
  }
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new ClickClackSettingTab(this.app, this));
    this.sounds = await this.schemeHelper.loadScheme(
      this.settings.activeScheme
    );
    this.registerDomEvent(
      this.app.workspace.containerEl,
      "keydown",
      (evt) => {
        var _a;
        if (!this.settings.enabled)
          return;
        if (evt.ctrlKey)
          return;
        if (evt.metaKey)
          return;
        if (evt.altKey && !evt.ctrlKey && !evt.metaKey)
          return;
        (_a = this.sounds[DEFAULT_MAP[evt.code]]) == null ? void 0 : _a.play();
      }
    );
    this.addCommand({
      id: "enable click clack sound",
      name: "enable click clack sound",
      checkCallback: (checking) => {
        if (checking)
          return !this.settings.enabled;
        this.toggleSound(true);
      }
    });
    this.addCommand({
      id: "disable click clack sound",
      name: "disable click clack sound",
      checkCallback: (checking) => {
        if (checking)
          return this.settings.enabled;
        this.toggleSound(false);
      }
    });
  }
  onunload() {
    this.unloadSounds();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS_V1,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async toggleSound(targetState) {
    this.settings.enabled = targetState;
    await this.saveSettings();
  }
  async refreshSounds() {
    this.sounds = await this.schemeHelper.loadScheme(
      this.settings.activeScheme
    );
  }
  stopSounds() {
    for (const key in this.sounds) {
      this.sounds[key].stop();
    }
  }
  unloadSounds() {
    for (const key in this.sounds) {
      this.sounds[key].unload();
    }
  }
};
/*! Bundled license information:

howler/dist/howler.js:
  (*!
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
  (*!
   *  Spatial Plugin - Adds support for stereo and 3D audio where Web Audio is supported.
   *  
   *  howler.js v2.2.3
   *  howlerjs.com
   *
   *  (c) 2013-2020, James Simpson of GoldFire Studios
   *  goldfirestudios.com
   *
   *  MIT License
   *)
*/
