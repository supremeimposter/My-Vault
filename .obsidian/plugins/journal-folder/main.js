/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// src/plugin/journal-folder-plugin.ts
var journal_folder_plugin_exports = {};
__export(journal_folder_plugin_exports, {
  default: () => JournalFolderPlugin
});
module.exports = __toCommonJS(journal_folder_plugin_exports);
var import_obsidian4 = require("obsidian");

// src/plugin/plugin-feature-set.ts
var _pluginFeatures;
var PluginFeatureSet = class {
  constructor() {
    __privateAdd(this, _pluginFeatures, []);
    this.addFeature = (feature) => {
      __privateGet(this, _pluginFeatures).push(feature);
      return this;
    };
    this.load = async () => {
      for (const feature of __privateGet(this, _pluginFeatures)) {
        try {
          await feature.load();
        } catch (e) {
          console.error(e);
        }
      }
    };
    this.unload = () => {
      __privateGet(this, _pluginFeatures).forEach((feature) => {
        try {
          feature.unload();
        } catch (e) {
          console.error(e);
        }
      });
    };
    this.useSettings = (settings) => {
      __privateGet(this, _pluginFeatures).forEach((feature) => {
        try {
          feature.useSettings({ ...settings });
        } catch (e) {
          console.error(e);
        }
      });
    };
    this.onExternalSettingsChange = () => {
      __privateGet(this, _pluginFeatures).forEach((feature) => {
        try {
          feature.onExternalSettingsChange();
        } catch (e) {
          console.error(e);
        }
      });
    };
  }
};
_pluginFeatures = new WeakMap();

// node_modules/esm-env/prod-browser.js
var DEV = false;

// node_modules/svelte/src/internal/client/utils.js
var is_array = Array.isArray;
var array_from = Array.from;
var object_keys = Object.keys;
var is_frozen = Object.isFrozen;
var define_property = Object.defineProperty;
var get_descriptor = Object.getOwnPropertyDescriptor;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
var get_prototype_of = Object.getPrototypeOf;
var map_prototype = Map.prototype;
var map_set_method = map_prototype.set;
var map_get_method = map_prototype.get;
function is_function(thing) {
  return typeof thing === "function";
}

// node_modules/svelte/src/internal/client/constants.js
var DERIVED = 1 << 1;
var EFFECT = 1 << 2;
var RENDER_EFFECT = 1 << 3;
var BLOCK_EFFECT = 1 << 4;
var BRANCH_EFFECT = 1 << 5;
var ROOT_EFFECT = 1 << 6;
var UNOWNED = 1 << 7;
var DISCONNECTED = 1 << 8;
var CLEAN = 1 << 9;
var DIRTY = 1 << 10;
var MAYBE_DIRTY = 1 << 11;
var INERT = 1 << 12;
var DESTROYED = 1 << 13;
var EFFECT_RAN = 1 << 14;
var EFFECT_TRANSPARENT = 1 << 15;
var LEGACY_DERIVED_PROP = 1 << 16;
var INSPECT_EFFECT = 1 << 17;
var STATE_SYMBOL = Symbol("$state");
var STATE_FROZEN_SYMBOL = Symbol("$state.frozen");
var LOADING_ATTR_SYMBOL = Symbol("");

// node_modules/svelte/src/internal/client/reactivity/equality.js
function equals(value) {
  return value === this.v;
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a !== null && typeof a === "object" || typeof a === "function";
}
function safe_equals(value) {
  return !safe_not_equal(value, this.v);
}

// node_modules/svelte/src/constants.js
var EACH_ITEM_REACTIVE = 1;
var EACH_INDEX_REACTIVE = 1 << 1;
var EACH_KEYED = 1 << 2;
var EACH_IS_CONTROLLED = 1 << 3;
var EACH_IS_ANIMATED = 1 << 4;
var EACH_IS_STRICT_EQUALS = 1 << 6;
var PROPS_IS_IMMUTABLE = 1;
var PROPS_IS_RUNES = 1 << 1;
var PROPS_IS_UPDATED = 1 << 2;
var PROPS_IS_LAZY_INITIAL = 1 << 3;
var TRANSITION_OUT = 1 << 1;
var TRANSITION_GLOBAL = 1 << 2;
var TEMPLATE_FRAGMENT = 1;
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var HYDRATION_START = "[";
var HYDRATION_END = "]";
var HYDRATION_ANCHOR = "";
var HYDRATION_END_ELSE = `${HYDRATION_END}!`;
var HYDRATION_ERROR = {};
var ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;
var UNINITIALIZED = Symbol();
var PassiveDelegatedEvents = ["touchstart", "touchmove", "touchend"];

// node_modules/svelte/src/internal/client/errors.js
function effect_update_depth_exceeded() {
  if (DEV) {
    const error = new Error(`effect_update_depth_exceeded
Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("effect_update_depth_exceeded");
  }
}
function hydration_failed() {
  if (DEV) {
    const error = new Error(`hydration_failed
Failed to hydrate the application`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("hydration_failed");
  }
}
function props_invalid_value(key) {
  if (DEV) {
    const error = new Error(`props_invalid_value
Cannot do \`bind:${key}={undefined}\` when \`${key}\` has a fallback value`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("props_invalid_value");
  }
}
function rune_outside_svelte(rune) {
  if (DEV) {
    const error = new Error(`rune_outside_svelte
The \`${rune}\` rune is only available inside \`.svelte\` and \`.svelte.js/ts\` files`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("rune_outside_svelte");
  }
}
function state_prototype_fixed() {
  if (DEV) {
    const error = new Error(`state_prototype_fixed
Cannot set prototype of \`$state\` object`);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("state_prototype_fixed");
  }
}
function state_unsafe_mutation() {
  if (DEV) {
    const error = new Error(`state_unsafe_mutation
Updating state inside a derived is forbidden. If the value should not be reactive, declare it without \`$state\``);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("state_unsafe_mutation");
  }
}

// node_modules/svelte/src/internal/client/reactivity/sources.js
function source(v) {
  return {
    f: 0,
    // TODO ideally we could skip this altogether, but it causes type errors
    v,
    reactions: null,
    equals,
    version: 0
  };
}
function mutable_source(initial_value) {
  var _a, _b;
  const s = source(initial_value);
  s.equals = safe_equals;
  if (current_component_context !== null && current_component_context.l !== null) {
    ((_b = (_a = current_component_context.l).s) != null ? _b : _a.s = []).push(s);
  }
  return s;
}
function set(source2, value) {
  var initialized = source2.v !== UNINITIALIZED;
  if (initialized && current_reaction !== null && is_runes() && (current_reaction.f & DERIVED) !== 0) {
    state_unsafe_mutation();
  }
  if (!source2.equals(value)) {
    source2.v = value;
    source2.version = increment_version();
    mark_reactions(source2, DIRTY, true);
    if (is_runes() && initialized && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0) {
      if (current_dependencies !== null && current_dependencies.includes(source2)) {
        set_signal_status(current_effect, DIRTY);
        schedule_effect(current_effect);
      } else {
        if (current_untracked_writes === null) {
          set_current_untracked_writes([source2]);
        } else {
          current_untracked_writes.push(source2);
        }
      }
    }
    if (DEV) {
      for (const effect2 of inspect_effects) {
        execute_effect(effect2);
      }
      inspect_effects.clear();
    }
  }
  return value;
}

// node_modules/svelte/src/internal/client/dom/reconciler.js
function create_fragment_from_html(html2) {
  var elem = document.createElement("template");
  elem.innerHTML = html2;
  return elem.content;
}
function remove(current) {
  if (is_array(current)) {
    for (var i = 0; i < current.length; i++) {
      var node = current[i];
      if (node.isConnected) {
        node.remove();
      }
    }
  } else if (current.isConnected) {
    current.remove();
  }
}

// node_modules/svelte/src/internal/client/reactivity/effects.js
function push_effect(effect2, parent_effect) {
  var parent_last = parent_effect.last;
  if (parent_last === null) {
    parent_effect.last = parent_effect.first = effect2;
  } else {
    parent_last.next = effect2;
    effect2.prev = parent_last;
    parent_effect.last = effect2;
  }
}
function create_effect(type, fn, sync) {
  var is_root = (type & ROOT_EFFECT) !== 0;
  var effect2 = {
    ctx: current_component_context,
    deps: null,
    dom: null,
    f: type | DIRTY,
    first: null,
    fn,
    last: null,
    next: null,
    parent: is_root ? null : current_effect,
    prev: null,
    teardown: null,
    transitions: null
  };
  if (DEV) {
    effect2.component_function = dev_current_component_function;
  }
  if (sync) {
    var previously_flushing_effect = is_flushing_effect;
    try {
      set_is_flushing_effect(true);
      execute_effect(effect2);
      effect2.f |= EFFECT_RAN;
    } finally {
      set_is_flushing_effect(previously_flushing_effect);
    }
  } else if (fn !== null) {
    schedule_effect(effect2);
  }
  var inert = sync && effect2.deps === null && effect2.first === null && effect2.dom === null && effect2.teardown === null;
  if (!inert && !is_root) {
    if (current_effect !== null) {
      push_effect(effect2, current_effect);
    }
    if (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {
      push_effect(effect2, current_reaction);
    }
  }
  return effect2;
}
function effect_root(fn) {
  const effect2 = create_effect(ROOT_EFFECT, fn, true);
  return () => {
    destroy_effect(effect2);
  };
}
function effect(fn) {
  return create_effect(EFFECT, fn, false);
}
function render_effect(fn) {
  return create_effect(RENDER_EFFECT, fn, true);
}
function template_effect(fn) {
  if (DEV) {
    define_property(fn, "name", {
      value: "{expression}"
    });
  }
  return render_effect(fn);
}
function block(fn, flags = 0) {
  return create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);
}
function branch(fn) {
  return create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true);
}
function execute_effect_teardown(effect2) {
  var teardown2 = effect2.teardown;
  if (teardown2 !== null) {
    const previously_destroying_effect = is_destroying_effect;
    const previous_reaction = current_reaction;
    set_is_destroying_effect(true);
    set_current_reaction(null);
    try {
      teardown2.call(null);
    } finally {
      set_is_destroying_effect(previously_destroying_effect);
      set_current_reaction(previous_reaction);
    }
  }
}
function destroy_effect(effect2, remove_dom = true) {
  var dom = effect2.dom;
  if (dom !== null && remove_dom) {
    remove(dom);
  }
  destroy_effect_children(effect2, remove_dom);
  remove_reactions(effect2, 0);
  set_signal_status(effect2, DESTROYED);
  if (effect2.transitions) {
    for (const transition2 of effect2.transitions) {
      transition2.stop();
    }
  }
  execute_effect_teardown(effect2);
  var parent = effect2.parent;
  if (parent !== null && (effect2.f & BRANCH_EFFECT) !== 0 && parent.first !== null) {
    unlink_effect(effect2);
  }
  effect2.next = effect2.prev = effect2.teardown = effect2.ctx = effect2.dom = effect2.deps = effect2.parent = effect2.fn = null;
}
function unlink_effect(effect2) {
  var parent = effect2.parent;
  var prev = effect2.prev;
  var next = effect2.next;
  if (prev !== null)
    prev.next = next;
  if (next !== null)
    next.prev = prev;
  if (parent !== null) {
    if (parent.first === effect2)
      parent.first = next;
    if (parent.last === effect2)
      parent.last = prev;
  }
}
function pause_effect(effect2, callback) {
  var transitions = [];
  pause_children(effect2, transitions, true);
  run_out_transitions(transitions, () => {
    destroy_effect(effect2);
    if (callback)
      callback();
  });
}
function run_out_transitions(transitions, fn) {
  var remaining = transitions.length;
  if (remaining > 0) {
    var check = () => --remaining || fn();
    for (var transition2 of transitions) {
      transition2.out(check);
    }
  } else {
    fn();
  }
}
function pause_children(effect2, transitions, local) {
  if ((effect2.f & INERT) !== 0)
    return;
  effect2.f ^= INERT;
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transitions.push(transition2);
      }
    }
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    pause_children(child2, transitions, transparent ? local : false);
    child2 = sibling2;
  }
}
function resume_effect(effect2) {
  resume_children(effect2, true);
}
function resume_children(effect2, local) {
  if ((effect2.f & INERT) === 0)
    return;
  effect2.f ^= INERT;
  if (check_dirtiness(effect2)) {
    execute_effect(effect2);
  }
  var child2 = effect2.first;
  while (child2 !== null) {
    var sibling2 = child2.next;
    var transparent = (child2.f & EFFECT_TRANSPARENT) !== 0 || (child2.f & BRANCH_EFFECT) !== 0;
    resume_children(child2, transparent ? local : false);
    child2 = sibling2;
  }
  if (effect2.transitions !== null) {
    for (const transition2 of effect2.transitions) {
      if (transition2.is_global || local) {
        transition2.in();
      }
    }
  }
}

// node_modules/svelte/src/internal/client/warnings.js
var bold = "font-weight: bold";
var normal = "font-weight: normal";
function hydration_attribute_changed(attribute, html2, value) {
  if (DEV) {
    console.warn(`%c[svelte] hydration_attribute_changed
%cThe \`${attribute}\` attribute on \`${html2}\` changed its value between server and client renders. The client value, \`${value}\`, will be ignored in favour of the server value`, bold, normal);
  } else {
    console.warn("hydration_attribute_changed");
  }
}
function hydration_mismatch(location) {
  if (DEV) {
    console.warn(`%c[svelte] hydration_mismatch
%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : "Hydration failed because the initial UI does not match what was rendered on the server"}`, bold, normal);
  } else {
    console.warn("hydration_mismatch");
  }
}
function lifecycle_double_unmount() {
  if (DEV) {
    console.warn(`%c[svelte] lifecycle_double_unmount
%cTried to unmount a component that was not mounted`, bold, normal);
  } else {
    console.warn("lifecycle_double_unmount");
  }
}
function ownership_invalid_mutation(component2, owner) {
  if (DEV) {
    console.warn(`%c[svelte] ownership_invalid_mutation
%c${component2 ? `${component2} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \`bind:\`, or use a callback instead` : "Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead"}`, bold, normal);
  } else {
    console.warn("ownership_invalid_mutation");
  }
}
function state_proxy_equality_mismatch(operator) {
  if (DEV) {
    console.warn(`%c[svelte] state_proxy_equality_mismatch
%cReactive \`$state(...)\` proxies and the values they proxy have different identities. Because of this, comparisons with \`${operator}\` will produce unexpected results. Consider using \`$state.is(a, b)\` instead`, bold, normal);
  } else {
    console.warn("state_proxy_equality_mismatch");
  }
}

// node_modules/svelte/src/internal/client/dev/ownership.js
var boundaries = {};
var chrome_pattern = /at (?:.+ \()?(.+):(\d+):(\d+)\)?$/;
var firefox_pattern = /@(.+):(\d+):(\d+)$/;
function get_stack() {
  var _a;
  const stack = new Error().stack;
  if (!stack)
    return null;
  const entries = [];
  for (const line of stack.split("\n")) {
    let match = (_a = chrome_pattern.exec(line)) != null ? _a : firefox_pattern.exec(line);
    if (match) {
      entries.push({
        file: match[1],
        line: +match[2],
        column: +match[3]
      });
    }
  }
  return entries;
}
function get_component() {
  var _a;
  const stack = (_a = get_stack()) == null ? void 0 : _a.slice(4);
  if (!stack)
    return null;
  for (let i = 0; i < stack.length; i++) {
    const entry = stack[i];
    const modules = boundaries[entry.file];
    if (!modules) {
      if (i === 0)
        return null;
      continue;
    }
    for (const module2 of modules) {
      if (module2.start.line < entry.line && module2.end.line > entry.line) {
        return module2.component;
      }
    }
  }
  return null;
}
var ADD_OWNER = Symbol("ADD_OWNER");
function widen_ownership(from, to) {
  if (to.owners === null) {
    return;
  }
  while (from) {
    if (from.owners === null) {
      to.owners = null;
      break;
    }
    for (const owner of from.owners) {
      to.owners.add(owner);
    }
    from = from.parent;
  }
}
function has_owner(metadata, component2) {
  if (metadata.owners === null) {
    return true;
  }
  return metadata.owners.has(component2) || metadata.parent !== null && has_owner(metadata.parent, component2);
}
function get_owner(metadata) {
  var _a, _b;
  return (_b = (_a = metadata == null ? void 0 : metadata.owners) == null ? void 0 : _a.values().next().value) != null ? _b : get_owner(
    /** @type {import('#client').ProxyMetadata} */
    metadata.parent
  );
}
function check_ownership(metadata) {
  const component2 = get_component();
  if (component2 && !has_owner(metadata, component2)) {
    let original = get_owner(metadata);
    if (original.filename !== component2.filename) {
      ownership_invalid_mutation(component2.filename, original.filename);
    } else {
      ownership_invalid_mutation();
    }
  }
}

// node_modules/svelte/src/internal/client/proxy.js
function proxy(value, immutable = true, parent = null, prev) {
  var _a, _b;
  if (typeof value === "object" && value != null && !is_frozen(value) && !(STATE_FROZEN_SYMBOL in value)) {
    if (STATE_SYMBOL in value) {
      const metadata = (
        /** @type {import('#client').ProxyMetadata<T>} */
        value[STATE_SYMBOL]
      );
      if (metadata.t === value || metadata.p === value) {
        if (DEV) {
          widen_ownership(metadata, metadata);
          metadata.parent = parent;
        }
        return metadata.p;
      }
    }
    const prototype = get_prototype_of(value);
    if (prototype === object_prototype || prototype === array_prototype) {
      const proxy2 = new Proxy(value, state_proxy_handler);
      define_property(value, STATE_SYMBOL, {
        value: (
          /** @type {import('#client').ProxyMetadata} */
          {
            s: /* @__PURE__ */ new Map(),
            v: source(0),
            a: is_array(value),
            i: immutable,
            p: proxy2,
            t: value
          }
        ),
        writable: true,
        enumerable: false
      });
      if (DEV) {
        value[STATE_SYMBOL].parent = parent;
        if (prev) {
          const prev_owners = (_b = (_a = prev == null ? void 0 : prev.v) == null ? void 0 : _a[STATE_SYMBOL]) == null ? void 0 : _b.owners;
          value[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;
        } else {
          value[STATE_SYMBOL].owners = parent === null ? current_component_context !== null ? /* @__PURE__ */ new Set([current_component_context.function]) : null : /* @__PURE__ */ new Set();
        }
      }
      return proxy2;
    }
  }
  return value;
}
function update_version(signal, d = 1) {
  set(signal, signal.v + d);
}
var state_proxy_handler = {
  defineProperty(target, prop2, descriptor) {
    if (descriptor.value) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop2);
      if (s !== void 0)
        set(s, proxy(descriptor.value, metadata.i, metadata));
    }
    return Reflect.defineProperty(target, prop2, descriptor);
  },
  deleteProperty(target, prop2) {
    const metadata = target[STATE_SYMBOL];
    const s = metadata.s.get(prop2);
    const is_array2 = metadata.a;
    const boolean = delete target[prop2];
    if (is_array2 && boolean) {
      const ls = metadata.s.get("length");
      const length = target.length - 1;
      if (ls !== void 0 && ls.v !== length) {
        set(ls, length);
      }
    }
    if (s !== void 0)
      set(s, UNINITIALIZED);
    if (boolean) {
      update_version(metadata.v);
    }
    return boolean;
  },
  get(target, prop2, receiver) {
    var _a;
    if (prop2 === STATE_SYMBOL) {
      return Reflect.get(target, STATE_SYMBOL);
    }
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop2);
    if (s === void 0 && (!(prop2 in target) || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {
      s = (metadata.i ? source : mutable_source)(proxy(target[prop2], metadata.i, metadata));
      metadata.s.set(prop2, s);
    }
    if (s !== void 0) {
      const value = get(s);
      return value === UNINITIALIZED ? void 0 : value;
    }
    return Reflect.get(target, prop2, receiver);
  },
  getOwnPropertyDescriptor(target, prop2) {
    const descriptor = Reflect.getOwnPropertyDescriptor(target, prop2);
    if (descriptor && "value" in descriptor) {
      const metadata = target[STATE_SYMBOL];
      const s = metadata.s.get(prop2);
      if (s) {
        descriptor.value = get(s);
      }
    }
    return descriptor;
  },
  has(target, prop2) {
    var _a;
    if (prop2 === STATE_SYMBOL) {
      return true;
    }
    const metadata = target[STATE_SYMBOL];
    const has = Reflect.has(target, prop2);
    let s = metadata.s.get(prop2);
    if (s !== void 0 || current_effect !== null && (!has || ((_a = get_descriptor(target, prop2)) == null ? void 0 : _a.writable))) {
      if (s === void 0) {
        s = (metadata.i ? source : mutable_source)(
          has ? proxy(target[prop2], metadata.i, metadata) : UNINITIALIZED
        );
        metadata.s.set(prop2, s);
      }
      const value = get(s);
      if (value === UNINITIALIZED) {
        return false;
      }
    }
    return has;
  },
  set(target, prop2, value, receiver) {
    const metadata = target[STATE_SYMBOL];
    let s = metadata.s.get(prop2);
    if (s === void 0) {
      untrack(() => receiver[prop2]);
      s = metadata.s.get(prop2);
    }
    if (s !== void 0) {
      set(s, proxy(value, metadata.i, metadata));
    }
    const is_array2 = metadata.a;
    const not_has = !(prop2 in target);
    if (DEV) {
      const prop_metadata = value == null ? void 0 : value[STATE_SYMBOL];
      if (prop_metadata && (prop_metadata == null ? void 0 : prop_metadata.parent) !== metadata) {
        widen_ownership(metadata, prop_metadata);
      }
      check_ownership(metadata);
    }
    if (is_array2 && prop2 === "length") {
      for (let i = value; i < target.length; i += 1) {
        const s2 = metadata.s.get(i + "");
        if (s2 !== void 0)
          set(s2, UNINITIALIZED);
      }
    }
    target[prop2] = value;
    if (not_has) {
      if (is_array2) {
        const ls = metadata.s.get("length");
        const length = target.length;
        if (ls !== void 0 && ls.v !== length) {
          set(ls, length);
        }
      }
      update_version(metadata.v);
    }
    return true;
  },
  ownKeys(target) {
    const metadata = target[STATE_SYMBOL];
    get(metadata.v);
    return Reflect.ownKeys(target);
  }
};
if (DEV) {
  state_proxy_handler.setPrototypeOf = () => {
    state_prototype_fixed();
  };
}
function get_proxied_value(value) {
  if (value !== null && typeof value === "object" && STATE_SYMBOL in value) {
    var metadata = value[STATE_SYMBOL];
    if (metadata) {
      return metadata.p;
    }
  }
  return value;
}

// node_modules/svelte/src/internal/shared/utils.js
function run_all(arr) {
  for (var i = 0; i < arr.length; i++) {
    arr[i]();
  }
}

// node_modules/svelte/src/internal/client/dom/task.js
var is_micro_task_queued = false;
var is_idle_task_queued = false;
var current_queued_micro_tasks = [];
var current_queued_idle_tasks = [];
function process_micro_tasks() {
  is_micro_task_queued = false;
  const tasks = current_queued_micro_tasks.slice();
  current_queued_micro_tasks = [];
  run_all(tasks);
}
function process_idle_tasks() {
  is_idle_task_queued = false;
  const tasks = current_queued_idle_tasks.slice();
  current_queued_idle_tasks = [];
  run_all(tasks);
}
function queue_micro_task(fn) {
  if (!is_micro_task_queued) {
    is_micro_task_queued = true;
    queueMicrotask(process_micro_tasks);
  }
  current_queued_micro_tasks.push(fn);
}
function flush_tasks() {
  if (is_micro_task_queued) {
    process_micro_tasks();
  }
  if (is_idle_task_queued) {
    process_idle_tasks();
  }
}

// node_modules/svelte/src/internal/client/reactivity/deriveds.js
var updating_derived = false;
function derived(fn) {
  let flags = DERIVED | DIRTY;
  if (current_effect === null)
    flags |= UNOWNED;
  const signal = {
    deps: null,
    deriveds: null,
    equals,
    f: flags,
    first: null,
    fn,
    last: null,
    reactions: null,
    v: (
      /** @type {V} */
      null
    ),
    version: 0
  };
  if (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {
    var current_derived = (
      /** @type {import('#client').Derived<V>} */
      current_reaction
    );
    if (current_derived.deriveds === null) {
      current_derived.deriveds = [signal];
    } else {
      current_derived.deriveds.push(signal);
    }
  }
  return signal;
}
function derived_safe_equal(fn) {
  const signal = derived(fn);
  signal.equals = safe_equals;
  return signal;
}
function destroy_derived_children(signal) {
  destroy_effect_children(signal);
  var deriveds = signal.deriveds;
  if (deriveds !== null) {
    signal.deriveds = null;
    for (var i = 0; i < deriveds.length; i += 1) {
      destroy_derived(deriveds[i]);
    }
  }
}
function update_derived(derived2) {
  var previous_updating_derived = updating_derived;
  updating_derived = true;
  destroy_derived_children(derived2);
  var value = execute_reaction_fn(derived2);
  updating_derived = previous_updating_derived;
  var status = (current_skip_reaction || (derived2.f & UNOWNED) !== 0) && derived2.deps !== null ? MAYBE_DIRTY : CLEAN;
  set_signal_status(derived2, status);
  if (!derived2.equals(value)) {
    derived2.v = value;
    derived2.version = increment_version();
    mark_reactions(derived2, DIRTY, false);
  }
}
function destroy_derived(signal) {
  destroy_derived_children(signal);
  remove_reactions(signal, 0);
  set_signal_status(signal, DESTROYED);
  signal.first = signal.last = signal.deps = signal.reactions = // @ts-expect-error `signal.fn` cannot be `null` while the signal is alive
  signal.fn = null;
}

// node_modules/svelte/src/internal/shared/errors.js
function snippet_used_as_component() {
  if (DEV) {
    const error = new Error(`snippet_used_as_component
A snippet must be rendered with \`{@render ...}\``);
    error.name = "Svelte error";
    throw error;
  } else {
    throw new Error("snippet_used_as_component");
  }
}

// node_modules/svelte/src/internal/client/runtime.js
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var handled_errors = /* @__PURE__ */ new WeakSet();
var current_scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued2 = false;
var is_flushing_effect = false;
var is_destroying_effect = false;
function set_is_flushing_effect(value) {
  is_flushing_effect = value;
}
function set_is_destroying_effect(value) {
  is_destroying_effect = value;
}
var inspect_effects = /* @__PURE__ */ new Set();
var current_queued_root_effects = [];
var flush_count = 0;
var current_reaction = null;
function set_current_reaction(reaction) {
  current_reaction = reaction;
}
var current_effect = null;
var current_dependencies = null;
var current_dependencies_index = 0;
var current_untracked_writes = null;
function set_current_untracked_writes(value) {
  current_untracked_writes = value;
}
var current_version = 0;
var current_skip_reaction = false;
var is_signals_recorded = false;
var captured_signals = /* @__PURE__ */ new Set();
var current_component_context = null;
var dev_current_component_function = null;
function increment_version() {
  return current_version++;
}
function is_runes() {
  return current_component_context !== null && current_component_context.l === null;
}
function check_dirtiness(reaction) {
  var _a, _b;
  var flags = reaction.f;
  var is_dirty = (flags & DIRTY) !== 0;
  if (is_dirty) {
    return true;
  }
  var is_unowned = (flags & UNOWNED) !== 0;
  var is_disconnected = (flags & DISCONNECTED) !== 0;
  if ((flags & MAYBE_DIRTY) !== 0) {
    var dependencies = reaction.deps;
    if (dependencies !== null) {
      var length = dependencies.length;
      var reactions;
      for (var i = 0; i < length; i++) {
        var dependency = dependencies[i];
        if (!is_dirty && check_dirtiness(
          /** @type {import('#client').Derived} */
          dependency
        )) {
          update_derived(
            /** @type {import('#client').Derived} **/
            dependency
          );
        }
        var version = dependency.version;
        if (is_unowned) {
          if (version > /** @type {import('#client').Derived} */
          reaction.version) {
            return true;
          }
          if (!current_skip_reaction && !((_a = dependency == null ? void 0 : dependency.reactions) == null ? void 0 : _a.includes(reaction))) {
            ((_b = dependency.reactions) != null ? _b : dependency.reactions = []).push(reaction);
          }
        } else if ((reaction.f & DIRTY) !== 0) {
          return true;
        } else if (is_disconnected) {
          if (version > /** @type {import('#client').Derived} */
          reaction.version) {
            is_dirty = true;
          }
          reactions = dependency.reactions;
          if (reactions === null) {
            dependency.reactions = [reaction];
          } else if (!reactions.includes(reaction)) {
            reactions.push(reaction);
          }
        }
      }
    }
    if (!is_unowned) {
      set_signal_status(reaction, CLEAN);
    }
    if (is_disconnected) {
      reaction.f ^= DISCONNECTED;
    }
  }
  return is_dirty;
}
function handle_error(error, effect2, component_context) {
  var _a, _b;
  if (!DEV || handled_errors.has(error) || component_context === null) {
    throw error;
  }
  const component_stack = [];
  const effect_name = (_a = effect2.fn) == null ? void 0 : _a.name;
  if (effect_name) {
    component_stack.push(effect_name);
  }
  let current_context = component_context;
  while (current_context !== null) {
    var filename = (_b = current_context.function) == null ? void 0 : _b.filename;
    if (filename) {
      const file = filename.split("/").at(-1);
      component_stack.push(file);
    }
    current_context = current_context.p;
  }
  const indent = /Firefox/.test(navigator.userAgent) ? "  " : "	";
  define_property(error, "message", {
    value: error.message + `
${component_stack.map((name) => `
${indent}in ${name}`).join("")}
`
  });
  const stack = error.stack;
  if (stack) {
    const lines = stack.split("\n");
    const new_lines = [];
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (line.includes("svelte/src/internal")) {
        continue;
      }
      new_lines.push(line);
    }
    define_property(error, "stack", {
      value: error.stack + new_lines.join("\n")
    });
  }
  handled_errors.add(error);
  throw error;
}
function execute_reaction_fn(signal) {
  const previous_dependencies = current_dependencies;
  const previous_dependencies_index = current_dependencies_index;
  const previous_untracked_writes = current_untracked_writes;
  const previous_reaction = current_reaction;
  const previous_skip_reaction = current_skip_reaction;
  current_dependencies = /** @type {null | import('#client').Value[]} */
  null;
  current_dependencies_index = 0;
  current_untracked_writes = null;
  current_reaction = (signal.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? signal : null;
  current_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;
  try {
    let res = (
      /** @type {Function} */
      (0, signal.fn)()
    );
    let dependencies = (
      /** @type {import('#client').Value<unknown>[]} **/
      signal.deps
    );
    if (current_dependencies !== null) {
      let i;
      if (dependencies !== null) {
        const deps_length = dependencies.length;
        const full_current_dependencies = current_dependencies_index === 0 ? current_dependencies : dependencies.slice(0, current_dependencies_index).concat(current_dependencies);
        const current_dep_length = full_current_dependencies.length;
        const full_current_dependencies_set = current_dep_length > 16 && deps_length - current_dependencies_index > 1 ? new Set(full_current_dependencies) : null;
        for (i = current_dependencies_index; i < deps_length; i++) {
          const dependency = dependencies[i];
          if (full_current_dependencies_set !== null ? !full_current_dependencies_set.has(dependency) : !full_current_dependencies.includes(dependency)) {
            remove_reaction(signal, dependency);
          }
        }
      }
      if (dependencies !== null && current_dependencies_index > 0) {
        dependencies.length = current_dependencies_index + current_dependencies.length;
        for (i = 0; i < current_dependencies.length; i++) {
          dependencies[current_dependencies_index + i] = current_dependencies[i];
        }
      } else {
        signal.deps = /** @type {import('#client').Value<V>[]} **/
        dependencies = current_dependencies;
      }
      if (!current_skip_reaction) {
        for (i = current_dependencies_index; i < dependencies.length; i++) {
          const dependency = dependencies[i];
          const reactions = dependency.reactions;
          if (reactions === null) {
            dependency.reactions = [signal];
          } else if (reactions[reactions.length - 1] !== signal && !reactions.includes(signal)) {
            reactions.push(signal);
          }
        }
      }
    } else if (dependencies !== null && current_dependencies_index < dependencies.length) {
      remove_reactions(signal, current_dependencies_index);
      dependencies.length = current_dependencies_index;
    }
    return res;
  } finally {
    current_dependencies = previous_dependencies;
    current_dependencies_index = previous_dependencies_index;
    current_untracked_writes = previous_untracked_writes;
    current_reaction = previous_reaction;
    current_skip_reaction = previous_skip_reaction;
  }
}
function remove_reaction(signal, dependency) {
  const reactions = dependency.reactions;
  let reactions_length = 0;
  if (reactions !== null) {
    reactions_length = reactions.length - 1;
    const index2 = reactions.indexOf(signal);
    if (index2 !== -1) {
      if (reactions_length === 0) {
        dependency.reactions = null;
      } else {
        reactions[index2] = reactions[reactions_length];
        reactions.pop();
      }
    }
  }
  if (reactions_length === 0 && (dependency.f & DERIVED) !== 0) {
    set_signal_status(dependency, MAYBE_DIRTY);
    if ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {
      dependency.f ^= DISCONNECTED;
    }
    remove_reactions(
      /** @type {import('#client').Derived} **/
      dependency,
      0
    );
  }
}
function remove_reactions(signal, start_index) {
  const dependencies = signal.deps;
  if (dependencies !== null) {
    const active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);
    let i;
    for (i = start_index; i < dependencies.length; i++) {
      const dependency = dependencies[i];
      if (active_dependencies === null || !active_dependencies.includes(dependency)) {
        remove_reaction(signal, dependency);
      }
    }
  }
}
function destroy_effect_children(signal, remove_dom = true) {
  let effect2 = signal.first;
  signal.first = null;
  signal.last = null;
  var sibling2;
  while (effect2 !== null) {
    sibling2 = effect2.next;
    destroy_effect(effect2, remove_dom);
    effect2 = sibling2;
  }
}
function execute_effect(effect2) {
  var flags = effect2.f;
  if ((flags & DESTROYED) !== 0) {
    return;
  }
  set_signal_status(effect2, CLEAN);
  var component_context = effect2.ctx;
  var previous_effect = current_effect;
  var previous_component_context = current_component_context;
  current_effect = effect2;
  current_component_context = component_context;
  if (DEV) {
    var previous_component_fn = dev_current_component_function;
    dev_current_component_function = effect2.component_function;
  }
  try {
    if ((flags & BLOCK_EFFECT) === 0) {
      destroy_effect_children(effect2);
    }
    execute_effect_teardown(effect2);
    var teardown2 = execute_reaction_fn(effect2);
    effect2.teardown = typeof teardown2 === "function" ? teardown2 : null;
  } catch (error) {
    handle_error(
      /** @type {Error} */
      error,
      effect2,
      current_component_context
    );
  } finally {
    current_effect = previous_effect;
    current_component_context = previous_component_context;
    if (DEV) {
      dev_current_component_function = previous_component_fn;
    }
  }
}
function infinite_loop_guard() {
  if (flush_count > 1e3) {
    flush_count = 0;
    effect_update_depth_exceeded();
  }
  flush_count++;
}
function flush_queued_root_effects(root_effects) {
  var length = root_effects.length;
  if (length === 0) {
    return;
  }
  infinite_loop_guard();
  var previously_flushing_effect = is_flushing_effect;
  is_flushing_effect = true;
  try {
    for (var i = 0; i < length; i++) {
      var effect2 = root_effects[i];
      if (effect2.first === null && (effect2.f & BRANCH_EFFECT) === 0) {
        flush_queued_effects([effect2]);
      } else {
        var collected_effects = [];
        process_effects(effect2, collected_effects);
        flush_queued_effects(collected_effects);
      }
    }
  } finally {
    is_flushing_effect = previously_flushing_effect;
  }
}
function flush_queued_effects(effects) {
  var length = effects.length;
  if (length === 0)
    return;
  for (var i = 0; i < length; i++) {
    var effect2 = effects[i];
    if ((effect2.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect2)) {
      execute_effect(effect2);
      if (effect2.deps === null && effect2.first === null && effect2.dom === null) {
        if (effect2.teardown === null) {
          unlink_effect(effect2);
        } else {
          effect2.fn = null;
        }
      }
    }
  }
}
function process_deferred() {
  is_micro_task_queued2 = false;
  if (flush_count > 1001) {
    return;
  }
  const previous_queued_root_effects = current_queued_root_effects;
  current_queued_root_effects = [];
  flush_queued_root_effects(previous_queued_root_effects);
  if (!is_micro_task_queued2) {
    flush_count = 0;
  }
}
function schedule_effect(signal) {
  if (current_scheduler_mode === FLUSH_MICROTASK) {
    if (!is_micro_task_queued2) {
      is_micro_task_queued2 = true;
      queueMicrotask(process_deferred);
    }
  }
  var effect2 = signal;
  while (effect2.parent !== null) {
    effect2 = effect2.parent;
    var flags = effect2.f;
    if ((flags & BRANCH_EFFECT) !== 0) {
      if ((flags & CLEAN) === 0)
        return;
      set_signal_status(effect2, MAYBE_DIRTY);
    }
  }
  current_queued_root_effects.push(effect2);
}
function process_effects(effect2, collected_effects) {
  var current_effect2 = effect2.first;
  var effects = [];
  main_loop:
    while (current_effect2 !== null) {
      var flags = current_effect2.f;
      var is_active = (flags & (DESTROYED | INERT)) === 0;
      var is_branch = flags & BRANCH_EFFECT;
      var is_clean = (flags & CLEAN) !== 0;
      var child2 = current_effect2.first;
      if (is_active && (!is_branch || !is_clean)) {
        if (is_branch) {
          set_signal_status(current_effect2, CLEAN);
        }
        if ((flags & RENDER_EFFECT) !== 0) {
          if (!is_branch && check_dirtiness(current_effect2)) {
            execute_effect(current_effect2);
            child2 = current_effect2.first;
          }
          if (child2 !== null) {
            current_effect2 = child2;
            continue;
          }
        } else if ((flags & EFFECT) !== 0) {
          if (is_branch || is_clean) {
            if (child2 !== null) {
              current_effect2 = child2;
              continue;
            }
          } else {
            effects.push(current_effect2);
          }
        }
      }
      var sibling2 = current_effect2.next;
      if (sibling2 === null) {
        let parent = current_effect2.parent;
        while (parent !== null) {
          if (effect2 === parent) {
            break main_loop;
          }
          var parent_sibling = parent.next;
          if (parent_sibling !== null) {
            current_effect2 = parent_sibling;
            continue main_loop;
          }
          parent = parent.parent;
        }
      }
      current_effect2 = sibling2;
    }
  for (var i = 0; i < effects.length; i++) {
    child2 = effects[i];
    collected_effects.push(child2);
    process_effects(child2, collected_effects);
  }
}
function flush_sync(fn, flush_previous = true) {
  var previous_scheduler_mode = current_scheduler_mode;
  var previous_queued_root_effects = current_queued_root_effects;
  try {
    infinite_loop_guard();
    const root_effects = [];
    current_scheduler_mode = FLUSH_SYNC;
    current_queued_root_effects = root_effects;
    is_micro_task_queued2 = false;
    if (flush_previous) {
      flush_queued_root_effects(previous_queued_root_effects);
    }
    var result = fn == null ? void 0 : fn();
    flush_tasks();
    if (current_queued_root_effects.length > 0 || root_effects.length > 0) {
      flush_sync();
    }
    flush_count = 0;
    return result;
  } finally {
    current_scheduler_mode = previous_scheduler_mode;
    current_queued_root_effects = previous_queued_root_effects;
  }
}
function get(signal) {
  const flags = signal.f;
  if ((flags & DESTROYED) !== 0) {
    return signal.v;
  }
  if (is_signals_recorded) {
    captured_signals.add(signal);
  }
  if (current_reaction !== null) {
    const unowned = (current_reaction.f & UNOWNED) !== 0;
    const dependencies = current_reaction.deps;
    if (current_dependencies === null && dependencies !== null && dependencies[current_dependencies_index] === signal && !(unowned && current_effect !== null)) {
      current_dependencies_index++;
    } else if (dependencies === null || current_dependencies_index === 0 || dependencies[current_dependencies_index - 1] !== signal) {
      if (current_dependencies === null) {
        current_dependencies = [signal];
      } else if (current_dependencies[current_dependencies.length - 1] !== signal) {
        current_dependencies.push(signal);
      }
    }
    if (current_untracked_writes !== null && current_effect !== null && (current_effect.f & CLEAN) !== 0 && (current_effect.f & BRANCH_EFFECT) === 0 && current_untracked_writes.includes(signal)) {
      set_signal_status(current_effect, DIRTY);
      schedule_effect(current_effect);
    }
  }
  if ((flags & DERIVED) !== 0 && check_dirtiness(
    /** @type {import('#client').Derived} */
    signal
  )) {
    update_derived(
      /** @type {import('#client').Derived} **/
      signal
    );
  }
  return signal.v;
}
function mark_reactions(signal, to_status, force_schedule) {
  var reactions = signal.reactions;
  if (reactions === null)
    return;
  var runes = is_runes();
  var length = reactions.length;
  for (var i = 0; i < length; i++) {
    var reaction = reactions[i];
    var flags = reaction.f;
    if (DEV && (flags & INSPECT_EFFECT) !== 0) {
      inspect_effects.add(reaction);
      continue;
    }
    if ((flags & DIRTY) !== 0 || (!force_schedule || !runes) && reaction === current_effect) {
      continue;
    }
    set_signal_status(reaction, to_status);
    var maybe_dirty = (flags & MAYBE_DIRTY) !== 0;
    var unowned = (flags & UNOWNED) !== 0;
    if ((flags & CLEAN) !== 0 || maybe_dirty && unowned) {
      if ((reaction.f & DERIVED) !== 0) {
        mark_reactions(
          /** @type {import('#client').Derived} */
          reaction,
          MAYBE_DIRTY,
          force_schedule
        );
      } else {
        schedule_effect(
          /** @type {import('#client').Effect} */
          reaction
        );
      }
    }
  }
}
function untrack(fn) {
  const previous_reaction = current_reaction;
  try {
    current_reaction = null;
    return fn();
  } finally {
    current_reaction = previous_reaction;
  }
}
var STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);
function set_signal_status(signal, status) {
  signal.f = signal.f & STATUS_MASK | status;
}
function is_signal(val) {
  return typeof val === "object" && val !== null && typeof /** @type {import('#client').Value<V>} */
  val.f === "number";
}
function push(props, runes = false, fn) {
  current_component_context = {
    p: current_component_context,
    c: null,
    e: null,
    m: false,
    s: props,
    x: null,
    l: null
  };
  if (!runes) {
    current_component_context.l = {
      s: null,
      u: null,
      r1: [],
      r2: source(false)
    };
  }
  if (DEV) {
    current_component_context.function = fn;
    dev_current_component_function = fn;
  }
}
function pop(component2) {
  var _a, _b;
  const context_stack_item = current_component_context;
  if (context_stack_item !== null) {
    if (component2 !== void 0) {
      context_stack_item.x = component2;
    }
    const effects = context_stack_item.e;
    if (effects !== null) {
      context_stack_item.e = null;
      for (var i = 0; i < effects.length; i++) {
        effect(effects[i]);
      }
    }
    current_component_context = context_stack_item.p;
    if (DEV) {
      dev_current_component_function = (_b = (_a = context_stack_item.p) == null ? void 0 : _a.function) != null ? _b : null;
    }
    context_stack_item.m = true;
  }
  return component2 || /** @type {T} */
  {};
}
function unwrap(value) {
  if (is_signal(value)) {
    return get(value);
  }
  return value;
}
if (DEV) {
  let throw_rune_error = function(rune) {
    if (!(rune in globalThis)) {
      let value;
      Object.defineProperty(globalThis, rune, {
        configurable: true,
        // eslint-disable-next-line getter-return
        get: () => {
          if (value !== void 0) {
            return value;
          }
          rune_outside_svelte(rune);
        },
        set: (v) => {
          value = v;
        }
      });
    }
  };
  throw_rune_error("$state");
  throw_rune_error("$effect");
  throw_rune_error("$derived");
  throw_rune_error("$inspect");
  throw_rune_error("$props");
  throw_rune_error("$bindable");
}

// node_modules/svelte/src/internal/client/dom/hydration.js
var hydrating = false;
function set_hydrating(value) {
  hydrating = value;
}
var hydrate_nodes = (
  /** @type {any} */
  null
);
var hydrate_start;
function set_hydrate_nodes(nodes) {
  hydrate_nodes = nodes;
  hydrate_start = nodes && nodes[0];
}
function hydrate_anchor(node) {
  var _a, _b;
  if (node.nodeType !== 8) {
    return node;
  }
  var current = (
    /** @type {Node | null} */
    node
  );
  if (
    /** @type {Comment} */
    current.data !== HYDRATION_START
  ) {
    return node;
  }
  var nodes = [];
  var depth = 0;
  while ((current = /** @type {Node} */
  current.nextSibling) !== null) {
    if (current.nodeType === 8) {
      var data = (
        /** @type {Comment} */
        current.data
      );
      if (data === HYDRATION_START) {
        depth += 1;
      } else if (data[0] === HYDRATION_END) {
        if (depth === 0) {
          hydrate_nodes = /** @type {import('#client').TemplateNode[]} */
          nodes;
          hydrate_start = /** @type {import('#client').TemplateNode} */
          nodes[0];
          return current;
        }
        depth -= 1;
      }
    }
    nodes.push(current);
  }
  let location;
  if (DEV) {
    const loc = (_b = (_a = node.parentNode) == null ? void 0 : _a.__svelte_meta) == null ? void 0 : _b.loc;
    if (loc) {
      location = `${loc.file}:${loc.line}:${loc.column}`;
    }
  }
  hydration_mismatch(location);
  throw HYDRATION_ERROR;
}

// node_modules/svelte/src/internal/client/dev/equality.js
function init_array_prototype_warnings() {
  const array_prototype2 = Array.prototype;
  const cleanup = Array.__svelte_cleanup;
  if (cleanup) {
    cleanup();
  }
  const { indexOf, lastIndexOf, includes } = array_prototype2;
  array_prototype2.indexOf = function(item, from_index) {
    const index2 = indexOf.call(this, item, from_index);
    if (index2 === -1) {
      const test = indexOf.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test !== -1) {
        state_proxy_equality_mismatch("array.indexOf(...)");
      }
    }
    return index2;
  };
  array_prototype2.lastIndexOf = function(item, from_index) {
    const index2 = lastIndexOf.call(this, item, from_index != null ? from_index : this.length - 1);
    if (index2 === -1) {
      const test = lastIndexOf.call(
        get_proxied_value(this),
        get_proxied_value(item),
        from_index != null ? from_index : this.length - 1
      );
      if (test !== -1) {
        state_proxy_equality_mismatch("array.lastIndexOf(...)");
      }
    }
    return index2;
  };
  array_prototype2.includes = function(item, from_index) {
    const has = includes.call(this, item, from_index);
    if (!has) {
      const test = includes.call(get_proxied_value(this), get_proxied_value(item), from_index);
      if (test) {
        state_proxy_equality_mismatch("array.includes(...)");
      }
    }
    return has;
  };
  Array.__svelte_cleanup = () => {
    array_prototype2.indexOf = indexOf;
    array_prototype2.lastIndexOf = lastIndexOf;
    array_prototype2.includes = includes;
  };
}

// node_modules/svelte/src/internal/client/dom/operations.js
var $window;
var $document;
function init_operations() {
  if ($window !== void 0) {
    return;
  }
  $window = window;
  $document = document;
  var element_prototype = Element.prototype;
  element_prototype.__click = void 0;
  element_prototype.__className = "";
  element_prototype.__attributes = null;
  element_prototype.__e = void 0;
  Text.prototype.__t = void 0;
  if (DEV) {
    element_prototype.__svelte_meta = null;
    init_array_prototype_warnings();
  }
}
function empty() {
  return document.createTextNode("");
}
function child(node) {
  const child2 = node.firstChild;
  if (!hydrating)
    return child2;
  if (child2 === null) {
    return node.appendChild(empty());
  }
  return hydrate_anchor(child2);
}
function first_child(fragment, is_text) {
  var _a, _b;
  if (!hydrating) {
    return (
      /** @type {DocumentFragment} */
      fragment.firstChild
    );
  }
  if (is_text && ((_a = hydrate_start) == null ? void 0 : _a.nodeType) !== 3) {
    var text2 = empty();
    var dom = (
      /** @type {import('#client').TemplateNode[]} */
      /** @type {import('#client').Effect} */
      current_effect.dom
    );
    dom.unshift(text2);
    (_b = hydrate_start) == null ? void 0 : _b.before(text2);
    return text2;
  }
  return hydrate_anchor(hydrate_start);
}
function sibling(node, is_text = false) {
  var next_sibling = (
    /** @type {import('#client').TemplateNode} */
    node.nextSibling
  );
  if (!hydrating) {
    return next_sibling;
  }
  var type = next_sibling.nodeType;
  if (type === 8 && /** @type {Comment} */
  next_sibling.data === HYDRATION_ANCHOR) {
    return sibling(next_sibling, is_text);
  }
  if (is_text && type !== 3) {
    var text2 = empty();
    var dom = (
      /** @type {import('#client').TemplateNode[]} */
      /** @type {import('#client').Effect} */
      current_effect.dom
    );
    dom.unshift(text2);
    next_sibling == null ? void 0 : next_sibling.before(text2);
    return text2;
  }
  return hydrate_anchor(
    /** @type {Node} */
    next_sibling
  );
}
function clear_text_content(node) {
  node.textContent = "";
}

// node_modules/svelte/src/internal/client/dom/elements/events.js
function handle_event_propagation(event2) {
  var _a;
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  var path_idx = 0;
  var handled_at = event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element)
    return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated !== void 0 && !/** @type {any} */
        current_target.disabled) {
          if (is_array(delegated)) {
            var [fn, ...data] = delegated;
            fn.apply(current_target, [event2, ...data]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    event2.__root = handler_element;
    current_target = handler_element;
  }
}

// node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js
var head_anchor;
function reset_head_anchor() {
  head_anchor = void 0;
}

// node_modules/svelte/src/internal/shared/validate.js
var snippet_symbol = Symbol.for("svelte.snippet");
function validate_component(component_fn) {
  if ((component_fn == null ? void 0 : component_fn[snippet_symbol]) === true) {
    snippet_used_as_component();
  }
  return component_fn;
}

// node_modules/svelte/src/internal/client/render.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
var should_intro = true;
function set_text(text2, value) {
  var _a;
  const prev = (_a = text2.__t) != null ? _a : text2.__t = text2.nodeValue;
  if (prev !== value) {
    text2.nodeValue = text2.__t = value;
  }
}
function mount(component2, options) {
  var _a;
  if (DEV) {
    validate_component(component2);
  }
  const anchor = (_a = options.anchor) != null ? _a : options.target.appendChild(empty());
  return flush_sync(() => _mount(component2, { ...options, anchor }), false);
}
function hydrate(component2, options) {
  if (DEV) {
    validate_component(component2);
  }
  const target = options.target;
  const previous_hydrate_nodes = hydrate_nodes;
  try {
    return flush_sync(() => {
      set_hydrating(true);
      var node = target.firstChild;
      while (node && (node.nodeType !== 8 || /** @type {Comment} */
      node.data !== HYDRATION_START)) {
        node = node.nextSibling;
      }
      if (!node) {
        throw HYDRATION_ERROR;
      }
      const anchor = hydrate_anchor(node);
      const instance = _mount(component2, { ...options, anchor });
      set_hydrating(false);
      return instance;
    }, false);
  } catch (error) {
    if (error === HYDRATION_ERROR) {
      if (options.recover === false) {
        hydration_failed();
      }
      init_operations();
      clear_text_content(target);
      set_hydrating(false);
      return mount(component2, options);
    }
    throw error;
  } finally {
    set_hydrating(!!previous_hydrate_nodes);
    set_hydrate_nodes(previous_hydrate_nodes);
    reset_head_anchor();
  }
}
function _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {
  init_operations();
  const registered_events = /* @__PURE__ */ new Set();
  const event_handle = (events2) => {
    for (let i = 0; i < events2.length; i++) {
      const event_name = events2[i];
      const passive = PassiveDelegatedEvents.includes(event_name);
      if (!registered_events.has(event_name)) {
        registered_events.add(event_name);
        target.addEventListener(event_name, handle_event_propagation, { passive });
        document.addEventListener(event_name, handle_event_propagation, { passive });
      }
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  let component2 = void 0;
  const unmount2 = effect_root(() => {
    branch(() => {
      if (context) {
        push({});
        var ctx = (
          /** @type {import('#client').ComponentContext} */
          current_component_context
        );
        ctx.c = context;
      }
      if (events) {
        props.$$events = events;
      }
      should_intro = intro;
      component2 = Component(anchor, props) || {};
      should_intro = true;
      if (context) {
        pop();
      }
    });
    return () => {
      for (const event_name of registered_events) {
        target.removeEventListener(event_name, handle_event_propagation);
        document.removeEventListener(event_name, handle_event_propagation);
      }
      root_event_handles.delete(event_handle);
      mounted_components.delete(component2);
    };
  });
  mounted_components.set(component2, unmount2);
  return component2;
}
var mounted_components = /* @__PURE__ */ new WeakMap();
function unmount(component2) {
  const fn = mounted_components.get(component2);
  if (DEV && !fn) {
    lifecycle_double_unmount();
    console.trace("stack trace");
  }
  fn == null ? void 0 : fn();
}

// node_modules/svelte/src/internal/client/dom/blocks/if.js
function if_block(anchor, get_condition, consequent_fn, alternate_fn = null, elseif = false) {
  var consequent_effect = null;
  var alternate_effect = null;
  var condition = null;
  var flags = elseif ? EFFECT_TRANSPARENT : 0;
  block(() => {
    if (condition === (condition = !!get_condition()))
      return;
    let mismatch = false;
    if (hydrating) {
      const is_else = anchor.data === HYDRATION_END_ELSE;
      if (condition === is_else) {
        remove(hydrate_nodes);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (condition) {
      if (consequent_effect) {
        resume_effect(consequent_effect);
      } else {
        consequent_effect = branch(() => consequent_fn(anchor));
      }
      if (alternate_effect) {
        pause_effect(alternate_effect, () => {
          alternate_effect = null;
        });
      }
    } else {
      if (alternate_effect) {
        resume_effect(alternate_effect);
      } else if (alternate_fn) {
        alternate_effect = branch(() => alternate_fn(anchor));
      }
      if (consequent_effect) {
        pause_effect(consequent_effect, () => {
          consequent_effect = null;
        });
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
  }, flags);
}

// node_modules/svelte/src/internal/client/dom/blocks/each.js
var current_each_item = null;
function index(_, i) {
  return i;
}
function pause_effects(items, controlled_anchor, items_map) {
  var transitions = [];
  var length = items.length;
  for (var i = 0; i < length; i++) {
    pause_children(items[i].e, transitions, true);
  }
  var is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      /** @type {Element} */
      controlled_anchor.parentNode
    );
    clear_text_content(parent_node);
    parent_node.append(
      /** @type {Element} */
      controlled_anchor
    );
    items_map.clear();
    link(items[0].prev, items[length - 1].next);
  }
  run_out_transitions(transitions, () => {
    for (var i2 = 0; i2 < length; i2++) {
      var item = items[i2];
      if (!is_controlled) {
        items_map.delete(item.k);
        link(item.prev, item.next);
      }
      destroy_effect(item.e, !is_controlled);
    }
  });
}
function each(anchor, flags, get_collection, get_key, render_fn, fallback_fn = null) {
  var state = { flags, items: /* @__PURE__ */ new Map(), next: null };
  var is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;
  if (is_controlled) {
    var parent_node = (
      /** @type {Element} */
      anchor
    );
    anchor = hydrating ? (
      /** @type {Comment | Text} */
      hydrate_anchor(
        /** @type {Comment | Text} */
        parent_node.firstChild
      )
    ) : parent_node.appendChild(empty());
  }
  var fallback = null;
  block(() => {
    var collection = get_collection();
    var array = is_array(collection) ? collection : collection == null ? [] : Array.from(collection);
    var length = array.length;
    var flags2 = state.flags;
    if ((flags2 & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {
      flags2 ^= EACH_IS_STRICT_EQUALS;
      if ((flags2 & EACH_KEYED) !== 0 && (flags2 & EACH_ITEM_REACTIVE) === 0) {
        flags2 ^= EACH_ITEM_REACTIVE;
      }
    }
    let mismatch = false;
    if (hydrating) {
      var is_else = (
        /** @type {Comment} */
        anchor.data === HYDRATION_END_ELSE
      );
      if (is_else !== (length === 0) || hydrate_start === void 0) {
        remove(hydrate_nodes);
        set_hydrating(false);
        mismatch = true;
      }
    }
    if (hydrating) {
      var child_anchor = hydrate_start;
      var prev = state;
      var item;
      for (var i = 0; i < length; i++) {
        if (child_anchor.nodeType !== 8 || /** @type {Comment} */
        child_anchor.data !== HYDRATION_START) {
          mismatch = true;
          set_hydrating(false);
          break;
        }
        child_anchor = hydrate_anchor(child_anchor);
        var value = array[i];
        var key = get_key(value, i);
        item = create_item(child_anchor, prev, null, value, key, i, render_fn, flags2);
        state.items.set(key, item);
        child_anchor = /** @type {Comment} */
        child_anchor.nextSibling;
        prev = item;
      }
      if (length > 0) {
        while (child_anchor !== anchor) {
          var next = (
            /** @type {import('#client').TemplateNode} */
            child_anchor.nextSibling
          );
          child_anchor.remove();
          child_anchor = next;
        }
      }
    }
    if (!hydrating) {
      reconcile(array, state, anchor, render_fn, flags2, get_key);
    }
    if (fallback_fn !== null) {
      if (length === 0) {
        if (fallback) {
          resume_effect(fallback);
        } else {
          fallback = branch(() => fallback_fn(anchor));
        }
      } else if (fallback !== null) {
        pause_effect(fallback, () => {
          fallback = null;
        });
      }
    }
    if (mismatch) {
      set_hydrating(true);
    }
  });
}
function reconcile(array, state, anchor, render_fn, flags, get_key) {
  var _a, _b, _c, _d;
  var is_animated = (flags & EACH_IS_ANIMATED) !== 0;
  var should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;
  var length = array.length;
  var items = state.items;
  var first = state.next;
  var current = first;
  var seen = /* @__PURE__ */ new Set();
  var prev = state;
  var to_animate = /* @__PURE__ */ new Set();
  var matched = [];
  var stashed = [];
  var value;
  var key;
  var item;
  var i;
  if (is_animated) {
    for (i = 0; i < length; i += 1) {
      value = array[i];
      key = get_key(value, i);
      item = items.get(key);
      if (item !== void 0) {
        (_a = item.a) == null ? void 0 : _a.measure();
        to_animate.add(item);
      }
    }
  }
  for (i = 0; i < length; i += 1) {
    value = array[i];
    key = get_key(value, i);
    item = items.get(key);
    if (item === void 0) {
      var child_anchor = current ? get_first_node(current.e) : anchor;
      prev = create_item(child_anchor, prev, prev.next, value, key, i, render_fn, flags);
      items.set(key, prev);
      matched = [];
      stashed = [];
      current = prev.next;
      continue;
    }
    if (should_update) {
      update_item(item, value, i, flags);
    }
    if ((item.e.f & INERT) !== 0) {
      resume_effect(item.e);
      if (is_animated) {
        (_b = item.a) == null ? void 0 : _b.unfix();
        to_animate.delete(item);
      }
    }
    if (item !== current) {
      if (seen.has(item)) {
        if (matched.length < stashed.length) {
          var start = stashed[0];
          var j;
          prev = start.prev;
          var a = matched[0];
          var b = matched[matched.length - 1];
          for (j = 0; j < matched.length; j += 1) {
            move(matched[j], start, anchor);
          }
          for (j = 0; j < stashed.length; j += 1) {
            seen.delete(stashed[j]);
          }
          link(a.prev, b.next);
          link(prev, a);
          link(b, start);
          current = start;
          prev = b;
          i -= 1;
          matched = [];
          stashed = [];
        } else {
          seen.delete(item);
          move(item, current, anchor);
          link(item.prev, item.next);
          link(item, prev.next);
          link(prev, item);
          prev = item;
        }
        continue;
      }
      matched = [];
      stashed = [];
      while (current !== null && current.k !== key) {
        seen.add(current);
        stashed.push(current);
        current = current.next;
      }
      if (current === null) {
        continue;
      }
      item = current;
    }
    matched.push(item);
    prev = item;
    current = item.next;
  }
  const to_destroy = Array.from(seen);
  while (current !== null) {
    to_destroy.push(current);
    current = current.next;
  }
  var destroy_length = to_destroy.length;
  if (destroy_length > 0) {
    var controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;
    if (is_animated) {
      for (i = 0; i < destroy_length; i += 1) {
        (_c = to_destroy[i].a) == null ? void 0 : _c.measure();
      }
      for (i = 0; i < destroy_length; i += 1) {
        (_d = to_destroy[i].a) == null ? void 0 : _d.fix();
      }
    }
    pause_effects(to_destroy, controlled_anchor, items);
  }
  if (is_animated) {
    queue_micro_task(() => {
      var _a2;
      for (item of to_animate) {
        (_a2 = item.a) == null ? void 0 : _a2.apply();
      }
    });
  }
}
function update_item(item, value, index2, type) {
  if ((type & EACH_ITEM_REACTIVE) !== 0) {
    set(item.v, value);
  }
  if ((type & EACH_INDEX_REACTIVE) !== 0) {
    set(
      /** @type {import('#client').Value<number>} */
      item.i,
      index2
    );
  } else {
    item.i = index2;
  }
}
function create_item(anchor, prev, next, value, key, index2, render_fn, flags) {
  var previous_each_item = current_each_item;
  try {
    var reactive = (flags & EACH_ITEM_REACTIVE) !== 0;
    var mutable = (flags & EACH_IS_STRICT_EQUALS) === 0;
    var v = reactive ? mutable ? mutable_source(value) : source(value) : value;
    var i = (flags & EACH_INDEX_REACTIVE) === 0 ? index2 : source(index2);
    var item = {
      i,
      v,
      k: key,
      a: null,
      // @ts-expect-error
      e: null,
      prev,
      next
    };
    prev.next = item;
    if (next !== null)
      next.prev = item;
    current_each_item = item;
    item.e = branch(() => render_fn(anchor, v, i));
    return item;
  } finally {
    current_each_item = previous_each_item;
  }
}
function get_adjusted_first_node(dom, effect2) {
  if (dom.nodeType === 3 && /** @type {Text} */
  dom.data === "" || dom.nodeType === 8) {
    var adjusted = effect2.first;
    var next;
    while (adjusted !== null) {
      next = adjusted.first;
      if (adjusted.dom !== null) {
        break;
      } else if (next === null) {
        return (
          /** @type {import('#client').TemplateNode} */
          dom.previousSibling
        );
      }
      adjusted = next;
    }
    return get_first_node(
      /** @type {import("#client").Effect} */
      adjusted
    );
  }
  return dom;
}
function get_first_node(effect2) {
  var dom = effect2.dom;
  if (is_array(dom)) {
    return get_adjusted_first_node(dom[0], effect2);
  }
  return get_adjusted_first_node(
    /** @type {import('#client').TemplateNode} **/
    dom,
    effect2
  );
}
function move(item, next, anchor) {
  var end = item.next ? get_first_node(item.next.e) : anchor;
  var dest = next ? get_first_node(next.e) : anchor;
  var node = get_first_node(item.e);
  while (node !== end) {
    var next_node = (
      /** @type {import('#client').TemplateNode} */
      node.nextSibling
    );
    dest.before(node);
    node = next_node;
  }
}
function link(prev, next) {
  prev.next = next;
  if (next !== null)
    next.prev = prev;
}

// node_modules/svelte/src/internal/client/dom/template.js
function push_template_node(dom, effect2 = (
  /** @type {import('#client').Effect} */
  current_effect
)) {
  var current_dom = effect2.dom;
  if (current_dom === null) {
    effect2.dom = dom;
  } else {
    if (!is_array(current_dom)) {
      current_dom = effect2.dom = [current_dom];
    }
    if (is_array(dom)) {
      current_dom.push(...dom);
    } else {
      current_dom.push(dom);
    }
  }
  return dom;
}
function template(content, flags) {
  var is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;
  var use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;
  var node;
  return () => {
    if (hydrating) {
      push_template_node(is_fragment ? hydrate_nodes : hydrate_start);
      return hydrate_start;
    }
    if (!node) {
      node = create_fragment_from_html(content);
      if (!is_fragment)
        node = /** @type {Node} */
        node.firstChild;
    }
    var clone = use_import_node ? document.importNode(node, true) : node.cloneNode(true);
    push_template_node(
      is_fragment ? (
        /** @type {import('#client').TemplateNode[]} */
        [...clone.childNodes]
      ) : (
        /** @type {import('#client').TemplateNode} */
        clone
      )
    );
    return clone;
  };
}
function comment() {
  if (hydrating) {
    push_template_node(hydrate_nodes);
    return hydrate_start;
  }
  var frag = document.createDocumentFragment();
  var anchor = empty();
  frag.append(anchor);
  push_template_node([anchor]);
  return frag;
}
function append(anchor, dom) {
  if (hydrating)
    return;
  anchor.before(
    /** @type {Node} */
    dom
  );
}

// node_modules/svelte/src/internal/client/dom/elements/attributes.js
function set_attribute(element2, attribute, value) {
  var _a;
  value = value == null ? null : value + "";
  var attributes = (_a = element2.__attributes) != null ? _a : element2.__attributes = {};
  if (hydrating) {
    attributes[attribute] = element2.getAttribute(attribute);
    if (attribute === "src" || attribute === "href" || attribute === "srcset") {
      check_src_in_dev_hydration(element2, attribute, value);
      return;
    }
  }
  if (attributes[attribute] === (attributes[attribute] = value))
    return;
  if (attribute === "loading") {
    element2[LOADING_ATTR_SYMBOL] = value;
  }
  if (value === null) {
    element2.removeAttribute(attribute);
  } else {
    element2.setAttribute(attribute, value);
  }
}
function check_src_in_dev_hydration(element2, attribute, value) {
  var _a;
  if (!DEV)
    return;
  if (attribute === "srcset" && srcset_url_equal(element2, value))
    return;
  if (src_url_equal((_a = element2.getAttribute(attribute)) != null ? _a : "", value != null ? value : ""))
    return;
  hydration_attribute_changed(
    attribute,
    element2.outerHTML.replace(element2.innerHTML, "..."),
    String(value)
  );
}
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  return new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;
}
function split_srcset(srcset) {
  return srcset.split(",").map((src) => src.trim().split(" ").filter(Boolean));
}
function srcset_url_equal(element2, srcset) {
  var element_urls = split_srcset(element2.srcset);
  var urls = split_srcset(srcset != null ? srcset : "");
  return urls.length === element_urls.length && urls.every(
    ([url, width], i) => width === element_urls[i][1] && // We need to test both ways because Vite will create an a full URL with
    // `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the
    // relative URLs inside srcset are not automatically resolved to absolute URLs by
    // browsers (in contrast to img.src). This means both SSR and DOM code could
    // contain relative or absolute URLs.
    (src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))
  );
}

// node_modules/svelte/src/internal/client/dom/elements/class.js
function toggle_class(dom, class_name, value) {
  if (value) {
    dom.classList.add(class_name);
  } else {
    dom.classList.remove(class_name);
  }
}

// node_modules/svelte/src/internal/client/dom/elements/bindings/size.js
var _listeners, _observer, _options, _getObserver, getObserver_fn;
var _ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _getObserver);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer, void 0);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options, void 0);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element2, listener) {
    var listeners = __privateGet(this, _listeners).get(element2) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element2, listeners);
    __privateMethod(this, _getObserver, getObserver_fn).call(this).observe(element2, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element2);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element2);
        __privateGet(this, _observer).unobserve(element2);
      }
    };
  }
};
var ResizeObserverSingleton = _ResizeObserverSingleton;
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_getObserver = new WeakSet();
getObserver_fn = function() {
  var _a;
  return (_a = __privateGet(this, _observer)) != null ? _a : __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (var entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());

// node_modules/svelte/src/internal/client/reactivity/props.js
var spread_props_handler = {
  get(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return p[key];
    }
  },
  getOwnPropertyDescriptor(target, key) {
    let i = target.props.length;
    while (i--) {
      let p = target.props[i];
      if (is_function(p))
        p = p();
      if (typeof p === "object" && p !== null && key in p)
        return get_descriptor(p, key);
    }
  },
  has(target, key) {
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      if (p != null && key in p)
        return true;
    }
    return false;
  },
  ownKeys(target) {
    const keys = [];
    for (let p of target.props) {
      if (is_function(p))
        p = p();
      for (const key in p) {
        if (!keys.includes(key))
          keys.push(key);
      }
    }
    return keys;
  }
};
function spread_props(...props) {
  return new Proxy({ props }, spread_props_handler);
}
function prop(props, key, flags, fallback) {
  var _a;
  var immutable = (flags & PROPS_IS_IMMUTABLE) !== 0;
  var runes = (flags & PROPS_IS_RUNES) !== 0;
  var lazy = (flags & PROPS_IS_LAZY_INITIAL) !== 0;
  var prop_value = (
    /** @type {V} */
    props[key]
  );
  var setter = (_a = get_descriptor(props, key)) == null ? void 0 : _a.set;
  var fallback_value = (
    /** @type {V} */
    fallback
  );
  var fallback_dirty = true;
  var get_fallback = () => {
    if (lazy && fallback_dirty) {
      fallback_dirty = false;
      fallback_value = untrack(
        /** @type {() => V} */
        fallback
      );
    }
    return fallback_value;
  };
  if (prop_value === void 0 && fallback !== void 0) {
    if (setter && runes) {
      props_invalid_value(key);
    }
    prop_value = get_fallback();
    if (setter)
      setter(prop_value);
  }
  var getter;
  if (runes) {
    getter = () => {
      var value = (
        /** @type {V} */
        props[key]
      );
      if (value === void 0)
        return get_fallback();
      fallback_dirty = true;
      return value;
    };
  } else {
    var derived_getter = (immutable ? derived : derived_safe_equal)(
      () => (
        /** @type {V} */
        props[key]
      )
    );
    derived_getter.f |= LEGACY_DERIVED_PROP;
    getter = () => {
      var value = get(derived_getter);
      if (value !== void 0)
        fallback_value = /** @type {V} */
        void 0;
      return value === void 0 ? fallback_value : value;
    };
  }
  if ((flags & PROPS_IS_UPDATED) === 0) {
    return getter;
  }
  if (setter) {
    var legacy_parent = props.$$legacy;
    return function(value, mutation) {
      if (arguments.length > 0) {
        if (!runes || !mutation || legacy_parent) {
          setter(mutation ? getter() : value);
        }
        return value;
      } else {
        return getter();
      }
    };
  }
  var from_child = false;
  var was_from_child = false;
  var inner_current_value = mutable_source(prop_value);
  var current_value = derived(() => {
    var parent_value = getter();
    var child_value = get(inner_current_value);
    if (from_child) {
      from_child = false;
      was_from_child = true;
      return child_value;
    }
    was_from_child = false;
    return inner_current_value.v = parent_value;
  });
  if (!immutable)
    current_value.equals = safe_equals;
  return function(value, mutation) {
    var current = get(current_value);
    if (is_signals_recorded) {
      from_child = was_from_child;
      getter();
      get(inner_current_value);
    }
    if (arguments.length > 0) {
      const new_value = mutation ? get(current_value) : value;
      if (!current_value.equals(new_value)) {
        from_child = true;
        set(inner_current_value, new_value);
        get(current_value);
      }
      return value;
    }
    return current;
  };
}

// node_modules/svelte/src/legacy/legacy-client.js
function createClassComponent(options) {
  return new Svelte4Component(options);
}
var _events, _instance;
var Svelte4Component = class {
  /**
   * @param {import('svelte').ComponentConstructorOptions & {
   *  component: any;
   * 	immutable?: boolean;
   * 	hydrate?: boolean;
   * 	recover?: false;
   * }} options
   */
  constructor(options) {
    /** @type {any} */
    __privateAdd(this, _events, void 0);
    /** @type {Record<string, any>} */
    __privateAdd(this, _instance, void 0);
    const props = proxy({ ...options.props || {}, $$events: {} }, false);
    __privateSet(this, _instance, (options.hydrate ? hydrate : mount)(options.component, {
      target: options.target,
      props,
      context: options.context,
      intro: options.intro,
      recover: options.recover
    }));
    __privateSet(this, _events, props.$$events);
    for (const key of Object.keys(__privateGet(this, _instance))) {
      if (key === "$set" || key === "$destroy" || key === "$on")
        continue;
      define_property(this, key, {
        get() {
          return __privateGet(this, _instance)[key];
        },
        /** @param {any} value */
        set(value) {
          __privateGet(this, _instance)[key] = value;
        },
        enumerable: true
      });
    }
    __privateGet(this, _instance).$set = /** @param {Record<string, any>} next */
    (next) => {
      Object.assign(props, next);
    };
    __privateGet(this, _instance).$destroy = () => {
      unmount(__privateGet(this, _instance));
    };
  }
  /** @param {Record<string, any>} props */
  $set(props) {
    __privateGet(this, _instance).$set(props);
  }
  /**
   * @param {string} event
   * @param {(...args: any[]) => any} callback
   * @returns {any}
   */
  $on(event2, callback) {
    __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2] || [];
    const cb = (...args) => callback.call(this, ...args);
    __privateGet(this, _events)[event2].push(cb);
    return () => {
      __privateGet(this, _events)[event2] = __privateGet(this, _events)[event2].filter(
        /** @param {any} fn */
        (fn) => fn !== cb
      );
    };
  }
  $destroy() {
    __privateGet(this, _instance).$destroy();
  }
};
_events = new WeakMap();
_instance = new WeakMap();

// node_modules/svelte/src/internal/client/dom/elements/custom-element.js
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    /**
     * @param {*} $$componentCtor
     * @param {*} $$slots
     * @param {*} use_shadow_dom
     */
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** @type {any} The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** @type {Record<string, any>} Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      /** @type {any} The managed render effect for reflecting attributes */
      __publicField(this, "$$me");
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    /**
     * @param {string} type
     * @param {EventListenerOrEventListenerObject} listener
     * @param {boolean | AddEventListenerOptions} [options]
     */
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot = function(name) {
          return (anchor) => {
            const slot2 = document.createElement("slot");
            if (name !== "default")
              slot2.name = name;
            append(anchor, slot2);
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            if (name === "default" && !this.$$d.children) {
              this.$$d.children = create_slot(name);
              $$slots.default = true;
            } else {
              $$slots[name] = create_slot(name);
            }
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = createClassComponent({
          component: this.$$ctor,
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$host: this
          }
        });
        this.$$me = render_effect(() => {
          var _a;
          this.$$r = true;
          for (const key of object_keys(this.$$c)) {
            if (!((_a = this.$$p_d[key]) == null ? void 0 : _a.reflect))
              continue;
            this.$$d[key] = this.$$c[key];
            const attribute_value = get_custom_element_value(
              key,
              this.$$d[key],
              this.$$p_d,
              "toAttribute"
            );
            if (attribute_value == null) {
              this.removeAttribute(this.$$p_d[key].attribute || key);
            } else {
              this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
            }
          }
          this.$$r = false;
        });
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    /**
     * @param {string} attr
     * @param {string} _oldValue
     * @param {string} newValue
     */
    attributeChangedCallback(attr, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr = this.$$g_p(attr);
      this.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr]: this.$$d[attr] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          destroy_effect(this.$$me);
          this.$$c = void 0;
        }
      });
    }
    /**
     * @param {string} attribute_name
     */
    $$g_p(attribute_name) {
      return object_keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop2, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop2]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop2]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach((node) => {
    result[
      /** @type {Element} node */
      node.slot || "default"
    ] = true;
  });
  return result;
}

// src/data-access/journal-folder-settings.type.ts
var DEFAULT_SETTINGS = {
  dailyNoteTitlePattern: "dddd, DD MMMM YYYY",
  dailyNoteShortTitlePattern: "ddd, D MMM",
  dailyNoteMediumTitlePattern: "ddd, D MMM YY",
  weeklyNoteTitlePattern: "gggg [Week] w",
  weeklyNoteShortTitlePattern: "[W]ww",
  weeklyNoteMediumTitlePattern: "[W]ww gg",
  monthlyNoteTitlePattern: "MMMM YYYY",
  monthlyNoteShortTitlePattern: "MMM",
  monthlyNoteMediumTitlePattern: "MMM YY",
  yearlyNoteTitlePattern: "YYYY",
  yearlyNoteShortTitlePattern: "YYYY",
  yearlyNoteMediumTitlePattern: "YYYY",
  showWeeklyLinks: true,
  showMonthlyLinks: true,
  showYearlyLinks: true
};

// src/data-access/plugin-feature.ts
var _settings;
var PluginFeature = class {
  constructor(plugin) {
    this.plugin = plugin;
    __privateAdd(this, _settings, void 0);
  }
  // noinspection JSUnusedGlobalSymbols
  get settings() {
    if (!__privateGet(this, _settings))
      throw new Error("Settings must be set");
    return __privateGet(this, _settings);
  }
  async load() {
  }
  unload() {
  }
  onExternalSettingsChange() {
  }
  useSettings(settings) {
    __privateSet(this, _settings, settings);
  }
  getCurrentFile(linkPath, sourcePath = "") {
    return this.plugin.app.metadataCache.getFirstLinkpathDest(linkPath, sourcePath);
  }
  expectCurrentFile(linkPath, sourcePath = "") {
    const file = this.getCurrentFile(linkPath, sourcePath);
    if (!file)
      throw Error(`Current not found (linkPath: ${sourcePath}, sourcePath: ${sourcePath})`);
    return file;
  }
};
_settings = new WeakMap();

// src/data-access/journal-note.ts
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
function startOfInterval(sourceMoment, pattern) {
  return (0, import_obsidian2.moment)(sourceMoment.format(pattern), pattern);
}
function journalNoteFactoryWithSettings(settings) {
  const DAILY_NOTE_STRATEGY = {
    fileRegex: /^20\d{2}-((0[1-9])|(1[12]))-(([0-2][0-9])|(3[01]))$/,
    filePattern: "YYYY-MM-DD",
    titlePattern: settings.dailyNoteTitlePattern,
    shortTitlePattern: settings.dailyNoteShortTitlePattern,
    mediumTitlePattern: settings.dailyNoteMediumTitlePattern,
    yearPattern: "YYYY",
    timeUnit: "day"
  };
  const WEEKLY_NOTE_STRATEGY = {
    fileRegex: /^\d{4}-W((0[1-9])|([1-4][0-9])|(5[0-3]))$/,
    filePattern: "gggg-[W]ww",
    titlePattern: settings.weeklyNoteTitlePattern,
    shortTitlePattern: settings.weeklyNoteShortTitlePattern,
    mediumTitlePattern: settings.weeklyNoteMediumTitlePattern,
    yearPattern: "gggg",
    timeUnit: "week"
  };
  const MONTHLY_NOTE_STRATEGY = {
    fileRegex: /^20\d{2}-((0[1-9])|(1[12]))$/,
    filePattern: "YYYY-MM",
    titlePattern: settings.monthlyNoteTitlePattern,
    shortTitlePattern: settings.monthlyNoteShortTitlePattern,
    mediumTitlePattern: settings.monthlyNoteMediumTitlePattern,
    yearPattern: "YYYY",
    timeUnit: "month"
  };
  const YEARLY_NOTE_STRATEGY = {
    fileRegex: /^20\d{2}$/,
    filePattern: "YYYY",
    titlePattern: settings.yearlyNoteTitlePattern,
    shortTitlePattern: settings.yearlyNoteShortTitlePattern,
    mediumTitlePattern: settings.yearlyNoteMediumTitlePattern,
    yearPattern: "YYYY",
    timeUnit: "year"
  };
  const strategies = {
    DAILY_NOTE_STRATEGY,
    WEEKLY_NOTE_STRATEGY,
    MONTHLY_NOTE_STRATEGY,
    YEARLY_NOTE_STRATEGY,
    BY_DESCENDING_ORDER: [YEARLY_NOTE_STRATEGY, MONTHLY_NOTE_STRATEGY, WEEKLY_NOTE_STRATEGY, DAILY_NOTE_STRATEGY]
  };
  function getNoteStrategy(file) {
    const buildStrategy = strategies.BY_DESCENDING_ORDER.filter((s) => s.fileRegex.test(file.basename)).first();
    if (!buildStrategy)
      throw new Error(`File name does not represent a valid journal file - ${file.basename}`);
    return buildStrategy;
  }
  return function journalNote(file) {
    var _a, _b;
    const strategy = getNoteStrategy(file);
    const today = (0, import_obsidian2.moment)().startOf("day");
    const noteNames = (((_a = file.parent) == null ? void 0 : _a.children) || []).map((f) => f.name.replace(/\.md$/, ""));
    return new JournalNote(
      strategies,
      ((_b = file.parent) == null ? void 0 : _b.path) || "",
      noteNames,
      strategy,
      // @ts-ignore
      (0, import_obsidian2.moment)(file.basename, strategy.filePattern),
      startOfInterval(today, strategy.filePattern),
      today
    );
  };
}
var JournalNote = class {
  constructor(strategies, path, noteNames, strategy, fileMoment, present, today) {
    this.strategies = strategies;
    this.path = path;
    this.noteNames = noteNames;
    this.strategy = strategy;
    this.fileMoment = fileMoment;
    this.present = present;
    this.today = today;
    this.name = fileMoment.format(this.strategy.filePattern);
    this.lastDay = fileMoment.clone().add(1, strategy.timeUnit).subtract(1, "day");
  }
  getTitle() {
    return this.fileMoment.format(this.strategy.titlePattern);
  }
  forwardInTime() {
    const moment2 = this.fileMoment.clone().add(1, this.strategy.timeUnit);
    return this.createNoteOfSameTimeUnit(moment2);
  }
  backInTime() {
    const moment2 = this.fileMoment.clone().subtract(1, this.strategy.timeUnit);
    return this.createNoteOfSameTimeUnit(moment2);
  }
  // noinspection JSUnusedGlobalSymbols
  presentNote() {
    return this.createNoteOfSameTimeUnit(this.present);
  }
  dailyNoteToday() {
    return this.createNote(this.strategies.DAILY_NOTE_STRATEGY, this.today);
  }
  // noinspection JSUnusedGlobalSymbols
  isFuture() {
    return this.fileMoment.isAfter(this.present);
  }
  // noinspection JSUnusedGlobalSymbols
  isPast() {
    return this.fileMoment.isBefore(this.present, this.strategy.timeUnit);
  }
  isPresentTime() {
    return this.fileMoment.isSame(this.present, this.strategy.timeUnit);
  }
  isPresentOrFuture() {
    return this.fileMoment.isSameOrAfter(this.present, this.strategy.timeUnit);
  }
  isExistingNote() {
    return this.noteNames.some((name) => name === this.name);
  }
  isToday() {
    return this.strategy.timeUnit === "day" && this.isPresentTime();
  }
  // noinspection JSUnusedGlobalSymbols
  isMissingNote() {
    return !this.isExistingNote();
  }
  getHigherOrderNotes() {
    const notes = [];
    for (const strategy of this.strategies.BY_DESCENDING_ORDER) {
      if (this.strategy === strategy)
        break;
      const note = this.createNote(strategy);
      notes.push(note);
      const note2 = this.createNote(strategy, this.lastDay);
      if (!note2.sameNoteAs(note))
        notes.push(note2);
    }
    return notes;
  }
  sameNoteAs(note) {
    return note.strategy === this.strategy && note.fileMoment.isSame(this.fileMoment, "day");
  }
  getLowerOrderNotes() {
    const notes = [];
    const lowerOrderStrategy = this.getLowerOrderStrategy();
    if (lowerOrderStrategy) {
      const moment2 = this.fileMoment.clone();
      while (this.name === moment2.format(this.strategy.filePattern)) {
        notes.push(this.createNote(lowerOrderStrategy, moment2));
        moment2.add(1, lowerOrderStrategy.timeUnit);
      }
    }
    return notes;
  }
  shortLinkFrom(note, inactive = false) {
    const pattern = note.formattedYear() === this.formattedYear(note.strategy.yearPattern) ? this.strategy.shortTitlePattern : this.strategy.mediumTitlePattern;
    return this.linkWithTitlePattern(pattern, inactive);
  }
  link(titlePattern = "short", inactive = false) {
    const pattern = titlePattern === "regular" ? this.strategy.titlePattern : this.strategy.shortTitlePattern;
    return this.linkWithTitlePattern(pattern, inactive);
  }
  linkWithTitlePattern(pattern, inactive = false) {
    return this.createJournalNoteLink(
      pattern,
      this.strategy.filePattern,
      this.fileMoment,
      inactive
    );
  }
  closestSibling(beforeOrAfter) {
    const multiplier = beforeOrAfter === "before" ? -1 : 1;
    const adjacentFileName = this.noteNames.reduce((prev, curr) => {
      if (!this.strategy.fileRegex.test(curr))
        return prev;
      if (curr.localeCompare(this.name) * multiplier <= 0)
        return prev;
      if (prev == null)
        return curr;
      return curr.localeCompare(prev) * multiplier < 0 ? curr : prev;
    }, null);
    if (adjacentFileName) {
      return this.createNoteOfSameTimeUnit(
        // @ts-ignore
        (0, import_obsidian2.moment)(adjacentFileName, this.strategy.filePattern)
      );
    }
  }
  formattedYear(yearPattern = this.strategy.yearPattern) {
    return this.fileMoment.format(yearPattern);
  }
  getLowerOrderStrategy() {
    let currentStrategyFound = false;
    for (const strategy of this.strategies.BY_DESCENDING_ORDER) {
      if (currentStrategyFound)
        return strategy;
      currentStrategyFound = this.strategy === strategy;
    }
  }
  createJournalNoteLink(titlePattern, fileNamePattern, targetMoment = this.fileMoment, inactive = false) {
    return {
      title: targetMoment.format(titlePattern),
      url: this.fullPath(targetMoment.format(fileNamePattern)),
      inactive
    };
  }
  createNoteOfSameTimeUnit(moment2) {
    return new JournalNote(
      this.strategies,
      this.path,
      this.noteNames,
      this.strategy,
      moment2,
      this.present,
      this.today
    );
  }
  createNote(strategy, moment2 = this.fileMoment) {
    return new JournalNote(
      this.strategies,
      this.path,
      this.noteNames,
      strategy,
      startOfInterval(moment2, strategy.filePattern),
      startOfInterval(this.today, strategy.filePattern),
      this.today
    );
  }
  fullPath(fileName) {
    return (0, import_obsidian.normalizePath)(this.path ? `${this.path}/${fileName}` : fileName);
  }
};

// node_modules/svelte/src/version.js
var PUBLIC_VERSION = "5";

// node_modules/svelte/src/internal/disclose-version.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/ui/ErrorMessage.svelte
var root = template(`<div class="journal-folder-error-message"> </div>`);
function ErrorMessage($$anchor, $$props) {
  let error = prop($$props, "error");
  var div = root();
  var text2 = child(div);
  template_effect(() => set_text(text2, error()));
  append($$anchor, div);
}

// src/ui/NoteLink.svelte
var root_1 = template(`<span class="journal-folder-note-link no-link"> </span>`);
var root_2 = template(`<a class="internal-link journal-folder-note-link"> </a>`);
function NoteLink($$anchor, $$props) {
  "use strict";
  let inactive = prop($$props, "inactive", 3, false), linkStyle = prop($$props, "linkStyle", 3, "hyperlink");
  var fragment = comment();
  var node = first_child(fragment);
  if_block(
    node,
    inactive,
    ($$anchor2) => {
      var span = root_1();
      var text2 = child(span);
      template_effect(() => set_text(text2, $$props.title));
      append($$anchor2, span);
    },
    ($$anchor2) => {
      var a = root_2();
      var text_1 = child(a);
      template_effect(() => {
        set_attribute(a, "href", $$props.url);
        toggle_class(a, "chip", linkStyle() === "chip");
        set_text(text_1, $$props.title);
      });
      append($$anchor2, a);
    }
  );
  append($$anchor, fragment);
}

// src/features/journal-header/JournalHeader.svelte
var root_12 = template(`<!> <div>&lt;--</div>`, 1);
var root_3 = template(`<div>--&gt;</div> <!>`, 1);
var root_6 = template(`<div>|</div>`);
var root_5 = template(`<!> <!>`, 1);
var root_4 = template(`<div class="journal-folder-header-links"></div>`);
var root2 = template(`<div class="journal-folder-header"><h1 class="journal-folder-header-title"> </h1> <div class="journal-folder-header-options"><div class="journal-folder-header-links"><!> <!> <!></div> <!></div></div>`);
function JournalHeader($$anchor, $$props) {
  push($$props, true);
  var div = root2();
  var h1 = child(div);
  var text2 = child(h1);
  var div_1 = sibling(sibling(h1, true));
  var div_2 = child(div_1);
  var node = child(div_2);
  if_block(node, () => $$props.info.backwardLink, ($$anchor2) => {
    var fragment = root_12();
    var node_1 = first_child(fragment);
    NoteLink(node_1, spread_props(() => $$props.info.backwardLink, { linkStyle: "chip" }));
    var div_3 = sibling(sibling(node_1, true));
    append($$anchor2, fragment);
  });
  var node_2 = sibling(sibling(node, true));
  each(node_2, 65, () => $$props.info.centerLinks, index, ($$anchor2, link2, $$index) => {
    var fragment_1 = comment();
    var node_3 = first_child(fragment_1);
    NoteLink(node_3, spread_props(() => unwrap(link2), { linkStyle: "chip" }));
    append($$anchor2, fragment_1);
  });
  var node_4 = sibling(sibling(node_2, true));
  if_block(node_4, () => $$props.info.forwardLink, ($$anchor2) => {
    var fragment_2 = root_3();
    var div_4 = first_child(fragment_2);
    var node_5 = sibling(sibling(div_4, true));
    NoteLink(node_5, spread_props(() => $$props.info.forwardLink, { linkStyle: "chip" }));
    append($$anchor2, fragment_2);
  });
  var node_6 = sibling(sibling(div_2, true));
  if_block(node_6, () => $$props.info.secondaryLinks.length > 0, ($$anchor2) => {
    var div_5 = root_4();
    each(div_5, 73, () => $$props.info.secondaryLinks, index, ($$anchor3, link2, i) => {
      var fragment_3 = root_5();
      var node_7 = first_child(fragment_3);
      if_block(node_7, () => unwrap(i) > 0, ($$anchor4) => {
        var div_6 = root_6();
        append($$anchor4, div_6);
      });
      var node_8 = sibling(sibling(node_7, true));
      NoteLink(node_8, spread_props(() => unwrap(link2)));
      append($$anchor3, fragment_3);
    });
    append($$anchor2, div_5);
  });
  template_effect(() => set_text(text2, $$props.info.title));
  append($$anchor, div);
  pop();
}

// src/features/journal-header/journal-header-info.ts
function buildJournalHeaderInfo(note) {
  return {
    title: note.getTitle(),
    centerLinks: buildCenterLinks(),
    backwardLink: createBackwardLink(),
    forwardLink: createForwardLink(),
    secondaryLinks: buildSecondaryLinks()
  };
  function buildCenterLinks() {
    const links = note.getHigherOrderNotes().filter((n) => n.isExistingNote() || n.isPresentOrFuture()).map((n) => n.shortLinkFrom(note));
    if (!note.isToday()) {
      links.push(note.dailyNoteToday().linkWithTitlePattern("[Today]"));
    }
    return links;
  }
  function createForwardLink() {
    const directSibling = note.forwardInTime();
    if (directSibling.isExistingNote() || directSibling.isPresentOrFuture()) {
      return directSibling.shortLinkFrom(note);
    }
    const closestSibling = note.closestSibling("after");
    if (closestSibling) {
      return closestSibling.shortLinkFrom(note);
    }
  }
  function createBackwardLink() {
    var _a;
    const directSibling = note.backInTime();
    if (directSibling.isExistingNote() || directSibling.isPresentOrFuture()) {
      return directSibling.shortLinkFrom(note);
    }
    return (_a = note.closestSibling("before")) == null ? void 0 : _a.shortLinkFrom(note);
  }
  function buildSecondaryLinks() {
    return note.getLowerOrderNotes().map((n) => n.link(
      "short",
      n.isMissingNote() && n.isPast()
    ));
  }
}

// src/features/journal-header/journal-header-feature.ts
var _journalNote;
var JournalHeaderFeature = class extends PluginFeature {
  constructor(plugin) {
    super(plugin);
    __privateAdd(this, _journalNote, void 0);
  }
  get journalNote() {
    if (!__privateGet(this, _journalNote))
      throw new Error("Settings must be set");
    return __privateGet(this, _journalNote);
  }
  useSettings(settings) {
    super.useSettings(settings);
    __privateSet(this, _journalNote, journalNoteFactoryWithSettings(settings));
  }
  async load() {
    this.plugin.registerMarkdownCodeBlockProcessor("journal-header", (_source, el, ctx) => {
      try {
        const note = this.journalNote(this.expectCurrentFile(ctx.sourcePath));
        const info = buildJournalHeaderInfo(note);
        mount(JournalHeader, { target: el, props: { info } });
      } catch (error) {
        mount(ErrorMessage, { target: el, props: { error: `${error}` } });
      }
    });
  }
};
_journalNote = new WeakMap();

// src/features/journal-folder-settings/journal-folder-settings-tab.ts
var import_obsidian3 = require("obsidian");
var JournalFolderSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(plugin, getCurrentSettings, saveSettings) {
    super(plugin.app, plugin);
    this.plugin = plugin;
    this.getCurrentSettings = getCurrentSettings;
    this.saveSettings = saveSettings;
  }
  display() {
    this.containerEl.empty();
    const settings = { ...this.getCurrentSettings() };
    this.createMomentSetting(settings, "dailyNoteTitlePattern", "Daily note title pattern").setDesc(
      "The pattern used to render the title of a daily note. This pattern should not render any date/time elements shorter than a day (e.g. hour or minute). For instance, using a pattern of 'DD-HH' would not make sense as the hour component represents a fraction of the day. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "dailyNoteShortTitlePattern", "Daily note short title pattern").setDesc(
      "The pattern used to render links to daily notes. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a day (e.g. hour or minute). For instance, using a pattern of 'DD-HH' would not make sense as the hour component represents a fraction of the day. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "dailyNoteMediumTitlePattern", "Daily note medium title pattern").setDesc(
      "The pattern used to render links to daily notes where the destination note falls in a different year then the current note. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a day (e.g. hour or minute). For instance, using a pattern of 'DD-HH' would not make sense as the hour component represents a fraction of the day. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "weeklyNoteTitlePattern", "Weekly note title pattern").setDesc(
      "The pattern used to render the title of a weekly note. This pattern should not render any date/time elements shorter than a week (e.g. day or hour). For instance, using a pattern of 'WW-DD' would not make sense as the day component represents a fraction of the week. PLEASE NOTE: for weekly patterns 'gg' or 'gggg' should be used to reflect the yearFor help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "weeklyNoteShortTitlePattern", "Weekly note short title pattern").setDesc(
      "The pattern used to render links to weekly notes. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a week (e.g. day or hour). For instance, using a pattern of 'WW-DD' would not make sense as the day component represents a fraction of the week. PLEASE NOTE: for weekly patterns 'gg' or 'gggg' should be used to reflect the yearFor help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "weeklyNoteMediumTitlePattern", "Weekly note medium title pattern").setDesc(
      "The pattern used to render links to weekly notes where the destination note falls in a different year then the current note. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a week (e.g. day or hour). For instance, using a pattern of 'WW-DD' would not make sense as the day component represents a fraction of the week. PLEASE NOTE: for weekly patterns 'gg' or 'gggg' should be used to reflect the yearFor help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "monthlyNoteTitlePattern", "Monthly note title pattern").setDesc(
      "The pattern used to render the title of a monthly note. This pattern should not render any date/time elements shorter than a month (e.g. week or day). For instance, using a pattern of 'MM-DD' would not make sense as the day component represents a fraction of the month. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "monthlyNoteShortTitlePattern", "Monthly note short title pattern").setDesc(
      "The pattern used to render links to monthly notes. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a month (e.g. week or day). For instance, using a pattern of 'MM-DD' would not make sense as the day component represents a fraction of the month. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "monthlyNoteMediumTitlePattern", "Monthly note medium title pattern").setDesc(
      "The pattern used to render links to monthly notes where the destination note falls in a different year then the current note. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a month (e.g. week or day). For instance, using a pattern of 'MM-DD' would not make sense as the day component represents a fraction of the month. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "yearlyNoteTitlePattern", "Yearly note title pattern").setDesc(
      "The pattern used to render the title of a yearly note. This pattern should not render any date/time elements shorter than a year (e.g. month, week or day). For instance, using a pattern of 'YYYY-MM' would not make sense as the month component represents a fraction of the year. For help on the pattern syntax, refer to the link below."
    );
    this.createMomentSetting(settings, "yearlyNoteShortTitlePattern", "Yearly note short title pattern").setDesc(
      "The pattern used to render links to yearly notes. The user should aim to keep this pattern short as multiple links may be rendered next to each other. This pattern should not render any date/time elements shorter than a year (e.g. month, week or day). For instance, using a pattern of 'YYYY-MM' would not make sense as the month component represents a fraction of the year. For help on the pattern syntax, refer to the link below."
    );
    new import_obsidian3.Setting(this.containerEl).setName("Reset all to default values").addButton((btn) => {
      btn.setIcon("reset").setWarning().onClick(() => {
        this.saveSettings(DEFAULT_SETTINGS).then(() => this.display());
      });
    });
  }
  createMomentSetting(settings, fieldName, name) {
    let component2;
    const sampleValueEl = document.createElement("div");
    sampleValueEl.addClass("journal-folder-config-sample-value");
    const setting = new import_obsidian3.Setting(this.containerEl).setName(name).addMomentFormat((text2) => {
      component2 = text2;
      const onChange = (0, import_obsidian3.debounce)(
        (value) => {
          settings[fieldName] = value;
          this.saveSettings(settings);
        },
        250,
        true
      );
      text2.setDefaultFormat(DEFAULT_SETTINGS[fieldName]);
      text2.setValue(settings[fieldName]).onChange(onChange);
      text2.setSampleEl(sampleValueEl);
    }).addExtraButton((btn) => {
      btn.setIcon("reset").setTooltip("Reset to default value").onClick(() => {
        component2.setValue(DEFAULT_SETTINGS[fieldName]);
        component2.onChanged();
      });
    });
    const sampleEl = document.createElement("div");
    sampleEl.addClass("journal-folder-config-hints-row");
    const helpLinkEl = document.createElement("a");
    helpLinkEl.setAttribute("href", "https://momentjs.com/docs/#/displaying/format/");
    helpLinkEl.innerText = "Pattern syntax reference";
    helpLinkEl.addClass("journal-folder-config-syntax-reference-link");
    const sampleLabelEl = document.createElement("div");
    sampleLabelEl.addClass("journal-folder-config-sample-label");
    sampleLabelEl.setText("Sample value:");
    sampleEl.appendChild(helpLinkEl);
    sampleEl.appendChild(sampleLabelEl);
    sampleEl.appendChild(sampleValueEl);
    this.containerEl.appendChild(sampleEl);
    return setting;
  }
};

// src/features/journal-folder-settings/journal-folder-settings-feature.ts
var JournalFolderSettingsFeature = class extends PluginFeature {
  constructor(plugin, propagateSettings) {
    super(plugin);
    this.propagateSettings = propagateSettings;
    this.saveSettings = async (settings) => {
      await this.plugin.saveData(settings);
      this.propagateSettings(settings);
    };
    this.updateSettingsFromStorage = async () => {
      const settings = { ...this.settings, ...await this.plugin.loadData() };
      await this.saveSettings(settings);
    };
    this.onExternalSettingsChange = this.updateSettingsFromStorage;
    this.useSettings(DEFAULT_SETTINGS);
  }
  async load() {
    await this.updateSettingsFromStorage();
    this.plugin.addSettingTab(
      new JournalFolderSettingsTab(
        this.plugin,
        () => this.settings,
        this.saveSettings
      )
    );
  }
};

// src/plugin/journal-folder-plugin.ts
var _features;
var JournalFolderPlugin = class extends import_obsidian4.Plugin {
  constructor(app, manifest) {
    super(app, manifest);
    __privateAdd(this, _features, new PluginFeatureSet());
    this.onExternalSettingsChange = __privateGet(this, _features).onExternalSettingsChange;
    this.onload = __privateGet(this, _features).load;
    this.unload = __privateGet(this, _features).unload;
    __privateGet(this, _features).addFeature(new JournalFolderSettingsFeature(this, __privateGet(this, _features).useSettings)).addFeature(new JournalHeaderFeature(this));
  }
};
_features = new WeakMap();
