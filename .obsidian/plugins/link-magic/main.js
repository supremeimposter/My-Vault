/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LinkMagicPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {};
var LinkMagicPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new SettingTab(this.app, this));
    const onKeyEvent = (evt) => {
      if (!evt.shiftKey) {
        const mdFile = this.app.workspace.activeEditor;
        if (mdFile == null ? void 0 : mdFile.editor) {
          this.triggerSnippet(mdFile.editor, evt);
        }
      }
    };
    this.registerDomEvent(document, "keydown", onKeyEvent);
    this.registerEvent(this.app.workspace.on("window-open", (event) => {
      this.registerDomEvent(activeWindow, "keydown", onKeyEvent);
    }));
  }
  onunload() {
    console.log("Unloading plugin.");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  checkForMatch(editor, pos) {
    let curPos = pos ? pos : editor.getCursor();
    const editorView = editor.cm;
    let line = editor.getLine(curPos.line);
    let word = "";
    let i = curPos.ch - 1;
    while (i >= 0 && line[i] !== " ") {
      word = line[i] + word;
      i--;
    }
    if (RegExp("([.*](.*))", "g").test(word)) {
      return;
    }
    Object.values(this.settings).filter(({ pattern, link }) => pattern && link).some(({ pattern, link }) => {
      const regex = RegExp(pattern, "g");
      if (regex.test(word)) {
        const enclosingRegex = /^(\()?(.*?)(\))?$/;
        let match = enclosingRegex.exec(word);
        if (match) {
          const startChar = match[1] || "";
          const innerWord = match[2];
          const endChar = match[3] || "";
          let markdownLink = `${startChar}[${innerWord}](${link.replace("{pattern}", innerWord)})${endChar}`;
          editor.replaceRange(markdownLink, { line: curPos.line, ch: curPos.ch - word.length }, curPos);
        }
      }
    });
  }
  handleEnter(editor, pos) {
    let curPos = pos ? pos : editor.getCursor();
    let lineAbove = editor.getLine(curPos.line - 1);
    this.checkForMatch(editor, { line: curPos.line - 1, ch: lineAbove.length });
  }
  handleTab(editor, pos) {
    let curPos = pos ? pos : editor.getCursor();
    editor.getLine(curPos.line).trimStart();
  }
  triggerSnippet(editor, evt) {
    switch (evt.key) {
      case " ": {
        this.checkForMatch(editor);
        break;
      }
      case "Tab": {
        this.handleTab(editor);
        break;
      }
      case "Enter": {
        this.handleEnter(editor);
        break;
      }
      default: {
        break;
      }
    }
  }
};
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    let settingName = "";
    new import_obsidian.Setting(containerEl).setName("Add a new rule").addText((text) => {
      text.setPlaceholder("Rule Name").onChange((value) => {
        settingName = value;
      });
    }).addButton((button) => {
      button.setButtonText("+").onClick(async () => {
        if (!settingName) {
          return;
        }
        this.plugin.settings = {
          ...this.plugin.settings,
          [settingName]: {
            pattern: "",
            link: ""
          }
        };
        await this.plugin.saveSettings();
        this.display();
      });
    });
    Object.keys(this.plugin.settings).forEach((key) => {
      new import_obsidian.Setting(containerEl).setName(key).addText((text) => {
        text.setPlaceholder("Pattern").setValue(this.plugin.settings[key].pattern).onChange(async (value) => {
          this.plugin.settings[key].pattern = value;
          await this.plugin.saveSettings();
        });
      }).addText((text) => {
        text.setPlaceholder("Link").setValue(this.plugin.settings[key].link).onChange(async (value) => {
          this.plugin.settings[key].link = value;
          await this.plugin.saveSettings();
        });
      }).addButton((button) => {
        button.setButtonText("-").onClick(async () => {
          this.plugin.settings = Object.keys(this.plugin.settings).filter((settingsKey) => settingsKey !== key).reduce(
            (settings, settingsKey) => ({
              ...settings,
              [settingsKey]: this.plugin.settings[settingsKey]
            }),
            {}
          );
          await this.plugin.saveSettings();
          this.display();
        });
      });
    });
  }
};

/* nosourcemap */