/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __copyProps = (to, from2, except, desc) => {
  if (from2 && typeof from2 === "object" || typeof from2 === "function") {
    for (let key of __getOwnPropNames(from2))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from2[key], enumerable: !(desc = __getOwnPropDesc(from2, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cuint/lib/uint32.js
var require_uint32 = __commonJS({
  "node_modules/cuint/lib/uint32.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        36: UINT32(Math.pow(36, 5)),
        16: UINT32(Math.pow(16, 7)),
        10: UINT32(Math.pow(10, 9)),
        2: UINT32(Math.pow(2, 30))
      };
      var radixCache = {
        36: UINT32(36),
        16: UINT32(16),
        10: UINT32(10),
        2: UINT32(2)
      };
      function UINT32(l, h) {
        if (!(this instanceof UINT32))
          return new UINT32(l, h);
        this._low = 0;
        this._high = 0;
        this.remainder = null;
        if (typeof h == "undefined")
          return fromNumber.call(this, l);
        if (typeof l == "string")
          return fromString.call(this, l, h);
        fromBits.call(this, l, h);
      }
      function fromBits(l, h) {
        this._low = l | 0;
        this._high = h | 0;
        return this;
      }
      UINT32.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        var value = parseInt(s, radix || 10);
        this._low = value & 65535;
        this._high = value >>> 16;
        return this;
      }
      UINT32.prototype.fromString = fromString;
      UINT32.prototype.toNumber = function() {
        return this._high * 65536 + this._low;
      };
      UINT32.prototype.toString = function(radix) {
        return this.toNumber().toString(radix || 10);
      };
      UINT32.prototype.add = function(other) {
        var a00 = this._low + other._low;
        var a16 = a00 >>> 16;
        a16 += this._high + other._high;
        this._low = a00 & 65535;
        this._high = a16 & 65535;
        return this;
      };
      UINT32.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT32.prototype.multiply = function(other) {
        var a16 = this._high;
        var a00 = this._low;
        var b16 = other._high;
        var b00 = other._low;
        var c16, c00;
        c00 = a00 * b00;
        c16 = c00 >>> 16;
        c16 += a16 * b00;
        c16 &= 65535;
        c16 += a00 * b16;
        this._low = c00 & 65535;
        this._high = c16 & 65535;
        return this;
      };
      UINT32.prototype.div = function(other) {
        if (other._low == 0 && other._high == 0)
          throw Error("division by zero");
        if (other._high == 0 && other._low == 1) {
          this.remainder = new UINT32(0);
          return this;
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._low = 0;
          this._high = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT32(0);
          this._low = 1;
          this._high = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._low = 0;
        this._high = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 16) {
              this._high |= 1 << i - 16;
            } else {
              this._low |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT32.prototype.negate = function() {
        var v = (~this._low & 65535) + 1;
        this._low = v & 65535;
        this._high = ~this._high + (v >>> 16) & 65535;
        return this;
      };
      UINT32.prototype.equals = UINT32.prototype.eq = function(other) {
        return this._low == other._low && this._high == other._high;
      };
      UINT32.prototype.greaterThan = UINT32.prototype.gt = function(other) {
        if (this._high > other._high)
          return true;
        if (this._high < other._high)
          return false;
        return this._low > other._low;
      };
      UINT32.prototype.lessThan = UINT32.prototype.lt = function(other) {
        if (this._high < other._high)
          return true;
        if (this._high > other._high)
          return false;
        return this._low < other._low;
      };
      UINT32.prototype.or = function(other) {
        this._low |= other._low;
        this._high |= other._high;
        return this;
      };
      UINT32.prototype.and = function(other) {
        this._low &= other._low;
        this._high &= other._high;
        return this;
      };
      UINT32.prototype.not = function() {
        this._low = ~this._low & 65535;
        this._high = ~this._high & 65535;
        return this;
      };
      UINT32.prototype.xor = function(other) {
        this._low ^= other._low;
        this._high ^= other._high;
        return this;
      };
      UINT32.prototype.shiftRight = UINT32.prototype.shiftr = function(n) {
        if (n > 16) {
          this._low = this._high >> n - 16;
          this._high = 0;
        } else if (n == 16) {
          this._low = this._high;
          this._high = 0;
        } else {
          this._low = this._low >> n | this._high << 16 - n & 65535;
          this._high >>= n;
        }
        return this;
      };
      UINT32.prototype.shiftLeft = UINT32.prototype.shiftl = function(n, allowOverflow) {
        if (n > 16) {
          this._high = this._low << n - 16;
          this._low = 0;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        } else if (n == 16) {
          this._high = this._low;
          this._low = 0;
        } else {
          this._high = this._high << n | this._low >> 16 - n;
          this._low = this._low << n & 65535;
          if (!allowOverflow) {
            this._high &= 65535;
          }
        }
        return this;
      };
      UINT32.prototype.rotateLeft = UINT32.prototype.rotl = function(n) {
        var v = this._high << 16 | this._low;
        v = v << n | v >>> 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.rotateRight = UINT32.prototype.rotr = function(n) {
        var v = this._high << 16 | this._low;
        v = v >>> n | v << 32 - n;
        this._low = v & 65535;
        this._high = v >>> 16;
        return this;
      };
      UINT32.prototype.clone = function() {
        return new UINT32(this._low, this._high);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT32;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT32;
      } else {
        root["UINT32"] = UINT32;
      }
    })(exports);
  }
});

// node_modules/cuint/lib/uint64.js
var require_uint64 = __commonJS({
  "node_modules/cuint/lib/uint64.js"(exports, module2) {
    (function(root) {
      var radixPowerCache = {
        16: UINT64(Math.pow(16, 5)),
        10: UINT64(Math.pow(10, 5)),
        2: UINT64(Math.pow(2, 5))
      };
      var radixCache = {
        16: UINT64(16),
        10: UINT64(10),
        2: UINT64(2)
      };
      function UINT64(a00, a16, a32, a48) {
        if (!(this instanceof UINT64))
          return new UINT64(a00, a16, a32, a48);
        this.remainder = null;
        if (typeof a00 == "string")
          return fromString.call(this, a00, a16);
        if (typeof a16 == "undefined")
          return fromNumber.call(this, a00);
        fromBits.apply(this, arguments);
      }
      function fromBits(a00, a16, a32, a48) {
        if (typeof a32 == "undefined") {
          this._a00 = a00 & 65535;
          this._a16 = a00 >>> 16;
          this._a32 = a16 & 65535;
          this._a48 = a16 >>> 16;
          return this;
        }
        this._a00 = a00 | 0;
        this._a16 = a16 | 0;
        this._a32 = a32 | 0;
        this._a48 = a48 | 0;
        return this;
      }
      UINT64.prototype.fromBits = fromBits;
      function fromNumber(value) {
        this._a00 = value & 65535;
        this._a16 = value >>> 16;
        this._a32 = 0;
        this._a48 = 0;
        return this;
      }
      UINT64.prototype.fromNumber = fromNumber;
      function fromString(s, radix) {
        radix = radix || 10;
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        var radixUint = radixPowerCache[radix] || new UINT64(Math.pow(radix, 5));
        for (var i = 0, len = s.length; i < len; i += 5) {
          var size2 = Math.min(5, len - i);
          var value = parseInt(s.slice(i, i + size2), radix);
          this.multiply(
            size2 < 5 ? new UINT64(Math.pow(radix, size2)) : radixUint
          ).add(new UINT64(value));
        }
        return this;
      }
      UINT64.prototype.fromString = fromString;
      UINT64.prototype.toNumber = function() {
        return this._a16 * 65536 + this._a00;
      };
      UINT64.prototype.toString = function(radix) {
        radix = radix || 10;
        var radixUint = radixCache[radix] || new UINT64(radix);
        if (!this.gt(radixUint))
          return this.toNumber().toString(radix);
        var self2 = this.clone();
        var res = new Array(64);
        for (var i = 63; i >= 0; i--) {
          self2.div(radixUint);
          res[i] = self2.remainder.toNumber().toString(radix);
          if (!self2.gt(radixUint))
            break;
        }
        res[i - 1] = self2.toNumber().toString(radix);
        return res.join("");
      };
      UINT64.prototype.add = function(other) {
        var a00 = this._a00 + other._a00;
        var a16 = a00 >>> 16;
        a16 += this._a16 + other._a16;
        var a32 = a16 >>> 16;
        a32 += this._a32 + other._a32;
        var a48 = a32 >>> 16;
        a48 += this._a48 + other._a48;
        this._a00 = a00 & 65535;
        this._a16 = a16 & 65535;
        this._a32 = a32 & 65535;
        this._a48 = a48 & 65535;
        return this;
      };
      UINT64.prototype.subtract = function(other) {
        return this.add(other.clone().negate());
      };
      UINT64.prototype.multiply = function(other) {
        var a00 = this._a00;
        var a16 = this._a16;
        var a32 = this._a32;
        var a48 = this._a48;
        var b00 = other._a00;
        var b16 = other._a16;
        var b32 = other._a32;
        var b48 = other._a48;
        var c00 = a00 * b00;
        var c16 = c00 >>> 16;
        c16 += a00 * b16;
        var c32 = c16 >>> 16;
        c16 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c32 += a00 * b32;
        var c48 = c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c48 += a00 * b48;
        c48 &= 65535;
        c48 += a16 * b32;
        c48 &= 65535;
        c48 += a32 * b16;
        c48 &= 65535;
        c48 += a48 * b00;
        this._a00 = c00 & 65535;
        this._a16 = c16 & 65535;
        this._a32 = c32 & 65535;
        this._a48 = c48 & 65535;
        return this;
      };
      UINT64.prototype.div = function(other) {
        if (other._a16 == 0 && other._a32 == 0 && other._a48 == 0) {
          if (other._a00 == 0)
            throw Error("division by zero");
          if (other._a00 == 1) {
            this.remainder = new UINT64(0);
            return this;
          }
        }
        if (other.gt(this)) {
          this.remainder = this.clone();
          this._a00 = 0;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        if (this.eq(other)) {
          this.remainder = new UINT64(0);
          this._a00 = 1;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
          return this;
        }
        var _other = other.clone();
        var i = -1;
        while (!this.lt(_other)) {
          _other.shiftLeft(1, true);
          i++;
        }
        this.remainder = this.clone();
        this._a00 = 0;
        this._a16 = 0;
        this._a32 = 0;
        this._a48 = 0;
        for (; i >= 0; i--) {
          _other.shiftRight(1);
          if (!this.remainder.lt(_other)) {
            this.remainder.subtract(_other);
            if (i >= 48) {
              this._a48 |= 1 << i - 48;
            } else if (i >= 32) {
              this._a32 |= 1 << i - 32;
            } else if (i >= 16) {
              this._a16 |= 1 << i - 16;
            } else {
              this._a00 |= 1 << i;
            }
          }
        }
        return this;
      };
      UINT64.prototype.negate = function() {
        var v = (~this._a00 & 65535) + 1;
        this._a00 = v & 65535;
        v = (~this._a16 & 65535) + (v >>> 16);
        this._a16 = v & 65535;
        v = (~this._a32 & 65535) + (v >>> 16);
        this._a32 = v & 65535;
        this._a48 = ~this._a48 + (v >>> 16) & 65535;
        return this;
      };
      UINT64.prototype.equals = UINT64.prototype.eq = function(other) {
        return this._a48 == other._a48 && this._a00 == other._a00 && this._a32 == other._a32 && this._a16 == other._a16;
      };
      UINT64.prototype.greaterThan = UINT64.prototype.gt = function(other) {
        if (this._a48 > other._a48)
          return true;
        if (this._a48 < other._a48)
          return false;
        if (this._a32 > other._a32)
          return true;
        if (this._a32 < other._a32)
          return false;
        if (this._a16 > other._a16)
          return true;
        if (this._a16 < other._a16)
          return false;
        return this._a00 > other._a00;
      };
      UINT64.prototype.lessThan = UINT64.prototype.lt = function(other) {
        if (this._a48 < other._a48)
          return true;
        if (this._a48 > other._a48)
          return false;
        if (this._a32 < other._a32)
          return true;
        if (this._a32 > other._a32)
          return false;
        if (this._a16 < other._a16)
          return true;
        if (this._a16 > other._a16)
          return false;
        return this._a00 < other._a00;
      };
      UINT64.prototype.or = function(other) {
        this._a00 |= other._a00;
        this._a16 |= other._a16;
        this._a32 |= other._a32;
        this._a48 |= other._a48;
        return this;
      };
      UINT64.prototype.and = function(other) {
        this._a00 &= other._a00;
        this._a16 &= other._a16;
        this._a32 &= other._a32;
        this._a48 &= other._a48;
        return this;
      };
      UINT64.prototype.xor = function(other) {
        this._a00 ^= other._a00;
        this._a16 ^= other._a16;
        this._a32 ^= other._a32;
        this._a48 ^= other._a48;
        return this;
      };
      UINT64.prototype.not = function() {
        this._a00 = ~this._a00 & 65535;
        this._a16 = ~this._a16 & 65535;
        this._a32 = ~this._a32 & 65535;
        this._a48 = ~this._a48 & 65535;
        return this;
      };
      UINT64.prototype.shiftRight = UINT64.prototype.shiftr = function(n) {
        n %= 64;
        if (n >= 48) {
          this._a00 = this._a48 >> n - 48;
          this._a16 = 0;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a00 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a16 = this._a48 >> n & 65535;
          this._a32 = 0;
          this._a48 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a00 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a16 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a32 = this._a48 >> n & 65535;
          this._a48 = 0;
        } else {
          this._a00 = (this._a00 >> n | this._a16 << 16 - n) & 65535;
          this._a16 = (this._a16 >> n | this._a32 << 16 - n) & 65535;
          this._a32 = (this._a32 >> n | this._a48 << 16 - n) & 65535;
          this._a48 = this._a48 >> n & 65535;
        }
        return this;
      };
      UINT64.prototype.shiftLeft = UINT64.prototype.shiftl = function(n, allowOverflow) {
        n %= 64;
        if (n >= 48) {
          this._a48 = this._a00 << n - 48;
          this._a32 = 0;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 32) {
          n -= 32;
          this._a48 = this._a16 << n | this._a00 >> 16 - n;
          this._a32 = this._a00 << n & 65535;
          this._a16 = 0;
          this._a00 = 0;
        } else if (n >= 16) {
          n -= 16;
          this._a48 = this._a32 << n | this._a16 >> 16 - n;
          this._a32 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a16 = this._a00 << n & 65535;
          this._a00 = 0;
        } else {
          this._a48 = this._a48 << n | this._a32 >> 16 - n;
          this._a32 = (this._a32 << n | this._a16 >> 16 - n) & 65535;
          this._a16 = (this._a16 << n | this._a00 >> 16 - n) & 65535;
          this._a00 = this._a00 << n & 65535;
        }
        if (!allowOverflow) {
          this._a48 &= 65535;
        }
        return this;
      };
      UINT64.prototype.rotateLeft = UINT64.prototype.rotl = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high << n | low >>> 32 - n;
        var _low = low << n | high >>> 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.rotateRight = UINT64.prototype.rotr = function(n) {
        n %= 64;
        if (n == 0)
          return this;
        if (n >= 32) {
          var v = this._a00;
          this._a00 = this._a32;
          this._a32 = v;
          v = this._a48;
          this._a48 = this._a16;
          this._a16 = v;
          if (n == 32)
            return this;
          n -= 32;
        }
        var high = this._a48 << 16 | this._a32;
        var low = this._a16 << 16 | this._a00;
        var _high = high >>> n | low << 32 - n;
        var _low = low >>> n | high << 32 - n;
        this._a00 = _low & 65535;
        this._a16 = _low >>> 16;
        this._a32 = _high & 65535;
        this._a48 = _high >>> 16;
        return this;
      };
      UINT64.prototype.clone = function() {
        return new UINT64(this._a00, this._a16, this._a32, this._a48);
      };
      if (typeof define != "undefined" && define.amd) {
        define([], function() {
          return UINT64;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = UINT64;
      } else {
        root["UINT64"] = UINT64;
      }
    })(exports);
  }
});

// node_modules/cuint/index.js
var require_cuint = __commonJS({
  "node_modules/cuint/index.js"(exports) {
    exports.UINT32 = require_uint32();
    exports.UINT64 = require_uint64();
  }
});

// node_modules/xxhashjs/lib/xxhash.js
var require_xxhash = __commonJS({
  "node_modules/xxhashjs/lib/xxhash.js"(exports, module2) {
    var UINT32 = require_cuint().UINT32;
    UINT32.prototype.xxh_update = function(low, high) {
      var b00 = PRIME32_2._low;
      var b16 = PRIME32_2._high;
      var c16, c00;
      c00 = low * b00;
      c16 = c00 >>> 16;
      c16 += high * b00;
      c16 &= 65535;
      c16 += low * b16;
      var a00 = this._low + (c00 & 65535);
      var a16 = a00 >>> 16;
      a16 += this._high + (c16 & 65535);
      var v = a16 << 16 | a00 & 65535;
      v = v << 13 | v >>> 19;
      a00 = v & 65535;
      a16 = v >>> 16;
      b00 = PRIME32_1._low;
      b16 = PRIME32_1._high;
      c00 = a00 * b00;
      c16 = c00 >>> 16;
      c16 += a16 * b00;
      c16 &= 65535;
      c16 += a00 * b16;
      this._low = c00 & 65535;
      this._high = c16 & 65535;
    };
    var PRIME32_1 = UINT32("2654435761");
    var PRIME32_2 = UINT32("2246822519");
    var PRIME32_3 = UINT32("3266489917");
    var PRIME32_4 = UINT32("668265263");
    var PRIME32_5 = UINT32("374761393");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH2() {
      if (arguments.length == 2)
        return new XXH2(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH2))
        return new XXH2(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT32 ? seed.clone() : UINT32(seed);
      this.v1 = this.seed.clone().add(PRIME32_1).add(PRIME32_2);
      this.v2 = this.seed.clone().add(PRIME32_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME32_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH2.prototype.init = init;
    XXH2.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(16);
        } else {
          this.memory = new Buffer(16);
        }
      }
      if (this.memsize + len < 16) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 16 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 16 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 16 - this.memsize);
        }
        var p32 = 0;
        if (isString) {
          this.v1.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory.charCodeAt(p32 + 1) << 8 | this.memory.charCodeAt(p32),
            this.memory.charCodeAt(p32 + 3) << 8 | this.memory.charCodeAt(p32 + 2)
          );
        } else {
          this.v1.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v2.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v3.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
          p32 += 4;
          this.v4.xxh_update(
            this.memory[p32 + 1] << 8 | this.memory[p32],
            this.memory[p32 + 3] << 8 | this.memory[p32 + 2]
          );
        }
        p += 16 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 16) {
        var limit = bEnd - 16;
        do {
          if (isString) {
            this.v1.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v2.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v3.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
            p += 4;
            this.v4.xxh_update(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
            );
          } else {
            this.v1.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v2.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v3.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
            p += 4;
            this.v4.xxh_update(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2]
            );
          }
          p += 4;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH2.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h322, h;
      var u = new UINT32();
      if (this.total_len >= 16) {
        h322 = this.v1.rotl(1).add(this.v2.rotl(7).add(this.v3.rotl(12).add(this.v4.rotl(18))));
      } else {
        h322 = this.seed.clone().add(PRIME32_5);
      }
      h322.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 4) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2]
          );
        }
        h322.add(u.multiply(PRIME32_3)).rotl(17).multiply(PRIME32_4);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0);
        h322.add(u.multiply(PRIME32_5)).rotl(11).multiply(PRIME32_1);
      }
      h = h322.clone().shiftRight(15);
      h322.xor(h).multiply(PRIME32_2);
      h = h322.clone().shiftRight(13);
      h322.xor(h).multiply(PRIME32_3);
      h = h322.clone().shiftRight(16);
      h322.xor(h);
      this.init(this.seed);
      return h322;
    };
    module2.exports = XXH2;
  }
});

// node_modules/xxhashjs/lib/xxhash64.js
var require_xxhash64 = __commonJS({
  "node_modules/xxhashjs/lib/xxhash64.js"(exports, module2) {
    var UINT64 = require_cuint().UINT64;
    var PRIME64_1 = UINT64("11400714785074694791");
    var PRIME64_2 = UINT64("14029467366897019727");
    var PRIME64_3 = UINT64("1609587929392839161");
    var PRIME64_4 = UINT64("9650029242287828579");
    var PRIME64_5 = UINT64("2870177450012600261");
    function toUTF8Array(str) {
      var utf8 = [];
      for (var i = 0, n = str.length; i < n; i++) {
        var charcode = str.charCodeAt(i);
        if (charcode < 128)
          utf8.push(charcode);
        else if (charcode < 2048) {
          utf8.push(
            192 | charcode >> 6,
            128 | charcode & 63
          );
        } else if (charcode < 55296 || charcode >= 57344) {
          utf8.push(
            224 | charcode >> 12,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        } else {
          i++;
          charcode = 65536 + ((charcode & 1023) << 10 | str.charCodeAt(i) & 1023);
          utf8.push(
            240 | charcode >> 18,
            128 | charcode >> 12 & 63,
            128 | charcode >> 6 & 63,
            128 | charcode & 63
          );
        }
      }
      return new Uint8Array(utf8);
    }
    function XXH64() {
      if (arguments.length == 2)
        return new XXH64(arguments[1]).update(arguments[0]).digest();
      if (!(this instanceof XXH64))
        return new XXH64(arguments[0]);
      init.call(this, arguments[0]);
    }
    function init(seed) {
      this.seed = seed instanceof UINT64 ? seed.clone() : UINT64(seed);
      this.v1 = this.seed.clone().add(PRIME64_1).add(PRIME64_2);
      this.v2 = this.seed.clone().add(PRIME64_2);
      this.v3 = this.seed.clone();
      this.v4 = this.seed.clone().subtract(PRIME64_1);
      this.total_len = 0;
      this.memsize = 0;
      this.memory = null;
      return this;
    }
    XXH64.prototype.init = init;
    XXH64.prototype.update = function(input) {
      var isString = typeof input == "string";
      var isArrayBuffer;
      if (isString) {
        input = toUTF8Array(input);
        isString = false;
        isArrayBuffer = true;
      }
      if (typeof ArrayBuffer !== "undefined" && input instanceof ArrayBuffer) {
        isArrayBuffer = true;
        input = new Uint8Array(input);
      }
      var p = 0;
      var len = input.length;
      var bEnd = p + len;
      if (len == 0)
        return this;
      this.total_len += len;
      if (this.memsize == 0) {
        if (isString) {
          this.memory = "";
        } else if (isArrayBuffer) {
          this.memory = new Uint8Array(32);
        } else {
          this.memory = new Buffer(32);
        }
      }
      if (this.memsize + len < 32) {
        if (isString) {
          this.memory += input;
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, len), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, len);
        }
        this.memsize += len;
        return this;
      }
      if (this.memsize > 0) {
        if (isString) {
          this.memory += input.slice(0, 32 - this.memsize);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(0, 32 - this.memsize), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, 0, 32 - this.memsize);
        }
        var p64 = 0;
        if (isString) {
          var other;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory.charCodeAt(p64 + 1) << 8 | this.memory.charCodeAt(p64),
            this.memory.charCodeAt(p64 + 3) << 8 | this.memory.charCodeAt(p64 + 2),
            this.memory.charCodeAt(p64 + 5) << 8 | this.memory.charCodeAt(p64 + 4),
            this.memory.charCodeAt(p64 + 7) << 8 | this.memory.charCodeAt(p64 + 6)
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        } else {
          var other;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          p64 += 8;
          other = UINT64(
            this.memory[p64 + 1] << 8 | this.memory[p64],
            this.memory[p64 + 3] << 8 | this.memory[p64 + 2],
            this.memory[p64 + 5] << 8 | this.memory[p64 + 4],
            this.memory[p64 + 7] << 8 | this.memory[p64 + 6]
          );
          this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
        }
        p += 32 - this.memsize;
        this.memsize = 0;
        if (isString)
          this.memory = "";
      }
      if (p <= bEnd - 32) {
        var limit = bEnd - 32;
        do {
          if (isString) {
            var other;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
              input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
              input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
              input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          } else {
            var other;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v1.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v2.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v3.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
            p += 8;
            other = UINT64(
              input[p + 1] << 8 | input[p],
              input[p + 3] << 8 | input[p + 2],
              input[p + 5] << 8 | input[p + 4],
              input[p + 7] << 8 | input[p + 6]
            );
            this.v4.add(other.multiply(PRIME64_2)).rotl(31).multiply(PRIME64_1);
          }
          p += 8;
        } while (p <= limit);
      }
      if (p < bEnd) {
        if (isString) {
          this.memory += input.slice(p);
        } else if (isArrayBuffer) {
          this.memory.set(input.subarray(p, bEnd), this.memsize);
        } else {
          input.copy(this.memory, this.memsize, p, bEnd);
        }
        this.memsize = bEnd - p;
      }
      return this;
    };
    XXH64.prototype.digest = function() {
      var input = this.memory;
      var isString = typeof input == "string";
      var p = 0;
      var bEnd = this.memsize;
      var h64, h;
      var u = new UINT64();
      if (this.total_len >= 32) {
        h64 = this.v1.clone().rotl(1);
        h64.add(this.v2.clone().rotl(7));
        h64.add(this.v3.clone().rotl(12));
        h64.add(this.v4.clone().rotl(18));
        h64.xor(this.v1.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v2.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v3.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
        h64.xor(this.v4.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1));
        h64.multiply(PRIME64_1).add(PRIME64_4);
      } else {
        h64 = this.seed.clone().add(PRIME64_5);
      }
      h64.add(u.fromNumber(this.total_len));
      while (p <= bEnd - 8) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            input.charCodeAt(p + 5) << 8 | input.charCodeAt(p + 4),
            input.charCodeAt(p + 7) << 8 | input.charCodeAt(p + 6)
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            input[p + 5] << 8 | input[p + 4],
            input[p + 7] << 8 | input[p + 6]
          );
        }
        u.multiply(PRIME64_2).rotl(31).multiply(PRIME64_1);
        h64.xor(u).rotl(27).multiply(PRIME64_1).add(PRIME64_4);
        p += 8;
      }
      if (p + 4 <= bEnd) {
        if (isString) {
          u.fromBits(
            input.charCodeAt(p + 1) << 8 | input.charCodeAt(p),
            input.charCodeAt(p + 3) << 8 | input.charCodeAt(p + 2),
            0,
            0
          );
        } else {
          u.fromBits(
            input[p + 1] << 8 | input[p],
            input[p + 3] << 8 | input[p + 2],
            0,
            0
          );
        }
        h64.xor(u.multiply(PRIME64_1)).rotl(23).multiply(PRIME64_2).add(PRIME64_3);
        p += 4;
      }
      while (p < bEnd) {
        u.fromBits(isString ? input.charCodeAt(p++) : input[p++], 0, 0, 0);
        h64.xor(u.multiply(PRIME64_5)).rotl(11).multiply(PRIME64_1);
      }
      h = h64.clone().shiftRight(33);
      h64.xor(h).multiply(PRIME64_2);
      h = h64.clone().shiftRight(29);
      h64.xor(h).multiply(PRIME64_3);
      h = h64.clone().shiftRight(32);
      h64.xor(h);
      this.init(this.seed);
      return h64;
    };
    module2.exports = XXH64;
  }
});

// node_modules/xxhashjs/lib/index.js
var require_lib = __commonJS({
  "node_modules/xxhashjs/lib/index.js"(exports, module2) {
    module2.exports = {
      h32: require_xxhash(),
      h64: require_xxhash64()
    };
  }
});

// node_modules/simple-peer/simplepeer.min.js
var require_simplepeer_min = __commonJS({
  "node_modules/simple-peer/simplepeer.min.js"(exports, module2) {
    (function(e) {
      if ("object" == typeof exports && "undefined" != typeof module2)
        module2.exports = e();
      else if ("function" == typeof define && define.amd)
        define([], e);
      else {
        var t;
        t = "undefined" == typeof window ? "undefined" == typeof global ? "undefined" == typeof self ? this : self : global : window, t.SimplePeer = e();
      }
    })(function() {
      var t = Math.floor, n = Math.abs, r = Math.pow;
      return function() {
        function d(s, e, n2) {
          function t2(o, i) {
            if (!e[o]) {
              if (!s[o]) {
                var l = "function" == typeof require && require;
                if (!i && l)
                  return l(o, true);
                if (r2)
                  return r2(o, true);
                var c = new Error("Cannot find module '" + o + "'");
                throw c.code = "MODULE_NOT_FOUND", c;
              }
              var a2 = e[o] = { exports: {} };
              s[o][0].call(a2.exports, function(e2) {
                var r3 = s[o][1][e2];
                return t2(r3 || e2);
              }, a2, a2.exports, d, s, e, n2);
            }
            return e[o].exports;
          }
          for (var r2 = "function" == typeof require && require, a = 0; a < n2.length; a++)
            t2(n2[a]);
          return t2;
        }
        return d;
      }()({ 1: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          var t3 = e2.length;
          if (0 < t3 % 4)
            throw new Error("Invalid string. Length must be a multiple of 4");
          var n3 = e2.indexOf("=");
          -1 === n3 && (n3 = t3);
          var r3 = n3 === t3 ? 0 : 4 - n3 % 4;
          return [n3, r3];
        }
        function a(e2, t3, n3) {
          return 3 * (t3 + n3) / 4 - n3;
        }
        function o(e2) {
          var t3, n3, o2 = r2(e2), d2 = o2[0], s2 = o2[1], l2 = new p(a(e2, d2, s2)), c2 = 0, f2 = 0 < s2 ? d2 - 4 : d2;
          for (n3 = 0; n3 < f2; n3 += 4)
            t3 = u[e2.charCodeAt(n3)] << 18 | u[e2.charCodeAt(n3 + 1)] << 12 | u[e2.charCodeAt(n3 + 2)] << 6 | u[e2.charCodeAt(n3 + 3)], l2[c2++] = 255 & t3 >> 16, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3;
          return 2 === s2 && (t3 = u[e2.charCodeAt(n3)] << 2 | u[e2.charCodeAt(n3 + 1)] >> 4, l2[c2++] = 255 & t3), 1 === s2 && (t3 = u[e2.charCodeAt(n3)] << 10 | u[e2.charCodeAt(n3 + 1)] << 4 | u[e2.charCodeAt(n3 + 2)] >> 2, l2[c2++] = 255 & t3 >> 8, l2[c2++] = 255 & t3), l2;
        }
        function d(e2) {
          return c[63 & e2 >> 18] + c[63 & e2 >> 12] + c[63 & e2 >> 6] + c[63 & e2];
        }
        function s(e2, t3, n3) {
          for (var r3, a2 = [], o2 = t3; o2 < n3; o2 += 3)
            r3 = (16711680 & e2[o2] << 16) + (65280 & e2[o2 + 1] << 8) + (255 & e2[o2 + 2]), a2.push(d(r3));
          return a2.join("");
        }
        function l(e2) {
          for (var t3, n3 = e2.length, r3 = n3 % 3, a2 = [], o2 = 16383, d2 = 0, l2 = n3 - r3; d2 < l2; d2 += o2)
            a2.push(s(e2, d2, d2 + o2 > l2 ? l2 : d2 + o2));
          return 1 === r3 ? (t3 = e2[n3 - 1], a2.push(c[t3 >> 2] + c[63 & t3 << 4] + "==")) : 2 === r3 && (t3 = (e2[n3 - 2] << 8) + e2[n3 - 1], a2.push(c[t3 >> 10] + c[63 & t3 >> 4] + c[63 & t3 << 2] + "=")), a2.join("");
        }
        n2.byteLength = function(e2) {
          var t3 = r2(e2), n3 = t3[0], a2 = t3[1];
          return 3 * (n3 + a2) / 4 - a2;
        }, n2.toByteArray = o, n2.fromByteArray = l;
        for (var c = [], u = [], p = "undefined" == typeof Uint8Array ? Array : Uint8Array, f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", g = 0, _ = f.length; g < _; ++g)
          c[g] = f[g], u[f.charCodeAt(g)] = g;
        u[45] = 62, u[95] = 63;
      }, {}], 2: [function() {
      }, {}], 3: [function(e, t2, n2) {
        (function() {
          (function() {
            "use strict";
            var t3 = String.fromCharCode, o = Math.min;
            function d(e2) {
              if (2147483647 < e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
              var t4 = new Uint8Array(e2);
              return t4.__proto__ = s.prototype, t4;
            }
            function s(e2, t4, n3) {
              if ("number" == typeof e2) {
                if ("string" == typeof t4)
                  throw new TypeError('The "string" argument must be of type string. Received type number');
                return p(e2);
              }
              return l(e2, t4, n3);
            }
            function l(e2, t4, n3) {
              if ("string" == typeof e2)
                return f(e2, t4);
              if (ArrayBuffer.isView(e2))
                return g(e2);
              if (null == e2)
                throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
              if (K(e2, ArrayBuffer) || e2 && K(e2.buffer, ArrayBuffer))
                return _(e2, t4, n3);
              if ("number" == typeof e2)
                throw new TypeError('The "value" argument must not be of type number. Received type number');
              var r2 = e2.valueOf && e2.valueOf();
              if (null != r2 && r2 !== e2)
                return s.from(r2, t4, n3);
              var a = h(e2);
              if (a)
                return a;
              if ("undefined" != typeof Symbol && null != Symbol.toPrimitive && "function" == typeof e2[Symbol.toPrimitive])
                return s.from(e2[Symbol.toPrimitive]("string"), t4, n3);
              throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
            }
            function c(e2) {
              if ("number" != typeof e2)
                throw new TypeError('"size" argument must be of type number');
              else if (0 > e2)
                throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
            }
            function u(e2, t4, n3) {
              return c(e2), 0 >= e2 ? d(e2) : void 0 === t4 ? d(e2) : "string" == typeof n3 ? d(e2).fill(t4, n3) : d(e2).fill(t4);
            }
            function p(e2) {
              return c(e2), d(0 > e2 ? 0 : 0 | m(e2));
            }
            function f(e2, t4) {
              if (("string" != typeof t4 || "" === t4) && (t4 = "utf8"), !s.isEncoding(t4))
                throw new TypeError("Unknown encoding: " + t4);
              var n3 = 0 | b(e2, t4), r2 = d(n3), a = r2.write(e2, t4);
              return a !== n3 && (r2 = r2.slice(0, a)), r2;
            }
            function g(e2) {
              for (var t4 = 0 > e2.length ? 0 : 0 | m(e2.length), n3 = d(t4), r2 = 0; r2 < t4; r2 += 1)
                n3[r2] = 255 & e2[r2];
              return n3;
            }
            function _(e2, t4, n3) {
              if (0 > t4 || e2.byteLength < t4)
                throw new RangeError('"offset" is outside of buffer bounds');
              if (e2.byteLength < t4 + (n3 || 0))
                throw new RangeError('"length" is outside of buffer bounds');
              var r2;
              return r2 = void 0 === t4 && void 0 === n3 ? new Uint8Array(e2) : void 0 === n3 ? new Uint8Array(e2, t4) : new Uint8Array(e2, t4, n3), r2.__proto__ = s.prototype, r2;
            }
            function h(e2) {
              if (s.isBuffer(e2)) {
                var t4 = 0 | m(e2.length), n3 = d(t4);
                return 0 === n3.length ? n3 : (e2.copy(n3, 0, 0, t4), n3);
              }
              return void 0 === e2.length ? "Buffer" === e2.type && Array.isArray(e2.data) ? g(e2.data) : void 0 : "number" != typeof e2.length || X(e2.length) ? d(0) : g(e2);
            }
            function m(e2) {
              if (e2 >= 2147483647)
                throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + 2147483647 .toString(16) + " bytes");
              return 0 | e2;
            }
            function b(e2, t4) {
              if (s.isBuffer(e2))
                return e2.length;
              if (ArrayBuffer.isView(e2) || K(e2, ArrayBuffer))
                return e2.byteLength;
              if ("string" != typeof e2)
                throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
              var n3 = e2.length, r2 = 2 < arguments.length && true === arguments[2];
              if (!r2 && 0 === n3)
                return 0;
              for (var a = false; ; )
                switch (t4) {
                  case "ascii":
                  case "latin1":
                  case "binary":
                    return n3;
                  case "utf8":
                  case "utf-8":
                    return H(e2).length;
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return 2 * n3;
                  case "hex":
                    return n3 >>> 1;
                  case "base64":
                    return z(e2).length;
                  default:
                    if (a)
                      return r2 ? -1 : H(e2).length;
                    t4 = ("" + t4).toLowerCase(), a = true;
                }
            }
            function y(e2, t4, n3) {
              var r2 = false;
              if ((void 0 === t4 || 0 > t4) && (t4 = 0), t4 > this.length)
                return "";
              if ((void 0 === n3 || n3 > this.length) && (n3 = this.length), 0 >= n3)
                return "";
              if (n3 >>>= 0, t4 >>>= 0, n3 <= t4)
                return "";
              for (e2 || (e2 = "utf8"); ; )
                switch (e2) {
                  case "hex":
                    return P(this, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return x(this, t4, n3);
                  case "ascii":
                    return D(this, t4, n3);
                  case "latin1":
                  case "binary":
                    return I(this, t4, n3);
                  case "base64":
                    return A(this, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return M(this, t4, n3);
                  default:
                    if (r2)
                      throw new TypeError("Unknown encoding: " + e2);
                    e2 = (e2 + "").toLowerCase(), r2 = true;
                }
            }
            function C(e2, t4, n3) {
              var r2 = e2[t4];
              e2[t4] = e2[n3], e2[n3] = r2;
            }
            function R(e2, t4, n3, r2, a) {
              if (0 === e2.length)
                return -1;
              if ("string" == typeof n3 ? (r2 = n3, n3 = 0) : 2147483647 < n3 ? n3 = 2147483647 : -2147483648 > n3 && (n3 = -2147483648), n3 = +n3, X(n3) && (n3 = a ? 0 : e2.length - 1), 0 > n3 && (n3 = e2.length + n3), n3 >= e2.length) {
                if (a)
                  return -1;
                n3 = e2.length - 1;
              } else if (0 > n3)
                if (a)
                  n3 = 0;
                else
                  return -1;
              if ("string" == typeof t4 && (t4 = s.from(t4, r2)), s.isBuffer(t4))
                return 0 === t4.length ? -1 : E(e2, t4, n3, r2, a);
              if ("number" == typeof t4)
                return t4 &= 255, "function" == typeof Uint8Array.prototype.indexOf ? a ? Uint8Array.prototype.indexOf.call(e2, t4, n3) : Uint8Array.prototype.lastIndexOf.call(e2, t4, n3) : E(e2, [t4], n3, r2, a);
              throw new TypeError("val must be string, number or Buffer");
            }
            function E(e2, t4, n3, r2, a) {
              function o2(e3, t5) {
                return 1 === d2 ? e3[t5] : e3.readUInt16BE(t5 * d2);
              }
              var d2 = 1, s2 = e2.length, l2 = t4.length;
              if (void 0 !== r2 && (r2 = (r2 + "").toLowerCase(), "ucs2" === r2 || "ucs-2" === r2 || "utf16le" === r2 || "utf-16le" === r2)) {
                if (2 > e2.length || 2 > t4.length)
                  return -1;
                d2 = 2, s2 /= 2, l2 /= 2, n3 /= 2;
              }
              var c2;
              if (a) {
                var u2 = -1;
                for (c2 = n3; c2 < s2; c2++)
                  if (o2(e2, c2) !== o2(t4, -1 === u2 ? 0 : c2 - u2))
                    -1 !== u2 && (c2 -= c2 - u2), u2 = -1;
                  else if (-1 === u2 && (u2 = c2), c2 - u2 + 1 === l2)
                    return u2 * d2;
              } else
                for (n3 + l2 > s2 && (n3 = s2 - l2), c2 = n3; 0 <= c2; c2--) {
                  for (var p2 = true, f2 = 0; f2 < l2; f2++)
                    if (o2(e2, c2 + f2) !== o2(t4, f2)) {
                      p2 = false;
                      break;
                    }
                  if (p2)
                    return c2;
                }
              return -1;
            }
            function w(e2, t4, n3, r2) {
              n3 = +n3 || 0;
              var a = e2.length - n3;
              r2 ? (r2 = +r2, r2 > a && (r2 = a)) : r2 = a;
              var o2 = t4.length;
              r2 > o2 / 2 && (r2 = o2 / 2);
              for (var d2, s2 = 0; s2 < r2; ++s2) {
                if (d2 = parseInt(t4.substr(2 * s2, 2), 16), X(d2))
                  return s2;
                e2[n3 + s2] = d2;
              }
              return s2;
            }
            function S(e2, t4, n3, r2) {
              return G(H(t4, e2.length - n3), e2, n3, r2);
            }
            function T(e2, t4, n3, r2) {
              return G(Y(t4), e2, n3, r2);
            }
            function v(e2, t4, n3, r2) {
              return T(e2, t4, n3, r2);
            }
            function k(e2, t4, n3, r2) {
              return G(z(t4), e2, n3, r2);
            }
            function L(e2, t4, n3, r2) {
              return G(V(t4, e2.length - n3), e2, n3, r2);
            }
            function A(e2, t4, n3) {
              return 0 === t4 && n3 === e2.length ? $.fromByteArray(e2) : $.fromByteArray(e2.slice(t4, n3));
            }
            function x(e2, t4, n3) {
              n3 = o(e2.length, n3);
              for (var r2 = [], a = t4; a < n3; ) {
                var d2 = e2[a], s2 = null, l2 = 239 < d2 ? 4 : 223 < d2 ? 3 : 191 < d2 ? 2 : 1;
                if (a + l2 <= n3) {
                  var c2, u2, p2, f2;
                  1 === l2 ? 128 > d2 && (s2 = d2) : 2 === l2 ? (c2 = e2[a + 1], 128 == (192 & c2) && (f2 = (31 & d2) << 6 | 63 & c2, 127 < f2 && (s2 = f2))) : 3 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], 128 == (192 & c2) && 128 == (192 & u2) && (f2 = (15 & d2) << 12 | (63 & c2) << 6 | 63 & u2, 2047 < f2 && (55296 > f2 || 57343 < f2) && (s2 = f2))) : 4 === l2 ? (c2 = e2[a + 1], u2 = e2[a + 2], p2 = e2[a + 3], 128 == (192 & c2) && 128 == (192 & u2) && 128 == (192 & p2) && (f2 = (15 & d2) << 18 | (63 & c2) << 12 | (63 & u2) << 6 | 63 & p2, 65535 < f2 && 1114112 > f2 && (s2 = f2))) : void 0;
                }
                null === s2 ? (s2 = 65533, l2 = 1) : 65535 < s2 && (s2 -= 65536, r2.push(55296 | 1023 & s2 >>> 10), s2 = 56320 | 1023 & s2), r2.push(s2), a += l2;
              }
              return N(r2);
            }
            function N(e2) {
              var n3 = e2.length;
              if (n3 <= 4096)
                return t3.apply(String, e2);
              for (var r2 = "", a = 0; a < n3; )
                r2 += t3.apply(String, e2.slice(a, a += 4096));
              return r2;
            }
            function D(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(127 & e2[d2]);
              return a;
            }
            function I(e2, n3, r2) {
              var a = "";
              r2 = o(e2.length, r2);
              for (var d2 = n3; d2 < r2; ++d2)
                a += t3(e2[d2]);
              return a;
            }
            function P(e2, t4, n3) {
              var r2 = e2.length;
              (!t4 || 0 > t4) && (t4 = 0), (!n3 || 0 > n3 || n3 > r2) && (n3 = r2);
              for (var a = "", o2 = t4; o2 < n3; ++o2)
                a += W(e2[o2]);
              return a;
            }
            function M(e2, n3, r2) {
              for (var a = e2.slice(n3, r2), o2 = "", d2 = 0; d2 < a.length; d2 += 2)
                o2 += t3(a[d2] + 256 * a[d2 + 1]);
              return o2;
            }
            function O(e2, t4, n3) {
              if (0 != e2 % 1 || 0 > e2)
                throw new RangeError("offset is not uint");
              if (e2 + t4 > n3)
                throw new RangeError("Trying to access beyond buffer length");
            }
            function F(e2, t4, n3, r2, a, o2) {
              if (!s.isBuffer(e2))
                throw new TypeError('"buffer" argument must be a Buffer instance');
              if (t4 > a || t4 < o2)
                throw new RangeError('"value" argument is out of bounds');
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
            }
            function B(e2, t4, n3, r2) {
              if (n3 + r2 > e2.length)
                throw new RangeError("Index out of range");
              if (0 > n3)
                throw new RangeError("Index out of range");
            }
            function U(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 4, 34028234663852886e22, -34028234663852886e22), J.write(e2, t4, n3, r2, 23, 4), n3 + 4;
            }
            function j(e2, t4, n3, r2, a) {
              return t4 = +t4, n3 >>>= 0, a || B(e2, t4, n3, 8, 17976931348623157e292, -17976931348623157e292), J.write(e2, t4, n3, r2, 52, 8), n3 + 8;
            }
            function q(e2) {
              if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Q, ""), 2 > e2.length)
                return "";
              for (; 0 != e2.length % 4; )
                e2 += "=";
              return e2;
            }
            function W(e2) {
              return 16 > e2 ? "0" + e2.toString(16) : e2.toString(16);
            }
            function H(e2, t4) {
              t4 = t4 || 1 / 0;
              for (var n3, r2 = e2.length, a = null, o2 = [], d2 = 0; d2 < r2; ++d2) {
                if (n3 = e2.charCodeAt(d2), 55295 < n3 && 57344 > n3) {
                  if (!a) {
                    if (56319 < n3) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    } else if (d2 + 1 === r2) {
                      -1 < (t4 -= 3) && o2.push(239, 191, 189);
                      continue;
                    }
                    a = n3;
                    continue;
                  }
                  if (56320 > n3) {
                    -1 < (t4 -= 3) && o2.push(239, 191, 189), a = n3;
                    continue;
                  }
                  n3 = (a - 55296 << 10 | n3 - 56320) + 65536;
                } else
                  a && -1 < (t4 -= 3) && o2.push(239, 191, 189);
                if (a = null, 128 > n3) {
                  if (0 > (t4 -= 1))
                    break;
                  o2.push(n3);
                } else if (2048 > n3) {
                  if (0 > (t4 -= 2))
                    break;
                  o2.push(192 | n3 >> 6, 128 | 63 & n3);
                } else if (65536 > n3) {
                  if (0 > (t4 -= 3))
                    break;
                  o2.push(224 | n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else if (1114112 > n3) {
                  if (0 > (t4 -= 4))
                    break;
                  o2.push(240 | n3 >> 18, 128 | 63 & n3 >> 12, 128 | 63 & n3 >> 6, 128 | 63 & n3);
                } else
                  throw new Error("Invalid code point");
              }
              return o2;
            }
            function Y(e2) {
              for (var t4 = [], n3 = 0; n3 < e2.length; ++n3)
                t4.push(255 & e2.charCodeAt(n3));
              return t4;
            }
            function V(e2, t4) {
              for (var n3, r2, a, o2 = [], d2 = 0; d2 < e2.length && !(0 > (t4 -= 2)); ++d2)
                n3 = e2.charCodeAt(d2), r2 = n3 >> 8, a = n3 % 256, o2.push(a), o2.push(r2);
              return o2;
            }
            function z(e2) {
              return $.toByteArray(q(e2));
            }
            function G(e2, t4, n3, r2) {
              for (var a = 0; a < r2 && !(a + n3 >= t4.length || a >= e2.length); ++a)
                t4[a + n3] = e2[a];
              return a;
            }
            function K(e2, t4) {
              return e2 instanceof t4 || null != e2 && null != e2.constructor && null != e2.constructor.name && e2.constructor.name === t4.name;
            }
            function X(e2) {
              return e2 !== e2;
            }
            var $ = e("base64-js"), J = e("ieee754");
            n2.Buffer = s, n2.SlowBuffer = function(e2) {
              return +e2 != e2 && (e2 = 0), s.alloc(+e2);
            }, n2.INSPECT_MAX_BYTES = 50;
            n2.kMaxLength = 2147483647, s.TYPED_ARRAY_SUPPORT = function() {
              try {
                var e2 = new Uint8Array(1);
                return e2.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                  return 42;
                } }, 42 === e2.foo();
              } catch (t4) {
                return false;
              }
            }(), s.TYPED_ARRAY_SUPPORT || "undefined" == typeof console || "function" != typeof console.error || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(s.prototype, "parent", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.buffer : void 0;
            } }), Object.defineProperty(s.prototype, "offset", { enumerable: true, get: function() {
              return s.isBuffer(this) ? this.byteOffset : void 0;
            } }), "undefined" != typeof Symbol && null != Symbol.species && s[Symbol.species] === s && Object.defineProperty(s, Symbol.species, { value: null, configurable: true, enumerable: false, writable: false }), s.poolSize = 8192, s.from = function(e2, t4, n3) {
              return l(e2, t4, n3);
            }, s.prototype.__proto__ = Uint8Array.prototype, s.__proto__ = Uint8Array, s.alloc = function(e2, t4, n3) {
              return u(e2, t4, n3);
            }, s.allocUnsafe = function(e2) {
              return p(e2);
            }, s.allocUnsafeSlow = function(e2) {
              return p(e2);
            }, s.isBuffer = function(e2) {
              return null != e2 && true === e2._isBuffer && e2 !== s.prototype;
            }, s.compare = function(e2, t4) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), K(t4, Uint8Array) && (t4 = s.from(t4, t4.offset, t4.byteLength)), !s.isBuffer(e2) || !s.isBuffer(t4))
                throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
              if (e2 === t4)
                return 0;
              for (var n3 = e2.length, r2 = t4.length, d2 = 0, l2 = o(n3, r2); d2 < l2; ++d2)
                if (e2[d2] !== t4[d2]) {
                  n3 = e2[d2], r2 = t4[d2];
                  break;
                }
              return n3 < r2 ? -1 : r2 < n3 ? 1 : 0;
            }, s.isEncoding = function(e2) {
              switch ((e2 + "").toLowerCase()) {
                case "hex":
                case "utf8":
                case "utf-8":
                case "ascii":
                case "latin1":
                case "binary":
                case "base64":
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return true;
                default:
                  return false;
              }
            }, s.concat = function(e2, t4) {
              if (!Array.isArray(e2))
                throw new TypeError('"list" argument must be an Array of Buffers');
              if (0 === e2.length)
                return s.alloc(0);
              var n3;
              if (t4 === void 0)
                for (t4 = 0, n3 = 0; n3 < e2.length; ++n3)
                  t4 += e2[n3].length;
              var r2 = s.allocUnsafe(t4), a = 0;
              for (n3 = 0; n3 < e2.length; ++n3) {
                var o2 = e2[n3];
                if (K(o2, Uint8Array) && (o2 = s.from(o2)), !s.isBuffer(o2))
                  throw new TypeError('"list" argument must be an Array of Buffers');
                o2.copy(r2, a), a += o2.length;
              }
              return r2;
            }, s.byteLength = b, s.prototype._isBuffer = true, s.prototype.swap16 = function() {
              var e2 = this.length;
              if (0 != e2 % 2)
                throw new RangeError("Buffer size must be a multiple of 16-bits");
              for (var t4 = 0; t4 < e2; t4 += 2)
                C(this, t4, t4 + 1);
              return this;
            }, s.prototype.swap32 = function() {
              var e2 = this.length;
              if (0 != e2 % 4)
                throw new RangeError("Buffer size must be a multiple of 32-bits");
              for (var t4 = 0; t4 < e2; t4 += 4)
                C(this, t4, t4 + 3), C(this, t4 + 1, t4 + 2);
              return this;
            }, s.prototype.swap64 = function() {
              var e2 = this.length;
              if (0 != e2 % 8)
                throw new RangeError("Buffer size must be a multiple of 64-bits");
              for (var t4 = 0; t4 < e2; t4 += 8)
                C(this, t4, t4 + 7), C(this, t4 + 1, t4 + 6), C(this, t4 + 2, t4 + 5), C(this, t4 + 3, t4 + 4);
              return this;
            }, s.prototype.toString = function() {
              var e2 = this.length;
              return 0 === e2 ? "" : 0 === arguments.length ? x(this, 0, e2) : y.apply(this, arguments);
            }, s.prototype.toLocaleString = s.prototype.toString, s.prototype.equals = function(e2) {
              if (!s.isBuffer(e2))
                throw new TypeError("Argument must be a Buffer");
              return this === e2 || 0 === s.compare(this, e2);
            }, s.prototype.inspect = function() {
              var e2 = "", t4 = n2.INSPECT_MAX_BYTES;
              return e2 = this.toString("hex", 0, t4).replace(/(.{2})/g, "$1 ").trim(), this.length > t4 && (e2 += " ... "), "<Buffer " + e2 + ">";
            }, s.prototype.compare = function(e2, t4, n3, r2, a) {
              if (K(e2, Uint8Array) && (e2 = s.from(e2, e2.offset, e2.byteLength)), !s.isBuffer(e2))
                throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e2);
              if (void 0 === t4 && (t4 = 0), void 0 === n3 && (n3 = e2 ? e2.length : 0), void 0 === r2 && (r2 = 0), void 0 === a && (a = this.length), 0 > t4 || n3 > e2.length || 0 > r2 || a > this.length)
                throw new RangeError("out of range index");
              if (r2 >= a && t4 >= n3)
                return 0;
              if (r2 >= a)
                return -1;
              if (t4 >= n3)
                return 1;
              if (t4 >>>= 0, n3 >>>= 0, r2 >>>= 0, a >>>= 0, this === e2)
                return 0;
              for (var d2 = a - r2, l2 = n3 - t4, c2 = o(d2, l2), u2 = this.slice(r2, a), p2 = e2.slice(t4, n3), f2 = 0; f2 < c2; ++f2)
                if (u2[f2] !== p2[f2]) {
                  d2 = u2[f2], l2 = p2[f2];
                  break;
                }
              return d2 < l2 ? -1 : l2 < d2 ? 1 : 0;
            }, s.prototype.includes = function(e2, t4, n3) {
              return -1 !== this.indexOf(e2, t4, n3);
            }, s.prototype.indexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, true);
            }, s.prototype.lastIndexOf = function(e2, t4, n3) {
              return R(this, e2, t4, n3, false);
            }, s.prototype.write = function(e2, t4, n3, r2) {
              if (void 0 === t4)
                r2 = "utf8", n3 = this.length, t4 = 0;
              else if (void 0 === n3 && "string" == typeof t4)
                r2 = t4, n3 = this.length, t4 = 0;
              else if (isFinite(t4))
                t4 >>>= 0, isFinite(n3) ? (n3 >>>= 0, void 0 === r2 && (r2 = "utf8")) : (r2 = n3, n3 = void 0);
              else
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              var a = this.length - t4;
              if ((void 0 === n3 || n3 > a) && (n3 = a), 0 < e2.length && (0 > n3 || 0 > t4) || t4 > this.length)
                throw new RangeError("Attempt to write outside buffer bounds");
              r2 || (r2 = "utf8");
              for (var o2 = false; ; )
                switch (r2) {
                  case "hex":
                    return w(this, e2, t4, n3);
                  case "utf8":
                  case "utf-8":
                    return S(this, e2, t4, n3);
                  case "ascii":
                    return T(this, e2, t4, n3);
                  case "latin1":
                  case "binary":
                    return v(this, e2, t4, n3);
                  case "base64":
                    return k(this, e2, t4, n3);
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return L(this, e2, t4, n3);
                  default:
                    if (o2)
                      throw new TypeError("Unknown encoding: " + r2);
                    r2 = ("" + r2).toLowerCase(), o2 = true;
                }
            }, s.prototype.toJSON = function() {
              return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
            };
            s.prototype.slice = function(e2, t4) {
              var n3 = this.length;
              e2 = ~~e2, t4 = t4 === void 0 ? n3 : ~~t4, 0 > e2 ? (e2 += n3, 0 > e2 && (e2 = 0)) : e2 > n3 && (e2 = n3), 0 > t4 ? (t4 += n3, 0 > t4 && (t4 = 0)) : t4 > n3 && (t4 = n3), t4 < e2 && (t4 = e2);
              var r2 = this.subarray(e2, t4);
              return r2.__proto__ = s.prototype, r2;
            }, s.prototype.readUIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2], a = 1, o2 = 0; ++o2 < t4 && (a *= 256); )
                r2 += this[e2 + o2] * a;
              return r2;
            }, s.prototype.readUIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var r2 = this[e2 + --t4], a = 1; 0 < t4 && (a *= 256); )
                r2 += this[e2 + --t4] * a;
              return r2;
            }, s.prototype.readUInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), this[e2];
            }, s.prototype.readUInt16LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] | this[e2 + 1] << 8;
            }, s.prototype.readUInt16BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 2, this.length), this[e2] << 8 | this[e2 + 1];
            }, s.prototype.readUInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), (this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16) + 16777216 * this[e2 + 3];
            }, s.prototype.readUInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), 16777216 * this[e2] + (this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3]);
            }, s.prototype.readIntLE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = this[e2], o2 = 1, d2 = 0; ++d2 < t4 && (o2 *= 256); )
                a += this[e2 + d2] * o2;
              return o2 *= 128, a >= o2 && (a -= r(2, 8 * t4)), a;
            }, s.prototype.readIntBE = function(e2, t4, n3) {
              e2 >>>= 0, t4 >>>= 0, n3 || O(e2, t4, this.length);
              for (var a = t4, o2 = 1, d2 = this[e2 + --a]; 0 < a && (o2 *= 256); )
                d2 += this[e2 + --a] * o2;
              return o2 *= 128, d2 >= o2 && (d2 -= r(2, 8 * t4)), d2;
            }, s.prototype.readInt8 = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 1, this.length), 128 & this[e2] ? -1 * (255 - this[e2] + 1) : this[e2];
            }, s.prototype.readInt16LE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2] | this[e2 + 1] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt16BE = function(e2, t4) {
              e2 >>>= 0, t4 || O(e2, 2, this.length);
              var n3 = this[e2 + 1] | this[e2] << 8;
              return 32768 & n3 ? 4294901760 | n3 : n3;
            }, s.prototype.readInt32LE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] | this[e2 + 1] << 8 | this[e2 + 2] << 16 | this[e2 + 3] << 24;
            }, s.prototype.readInt32BE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), this[e2] << 24 | this[e2 + 1] << 16 | this[e2 + 2] << 8 | this[e2 + 3];
            }, s.prototype.readFloatLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, true, 23, 4);
            }, s.prototype.readFloatBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 4, this.length), J.read(this, e2, false, 23, 4);
            }, s.prototype.readDoubleLE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, true, 52, 8);
            }, s.prototype.readDoubleBE = function(e2, t4) {
              return e2 >>>= 0, t4 || O(e2, 8, this.length), J.read(this, e2, false, 52, 8);
            }, s.prototype.writeUIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = 1, s2 = 0;
              for (this[t4] = 255 & e2; ++s2 < n3 && (d2 *= 256); )
                this[t4 + s2] = 255 & e2 / d2;
              return t4 + n3;
            }, s.prototype.writeUIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, n3 >>>= 0, !a) {
                var o2 = r(2, 8 * n3) - 1;
                F(this, e2, t4, n3, o2, 0);
              }
              var d2 = n3 - 1, s2 = 1;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                this[t4 + d2] = 255 & e2 / s2;
              return t4 + n3;
            }, s.prototype.writeUInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 255, 0), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeUInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeUInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 65535, 0), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeUInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4 + 3] = e2 >>> 24, this[t4 + 2] = e2 >>> 16, this[t4 + 1] = e2 >>> 8, this[t4] = 255 & e2, t4 + 4;
            }, s.prototype.writeUInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 4294967295, 0), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeIntLE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = 0, s2 = 1, l2 = 0;
              for (this[t4] = 255 & e2; ++d2 < n3 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 - 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeIntBE = function(e2, t4, n3, a) {
              if (e2 = +e2, t4 >>>= 0, !a) {
                var o2 = r(2, 8 * n3 - 1);
                F(this, e2, t4, n3, o2 - 1, -o2);
              }
              var d2 = n3 - 1, s2 = 1, l2 = 0;
              for (this[t4 + d2] = 255 & e2; 0 <= --d2 && (s2 *= 256); )
                0 > e2 && 0 === l2 && 0 !== this[t4 + d2 + 1] && (l2 = 1), this[t4 + d2] = 255 & (e2 / s2 >> 0) - l2;
              return t4 + n3;
            }, s.prototype.writeInt8 = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 1, 127, -128), 0 > e2 && (e2 = 255 + e2 + 1), this[t4] = 255 & e2, t4 + 1;
            }, s.prototype.writeInt16LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, t4 + 2;
            }, s.prototype.writeInt16BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 2, 32767, -32768), this[t4] = e2 >>> 8, this[t4 + 1] = 255 & e2, t4 + 2;
            }, s.prototype.writeInt32LE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), this[t4] = 255 & e2, this[t4 + 1] = e2 >>> 8, this[t4 + 2] = e2 >>> 16, this[t4 + 3] = e2 >>> 24, t4 + 4;
            }, s.prototype.writeInt32BE = function(e2, t4, n3) {
              return e2 = +e2, t4 >>>= 0, n3 || F(this, e2, t4, 4, 2147483647, -2147483648), 0 > e2 && (e2 = 4294967295 + e2 + 1), this[t4] = e2 >>> 24, this[t4 + 1] = e2 >>> 16, this[t4 + 2] = e2 >>> 8, this[t4 + 3] = 255 & e2, t4 + 4;
            }, s.prototype.writeFloatLE = function(e2, t4, n3) {
              return U(this, e2, t4, true, n3);
            }, s.prototype.writeFloatBE = function(e2, t4, n3) {
              return U(this, e2, t4, false, n3);
            }, s.prototype.writeDoubleLE = function(e2, t4, n3) {
              return j(this, e2, t4, true, n3);
            }, s.prototype.writeDoubleBE = function(e2, t4, n3) {
              return j(this, e2, t4, false, n3);
            }, s.prototype.copy = function(e2, t4, n3, r2) {
              if (!s.isBuffer(e2))
                throw new TypeError("argument should be a Buffer");
              if (n3 || (n3 = 0), r2 || 0 === r2 || (r2 = this.length), t4 >= e2.length && (t4 = e2.length), t4 || (t4 = 0), 0 < r2 && r2 < n3 && (r2 = n3), r2 === n3)
                return 0;
              if (0 === e2.length || 0 === this.length)
                return 0;
              if (0 > t4)
                throw new RangeError("targetStart out of bounds");
              if (0 > n3 || n3 >= this.length)
                throw new RangeError("Index out of range");
              if (0 > r2)
                throw new RangeError("sourceEnd out of bounds");
              r2 > this.length && (r2 = this.length), e2.length - t4 < r2 - n3 && (r2 = e2.length - t4 + n3);
              var a = r2 - n3;
              if (this === e2 && "function" == typeof Uint8Array.prototype.copyWithin)
                this.copyWithin(t4, n3, r2);
              else if (this === e2 && n3 < t4 && t4 < r2)
                for (var o2 = a - 1; 0 <= o2; --o2)
                  e2[o2 + t4] = this[o2 + n3];
              else
                Uint8Array.prototype.set.call(e2, this.subarray(n3, r2), t4);
              return a;
            }, s.prototype.fill = function(e2, t4, n3, r2) {
              if ("string" == typeof e2) {
                if ("string" == typeof t4 ? (r2 = t4, t4 = 0, n3 = this.length) : "string" == typeof n3 && (r2 = n3, n3 = this.length), void 0 !== r2 && "string" != typeof r2)
                  throw new TypeError("encoding must be a string");
                if ("string" == typeof r2 && !s.isEncoding(r2))
                  throw new TypeError("Unknown encoding: " + r2);
                if (1 === e2.length) {
                  var a = e2.charCodeAt(0);
                  ("utf8" === r2 && 128 > a || "latin1" === r2) && (e2 = a);
                }
              } else
                "number" == typeof e2 && (e2 &= 255);
              if (0 > t4 || this.length < t4 || this.length < n3)
                throw new RangeError("Out of range index");
              if (n3 <= t4)
                return this;
              t4 >>>= 0, n3 = n3 === void 0 ? this.length : n3 >>> 0, e2 || (e2 = 0);
              var o2;
              if ("number" == typeof e2)
                for (o2 = t4; o2 < n3; ++o2)
                  this[o2] = e2;
              else {
                var d2 = s.isBuffer(e2) ? e2 : s.from(e2, r2), l2 = d2.length;
                if (0 === l2)
                  throw new TypeError('The value "' + e2 + '" is invalid for argument "value"');
                for (o2 = 0; o2 < n3 - t4; ++o2)
                  this[o2 + t4] = d2[o2 % l2];
              }
              return this;
            };
            var Q = /[^+/0-9A-Za-z-_]/g;
          }).call(this);
        }).call(this, e("buffer").Buffer);
      }, { "base64-js": 1, buffer: 3, ieee754: 9 }], 4: [function(e, t2, n2) {
        (function(a) {
          (function() {
            function r2() {
              let e2;
              try {
                e2 = n2.storage.getItem("debug");
              } catch (e3) {
              }
              return !e2 && "undefined" != typeof a && "env" in a && (e2 = a.env.DEBUG), e2;
            }
            n2.formatArgs = function(e2) {
              if (e2[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + e2[0] + (this.useColors ? "%c " : " ") + "+" + t2.exports.humanize(this.diff), !this.useColors)
                return;
              const n3 = "color: " + this.color;
              e2.splice(1, 0, n3, "color: inherit");
              let r3 = 0, a2 = 0;
              e2[0].replace(/%[a-zA-Z%]/g, (e3) => {
                "%%" === e3 || (r3++, "%c" === e3 && (a2 = r3));
              }), e2.splice(a2, 0, n3);
            }, n2.save = function(e2) {
              try {
                e2 ? n2.storage.setItem("debug", e2) : n2.storage.removeItem("debug");
              } catch (e3) {
              }
            }, n2.load = r2, n2.useColors = function() {
              return !!("undefined" != typeof window && window.process && ("renderer" === window.process.type || window.process.__nwjs)) || !("undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) && ("undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
            }, n2.storage = function() {
              try {
                return localStorage;
              } catch (e2) {
              }
            }(), n2.destroy = (() => {
              let e2 = false;
              return () => {
                e2 || (e2 = true, console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."));
              };
            })(), n2.colors = ["#0000CC", "#0000FF", "#0033CC", "#0033FF", "#0066CC", "#0066FF", "#0099CC", "#0099FF", "#00CC00", "#00CC33", "#00CC66", "#00CC99", "#00CCCC", "#00CCFF", "#3300CC", "#3300FF", "#3333CC", "#3333FF", "#3366CC", "#3366FF", "#3399CC", "#3399FF", "#33CC00", "#33CC33", "#33CC66", "#33CC99", "#33CCCC", "#33CCFF", "#6600CC", "#6600FF", "#6633CC", "#6633FF", "#66CC00", "#66CC33", "#9900CC", "#9900FF", "#9933CC", "#9933FF", "#99CC00", "#99CC33", "#CC0000", "#CC0033", "#CC0066", "#CC0099", "#CC00CC", "#CC00FF", "#CC3300", "#CC3333", "#CC3366", "#CC3399", "#CC33CC", "#CC33FF", "#CC6600", "#CC6633", "#CC9900", "#CC9933", "#CCCC00", "#CCCC33", "#FF0000", "#FF0033", "#FF0066", "#FF0099", "#FF00CC", "#FF00FF", "#FF3300", "#FF3333", "#FF3366", "#FF3399", "#FF33CC", "#FF33FF", "#FF6600", "#FF6633", "#FF9900", "#FF9933", "#FFCC00", "#FFCC33"], n2.log = console.debug || console.log || (() => {
            }), t2.exports = e("./common")(n2);
            const { formatters: o } = t2.exports;
            o.j = function(e2) {
              try {
                return JSON.stringify(e2);
              } catch (e3) {
                return "[UnexpectedJSONParseError]: " + e3.message;
              }
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./common": 5, _process: 12 }], 5: [function(e, t2) {
        t2.exports = function(t3) {
          function r2(e2) {
            function t4(...e3) {
              if (!t4.enabled)
                return;
              const a2 = t4, o3 = +new Date(), i = o3 - (n2 || o3);
              a2.diff = i, a2.prev = n2, a2.curr = o3, n2 = o3, e3[0] = r2.coerce(e3[0]), "string" != typeof e3[0] && e3.unshift("%O");
              let d = 0;
              e3[0] = e3[0].replace(/%([a-zA-Z%])/g, (t5, n3) => {
                if ("%%" === t5)
                  return "%";
                d++;
                const o4 = r2.formatters[n3];
                if ("function" == typeof o4) {
                  const n4 = e3[d];
                  t5 = o4.call(a2, n4), e3.splice(d, 1), d--;
                }
                return t5;
              }), r2.formatArgs.call(a2, e3);
              const s = a2.log || r2.log;
              s.apply(a2, e3);
            }
            let n2, o2 = null;
            return t4.namespace = e2, t4.useColors = r2.useColors(), t4.color = r2.selectColor(e2), t4.extend = a, t4.destroy = r2.destroy, Object.defineProperty(t4, "enabled", { enumerable: true, configurable: false, get: () => null === o2 ? r2.enabled(e2) : o2, set: (e3) => {
              o2 = e3;
            } }), "function" == typeof r2.init && r2.init(t4), t4;
          }
          function a(e2, t4) {
            const n2 = r2(this.namespace + ("undefined" == typeof t4 ? ":" : t4) + e2);
            return n2.log = this.log, n2;
          }
          function o(e2) {
            return e2.toString().substring(2, e2.toString().length - 2).replace(/\.\*\?$/, "*");
          }
          return r2.debug = r2, r2.default = r2, r2.coerce = function(e2) {
            return e2 instanceof Error ? e2.stack || e2.message : e2;
          }, r2.disable = function() {
            const e2 = [...r2.names.map(o), ...r2.skips.map(o).map((e3) => "-" + e3)].join(",");
            return r2.enable(""), e2;
          }, r2.enable = function(e2) {
            r2.save(e2), r2.names = [], r2.skips = [];
            let t4;
            const n2 = ("string" == typeof e2 ? e2 : "").split(/[\s,]+/), a2 = n2.length;
            for (t4 = 0; t4 < a2; t4++)
              n2[t4] && (e2 = n2[t4].replace(/\*/g, ".*?"), "-" === e2[0] ? r2.skips.push(new RegExp("^" + e2.substr(1) + "$")) : r2.names.push(new RegExp("^" + e2 + "$")));
          }, r2.enabled = function(e2) {
            if ("*" === e2[e2.length - 1])
              return true;
            let t4, n2;
            for (t4 = 0, n2 = r2.skips.length; t4 < n2; t4++)
              if (r2.skips[t4].test(e2))
                return false;
            for (t4 = 0, n2 = r2.names.length; t4 < n2; t4++)
              if (r2.names[t4].test(e2))
                return true;
            return false;
          }, r2.humanize = e("ms"), r2.destroy = function() {
            console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
          }, Object.keys(t3).forEach((e2) => {
            r2[e2] = t3[e2];
          }), r2.names = [], r2.skips = [], r2.formatters = {}, r2.selectColor = function(e2) {
            let t4 = 0;
            for (let n2 = 0; n2 < e2.length; n2++)
              t4 = (t4 << 5) - t4 + e2.charCodeAt(n2), t4 |= 0;
            return r2.colors[n(t4) % r2.colors.length];
          }, r2.enable(r2.load()), r2;
        };
      }, { ms: 11 }], 6: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          for (const n3 in t3)
            Object.defineProperty(e2, n3, { value: t3[n3], enumerable: true, configurable: true });
          return e2;
        }
        t2.exports = function(e2, t3, r2) {
          if (!e2 || "string" == typeof e2)
            throw new TypeError("Please pass an Error to err-code");
          r2 || (r2 = {}), "object" == typeof t3 && (r2 = t3, t3 = ""), t3 && (r2.code = t3);
          try {
            return n2(e2, r2);
          } catch (t4) {
            r2.message = e2.message, r2.stack = e2.stack;
            const a = function() {
            };
            a.prototype = Object.create(Object.getPrototypeOf(e2));
            const o = n2(new a(), r2);
            return o;
          }
        };
      }, {}], 7: [function(e, t2) {
        "use strict";
        function n2(e2) {
          console && console.warn && console.warn(e2);
        }
        function r2() {
          r2.init.call(this);
        }
        function a(e2) {
          if ("function" != typeof e2)
            throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e2);
        }
        function o(e2) {
          return void 0 === e2._maxListeners ? r2.defaultMaxListeners : e2._maxListeners;
        }
        function i(e2, t3, r3, i2) {
          var d2, s2, l2;
          if (a(r3), s2 = e2._events, void 0 === s2 ? (s2 = e2._events = /* @__PURE__ */ Object.create(null), e2._eventsCount = 0) : (void 0 !== s2.newListener && (e2.emit("newListener", t3, r3.listener ? r3.listener : r3), s2 = e2._events), l2 = s2[t3]), void 0 === l2)
            l2 = s2[t3] = r3, ++e2._eventsCount;
          else if ("function" == typeof l2 ? l2 = s2[t3] = i2 ? [r3, l2] : [l2, r3] : i2 ? l2.unshift(r3) : l2.push(r3), d2 = o(e2), 0 < d2 && l2.length > d2 && !l2.warned) {
            l2.warned = true;
            var c2 = new Error("Possible EventEmitter memory leak detected. " + l2.length + " " + (t3 + " listeners added. Use emitter.setMaxListeners() to increase limit"));
            c2.name = "MaxListenersExceededWarning", c2.emitter = e2, c2.type = t3, c2.count = l2.length, n2(c2);
          }
          return e2;
        }
        function d() {
          if (!this.fired)
            return this.target.removeListener(this.type, this.wrapFn), this.fired = true, 0 === arguments.length ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
        }
        function s(e2, t3, n3) {
          var r3 = { fired: false, wrapFn: void 0, target: e2, type: t3, listener: n3 }, a2 = d.bind(r3);
          return a2.listener = n3, r3.wrapFn = a2, a2;
        }
        function l(e2, t3, n3) {
          var r3 = e2._events;
          if (r3 === void 0)
            return [];
          var a2 = r3[t3];
          return void 0 === a2 ? [] : "function" == typeof a2 ? n3 ? [a2.listener || a2] : [a2] : n3 ? f(a2) : u(a2, a2.length);
        }
        function c(e2) {
          var t3 = this._events;
          if (t3 !== void 0) {
            var n3 = t3[e2];
            if ("function" == typeof n3)
              return 1;
            if (void 0 !== n3)
              return n3.length;
          }
          return 0;
        }
        function u(e2, t3) {
          for (var n3 = Array(t3), r3 = 0; r3 < t3; ++r3)
            n3[r3] = e2[r3];
          return n3;
        }
        function p(e2, t3) {
          for (; t3 + 1 < e2.length; t3++)
            e2[t3] = e2[t3 + 1];
          e2.pop();
        }
        function f(e2) {
          for (var t3 = Array(e2.length), n3 = 0; n3 < t3.length; ++n3)
            t3[n3] = e2[n3].listener || e2[n3];
          return t3;
        }
        function g(e2, t3, n3) {
          "function" == typeof e2.on && _(e2, "error", t3, n3);
        }
        function _(e2, t3, n3, r3) {
          if ("function" == typeof e2.on)
            r3.once ? e2.once(t3, n3) : e2.on(t3, n3);
          else if ("function" == typeof e2.addEventListener)
            e2.addEventListener(t3, function a2(o2) {
              r3.once && e2.removeEventListener(t3, a2), n3(o2);
            });
          else
            throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e2);
        }
        var h, m = "object" == typeof Reflect ? Reflect : null, b = m && "function" == typeof m.apply ? m.apply : function(e2, t3, n3) {
          return Function.prototype.apply.call(e2, t3, n3);
        };
        h = m && "function" == typeof m.ownKeys ? m.ownKeys : Object.getOwnPropertySymbols ? function(e2) {
          return Object.getOwnPropertyNames(e2).concat(Object.getOwnPropertySymbols(e2));
        } : function(e2) {
          return Object.getOwnPropertyNames(e2);
        };
        var y = Number.isNaN || function(e2) {
          return e2 !== e2;
        };
        t2.exports = r2, t2.exports.once = function(e2, t3) {
          return new Promise(function(n3, r3) {
            function a2(n4) {
              e2.removeListener(t3, o2), r3(n4);
            }
            function o2() {
              "function" == typeof e2.removeListener && e2.removeListener("error", a2), n3([].slice.call(arguments));
            }
            _(e2, t3, o2, { once: true }), "error" !== t3 && g(e2, a2, { once: true });
          });
        }, r2.EventEmitter = r2, r2.prototype._events = void 0, r2.prototype._eventsCount = 0, r2.prototype._maxListeners = void 0;
        var C = 10;
        Object.defineProperty(r2, "defaultMaxListeners", { enumerable: true, get: function() {
          return C;
        }, set: function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          C = e2;
        } }), r2.init = function() {
          (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
        }, r2.prototype.setMaxListeners = function(e2) {
          if ("number" != typeof e2 || 0 > e2 || y(e2))
            throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e2 + ".");
          return this._maxListeners = e2, this;
        }, r2.prototype.getMaxListeners = function() {
          return o(this);
        }, r2.prototype.emit = function(e2) {
          for (var t3 = [], n3 = 1; n3 < arguments.length; n3++)
            t3.push(arguments[n3]);
          var r3 = "error" === e2, a2 = this._events;
          if (a2 !== void 0)
            r3 = r3 && a2.error === void 0;
          else if (!r3)
            return false;
          if (r3) {
            var o2;
            if (0 < t3.length && (o2 = t3[0]), o2 instanceof Error)
              throw o2;
            var d2 = new Error("Unhandled error." + (o2 ? " (" + o2.message + ")" : ""));
            throw d2.context = o2, d2;
          }
          var s2 = a2[e2];
          if (s2 === void 0)
            return false;
          if ("function" == typeof s2)
            b(s2, this, t3);
          else
            for (var l2 = s2.length, c2 = u(s2, l2), n3 = 0; n3 < l2; ++n3)
              b(c2[n3], this, t3);
          return true;
        }, r2.prototype.addListener = function(e2, t3) {
          return i(this, e2, t3, false);
        }, r2.prototype.on = r2.prototype.addListener, r2.prototype.prependListener = function(e2, t3) {
          return i(this, e2, t3, true);
        }, r2.prototype.once = function(e2, t3) {
          return a(t3), this.on(e2, s(this, e2, t3)), this;
        }, r2.prototype.prependOnceListener = function(e2, t3) {
          return a(t3), this.prependListener(e2, s(this, e2, t3)), this;
        }, r2.prototype.removeListener = function(e2, t3) {
          var n3, r3, o2, d2, s2;
          if (a(t3), r3 = this._events, void 0 === r3)
            return this;
          if (n3 = r3[e2], void 0 === n3)
            return this;
          if (n3 === t3 || n3.listener === t3)
            0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : (delete r3[e2], r3.removeListener && this.emit("removeListener", e2, n3.listener || t3));
          else if ("function" != typeof n3) {
            for (o2 = -1, d2 = n3.length - 1; 0 <= d2; d2--)
              if (n3[d2] === t3 || n3[d2].listener === t3) {
                s2 = n3[d2].listener, o2 = d2;
                break;
              }
            if (0 > o2)
              return this;
            0 === o2 ? n3.shift() : p(n3, o2), 1 === n3.length && (r3[e2] = n3[0]), void 0 !== r3.removeListener && this.emit("removeListener", e2, s2 || t3);
          }
          return this;
        }, r2.prototype.off = r2.prototype.removeListener, r2.prototype.removeAllListeners = function(e2) {
          var t3, n3, r3;
          if (n3 = this._events, void 0 === n3)
            return this;
          if (void 0 === n3.removeListener)
            return 0 === arguments.length ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : void 0 !== n3[e2] && (0 == --this._eventsCount ? this._events = /* @__PURE__ */ Object.create(null) : delete n3[e2]), this;
          if (0 === arguments.length) {
            var a2, o2 = Object.keys(n3);
            for (r3 = 0; r3 < o2.length; ++r3)
              a2 = o2[r3], "removeListener" !== a2 && this.removeAllListeners(a2);
            return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
          }
          if (t3 = n3[e2], "function" == typeof t3)
            this.removeListener(e2, t3);
          else if (void 0 !== t3)
            for (r3 = t3.length - 1; 0 <= r3; r3--)
              this.removeListener(e2, t3[r3]);
          return this;
        }, r2.prototype.listeners = function(e2) {
          return l(this, e2, true);
        }, r2.prototype.rawListeners = function(e2) {
          return l(this, e2, false);
        }, r2.listenerCount = function(e2, t3) {
          return "function" == typeof e2.listenerCount ? e2.listenerCount(t3) : c.call(e2, t3);
        }, r2.prototype.listenerCount = c, r2.prototype.eventNames = function() {
          return 0 < this._eventsCount ? h(this._events) : [];
        };
      }, {}], 8: [function(e, t2) {
        t2.exports = function() {
          if ("undefined" == typeof globalThis)
            return null;
          var e2 = { RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection, RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription, RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate };
          return e2.RTCPeerConnection ? e2 : null;
        };
      }, {}], 9: [function(e, a, o) {
        o.read = function(t2, n2, a2, o2, l) {
          var c, u, p = 8 * l - o2 - 1, f = (1 << p) - 1, g = f >> 1, _ = -7, h = a2 ? l - 1 : 0, b = a2 ? -1 : 1, d = t2[n2 + h];
          for (h += b, c = d & (1 << -_) - 1, d >>= -_, _ += p; 0 < _; c = 256 * c + t2[n2 + h], h += b, _ -= 8)
            ;
          for (u = c & (1 << -_) - 1, c >>= -_, _ += o2; 0 < _; u = 256 * u + t2[n2 + h], h += b, _ -= 8)
            ;
          if (0 === c)
            c = 1 - g;
          else {
            if (c === f)
              return u ? NaN : (d ? -1 : 1) * (1 / 0);
            u += r(2, o2), c -= g;
          }
          return (d ? -1 : 1) * u * r(2, c - o2);
        }, o.write = function(a2, o2, l, u, p, f) {
          var h, b, y, g = Math.LN2, _ = Math.log, C = 8 * f - p - 1, R = (1 << C) - 1, E = R >> 1, w = 23 === p ? r(2, -24) - r(2, -77) : 0, S = u ? 0 : f - 1, T = u ? 1 : -1, d = 0 > o2 || 0 === o2 && 0 > 1 / o2 ? 1 : 0;
          for (o2 = n(o2), isNaN(o2) || o2 === 1 / 0 ? (b = isNaN(o2) ? 1 : 0, h = R) : (h = t(_(o2) / g), 1 > o2 * (y = r(2, -h)) && (h--, y *= 2), o2 += 1 <= h + E ? w / y : w * r(2, 1 - E), 2 <= o2 * y && (h++, y /= 2), h + E >= R ? (b = 0, h = R) : 1 <= h + E ? (b = (o2 * y - 1) * r(2, p), h += E) : (b = o2 * r(2, E - 1) * r(2, p), h = 0)); 8 <= p; a2[l + S] = 255 & b, S += T, b /= 256, p -= 8)
            ;
          for (h = h << p | b, C += p; 0 < C; a2[l + S] = 255 & h, S += T, h /= 256, C -= 8)
            ;
          a2[l + S - T] |= 128 * d;
        };
      }, {}], 10: [function(e, t2) {
        t2.exports = "function" == typeof Object.create ? function(e2, t3) {
          t3 && (e2.super_ = t3, e2.prototype = Object.create(t3.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
        } : function(e2, t3) {
          if (t3) {
            e2.super_ = t3;
            var n2 = function() {
            };
            n2.prototype = t3.prototype, e2.prototype = new n2(), e2.prototype.constructor = e2;
          }
        };
      }, {}], 11: [function(e, t2) {
        var r2 = Math.round;
        function a(e2) {
          if (e2 += "", !(100 < e2.length)) {
            var t3 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e2);
            if (t3) {
              var r3 = parseFloat(t3[1]), n2 = (t3[2] || "ms").toLowerCase();
              return "years" === n2 || "year" === n2 || "yrs" === n2 || "yr" === n2 || "y" === n2 ? 315576e5 * r3 : "weeks" === n2 || "week" === n2 || "w" === n2 ? 6048e5 * r3 : "days" === n2 || "day" === n2 || "d" === n2 ? 864e5 * r3 : "hours" === n2 || "hour" === n2 || "hrs" === n2 || "hr" === n2 || "h" === n2 ? 36e5 * r3 : "minutes" === n2 || "minute" === n2 || "mins" === n2 || "min" === n2 || "m" === n2 ? 6e4 * r3 : "seconds" === n2 || "second" === n2 || "secs" === n2 || "sec" === n2 || "s" === n2 ? 1e3 * r3 : "milliseconds" === n2 || "millisecond" === n2 || "msecs" === n2 || "msec" === n2 || "ms" === n2 ? r3 : void 0;
            }
          }
        }
        function o(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? r2(e2 / 864e5) + "d" : 36e5 <= t3 ? r2(e2 / 36e5) + "h" : 6e4 <= t3 ? r2(e2 / 6e4) + "m" : 1e3 <= t3 ? r2(e2 / 1e3) + "s" : e2 + "ms";
        }
        function i(e2) {
          var t3 = n(e2);
          return 864e5 <= t3 ? s(e2, t3, 864e5, "day") : 36e5 <= t3 ? s(e2, t3, 36e5, "hour") : 6e4 <= t3 ? s(e2, t3, 6e4, "minute") : 1e3 <= t3 ? s(e2, t3, 1e3, "second") : e2 + " ms";
        }
        function s(e2, t3, a2, n2) {
          return r2(e2 / a2) + " " + n2 + (t3 >= 1.5 * a2 ? "s" : "");
        }
        var l = 24 * (60 * 6e4);
        t2.exports = function(e2, t3) {
          t3 = t3 || {};
          var n2 = typeof e2;
          if ("string" == n2 && 0 < e2.length)
            return a(e2);
          if ("number" === n2 && isFinite(e2))
            return t3.long ? i(e2) : o(e2);
          throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e2));
        };
      }, {}], 12: [function(e, t2) {
        function n2() {
          throw new Error("setTimeout has not been defined");
        }
        function r2() {
          throw new Error("clearTimeout has not been defined");
        }
        function a(t3) {
          if (c === setTimeout)
            return setTimeout(t3, 0);
          if ((c === n2 || !c) && setTimeout)
            return c = setTimeout, setTimeout(t3, 0);
          try {
            return c(t3, 0);
          } catch (n3) {
            try {
              return c.call(null, t3, 0);
            } catch (n4) {
              return c.call(this, t3, 0);
            }
          }
        }
        function o(t3) {
          if (u === clearTimeout)
            return clearTimeout(t3);
          if ((u === r2 || !u) && clearTimeout)
            return u = clearTimeout, clearTimeout(t3);
          try {
            return u(t3);
          } catch (n3) {
            try {
              return u.call(null, t3);
            } catch (n4) {
              return u.call(this, t3);
            }
          }
        }
        function i() {
          _ && f && (_ = false, f.length ? g = f.concat(g) : h = -1, g.length && d());
        }
        function d() {
          if (!_) {
            var e2 = a(i);
            _ = true;
            for (var t3 = g.length; t3; ) {
              for (f = g, g = []; ++h < t3; )
                f && f[h].run();
              h = -1, t3 = g.length;
            }
            f = null, _ = false, o(e2);
          }
        }
        function s(e2, t3) {
          this.fun = e2, this.array = t3;
        }
        function l() {
        }
        var c, u, p = t2.exports = {};
        (function() {
          try {
            c = "function" == typeof setTimeout ? setTimeout : n2;
          } catch (t3) {
            c = n2;
          }
          try {
            u = "function" == typeof clearTimeout ? clearTimeout : r2;
          } catch (t3) {
            u = r2;
          }
        })();
        var f, g = [], _ = false, h = -1;
        p.nextTick = function(e2) {
          var t3 = Array(arguments.length - 1);
          if (1 < arguments.length)
            for (var n3 = 1; n3 < arguments.length; n3++)
              t3[n3 - 1] = arguments[n3];
          g.push(new s(e2, t3)), 1 !== g.length || _ || a(d);
        }, s.prototype.run = function() {
          this.fun.apply(null, this.array);
        }, p.title = "browser", p.browser = true, p.env = {}, p.argv = [], p.version = "", p.versions = {}, p.on = l, p.addListener = l, p.once = l, p.off = l, p.removeListener = l, p.removeAllListeners = l, p.emit = l, p.prependListener = l, p.prependOnceListener = l, p.listeners = function() {
          return [];
        }, p.binding = function() {
          throw new Error("process.binding is not supported");
        }, p.cwd = function() {
          return "/";
        }, p.chdir = function() {
          throw new Error("process.chdir is not supported");
        }, p.umask = function() {
          return 0;
        };
      }, {}], 13: [function(e, t2) {
        (function(e2) {
          (function() {
            let n2;
            t2.exports = "function" == typeof queueMicrotask ? queueMicrotask.bind("undefined" == typeof window ? e2 : window) : (e3) => (n2 || (n2 = Promise.resolve())).then(e3).catch((e4) => setTimeout(() => {
              throw e4;
            }, 0));
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], 14: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            var a = e("safe-buffer").Buffer, o = r2.crypto || r2.msCrypto;
            t2.exports = o && o.getRandomValues ? function(e2, t3) {
              if (e2 > 4294967295)
                throw new RangeError("requested too many random bytes");
              var r3 = a.allocUnsafe(e2);
              if (0 < e2)
                if (65536 < e2)
                  for (var i = 0; i < e2; i += 65536)
                    o.getRandomValues(r3.slice(i, i + 65536));
                else
                  o.getRandomValues(r3);
              return "function" == typeof t3 ? n2.nextTick(function() {
                t3(null, r3);
              }) : r3;
            } : function() {
              throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { _process: 12, "safe-buffer": 30 }], 15: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          e2.prototype = Object.create(t3.prototype), e2.prototype.constructor = e2, e2.__proto__ = t3;
        }
        function r2(e2, t3, r3) {
          function a2(e3, n3, r4) {
            return "string" == typeof t3 ? t3 : t3(e3, n3, r4);
          }
          r3 || (r3 = Error);
          var o2 = function(e3) {
            function t4(t5, n3, r4) {
              return e3.call(this, a2(t5, n3, r4)) || this;
            }
            return n2(t4, e3), t4;
          }(r3);
          o2.prototype.name = r3.name, o2.prototype.code = e2, s[e2] = o2;
        }
        function a(e2, t3) {
          if (Array.isArray(e2)) {
            var n3 = e2.length;
            return e2 = e2.map(function(e3) {
              return e3 + "";
            }), 2 < n3 ? "one of ".concat(t3, " ").concat(e2.slice(0, n3 - 1).join(", "), ", or ") + e2[n3 - 1] : 2 === n3 ? "one of ".concat(t3, " ").concat(e2[0], " or ").concat(e2[1]) : "of ".concat(t3, " ").concat(e2[0]);
          }
          return "of ".concat(t3, " ").concat(e2 + "");
        }
        function o(e2, t3, n3) {
          return e2.substr(!n3 || 0 > n3 ? 0 : +n3, t3.length) === t3;
        }
        function i(e2, t3, n3) {
          return (void 0 === n3 || n3 > e2.length) && (n3 = e2.length), e2.substring(n3 - t3.length, n3) === t3;
        }
        function d(e2, t3, n3) {
          return "number" != typeof n3 && (n3 = 0), !(n3 + t3.length > e2.length) && -1 !== e2.indexOf(t3, n3);
        }
        var s = {};
        r2("ERR_INVALID_OPT_VALUE", function(e2, t3) {
          return 'The value "' + t3 + '" is invalid for option "' + e2 + '"';
        }, TypeError), r2("ERR_INVALID_ARG_TYPE", function(e2, t3, n3) {
          var r3;
          "string" == typeof t3 && o(t3, "not ") ? (r3 = "must not be", t3 = t3.replace(/^not /, "")) : r3 = "must be";
          var s2;
          if (i(e2, " argument"))
            s2 = "The ".concat(e2, " ").concat(r3, " ").concat(a(t3, "type"));
          else {
            var l = d(e2, ".") ? "property" : "argument";
            s2 = 'The "'.concat(e2, '" ').concat(l, " ").concat(r3, " ").concat(a(t3, "type"));
          }
          return s2 += ". Received type ".concat(typeof n3), s2;
        }, TypeError), r2("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), r2("ERR_METHOD_NOT_IMPLEMENTED", function(e2) {
          return "The " + e2 + " method is not implemented";
        }), r2("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), r2("ERR_STREAM_DESTROYED", function(e2) {
          return "Cannot call " + e2 + " after a stream was destroyed";
        }), r2("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), r2("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), r2("ERR_STREAM_WRITE_AFTER_END", "write after end"), r2("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), r2("ERR_UNKNOWN_ENCODING", function(e2) {
          return "Unknown encoding: " + e2;
        }, TypeError), r2("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), t2.exports.codes = s;
      }, {}], 16: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2) {
              return this instanceof r2 ? void (d.call(this, e2), s.call(this, e2), this.allowHalfOpen = true, e2 && (false === e2.readable && (this.readable = false), false === e2.writable && (this.writable = false), false === e2.allowHalfOpen && (this.allowHalfOpen = false, this.once("end", a)))) : new r2(e2);
            }
            function a() {
              this._writableState.ended || n2.nextTick(o, this);
            }
            function o(e2) {
              e2.end();
            }
            var i = Object.keys || function(e2) {
              var t3 = [];
              for (var n3 in e2)
                t3.push(n3);
              return t3;
            };
            t2.exports = r2;
            var d = e("./_stream_readable"), s = e("./_stream_writable");
            e("inherits")(r2, d);
            for (var l, c = i(s.prototype), u = 0; u < c.length; u++)
              l = c[u], r2.prototype[l] || (r2.prototype[l] = s.prototype[l]);
            Object.defineProperty(r2.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), Object.defineProperty(r2.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(r2.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(r2.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && void 0 !== this._writableState && this._readableState.destroyed && this._writableState.destroyed;
            }, set: function(e2) {
              void 0 === this._readableState || void 0 === this._writableState || (this._readableState.destroyed = e2, this._writableState.destroyed = e2);
            } });
          }).call(this);
        }).call(this, e("_process"));
      }, { "./_stream_readable": 18, "./_stream_writable": 20, _process: 12, inherits: 10 }], 17: [function(e, t2) {
        "use strict";
        function n2(e2) {
          return this instanceof n2 ? void r2.call(this, e2) : new n2(e2);
        }
        t2.exports = n2;
        var r2 = e("./_stream_transform");
        e("inherits")(n2, r2), n2.prototype._transform = function(e2, t3, n3) {
          n3(null, e2);
        };
      }, { "./_stream_transform": 19, inherits: 10 }], 18: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              return P.from(e2);
            }
            function o(e2) {
              return P.isBuffer(e2) || e2 instanceof M;
            }
            function i(e2, t3, n3) {
              return "function" == typeof e2.prependListener ? e2.prependListener(t3, n3) : void (e2._events && e2._events[t3] ? Array.isArray(e2._events[t3]) ? e2._events[t3].unshift(n3) : e2._events[t3] = [n3, e2._events[t3]] : e2.on(t3, n3));
            }
            function d(t3, n3, r3) {
              A = A || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof A), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.readableObjectMode), this.highWaterMark = H(this, t3, "readableHighWaterMark", r3), this.buffer = new j(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = false, this.endEmitted = false, this.reading = false, this.sync = true, this.needReadable = false, this.emittedReadable = false, this.readableListening = false, this.resumeScheduled = false, this.paused = true, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.destroyed = false, this.defaultEncoding = t3.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = false, this.decoder = null, this.encoding = null, t3.encoding && (!F && (F = e("string_decoder/").StringDecoder), this.decoder = new F(t3.encoding), this.encoding = t3.encoding);
            }
            function s(t3) {
              if (A = A || e("./_stream_duplex"), !(this instanceof s))
                return new s(t3);
              var n3 = this instanceof A;
              this._readableState = new d(t3, this, n3), this.readable = true, t3 && ("function" == typeof t3.read && (this._read = t3.read), "function" == typeof t3.destroy && (this._destroy = t3.destroy)), I.call(this);
            }
            function l(e2, t3, n3, r3, o2) {
              x("readableAddChunk", t3);
              var i2 = e2._readableState;
              if (null === t3)
                i2.reading = false, g(e2, i2);
              else {
                var d2;
                if (o2 || (d2 = u(i2, t3)), d2)
                  X(e2, d2);
                else if (!(i2.objectMode || t3 && 0 < t3.length))
                  r3 || (i2.reading = false, m(e2, i2));
                else if ("string" == typeof t3 || i2.objectMode || Object.getPrototypeOf(t3) === P.prototype || (t3 = a(t3)), r3)
                  i2.endEmitted ? X(e2, new K()) : c(e2, i2, t3, true);
                else if (i2.ended)
                  X(e2, new z());
                else {
                  if (i2.destroyed)
                    return false;
                  i2.reading = false, i2.decoder && !n3 ? (t3 = i2.decoder.write(t3), i2.objectMode || 0 !== t3.length ? c(e2, i2, t3, false) : m(e2, i2)) : c(e2, i2, t3, false);
                }
              }
              return !i2.ended && (i2.length < i2.highWaterMark || 0 === i2.length);
            }
            function c(e2, t3, n3, r3) {
              t3.flowing && 0 === t3.length && !t3.sync ? (t3.awaitDrain = 0, e2.emit("data", n3)) : (t3.length += t3.objectMode ? 1 : n3.length, r3 ? t3.buffer.unshift(n3) : t3.buffer.push(n3), t3.needReadable && _(e2)), m(e2, t3);
            }
            function u(e2, t3) {
              var n3;
              return o(t3) || "string" == typeof t3 || void 0 === t3 || e2.objectMode || (n3 = new V("chunk", ["string", "Buffer", "Uint8Array"], t3)), n3;
            }
            function p(e2) {
              return 1073741824 <= e2 ? e2 = 1073741824 : (e2--, e2 |= e2 >>> 1, e2 |= e2 >>> 2, e2 |= e2 >>> 4, e2 |= e2 >>> 8, e2 |= e2 >>> 16, e2++), e2;
            }
            function f(e2, t3) {
              return 0 >= e2 || 0 === t3.length && t3.ended ? 0 : t3.objectMode ? 1 : e2 === e2 ? (e2 > t3.highWaterMark && (t3.highWaterMark = p(e2)), e2 <= t3.length ? e2 : t3.ended ? t3.length : (t3.needReadable = true, 0)) : t3.flowing && t3.length ? t3.buffer.head.data.length : t3.length;
            }
            function g(e2, t3) {
              if (x("onEofChunk"), !t3.ended) {
                if (t3.decoder) {
                  var n3 = t3.decoder.end();
                  n3 && n3.length && (t3.buffer.push(n3), t3.length += t3.objectMode ? 1 : n3.length);
                }
                t3.ended = true, t3.sync ? _(e2) : (t3.needReadable = false, !t3.emittedReadable && (t3.emittedReadable = true, h(e2)));
              }
            }
            function _(e2) {
              var t3 = e2._readableState;
              x("emitReadable", t3.needReadable, t3.emittedReadable), t3.needReadable = false, t3.emittedReadable || (x("emitReadable", t3.flowing), t3.emittedReadable = true, n2.nextTick(h, e2));
            }
            function h(e2) {
              var t3 = e2._readableState;
              x("emitReadable_", t3.destroyed, t3.length, t3.ended), !t3.destroyed && (t3.length || t3.ended) && (e2.emit("readable"), t3.emittedReadable = false), t3.needReadable = !t3.flowing && !t3.ended && t3.length <= t3.highWaterMark, S(e2);
            }
            function m(e2, t3) {
              t3.readingMore || (t3.readingMore = true, n2.nextTick(b, e2, t3));
            }
            function b(e2, t3) {
              for (; !t3.reading && !t3.ended && (t3.length < t3.highWaterMark || t3.flowing && 0 === t3.length); ) {
                var n3 = t3.length;
                if (x("maybeReadMore read 0"), e2.read(0), n3 === t3.length)
                  break;
              }
              t3.readingMore = false;
            }
            function y(e2) {
              return function() {
                var t3 = e2._readableState;
                x("pipeOnDrain", t3.awaitDrain), t3.awaitDrain && t3.awaitDrain--, 0 === t3.awaitDrain && D(e2, "data") && (t3.flowing = true, S(e2));
              };
            }
            function C(e2) {
              var t3 = e2._readableState;
              t3.readableListening = 0 < e2.listenerCount("readable"), t3.resumeScheduled && !t3.paused ? t3.flowing = true : 0 < e2.listenerCount("data") && e2.resume();
            }
            function R(e2) {
              x("readable nexttick read 0"), e2.read(0);
            }
            function E(e2, t3) {
              t3.resumeScheduled || (t3.resumeScheduled = true, n2.nextTick(w, e2, t3));
            }
            function w(e2, t3) {
              x("resume", t3.reading), t3.reading || e2.read(0), t3.resumeScheduled = false, e2.emit("resume"), S(e2), t3.flowing && !t3.reading && e2.read(0);
            }
            function S(e2) {
              var t3 = e2._readableState;
              for (x("flow", t3.flowing); t3.flowing && null !== e2.read(); )
                ;
            }
            function T(e2, t3) {
              if (0 === t3.length)
                return null;
              var n3;
              return t3.objectMode ? n3 = t3.buffer.shift() : !e2 || e2 >= t3.length ? (n3 = t3.decoder ? t3.buffer.join("") : 1 === t3.buffer.length ? t3.buffer.first() : t3.buffer.concat(t3.length), t3.buffer.clear()) : n3 = t3.buffer.consume(e2, t3.decoder), n3;
            }
            function v(e2) {
              var t3 = e2._readableState;
              x("endReadable", t3.endEmitted), t3.endEmitted || (t3.ended = true, n2.nextTick(k, t3, e2));
            }
            function k(e2, t3) {
              if (x("endReadableNT", e2.endEmitted, e2.length), !e2.endEmitted && 0 === e2.length && (e2.endEmitted = true, t3.readable = false, t3.emit("end"), e2.autoDestroy)) {
                var n3 = t3._writableState;
                (!n3 || n3.autoDestroy && n3.finished) && t3.destroy();
              }
            }
            function L(e2, t3) {
              for (var n3 = 0, r3 = e2.length; n3 < r3; n3++)
                if (e2[n3] === t3)
                  return n3;
              return -1;
            }
            t2.exports = s;
            var A;
            s.ReadableState = d;
            var x, N = e("events").EventEmitter, D = function(e2, t3) {
              return e2.listeners(t3).length;
            }, I = e("./internal/streams/stream"), P = e("buffer").Buffer, M = r2.Uint8Array || function() {
            }, O = e("util");
            x = O && O.debuglog ? O.debuglog("stream") : function() {
            };
            var F, B, U, j = e("./internal/streams/buffer_list"), q = e("./internal/streams/destroy"), W = e("./internal/streams/state"), H = W.getHighWaterMark, Y = e("../errors").codes, V = Y.ERR_INVALID_ARG_TYPE, z = Y.ERR_STREAM_PUSH_AFTER_EOF, G = Y.ERR_METHOD_NOT_IMPLEMENTED, K = Y.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
            e("inherits")(s, I);
            var X = q.errorOrDestroy, $ = ["error", "close", "destroy", "pause", "resume"];
            Object.defineProperty(s.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._readableState && this._readableState.destroyed;
            }, set: function(e2) {
              this._readableState && (this._readableState.destroyed = e2);
            } }), s.prototype.destroy = q.destroy, s.prototype._undestroy = q.undestroy, s.prototype._destroy = function(e2, t3) {
              t3(e2);
            }, s.prototype.push = function(e2, t3) {
              var n3, r3 = this._readableState;
              return r3.objectMode ? n3 = true : "string" == typeof e2 && (t3 = t3 || r3.defaultEncoding, t3 !== r3.encoding && (e2 = P.from(e2, t3), t3 = ""), n3 = true), l(this, e2, t3, false, n3);
            }, s.prototype.unshift = function(e2) {
              return l(this, e2, null, true, false);
            }, s.prototype.isPaused = function() {
              return false === this._readableState.flowing;
            }, s.prototype.setEncoding = function(t3) {
              F || (F = e("string_decoder/").StringDecoder);
              var n3 = new F(t3);
              this._readableState.decoder = n3, this._readableState.encoding = this._readableState.decoder.encoding;
              for (var r3 = this._readableState.buffer.head, a2 = ""; null !== r3; )
                a2 += n3.write(r3.data), r3 = r3.next;
              return this._readableState.buffer.clear(), "" !== a2 && this._readableState.buffer.push(a2), this._readableState.length = a2.length, this;
            };
            s.prototype.read = function(e2) {
              x("read", e2), e2 = parseInt(e2, 10);
              var t3 = this._readableState, r3 = e2;
              if (0 !== e2 && (t3.emittedReadable = false), 0 === e2 && t3.needReadable && ((0 === t3.highWaterMark ? 0 < t3.length : t3.length >= t3.highWaterMark) || t3.ended))
                return x("read: emitReadable", t3.length, t3.ended), 0 === t3.length && t3.ended ? v(this) : _(this), null;
              if (e2 = f(e2, t3), 0 === e2 && t3.ended)
                return 0 === t3.length && v(this), null;
              var a2 = t3.needReadable;
              x("need readable", a2), (0 === t3.length || t3.length - e2 < t3.highWaterMark) && (a2 = true, x("length less than watermark", a2)), t3.ended || t3.reading ? (a2 = false, x("reading or ended", a2)) : a2 && (x("do read"), t3.reading = true, t3.sync = true, 0 === t3.length && (t3.needReadable = true), this._read(t3.highWaterMark), t3.sync = false, !t3.reading && (e2 = f(r3, t3)));
              var o2;
              return o2 = 0 < e2 ? T(e2, t3) : null, null === o2 ? (t3.needReadable = t3.length <= t3.highWaterMark, e2 = 0) : (t3.length -= e2, t3.awaitDrain = 0), 0 === t3.length && (!t3.ended && (t3.needReadable = true), r3 !== e2 && t3.ended && v(this)), null !== o2 && this.emit("data", o2), o2;
            }, s.prototype._read = function() {
              X(this, new G("_read()"));
            }, s.prototype.pipe = function(e2, t3) {
              function r3(e3, t4) {
                x("onunpipe"), e3 === p2 && t4 && false === t4.hasUnpiped && (t4.hasUnpiped = true, o2());
              }
              function a2() {
                x("onend"), e2.end();
              }
              function o2() {
                x("cleanup"), e2.removeListener("close", l2), e2.removeListener("finish", c2), e2.removeListener("drain", h2), e2.removeListener("error", s2), e2.removeListener("unpipe", r3), p2.removeListener("end", a2), p2.removeListener("end", u2), p2.removeListener("data", d2), m2 = true, f2.awaitDrain && (!e2._writableState || e2._writableState.needDrain) && h2();
              }
              function d2(t4) {
                x("ondata");
                var n3 = e2.write(t4);
                x("dest.write", n3), false === n3 && ((1 === f2.pipesCount && f2.pipes === e2 || 1 < f2.pipesCount && -1 !== L(f2.pipes, e2)) && !m2 && (x("false write response, pause", f2.awaitDrain), f2.awaitDrain++), p2.pause());
              }
              function s2(t4) {
                x("onerror", t4), u2(), e2.removeListener("error", s2), 0 === D(e2, "error") && X(e2, t4);
              }
              function l2() {
                e2.removeListener("finish", c2), u2();
              }
              function c2() {
                x("onfinish"), e2.removeListener("close", l2), u2();
              }
              function u2() {
                x("unpipe"), p2.unpipe(e2);
              }
              var p2 = this, f2 = this._readableState;
              switch (f2.pipesCount) {
                case 0:
                  f2.pipes = e2;
                  break;
                case 1:
                  f2.pipes = [f2.pipes, e2];
                  break;
                default:
                  f2.pipes.push(e2);
              }
              f2.pipesCount += 1, x("pipe count=%d opts=%j", f2.pipesCount, t3);
              var g2 = (!t3 || false !== t3.end) && e2 !== n2.stdout && e2 !== n2.stderr, _2 = g2 ? a2 : u2;
              f2.endEmitted ? n2.nextTick(_2) : p2.once("end", _2), e2.on("unpipe", r3);
              var h2 = y(p2);
              e2.on("drain", h2);
              var m2 = false;
              return p2.on("data", d2), i(e2, "error", s2), e2.once("close", l2), e2.once("finish", c2), e2.emit("pipe", p2), f2.flowing || (x("pipe resume"), p2.resume()), e2;
            }, s.prototype.unpipe = function(e2) {
              var t3 = this._readableState, n3 = { hasUnpiped: false };
              if (0 === t3.pipesCount)
                return this;
              if (1 === t3.pipesCount)
                return e2 && e2 !== t3.pipes ? this : (e2 || (e2 = t3.pipes), t3.pipes = null, t3.pipesCount = 0, t3.flowing = false, e2 && e2.emit("unpipe", this, n3), this);
              if (!e2) {
                var r3 = t3.pipes, a2 = t3.pipesCount;
                t3.pipes = null, t3.pipesCount = 0, t3.flowing = false;
                for (var o2 = 0; o2 < a2; o2++)
                  r3[o2].emit("unpipe", this, { hasUnpiped: false });
                return this;
              }
              var d2 = L(t3.pipes, e2);
              return -1 === d2 ? this : (t3.pipes.splice(d2, 1), t3.pipesCount -= 1, 1 === t3.pipesCount && (t3.pipes = t3.pipes[0]), e2.emit("unpipe", this, n3), this);
            }, s.prototype.on = function(e2, t3) {
              var r3 = I.prototype.on.call(this, e2, t3), a2 = this._readableState;
              return "data" === e2 ? (a2.readableListening = 0 < this.listenerCount("readable"), false !== a2.flowing && this.resume()) : "readable" == e2 && !a2.endEmitted && !a2.readableListening && (a2.readableListening = a2.needReadable = true, a2.flowing = false, a2.emittedReadable = false, x("on readable", a2.length, a2.reading), a2.length ? _(this) : !a2.reading && n2.nextTick(R, this)), r3;
            }, s.prototype.addListener = s.prototype.on, s.prototype.removeListener = function(e2, t3) {
              var r3 = I.prototype.removeListener.call(this, e2, t3);
              return "readable" === e2 && n2.nextTick(C, this), r3;
            }, s.prototype.removeAllListeners = function(e2) {
              var t3 = I.prototype.removeAllListeners.apply(this, arguments);
              return ("readable" === e2 || void 0 === e2) && n2.nextTick(C, this), t3;
            }, s.prototype.resume = function() {
              var e2 = this._readableState;
              return e2.flowing || (x("resume"), e2.flowing = !e2.readableListening, E(this, e2)), e2.paused = false, this;
            }, s.prototype.pause = function() {
              return x("call pause flowing=%j", this._readableState.flowing), false !== this._readableState.flowing && (x("pause"), this._readableState.flowing = false, this.emit("pause")), this._readableState.paused = true, this;
            }, s.prototype.wrap = function(e2) {
              var t3 = this, r3 = this._readableState, a2 = false;
              for (var o2 in e2.on("end", function() {
                if (x("wrapped end"), r3.decoder && !r3.ended) {
                  var e3 = r3.decoder.end();
                  e3 && e3.length && t3.push(e3);
                }
                t3.push(null);
              }), e2.on("data", function(n3) {
                if ((x("wrapped data"), r3.decoder && (n3 = r3.decoder.write(n3)), !(r3.objectMode && (null === n3 || void 0 === n3))) && (r3.objectMode || n3 && n3.length)) {
                  var o3 = t3.push(n3);
                  o3 || (a2 = true, e2.pause());
                }
              }), e2)
                void 0 === this[o2] && "function" == typeof e2[o2] && (this[o2] = function(t4) {
                  return function() {
                    return e2[t4].apply(e2, arguments);
                  };
                }(o2));
              for (var i2 = 0; i2 < $.length; i2++)
                e2.on($[i2], this.emit.bind(this, $[i2]));
              return this._read = function(t4) {
                x("wrapped _read", t4), a2 && (a2 = false, e2.resume());
              }, this;
            }, "function" == typeof Symbol && (s.prototype[Symbol.asyncIterator] = function() {
              return void 0 === B && (B = e("./internal/streams/async_iterator")), B(this);
            }), Object.defineProperty(s.prototype, "readableHighWaterMark", { enumerable: false, get: function() {
              return this._readableState.highWaterMark;
            } }), Object.defineProperty(s.prototype, "readableBuffer", { enumerable: false, get: function() {
              return this._readableState && this._readableState.buffer;
            } }), Object.defineProperty(s.prototype, "readableFlowing", { enumerable: false, get: function() {
              return this._readableState.flowing;
            }, set: function(e2) {
              this._readableState && (this._readableState.flowing = e2);
            } }), s._fromList = T, Object.defineProperty(s.prototype, "readableLength", { enumerable: false, get: function() {
              return this._readableState.length;
            } }), "function" == typeof Symbol && (s.from = function(t3, n3) {
              return void 0 === U && (U = e("./internal/streams/from")), U(s, t3, n3);
            });
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/async_iterator": 21, "./internal/streams/buffer_list": 22, "./internal/streams/destroy": 23, "./internal/streams/from": 25, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, events: 7, inherits: 10, "string_decoder/": 31, util: 2 }], 19: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = this._transformState;
          n3.transforming = false;
          var r3 = n3.writecb;
          if (null === r3)
            return this.emit("error", new s());
          n3.writechunk = null, n3.writecb = null, null != t3 && this.push(t3), r3(e2);
          var a2 = this._readableState;
          a2.reading = false, (a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
        }
        function r2(e2) {
          return this instanceof r2 ? void (u.call(this, e2), this._transformState = { afterTransform: n2.bind(this), needTransform: false, transforming: false, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = true, this._readableState.sync = false, e2 && ("function" == typeof e2.transform && (this._transform = e2.transform), "function" == typeof e2.flush && (this._flush = e2.flush)), this.on("prefinish", a)) : new r2(e2);
        }
        function a() {
          var e2 = this;
          "function" != typeof this._flush || this._readableState.destroyed ? o(this, null, null) : this._flush(function(t3, n3) {
            o(e2, t3, n3);
          });
        }
        function o(e2, t3, n3) {
          if (t3)
            return e2.emit("error", t3);
          if (null != n3 && e2.push(n3), e2._writableState.length)
            throw new c();
          if (e2._transformState.transforming)
            throw new l();
          return e2.push(null);
        }
        t2.exports = r2;
        var i = e("../errors").codes, d = i.ERR_METHOD_NOT_IMPLEMENTED, s = i.ERR_MULTIPLE_CALLBACK, l = i.ERR_TRANSFORM_ALREADY_TRANSFORMING, c = i.ERR_TRANSFORM_WITH_LENGTH_0, u = e("./_stream_duplex");
        e("inherits")(r2, u), r2.prototype.push = function(e2, t3) {
          return this._transformState.needTransform = false, u.prototype.push.call(this, e2, t3);
        }, r2.prototype._transform = function(e2, t3, n3) {
          n3(new d("_transform()"));
        }, r2.prototype._write = function(e2, t3, n3) {
          var r3 = this._transformState;
          if (r3.writecb = n3, r3.writechunk = e2, r3.writeencoding = t3, !r3.transforming) {
            var a2 = this._readableState;
            (r3.needTransform || a2.needReadable || a2.length < a2.highWaterMark) && this._read(a2.highWaterMark);
          }
        }, r2.prototype._read = function() {
          var e2 = this._transformState;
          null === e2.writechunk || e2.transforming ? e2.needTransform = true : (e2.transforming = true, this._transform(e2.writechunk, e2.writeencoding, e2.afterTransform));
        }, r2.prototype._destroy = function(e2, t3) {
          u.prototype._destroy.call(this, e2, function(e3) {
            t3(e3);
          });
        };
      }, { "../errors": 15, "./_stream_duplex": 16, inherits: 10 }], 20: [function(e, t2) {
        (function(n2, r2) {
          (function() {
            "use strict";
            function a(e2) {
              var t3 = this;
              this.next = null, this.entry = null, this.finish = function() {
                v(t3, e2);
              };
            }
            function o(e2) {
              return x.from(e2);
            }
            function i(e2) {
              return x.isBuffer(e2) || e2 instanceof N;
            }
            function d() {
            }
            function s(t3, n3, r3) {
              k = k || e("./_stream_duplex"), t3 = t3 || {}, "boolean" != typeof r3 && (r3 = n3 instanceof k), this.objectMode = !!t3.objectMode, r3 && (this.objectMode = this.objectMode || !!t3.writableObjectMode), this.highWaterMark = P(this, t3, "writableHighWaterMark", r3), this.finalCalled = false, this.needDrain = false, this.ending = false, this.ended = false, this.finished = false, this.destroyed = false;
              var o2 = false === t3.decodeStrings;
              this.decodeStrings = !o2, this.defaultEncoding = t3.defaultEncoding || "utf8", this.length = 0, this.writing = false, this.corked = 0, this.sync = true, this.bufferProcessing = false, this.onwrite = function(e2) {
                m(n3, e2);
              }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = false, this.errorEmitted = false, this.emitClose = false !== t3.emitClose, this.autoDestroy = !!t3.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new a(this);
            }
            function l(t3) {
              k = k || e("./_stream_duplex");
              var n3 = this instanceof k;
              return n3 || V.call(l, this) ? void (this._writableState = new s(t3, this, n3), this.writable = true, t3 && ("function" == typeof t3.write && (this._write = t3.write), "function" == typeof t3.writev && (this._writev = t3.writev), "function" == typeof t3.destroy && (this._destroy = t3.destroy), "function" == typeof t3.final && (this._final = t3.final)), A.call(this)) : new l(t3);
            }
            function c(e2, t3) {
              var r3 = new W();
              Y(e2, r3), n2.nextTick(t3, r3);
            }
            function u(e2, t3, r3, a2) {
              var o2;
              return null === r3 ? o2 = new q() : "string" != typeof r3 && !t3.objectMode && (o2 = new O("chunk", ["string", "Buffer"], r3)), !o2 || (Y(e2, o2), n2.nextTick(a2, o2), false);
            }
            function p(e2, t3, n3) {
              return e2.objectMode || false === e2.decodeStrings || "string" != typeof t3 || (t3 = x.from(t3, n3)), t3;
            }
            function f(e2, t3, n3, r3, a2, o2) {
              if (!n3) {
                var i2 = p(t3, r3, a2);
                r3 !== i2 && (n3 = true, a2 = "buffer", r3 = i2);
              }
              var d2 = t3.objectMode ? 1 : r3.length;
              t3.length += d2;
              var s2 = t3.length < t3.highWaterMark;
              if (s2 || (t3.needDrain = true), t3.writing || t3.corked) {
                var l2 = t3.lastBufferedRequest;
                t3.lastBufferedRequest = { chunk: r3, encoding: a2, isBuf: n3, callback: o2, next: null }, l2 ? l2.next = t3.lastBufferedRequest : t3.bufferedRequest = t3.lastBufferedRequest, t3.bufferedRequestCount += 1;
              } else
                g(e2, t3, false, d2, r3, a2, o2);
              return s2;
            }
            function g(e2, t3, n3, r3, a2, o2, i2) {
              t3.writelen = r3, t3.writecb = i2, t3.writing = true, t3.sync = true, t3.destroyed ? t3.onwrite(new j("write")) : n3 ? e2._writev(a2, t3.onwrite) : e2._write(a2, o2, t3.onwrite), t3.sync = false;
            }
            function _(e2, t3, r3, a2, o2) {
              --t3.pendingcb, r3 ? (n2.nextTick(o2, a2), n2.nextTick(S, e2, t3), e2._writableState.errorEmitted = true, Y(e2, a2)) : (o2(a2), e2._writableState.errorEmitted = true, Y(e2, a2), S(e2, t3));
            }
            function h(e2) {
              e2.writing = false, e2.writecb = null, e2.length -= e2.writelen, e2.writelen = 0;
            }
            function m(e2, t3) {
              var r3 = e2._writableState, a2 = r3.sync, o2 = r3.writecb;
              if ("function" != typeof o2)
                throw new B();
              if (h(r3), t3)
                _(e2, r3, a2, t3, o2);
              else {
                var i2 = R(r3) || e2.destroyed;
                i2 || r3.corked || r3.bufferProcessing || !r3.bufferedRequest || C(e2, r3), a2 ? n2.nextTick(b, e2, r3, i2, o2) : b(e2, r3, i2, o2);
              }
            }
            function b(e2, t3, n3, r3) {
              n3 || y(e2, t3), t3.pendingcb--, r3(), S(e2, t3);
            }
            function y(e2, t3) {
              0 === t3.length && t3.needDrain && (t3.needDrain = false, e2.emit("drain"));
            }
            function C(e2, t3) {
              t3.bufferProcessing = true;
              var n3 = t3.bufferedRequest;
              if (e2._writev && n3 && n3.next) {
                var r3 = t3.bufferedRequestCount, o2 = Array(r3), i2 = t3.corkedRequestsFree;
                i2.entry = n3;
                for (var d2 = 0, s2 = true; n3; )
                  o2[d2] = n3, n3.isBuf || (s2 = false), n3 = n3.next, d2 += 1;
                o2.allBuffers = s2, g(e2, t3, true, t3.length, o2, "", i2.finish), t3.pendingcb++, t3.lastBufferedRequest = null, i2.next ? (t3.corkedRequestsFree = i2.next, i2.next = null) : t3.corkedRequestsFree = new a(t3), t3.bufferedRequestCount = 0;
              } else {
                for (; n3; ) {
                  var l2 = n3.chunk, c2 = n3.encoding, u2 = n3.callback, p2 = t3.objectMode ? 1 : l2.length;
                  if (g(e2, t3, false, p2, l2, c2, u2), n3 = n3.next, t3.bufferedRequestCount--, t3.writing)
                    break;
                }
                null === n3 && (t3.lastBufferedRequest = null);
              }
              t3.bufferedRequest = n3, t3.bufferProcessing = false;
            }
            function R(e2) {
              return e2.ending && 0 === e2.length && null === e2.bufferedRequest && !e2.finished && !e2.writing;
            }
            function E(e2, t3) {
              e2._final(function(n3) {
                t3.pendingcb--, n3 && Y(e2, n3), t3.prefinished = true, e2.emit("prefinish"), S(e2, t3);
              });
            }
            function w(e2, t3) {
              t3.prefinished || t3.finalCalled || ("function" != typeof e2._final || t3.destroyed ? (t3.prefinished = true, e2.emit("prefinish")) : (t3.pendingcb++, t3.finalCalled = true, n2.nextTick(E, e2, t3)));
            }
            function S(e2, t3) {
              var n3 = R(t3);
              if (n3 && (w(e2, t3), 0 === t3.pendingcb && (t3.finished = true, e2.emit("finish"), t3.autoDestroy))) {
                var r3 = e2._readableState;
                (!r3 || r3.autoDestroy && r3.endEmitted) && e2.destroy();
              }
              return n3;
            }
            function T(e2, t3, r3) {
              t3.ending = true, S(e2, t3), r3 && (t3.finished ? n2.nextTick(r3) : e2.once("finish", r3)), t3.ended = true, e2.writable = false;
            }
            function v(e2, t3, n3) {
              var r3 = e2.entry;
              for (e2.entry = null; r3; ) {
                var a2 = r3.callback;
                t3.pendingcb--, a2(n3), r3 = r3.next;
              }
              t3.corkedRequestsFree.next = e2;
            }
            t2.exports = l;
            var k;
            l.WritableState = s;
            var L = { deprecate: e("util-deprecate") }, A = e("./internal/streams/stream"), x = e("buffer").Buffer, N = r2.Uint8Array || function() {
            }, D = e("./internal/streams/destroy"), I = e("./internal/streams/state"), P = I.getHighWaterMark, M = e("../errors").codes, O = M.ERR_INVALID_ARG_TYPE, F = M.ERR_METHOD_NOT_IMPLEMENTED, B = M.ERR_MULTIPLE_CALLBACK, U = M.ERR_STREAM_CANNOT_PIPE, j = M.ERR_STREAM_DESTROYED, q = M.ERR_STREAM_NULL_VALUES, W = M.ERR_STREAM_WRITE_AFTER_END, H = M.ERR_UNKNOWN_ENCODING, Y = D.errorOrDestroy;
            e("inherits")(l, A), s.prototype.getBuffer = function() {
              for (var e2 = this.bufferedRequest, t3 = []; e2; )
                t3.push(e2), e2 = e2.next;
              return t3;
            }, function() {
              try {
                Object.defineProperty(s.prototype, "buffer", { get: L.deprecate(function() {
                  return this.getBuffer();
                }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
              } catch (e2) {
              }
            }();
            var V;
            "function" == typeof Symbol && Symbol.hasInstance && "function" == typeof Function.prototype[Symbol.hasInstance] ? (V = Function.prototype[Symbol.hasInstance], Object.defineProperty(l, Symbol.hasInstance, { value: function(e2) {
              return !!V.call(this, e2) || !(this !== l) && e2 && e2._writableState instanceof s;
            } })) : V = function(e2) {
              return e2 instanceof this;
            }, l.prototype.pipe = function() {
              Y(this, new U());
            }, l.prototype.write = function(e2, t3, n3) {
              var r3 = this._writableState, a2 = false, s2 = !r3.objectMode && i(e2);
              return s2 && !x.isBuffer(e2) && (e2 = o(e2)), "function" == typeof t3 && (n3 = t3, t3 = null), s2 ? t3 = "buffer" : !t3 && (t3 = r3.defaultEncoding), "function" != typeof n3 && (n3 = d), r3.ending ? c(this, n3) : (s2 || u(this, r3, e2, n3)) && (r3.pendingcb++, a2 = f(this, r3, s2, e2, t3, n3)), a2;
            }, l.prototype.cork = function() {
              this._writableState.corked++;
            }, l.prototype.uncork = function() {
              var e2 = this._writableState;
              e2.corked && (e2.corked--, !e2.writing && !e2.corked && !e2.bufferProcessing && e2.bufferedRequest && C(this, e2));
            }, l.prototype.setDefaultEncoding = function(e2) {
              if ("string" == typeof e2 && (e2 = e2.toLowerCase()), !(-1 < ["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((e2 + "").toLowerCase())))
                throw new H(e2);
              return this._writableState.defaultEncoding = e2, this;
            }, Object.defineProperty(l.prototype, "writableBuffer", { enumerable: false, get: function() {
              return this._writableState && this._writableState.getBuffer();
            } }), Object.defineProperty(l.prototype, "writableHighWaterMark", { enumerable: false, get: function() {
              return this._writableState.highWaterMark;
            } }), l.prototype._write = function(e2, t3, n3) {
              n3(new F("_write()"));
            }, l.prototype._writev = null, l.prototype.end = function(e2, t3, n3) {
              var r3 = this._writableState;
              return "function" == typeof e2 ? (n3 = e2, e2 = null, t3 = null) : "function" == typeof t3 && (n3 = t3, t3 = null), null !== e2 && void 0 !== e2 && this.write(e2, t3), r3.corked && (r3.corked = 1, this.uncork()), r3.ending || T(this, r3, n3), this;
            }, Object.defineProperty(l.prototype, "writableLength", { enumerable: false, get: function() {
              return this._writableState.length;
            } }), Object.defineProperty(l.prototype, "destroyed", { enumerable: false, get: function() {
              return void 0 !== this._writableState && this._writableState.destroyed;
            }, set: function(e2) {
              this._writableState && (this._writableState.destroyed = e2);
            } }), l.prototype.destroy = D.destroy, l.prototype._undestroy = D.undestroy, l.prototype._destroy = function(e2, t3) {
              t3(e2);
            };
          }).call(this);
        }).call(this, e("_process"), "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, { "../errors": 15, "./_stream_duplex": 16, "./internal/streams/destroy": 23, "./internal/streams/state": 27, "./internal/streams/stream": 28, _process: 12, buffer: 3, inherits: 10, "util-deprecate": 32 }], 21: [function(e, t2) {
        (function(n2) {
          (function() {
            "use strict";
            function r2(e2, t3, n3) {
              return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
            }
            function a(e2, t3) {
              return { value: e2, done: t3 };
            }
            function o(e2) {
              var t3 = e2[c];
              if (null !== t3) {
                var n3 = e2[h].read();
                null !== n3 && (e2[g] = null, e2[c] = null, e2[u] = null, t3(a(n3, false)));
              }
            }
            function i(e2) {
              n2.nextTick(o, e2);
            }
            function d(e2, t3) {
              return function(n3, r3) {
                e2.then(function() {
                  return t3[f] ? void n3(a(void 0, true)) : void t3[_](n3, r3);
                }, r3);
              };
            }
            var s, l = e("./end-of-stream"), c = Symbol("lastResolve"), u = Symbol("lastReject"), p = Symbol("error"), f = Symbol("ended"), g = Symbol("lastPromise"), _ = Symbol("handlePromise"), h = Symbol("stream"), m = Object.getPrototypeOf(function() {
            }), b = Object.setPrototypeOf((s = { get stream() {
              return this[h];
            }, next: function() {
              var e2 = this, t3 = this[p];
              if (null !== t3)
                return Promise.reject(t3);
              if (this[f])
                return Promise.resolve(a(void 0, true));
              if (this[h].destroyed)
                return new Promise(function(t4, r4) {
                  n2.nextTick(function() {
                    e2[p] ? r4(e2[p]) : t4(a(void 0, true));
                  });
                });
              var r3, o2 = this[g];
              if (o2)
                r3 = new Promise(d(o2, this));
              else {
                var i2 = this[h].read();
                if (null !== i2)
                  return Promise.resolve(a(i2, false));
                r3 = new Promise(this[_]);
              }
              return this[g] = r3, r3;
            } }, r2(s, Symbol.asyncIterator, function() {
              return this;
            }), r2(s, "return", function() {
              var e2 = this;
              return new Promise(function(t3, n3) {
                e2[h].destroy(null, function(e3) {
                  return e3 ? void n3(e3) : void t3(a(void 0, true));
                });
              });
            }), s), m);
            t2.exports = function(e2) {
              var t3, n3 = Object.create(b, (t3 = {}, r2(t3, h, { value: e2, writable: true }), r2(t3, c, { value: null, writable: true }), r2(t3, u, { value: null, writable: true }), r2(t3, p, { value: null, writable: true }), r2(t3, f, { value: e2._readableState.endEmitted, writable: true }), r2(t3, _, { value: function(e3, t4) {
                var r3 = n3[h].read();
                r3 ? (n3[g] = null, n3[c] = null, n3[u] = null, e3(a(r3, false))) : (n3[c] = e3, n3[u] = t4);
              }, writable: true }), t3));
              return n3[g] = null, l(e2, function(e3) {
                if (e3 && "ERR_STREAM_PREMATURE_CLOSE" !== e3.code) {
                  var t4 = n3[u];
                  return null !== t4 && (n3[g] = null, n3[c] = null, n3[u] = null, t4(e3)), void (n3[p] = e3);
                }
                var r3 = n3[c];
                null !== r3 && (n3[g] = null, n3[c] = null, n3[u] = null, r3(a(void 0, true))), n3[f] = true;
              }), e2.on("readable", i.bind(null, n3)), n3;
            };
          }).call(this);
        }).call(this, e("_process"));
      }, { "./end-of-stream": 24, _process: 12 }], 22: [function(e, t2) {
        "use strict";
        function n2(e2, t3) {
          var n3 = Object.keys(e2);
          if (Object.getOwnPropertySymbols) {
            var r3 = Object.getOwnPropertySymbols(e2);
            t3 && (r3 = r3.filter(function(t4) {
              return Object.getOwnPropertyDescriptor(e2, t4).enumerable;
            })), n3.push.apply(n3, r3);
          }
          return n3;
        }
        function r2(e2) {
          for (var t3, r3 = 1; r3 < arguments.length; r3++)
            t3 = null == arguments[r3] ? {} : arguments[r3], r3 % 2 ? n2(Object(t3), true).forEach(function(n3) {
              a(e2, n3, t3[n3]);
            }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t3)) : n2(Object(t3)).forEach(function(n3) {
              Object.defineProperty(e2, n3, Object.getOwnPropertyDescriptor(t3, n3));
            });
          return e2;
        }
        function a(e2, t3, n3) {
          return t3 in e2 ? Object.defineProperty(e2, t3, { value: n3, enumerable: true, configurable: true, writable: true }) : e2[t3] = n3, e2;
        }
        function o(e2, t3) {
          if (!(e2 instanceof t3))
            throw new TypeError("Cannot call a class as a function");
        }
        function i(e2, t3) {
          for (var n3, r3 = 0; r3 < t3.length; r3++)
            n3 = t3[r3], n3.enumerable = n3.enumerable || false, n3.configurable = true, "value" in n3 && (n3.writable = true), Object.defineProperty(e2, n3.key, n3);
        }
        function d(e2, t3, n3) {
          return t3 && i(e2.prototype, t3), n3 && i(e2, n3), e2;
        }
        function s(e2, t3, n3) {
          u.prototype.copy.call(e2, t3, n3);
        }
        var l = e("buffer"), u = l.Buffer, p = e("util"), f = p.inspect, g = f && f.custom || "inspect";
        t2.exports = function() {
          function e2() {
            o(this, e2), this.head = null, this.tail = null, this.length = 0;
          }
          return d(e2, [{ key: "push", value: function(e3) {
            var t3 = { data: e3, next: null };
            0 < this.length ? this.tail.next = t3 : this.head = t3, this.tail = t3, ++this.length;
          } }, { key: "unshift", value: function(e3) {
            var t3 = { data: e3, next: this.head };
            0 === this.length && (this.tail = t3), this.head = t3, ++this.length;
          } }, { key: "shift", value: function() {
            if (0 !== this.length) {
              var e3 = this.head.data;
              return this.head = 1 === this.length ? this.tail = null : this.head.next, --this.length, e3;
            }
          } }, { key: "clear", value: function() {
            this.head = this.tail = null, this.length = 0;
          } }, { key: "join", value: function(e3) {
            if (0 === this.length)
              return "";
            for (var t3 = this.head, n3 = "" + t3.data; t3 = t3.next; )
              n3 += e3 + t3.data;
            return n3;
          } }, { key: "concat", value: function(e3) {
            if (0 === this.length)
              return u.alloc(0);
            for (var t3 = u.allocUnsafe(e3 >>> 0), n3 = this.head, r3 = 0; n3; )
              s(n3.data, t3, r3), r3 += n3.data.length, n3 = n3.next;
            return t3;
          } }, { key: "consume", value: function(e3, t3) {
            var n3;
            return e3 < this.head.data.length ? (n3 = this.head.data.slice(0, e3), this.head.data = this.head.data.slice(e3)) : e3 === this.head.data.length ? n3 = this.shift() : n3 = t3 ? this._getString(e3) : this._getBuffer(e3), n3;
          } }, { key: "first", value: function() {
            return this.head.data;
          } }, { key: "_getString", value: function(e3) {
            var t3 = this.head, r3 = 1, a2 = t3.data;
            for (e3 -= a2.length; t3 = t3.next; ) {
              var o2 = t3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (a2 += i2 === o2.length ? o2 : o2.slice(0, e3), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++r3, this.head = t3.next ? t3.next : this.tail = null) : (this.head = t3, t3.data = o2.slice(i2));
                break;
              }
              ++r3;
            }
            return this.length -= r3, a2;
          } }, { key: "_getBuffer", value: function(e3) {
            var t3 = u.allocUnsafe(e3), r3 = this.head, a2 = 1;
            for (r3.data.copy(t3), e3 -= r3.data.length; r3 = r3.next; ) {
              var o2 = r3.data, i2 = e3 > o2.length ? o2.length : e3;
              if (o2.copy(t3, t3.length - e3, 0, i2), e3 -= i2, 0 === e3) {
                i2 === o2.length ? (++a2, this.head = r3.next ? r3.next : this.tail = null) : (this.head = r3, r3.data = o2.slice(i2));
                break;
              }
              ++a2;
            }
            return this.length -= a2, t3;
          } }, { key: g, value: function(e3, t3) {
            return f(this, r2({}, t3, { depth: 0, customInspect: false }));
          } }]), e2;
        }();
      }, { buffer: 3, util: 2 }], 23: [function(e, t2) {
        (function(e2) {
          (function() {
            "use strict";
            function n2(e3, t3) {
              a(e3, t3), r2(e3);
            }
            function r2(e3) {
              e3._writableState && !e3._writableState.emitClose || e3._readableState && !e3._readableState.emitClose || e3.emit("close");
            }
            function a(e3, t3) {
              e3.emit("error", t3);
            }
            t2.exports = { destroy: function(t3, o) {
              var i = this, d = this._readableState && this._readableState.destroyed, s = this._writableState && this._writableState.destroyed;
              return d || s ? (o ? o(t3) : t3 && (this._writableState ? !this._writableState.errorEmitted && (this._writableState.errorEmitted = true, e2.nextTick(a, this, t3)) : e2.nextTick(a, this, t3)), this) : (this._readableState && (this._readableState.destroyed = true), this._writableState && (this._writableState.destroyed = true), this._destroy(t3 || null, function(t4) {
                !o && t4 ? i._writableState ? i._writableState.errorEmitted ? e2.nextTick(r2, i) : (i._writableState.errorEmitted = true, e2.nextTick(n2, i, t4)) : e2.nextTick(n2, i, t4) : o ? (e2.nextTick(r2, i), o(t4)) : e2.nextTick(r2, i);
              }), this);
            }, undestroy: function() {
              this._readableState && (this._readableState.destroyed = false, this._readableState.reading = false, this._readableState.ended = false, this._readableState.endEmitted = false), this._writableState && (this._writableState.destroyed = false, this._writableState.ended = false, this._writableState.ending = false, this._writableState.finalCalled = false, this._writableState.prefinished = false, this._writableState.finished = false, this._writableState.errorEmitted = false);
            }, errorOrDestroy: function(e3, t3) {
              var n3 = e3._readableState, r3 = e3._writableState;
              n3 && n3.autoDestroy || r3 && r3.autoDestroy ? e3.destroy(t3) : e3.emit("error", t3);
            } };
          }).call(this);
        }).call(this, e("_process"));
      }, { _process: 12 }], 24: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            if (!t3) {
              t3 = true;
              for (var n3 = arguments.length, r3 = Array(n3), a2 = 0; a2 < n3; a2++)
                r3[a2] = arguments[a2];
              e2.apply(this, r3);
            }
          };
        }
        function r2() {
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(e2, t3, d) {
          if ("function" == typeof t3)
            return o(e2, null, t3);
          t3 || (t3 = {}), d = n2(d || r2);
          var s = t3.readable || false !== t3.readable && e2.readable, l = t3.writable || false !== t3.writable && e2.writable, c = function() {
            e2.writable || p();
          }, u = e2._writableState && e2._writableState.finished, p = function() {
            l = false, u = true, s || d.call(e2);
          }, f = e2._readableState && e2._readableState.endEmitted, g = function() {
            s = false, f = true, l || d.call(e2);
          }, _ = function(t4) {
            d.call(e2, t4);
          }, h = function() {
            var t4;
            return s && !f ? (e2._readableState && e2._readableState.ended || (t4 = new i()), d.call(e2, t4)) : l && !u ? (e2._writableState && e2._writableState.ended || (t4 = new i()), d.call(e2, t4)) : void 0;
          }, m = function() {
            e2.req.on("finish", p);
          };
          return a(e2) ? (e2.on("complete", p), e2.on("abort", h), e2.req ? m() : e2.on("request", m)) : l && !e2._writableState && (e2.on("end", c), e2.on("close", c)), e2.on("end", g), e2.on("finish", p), false !== t3.error && e2.on("error", _), e2.on("close", h), function() {
            e2.removeListener("complete", p), e2.removeListener("abort", h), e2.removeListener("request", m), e2.req && e2.req.removeListener("finish", p), e2.removeListener("end", c), e2.removeListener("close", c), e2.removeListener("finish", p), e2.removeListener("end", g), e2.removeListener("error", _), e2.removeListener("close", h);
          };
        }
        var i = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
        t2.exports = o;
      }, { "../../../errors": 15 }], 25: [function(e, t2) {
        t2.exports = function() {
          throw new Error("Readable.from is not available in the browser");
        };
      }, {}], 26: [function(e, t2) {
        "use strict";
        function n2(e2) {
          var t3 = false;
          return function() {
            t3 || (t3 = true, e2.apply(void 0, arguments));
          };
        }
        function r2(e2) {
          if (e2)
            throw e2;
        }
        function a(e2) {
          return e2.setHeader && "function" == typeof e2.abort;
        }
        function o(t3, r3, o2, i2) {
          i2 = n2(i2);
          var d2 = false;
          t3.on("close", function() {
            d2 = true;
          }), l === void 0 && (l = e("./end-of-stream")), l(t3, { readable: r3, writable: o2 }, function(e2) {
            return e2 ? i2(e2) : void (d2 = true, i2());
          });
          var s2 = false;
          return function(e2) {
            if (!d2)
              return s2 ? void 0 : (s2 = true, a(t3) ? t3.abort() : "function" == typeof t3.destroy ? t3.destroy() : void i2(e2 || new p("pipe")));
          };
        }
        function i(e2) {
          e2();
        }
        function d(e2, t3) {
          return e2.pipe(t3);
        }
        function s(e2) {
          return e2.length ? "function" == typeof e2[e2.length - 1] ? e2.pop() : r2 : r2;
        }
        var l, c = e("../../../errors").codes, u = c.ERR_MISSING_ARGS, p = c.ERR_STREAM_DESTROYED;
        t2.exports = function() {
          for (var e2 = arguments.length, t3 = Array(e2), n3 = 0; n3 < e2; n3++)
            t3[n3] = arguments[n3];
          var r3 = s(t3);
          if (Array.isArray(t3[0]) && (t3 = t3[0]), 2 > t3.length)
            throw new u("streams");
          var a2, l2 = t3.map(function(e3, n4) {
            var d2 = n4 < t3.length - 1;
            return o(e3, d2, 0 < n4, function(e4) {
              a2 || (a2 = e4), e4 && l2.forEach(i), d2 || (l2.forEach(i), r3(a2));
            });
          });
          return t3.reduce(d);
        };
      }, { "../../../errors": 15, "./end-of-stream": 24 }], 27: [function(e, n2) {
        "use strict";
        function r2(e2, t2, n3) {
          return null == e2.highWaterMark ? t2 ? e2[n3] : null : e2.highWaterMark;
        }
        var a = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
        n2.exports = { getHighWaterMark: function(e2, n3, o, i) {
          var d = r2(n3, i, o);
          if (null != d) {
            if (!(isFinite(d) && t(d) === d) || 0 > d) {
              var s = i ? o : "highWaterMark";
              throw new a(s, d);
            }
            return t(d);
          }
          return e2.objectMode ? 16 : 16384;
        } };
      }, { "../../../errors": 15 }], 28: [function(e, t2) {
        t2.exports = e("events").EventEmitter;
      }, { events: 7 }], 29: [function(e, t2, n2) {
        n2 = t2.exports = e("./lib/_stream_readable.js"), n2.Stream = n2, n2.Readable = n2, n2.Writable = e("./lib/_stream_writable.js"), n2.Duplex = e("./lib/_stream_duplex.js"), n2.Transform = e("./lib/_stream_transform.js"), n2.PassThrough = e("./lib/_stream_passthrough.js"), n2.finished = e("./lib/internal/streams/end-of-stream.js"), n2.pipeline = e("./lib/internal/streams/pipeline.js");
      }, { "./lib/_stream_duplex.js": 16, "./lib/_stream_passthrough.js": 17, "./lib/_stream_readable.js": 18, "./lib/_stream_transform.js": 19, "./lib/_stream_writable.js": 20, "./lib/internal/streams/end-of-stream.js": 24, "./lib/internal/streams/pipeline.js": 26 }], 30: [function(e, t2, n2) {
        function r2(e2, t3) {
          for (var n3 in e2)
            t3[n3] = e2[n3];
        }
        function a(e2, t3, n3) {
          return i(e2, t3, n3);
        }
        var o = e("buffer"), i = o.Buffer;
        i.from && i.alloc && i.allocUnsafe && i.allocUnsafeSlow ? t2.exports = o : (r2(o, n2), n2.Buffer = a), a.prototype = Object.create(i.prototype), r2(i, a), a.from = function(e2, t3, n3) {
          if ("number" == typeof e2)
            throw new TypeError("Argument must not be a number");
          return i(e2, t3, n3);
        }, a.alloc = function(e2, t3, n3) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          var r3 = i(e2);
          return void 0 === t3 ? r3.fill(0) : "string" == typeof n3 ? r3.fill(t3, n3) : r3.fill(t3), r3;
        }, a.allocUnsafe = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return i(e2);
        }, a.allocUnsafeSlow = function(e2) {
          if ("number" != typeof e2)
            throw new TypeError("Argument must be a number");
          return o.SlowBuffer(e2);
        };
      }, { buffer: 3 }], 31: [function(e, t2, n2) {
        "use strict";
        function r2(e2) {
          if (!e2)
            return "utf8";
          for (var t3; ; )
            switch (e2) {
              case "utf8":
              case "utf-8":
                return "utf8";
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return "utf16le";
              case "latin1":
              case "binary":
                return "latin1";
              case "base64":
              case "ascii":
              case "hex":
                return e2;
              default:
                if (t3)
                  return;
                e2 = ("" + e2).toLowerCase(), t3 = true;
            }
        }
        function a(e2) {
          var t3 = r2(e2);
          if ("string" != typeof t3 && (m.isEncoding === b || !b(e2)))
            throw new Error("Unknown encoding: " + e2);
          return t3 || e2;
        }
        function o(e2) {
          this.encoding = a(e2);
          var t3;
          switch (this.encoding) {
            case "utf16le":
              this.text = u, this.end = p, t3 = 4;
              break;
            case "utf8":
              this.fillLast = c, t3 = 4;
              break;
            case "base64":
              this.text = f, this.end = g, t3 = 3;
              break;
            default:
              return this.write = _, void (this.end = h);
          }
          this.lastNeed = 0, this.lastTotal = 0, this.lastChar = m.allocUnsafe(t3);
        }
        function d(e2) {
          if (127 >= e2)
            return 0;
          return 6 == e2 >> 5 ? 2 : 14 == e2 >> 4 ? 3 : 30 == e2 >> 3 ? 4 : 2 == e2 >> 6 ? -1 : -2;
        }
        function s(e2, t3, n3) {
          var r3 = t3.length - 1;
          if (r3 < n3)
            return 0;
          var a2 = d(t3[r3]);
          return 0 <= a2 ? (0 < a2 && (e2.lastNeed = a2 - 1), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2) ? (0 < a2 && (e2.lastNeed = a2 - 2), a2) : --r3 < n3 || -2 === a2 ? 0 : (a2 = d(t3[r3]), 0 <= a2 ? (0 < a2 && (2 === a2 ? a2 = 0 : e2.lastNeed = a2 - 3), a2) : 0);
        }
        function l(e2, t3) {
          if (128 != (192 & t3[0]))
            return e2.lastNeed = 0, "\uFFFD";
          if (1 < e2.lastNeed && 1 < t3.length) {
            if (128 != (192 & t3[1]))
              return e2.lastNeed = 1, "\uFFFD";
            if (2 < e2.lastNeed && 2 < t3.length && 128 != (192 & t3[2]))
              return e2.lastNeed = 2, "\uFFFD";
          }
        }
        function c(e2) {
          var t3 = this.lastTotal - this.lastNeed, n3 = l(this, e2, t3);
          return void 0 === n3 ? this.lastNeed <= e2.length ? (e2.copy(this.lastChar, t3, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, t3, 0, e2.length), this.lastNeed -= e2.length) : n3;
        }
        function u(e2, t3) {
          if (0 == (e2.length - t3) % 2) {
            var n3 = e2.toString("utf16le", t3);
            if (n3) {
              var r3 = n3.charCodeAt(n3.length - 1);
              if (55296 <= r3 && 56319 >= r3)
                return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1], n3.slice(0, -1);
            }
            return n3;
          }
          return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e2[e2.length - 1], e2.toString("utf16le", t3, e2.length - 1);
        }
        function p(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          if (this.lastNeed) {
            var n3 = this.lastTotal - this.lastNeed;
            return t3 + this.lastChar.toString("utf16le", 0, n3);
          }
          return t3;
        }
        function f(e2, t3) {
          var r3 = (e2.length - t3) % 3;
          return 0 == r3 ? e2.toString("base64", t3) : (this.lastNeed = 3 - r3, this.lastTotal = 3, 1 == r3 ? this.lastChar[0] = e2[e2.length - 1] : (this.lastChar[0] = e2[e2.length - 2], this.lastChar[1] = e2[e2.length - 1]), e2.toString("base64", t3, e2.length - r3));
        }
        function g(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t3;
        }
        function _(e2) {
          return e2.toString(this.encoding);
        }
        function h(e2) {
          return e2 && e2.length ? this.write(e2) : "";
        }
        var m = e("safe-buffer").Buffer, b = m.isEncoding || function(e2) {
          switch (e2 = "" + e2, e2 && e2.toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
            case "raw":
              return true;
            default:
              return false;
          }
        };
        n2.StringDecoder = o, o.prototype.write = function(e2) {
          if (0 === e2.length)
            return "";
          var t3, n3;
          if (this.lastNeed) {
            if (t3 = this.fillLast(e2), void 0 === t3)
              return "";
            n3 = this.lastNeed, this.lastNeed = 0;
          } else
            n3 = 0;
          return n3 < e2.length ? t3 ? t3 + this.text(e2, n3) : this.text(e2, n3) : t3 || "";
        }, o.prototype.end = function(e2) {
          var t3 = e2 && e2.length ? this.write(e2) : "";
          return this.lastNeed ? t3 + "\uFFFD" : t3;
        }, o.prototype.text = function(e2, t3) {
          var n3 = s(this, e2, t3);
          if (!this.lastNeed)
            return e2.toString("utf8", t3);
          this.lastTotal = n3;
          var r3 = e2.length - (n3 - this.lastNeed);
          return e2.copy(this.lastChar, 0, r3), e2.toString("utf8", t3, r3);
        }, o.prototype.fillLast = function(e2) {
          return this.lastNeed <= e2.length ? (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : void (e2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e2.length), this.lastNeed -= e2.length);
        };
      }, { "safe-buffer": 30 }], 32: [function(e, t2) {
        (function(e2) {
          (function() {
            function n2(t3) {
              try {
                if (!e2.localStorage)
                  return false;
              } catch (e3) {
                return false;
              }
              var n3 = e2.localStorage[t3];
              return null != n3 && "true" === (n3 + "").toLowerCase();
            }
            t2.exports = function(e3, t3) {
              function r2() {
                if (!a) {
                  if (n2("throwDeprecation"))
                    throw new Error(t3);
                  else
                    n2("traceDeprecation") ? console.trace(t3) : console.warn(t3);
                  a = true;
                }
                return e3.apply(this, arguments);
              }
              if (n2("noDeprecation"))
                return e3;
              var a = false;
              return r2;
            };
          }).call(this);
        }).call(this, "undefined" == typeof global ? "undefined" == typeof self ? "undefined" == typeof window ? {} : window : self : global);
      }, {}], "/": [function(e, t2) {
        function n2(e2) {
          return e2.replace(/a=ice-options:trickle\s\n/g, "");
        }
        function r2(e2) {
          console.warn(e2);
        }
        const a = e("debug")("simple-peer"), o = e("get-browser-rtc"), i = e("randombytes"), d = e("readable-stream"), s = e("queue-microtask"), l = e("err-code"), { Buffer: c } = e("buffer"), u = 65536;
        class p extends d.Duplex {
          constructor(e2) {
            if (e2 = Object.assign({ allowHalfOpen: false }, e2), super(e2), this._id = i(4).toString("hex").slice(0, 7), this._debug("new peer %o", e2), this.channelName = e2.initiator ? e2.channelName || i(20).toString("hex") : null, this.initiator = e2.initiator || false, this.channelConfig = e2.channelConfig || p.channelConfig, this.channelNegotiated = this.channelConfig.negotiated, this.config = Object.assign({}, p.config, e2.config), this.offerOptions = e2.offerOptions || {}, this.answerOptions = e2.answerOptions || {}, this.sdpTransform = e2.sdpTransform || ((e3) => e3), this.streams = e2.streams || (e2.stream ? [e2.stream] : []), this.trickle = void 0 === e2.trickle || e2.trickle, this.allowHalfTrickle = void 0 !== e2.allowHalfTrickle && e2.allowHalfTrickle, this.iceCompleteTimeout = e2.iceCompleteTimeout || 5e3, this.destroyed = false, this.destroying = false, this._connected = false, this.remoteAddress = void 0, this.remoteFamily = void 0, this.remotePort = void 0, this.localAddress = void 0, this.localFamily = void 0, this.localPort = void 0, this._wrtc = e2.wrtc && "object" == typeof e2.wrtc ? e2.wrtc : o(), !this._wrtc)
              if ("undefined" == typeof window)
                throw l(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
              else
                throw l(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
            this._pcReady = false, this._channelReady = false, this._iceComplete = false, this._iceCompleteTimer = null, this._channel = null, this._pendingCandidates = [], this._isNegotiating = false, this._firstNegotiation = true, this._batchedNegotiation = false, this._queuedNegotiation = false, this._sendersAwaitingStable = [], this._senderMap = /* @__PURE__ */ new Map(), this._closingInterval = null, this._remoteTracks = [], this._remoteStreams = [], this._chunk = null, this._cb = null, this._interval = null;
            try {
              this._pc = new this._wrtc.RTCPeerConnection(this.config);
            } catch (e3) {
              return void this.destroy(l(e3, "ERR_PC_CONSTRUCTOR"));
            }
            this._isReactNativeWebrtc = "number" == typeof this._pc._peerConnectionId, this._pc.oniceconnectionstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onicegatheringstatechange = () => {
              this._onIceStateChange();
            }, this._pc.onconnectionstatechange = () => {
              this._onConnectionStateChange();
            }, this._pc.onsignalingstatechange = () => {
              this._onSignalingStateChange();
            }, this._pc.onicecandidate = (e3) => {
              this._onIceCandidate(e3);
            }, "object" == typeof this._pc.peerIdentity && this._pc.peerIdentity.catch((e3) => {
              this.destroy(l(e3, "ERR_PC_PEER_IDENTITY"));
            }), this.initiator || this.channelNegotiated ? this._setupData({ channel: this._pc.createDataChannel(this.channelName, this.channelConfig) }) : this._pc.ondatachannel = (e3) => {
              this._setupData(e3);
            }, this.streams && this.streams.forEach((e3) => {
              this.addStream(e3);
            }), this._pc.ontrack = (e3) => {
              this._onTrack(e3);
            }, this._debug("initial negotiation"), this._needsNegotiation(), this._onFinishBound = () => {
              this._onFinish();
            }, this.once("finish", this._onFinishBound);
          }
          get bufferSize() {
            return this._channel && this._channel.bufferedAmount || 0;
          }
          get connected() {
            return this._connected && "open" === this._channel.readyState;
          }
          address() {
            return { port: this.localPort, family: this.localFamily, address: this.localAddress };
          }
          signal(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot signal after peer is destroyed"), "ERR_DESTROYED");
              if ("string" == typeof e2)
                try {
                  e2 = JSON.parse(e2);
                } catch (t3) {
                  e2 = {};
                }
              this._debug("signal()"), e2.renegotiate && this.initiator && (this._debug("got request to renegotiate"), this._needsNegotiation()), e2.transceiverRequest && this.initiator && (this._debug("got request for transceiver"), this.addTransceiver(e2.transceiverRequest.kind, e2.transceiverRequest.init)), e2.candidate && (this._pc.remoteDescription && this._pc.remoteDescription.type ? this._addIceCandidate(e2.candidate) : this._pendingCandidates.push(e2.candidate)), e2.sdp && this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(e2)).then(() => {
                this.destroyed || (this._pendingCandidates.forEach((e3) => {
                  this._addIceCandidate(e3);
                }), this._pendingCandidates = [], "offer" === this._pc.remoteDescription.type && this._createAnswer());
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_REMOTE_DESCRIPTION"));
              }), e2.sdp || e2.candidate || e2.renegotiate || e2.transceiverRequest || this.destroy(l(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
            }
          }
          _addIceCandidate(e2) {
            const t3 = new this._wrtc.RTCIceCandidate(e2);
            this._pc.addIceCandidate(t3).catch((e3) => {
              !t3.address || t3.address.endsWith(".local") ? r2("Ignoring unsupported ICE candidate.") : this.destroy(l(e3, "ERR_ADD_ICE_CANDIDATE"));
            });
          }
          send(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot send after peer is destroyed"), "ERR_DESTROYED");
              this._channel.send(e2);
            }
          }
          addTransceiver(e2, t3) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addTransceiver after peer is destroyed"), "ERR_DESTROYED");
              if (this._debug("addTransceiver()"), this.initiator)
                try {
                  this._pc.addTransceiver(e2, t3), this._needsNegotiation();
                } catch (e3) {
                  this.destroy(l(e3, "ERR_ADD_TRANSCEIVER"));
                }
              else
                this.emit("signal", { type: "transceiverRequest", transceiverRequest: { kind: e2, init: t3 } });
            }
          }
          addStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot addStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("addStream()"), e2.getTracks().forEach((t3) => {
                this.addTrack(t3, e2);
              });
            }
          }
          addTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot addTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("addTrack()");
            const n3 = this._senderMap.get(e2) || /* @__PURE__ */ new Map();
            let r3 = n3.get(t3);
            if (!r3)
              r3 = this._pc.addTrack(e2, t3), n3.set(t3, r3), this._senderMap.set(e2, n3), this._needsNegotiation();
            else if (r3.removed)
              throw l(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
            else
              throw l(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
          }
          replaceTrack(e2, t3, n3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot replaceTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("replaceTrack()");
            const r3 = this._senderMap.get(e2), a2 = r3 ? r3.get(n3) : null;
            if (!a2)
              throw l(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
            t3 && this._senderMap.set(t3, r3), null == a2.replaceTrack ? this.destroy(l(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK")) : a2.replaceTrack(t3);
          }
          removeTrack(e2, t3) {
            if (this.destroying)
              return;
            if (this.destroyed)
              throw l(new Error("cannot removeTrack after peer is destroyed"), "ERR_DESTROYED");
            this._debug("removeSender()");
            const n3 = this._senderMap.get(e2), r3 = n3 ? n3.get(t3) : null;
            if (!r3)
              throw l(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
            try {
              r3.removed = true, this._pc.removeTrack(r3);
            } catch (e3) {
              "NS_ERROR_UNEXPECTED" === e3.name ? this._sendersAwaitingStable.push(r3) : this.destroy(l(e3, "ERR_REMOVE_TRACK"));
            }
            this._needsNegotiation();
          }
          removeStream(e2) {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot removeStream after peer is destroyed"), "ERR_DESTROYED");
              this._debug("removeSenders()"), e2.getTracks().forEach((t3) => {
                this.removeTrack(t3, e2);
              });
            }
          }
          _needsNegotiation() {
            this._debug("_needsNegotiation"), this._batchedNegotiation || (this._batchedNegotiation = true, s(() => {
              this._batchedNegotiation = false, this.initiator || !this._firstNegotiation ? (this._debug("starting batched negotiation"), this.negotiate()) : this._debug("non-initiator initial negotiation request discarded"), this._firstNegotiation = false;
            }));
          }
          negotiate() {
            if (!this.destroying) {
              if (this.destroyed)
                throw l(new Error("cannot negotiate after peer is destroyed"), "ERR_DESTROYED");
              this.initiator ? this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("start negotiation"), setTimeout(() => {
                this._createOffer();
              }, 0)) : this._isNegotiating ? (this._queuedNegotiation = true, this._debug("already negotiating, queueing")) : (this._debug("requesting negotiation from initiator"), this.emit("signal", { type: "renegotiate", renegotiate: true })), this._isNegotiating = true;
            }
          }
          destroy(e2) {
            this._destroy(e2, () => {
            });
          }
          _destroy(e2, t3) {
            this.destroyed || this.destroying || (this.destroying = true, this._debug("destroying (error: %s)", e2 && (e2.message || e2)), s(() => {
              if (this.destroyed = true, this.destroying = false, this._debug("destroy (error: %s)", e2 && (e2.message || e2)), this.readable = this.writable = false, this._readableState.ended || this.push(null), this._writableState.finished || this.end(), this._connected = false, this._pcReady = false, this._channelReady = false, this._remoteTracks = null, this._remoteStreams = null, this._senderMap = null, clearInterval(this._closingInterval), this._closingInterval = null, clearInterval(this._interval), this._interval = null, this._chunk = null, this._cb = null, this._onFinishBound && this.removeListener("finish", this._onFinishBound), this._onFinishBound = null, this._channel) {
                try {
                  this._channel.close();
                } catch (e3) {
                }
                this._channel.onmessage = null, this._channel.onopen = null, this._channel.onclose = null, this._channel.onerror = null;
              }
              if (this._pc) {
                try {
                  this._pc.close();
                } catch (e3) {
                }
                this._pc.oniceconnectionstatechange = null, this._pc.onicegatheringstatechange = null, this._pc.onsignalingstatechange = null, this._pc.onicecandidate = null, this._pc.ontrack = null, this._pc.ondatachannel = null;
              }
              this._pc = null, this._channel = null, e2 && this.emit("error", e2), this.emit("close"), t3();
            }));
          }
          _setupData(e2) {
            if (!e2.channel)
              return this.destroy(l(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
            this._channel = e2.channel, this._channel.binaryType = "arraybuffer", "number" == typeof this._channel.bufferedAmountLowThreshold && (this._channel.bufferedAmountLowThreshold = u), this.channelName = this._channel.label, this._channel.onmessage = (e3) => {
              this._onChannelMessage(e3);
            }, this._channel.onbufferedamountlow = () => {
              this._onChannelBufferedAmountLow();
            }, this._channel.onopen = () => {
              this._onChannelOpen();
            }, this._channel.onclose = () => {
              this._onChannelClose();
            }, this._channel.onerror = (e3) => {
              const t4 = e3.error instanceof Error ? e3.error : new Error(`Datachannel error: ${e3.message} ${e3.filename}:${e3.lineno}:${e3.colno}`);
              this.destroy(l(t4, "ERR_DATA_CHANNEL"));
            };
            let t3 = false;
            this._closingInterval = setInterval(() => {
              this._channel && "closing" === this._channel.readyState ? (t3 && this._onChannelClose(), t3 = true) : t3 = false;
            }, 5e3);
          }
          _read() {
          }
          _write(e2, t3, n3) {
            if (this.destroyed)
              return n3(l(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
            if (this._connected) {
              try {
                this.send(e2);
              } catch (e3) {
                return this.destroy(l(e3, "ERR_DATA_CHANNEL"));
              }
              this._channel.bufferedAmount > u ? (this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount), this._cb = n3) : n3(null);
            } else
              this._debug("write before connect"), this._chunk = e2, this._cb = n3;
          }
          _onFinish() {
            if (!this.destroyed) {
              const e2 = () => {
                setTimeout(() => this.destroy(), 1e3);
              };
              this._connected ? e2() : this.once("connect", e2);
            }
          }
          _startIceCompleteTimeout() {
            this.destroyed || this._iceCompleteTimer || (this._debug("started iceComplete timeout"), this._iceCompleteTimer = setTimeout(() => {
              this._iceComplete || (this._iceComplete = true, this._debug("iceComplete timeout completed"), this.emit("iceTimeout"), this.emit("_iceComplete"));
            }, this.iceCompleteTimeout));
          }
          _createOffer() {
            this.destroyed || this._pc.createOffer(this.offerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp });
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this._debug("createOffer success"), this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_OFFER"));
            });
          }
          _requestMissingTransceivers() {
            this._pc.getTransceivers && this._pc.getTransceivers().forEach((e2) => {
              e2.mid || !e2.sender.track || e2.requested || (e2.requested = true, this.addTransceiver(e2.sender.track.kind));
            });
          }
          _createAnswer() {
            this.destroyed || this._pc.createAnswer(this.answerOptions).then((e2) => {
              if (this.destroyed)
                return;
              this.trickle || this.allowHalfTrickle || (e2.sdp = n2(e2.sdp)), e2.sdp = this.sdpTransform(e2.sdp);
              const t3 = () => {
                if (!this.destroyed) {
                  const t4 = this._pc.localDescription || e2;
                  this._debug("signal"), this.emit("signal", { type: t4.type, sdp: t4.sdp }), this.initiator || this._requestMissingTransceivers();
                }
              };
              this._pc.setLocalDescription(e2).then(() => {
                this.destroyed || (this.trickle || this._iceComplete ? t3() : this.once("_iceComplete", t3));
              }).catch((e3) => {
                this.destroy(l(e3, "ERR_SET_LOCAL_DESCRIPTION"));
              });
            }).catch((e2) => {
              this.destroy(l(e2, "ERR_CREATE_ANSWER"));
            });
          }
          _onConnectionStateChange() {
            this.destroyed || "failed" === this._pc.connectionState && this.destroy(l(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
          }
          _onIceStateChange() {
            if (this.destroyed)
              return;
            const e2 = this._pc.iceConnectionState, t3 = this._pc.iceGatheringState;
            this._debug("iceStateChange (connection: %s) (gathering: %s)", e2, t3), this.emit("iceStateChange", e2, t3), ("connected" === e2 || "completed" === e2) && (this._pcReady = true, this._maybeReady()), "failed" === e2 && this.destroy(l(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE")), "closed" === e2 && this.destroy(l(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
          }
          getStats(e2) {
            const t3 = (e3) => ("[object Array]" === Object.prototype.toString.call(e3.values) && e3.values.forEach((t4) => {
              Object.assign(e3, t4);
            }), e3);
            0 === this._pc.getStats.length || this._isReactNativeWebrtc ? this._pc.getStats().then((n3) => {
              const r3 = [];
              n3.forEach((e3) => {
                r3.push(t3(e3));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : 0 < this._pc.getStats.length ? this._pc.getStats((n3) => {
              if (this.destroyed)
                return;
              const r3 = [];
              n3.result().forEach((e3) => {
                const n4 = {};
                e3.names().forEach((t4) => {
                  n4[t4] = e3.stat(t4);
                }), n4.id = e3.id, n4.type = e3.type, n4.timestamp = e3.timestamp, r3.push(t3(n4));
              }), e2(null, r3);
            }, (t4) => e2(t4)) : e2(null, []);
          }
          _maybeReady() {
            if (this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady), this._connected || this._connecting || !this._pcReady || !this._channelReady)
              return;
            this._connecting = true;
            const e2 = () => {
              this.destroyed || this.getStats((t3, n3) => {
                if (this.destroyed)
                  return;
                t3 && (n3 = []);
                const r3 = {}, a2 = {}, o2 = {};
                let i2 = false;
                n3.forEach((e3) => {
                  ("remotecandidate" === e3.type || "remote-candidate" === e3.type) && (r3[e3.id] = e3), ("localcandidate" === e3.type || "local-candidate" === e3.type) && (a2[e3.id] = e3), ("candidatepair" === e3.type || "candidate-pair" === e3.type) && (o2[e3.id] = e3);
                });
                const d2 = (e3) => {
                  i2 = true;
                  let t4 = a2[e3.localCandidateId];
                  t4 && (t4.ip || t4.address) ? (this.localAddress = t4.ip || t4.address, this.localPort = +t4.port) : t4 && t4.ipAddress ? (this.localAddress = t4.ipAddress, this.localPort = +t4.portNumber) : "string" == typeof e3.googLocalAddress && (t4 = e3.googLocalAddress.split(":"), this.localAddress = t4[0], this.localPort = +t4[1]), this.localAddress && (this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4");
                  let n4 = r3[e3.remoteCandidateId];
                  n4 && (n4.ip || n4.address) ? (this.remoteAddress = n4.ip || n4.address, this.remotePort = +n4.port) : n4 && n4.ipAddress ? (this.remoteAddress = n4.ipAddress, this.remotePort = +n4.portNumber) : "string" == typeof e3.googRemoteAddress && (n4 = e3.googRemoteAddress.split(":"), this.remoteAddress = n4[0], this.remotePort = +n4[1]), this.remoteAddress && (this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4"), this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
                };
                if (n3.forEach((e3) => {
                  "transport" === e3.type && e3.selectedCandidatePairId && d2(o2[e3.selectedCandidatePairId]), ("googCandidatePair" === e3.type && "true" === e3.googActiveConnection || ("candidatepair" === e3.type || "candidate-pair" === e3.type) && e3.selected) && d2(e3);
                }), !i2 && (!Object.keys(o2).length || Object.keys(a2).length))
                  return void setTimeout(e2, 100);
                if (this._connecting = false, this._connected = true, this._chunk) {
                  try {
                    this.send(this._chunk);
                  } catch (e4) {
                    return this.destroy(l(e4, "ERR_DATA_CHANNEL"));
                  }
                  this._chunk = null, this._debug('sent chunk from "write before connect"');
                  const e3 = this._cb;
                  this._cb = null, e3(null);
                }
                "number" != typeof this._channel.bufferedAmountLowThreshold && (this._interval = setInterval(() => this._onInterval(), 150), this._interval.unref && this._interval.unref()), this._debug("connect"), this.emit("connect");
              });
            };
            e2();
          }
          _onInterval() {
            this._cb && this._channel && !(this._channel.bufferedAmount > u) && this._onChannelBufferedAmountLow();
          }
          _onSignalingStateChange() {
            this.destroyed || ("stable" === this._pc.signalingState && (this._isNegotiating = false, this._debug("flushing sender queue", this._sendersAwaitingStable), this._sendersAwaitingStable.forEach((e2) => {
              this._pc.removeTrack(e2), this._queuedNegotiation = true;
            }), this._sendersAwaitingStable = [], this._queuedNegotiation ? (this._debug("flushing negotiation queue"), this._queuedNegotiation = false, this._needsNegotiation()) : (this._debug("negotiated"), this.emit("negotiated"))), this._debug("signalingStateChange %s", this._pc.signalingState), this.emit("signalingStateChange", this._pc.signalingState));
          }
          _onIceCandidate(e2) {
            this.destroyed || (e2.candidate && this.trickle ? this.emit("signal", { type: "candidate", candidate: { candidate: e2.candidate.candidate, sdpMLineIndex: e2.candidate.sdpMLineIndex, sdpMid: e2.candidate.sdpMid } }) : !e2.candidate && !this._iceComplete && (this._iceComplete = true, this.emit("_iceComplete")), e2.candidate && this._startIceCompleteTimeout());
          }
          _onChannelMessage(e2) {
            if (this.destroyed)
              return;
            let t3 = e2.data;
            t3 instanceof ArrayBuffer && (t3 = c.from(t3)), this.push(t3);
          }
          _onChannelBufferedAmountLow() {
            if (!this.destroyed && this._cb) {
              this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
              const e2 = this._cb;
              this._cb = null, e2(null);
            }
          }
          _onChannelOpen() {
            this._connected || this.destroyed || (this._debug("on channel open"), this._channelReady = true, this._maybeReady());
          }
          _onChannelClose() {
            this.destroyed || (this._debug("on channel close"), this.destroy());
          }
          _onTrack(e2) {
            this.destroyed || e2.streams.forEach((t3) => {
              this._debug("on track"), this.emit("track", e2.track, t3), this._remoteTracks.push({ track: e2.track, stream: t3 }), this._remoteStreams.some((e3) => e3.id === t3.id) || (this._remoteStreams.push(t3), s(() => {
                this._debug("on stream"), this.emit("stream", t3);
              }));
            });
          }
          _debug() {
            const e2 = [].slice.call(arguments);
            e2[0] = "[" + this._id + "] " + e2[0], a.apply(null, e2);
          }
        }
        p.WEBRTC_SUPPORT = !!o(), p.config = { iceServers: [{ urls: ["stun:stun.l.google.com:19302", "stun:global.stun.twilio.com:3478"] }], sdpSemantics: "unified-plan" }, p.channelConfig = {}, t2.exports = p;
      }, { buffer: 3, debug: 4, "err-code": 6, "get-browser-rtc": 8, "queue-microtask": 13, randombytes: 14, "readable-stream": 29 }] }, {}, [])("/");
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => main_default
});
module.exports = __toCommonJS(main_exports);

// src/peerdraftPlugin.ts
var import_obsidian16 = require("obsidian");

// node_modules/lib0/math.js
var floor = Math.floor;
var abs = Math.abs;
var log10 = Math.log10;
var min = (a, b) => a < b ? a : b;
var max = (a, b) => a > b ? a : b;
var isNaN2 = Number.isNaN;
var pow = Math.pow;
var isNegativeZero = (n) => n !== 0 ? n < 0 : 1 / n < 0;

// node_modules/lib0/time.js
var getUnixTime = Date.now;

// node_modules/lib0/map.js
var create = () => /* @__PURE__ */ new Map();
var copy = (m) => {
  const r = create();
  m.forEach((v, k) => {
    r.set(k, v);
  });
  return r;
};
var setIfUndefined = (map2, key, createT) => {
  let set = map2.get(key);
  if (set === void 0) {
    map2.set(key, set = createT());
  }
  return set;
};
var map = (m, f) => {
  const res = [];
  for (const [key, value] of m) {
    res.push(f(value, key));
  }
  return res;
};
var any = (m, f) => {
  for (const [key, value] of m) {
    if (f(value, key)) {
      return true;
    }
  }
  return false;
};

// node_modules/lib0/set.js
var create2 = () => /* @__PURE__ */ new Set();

// node_modules/lib0/array.js
var last = (arr) => arr[arr.length - 1];
var appendTo = (dest, src) => {
  for (let i = 0; i < src.length; i++) {
    dest.push(src[i]);
  }
};
var from = Array.from;
var some = (arr, f) => {
  for (let i = 0; i < arr.length; i++) {
    if (f(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};
var isArray = Array.isArray;

// node_modules/lib0/observable.js
var ObservableV2 = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(name, f) {
    setIfUndefined(
      this._observers,
      /** @type {string} */
      name,
      create2
    ).add(f);
    return f;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(
        name,
        /** @type {any} */
        _f
      );
      f(...args2);
    };
    this.on(
      name,
      /** @type {any} */
      _f
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};
var Observable = class {
  constructor() {
    this._observers = create();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(name, f) {
    setIfUndefined(this._observers, name, create2).add(f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(name, f) {
    const _f = (...args2) => {
      this.off(name, _f);
      f(...args2);
    };
    this.on(name, _f);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(name, f) {
    const observers = this._observers.get(name);
    if (observers !== void 0) {
      observers.delete(f);
      if (observers.size === 0) {
        this._observers.delete(name);
      }
    }
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(name, args2) {
    return from((this._observers.get(name) || create()).values()).forEach((f) => f(...args2));
  }
  destroy() {
    this._observers = create();
  }
};

// src/sharedEntities/sharedDocument.ts
var import_obsidian11 = require("obsidian");

// node_modules/lib0/binary.js
var BIT1 = 1;
var BIT2 = 2;
var BIT3 = 4;
var BIT4 = 8;
var BIT6 = 32;
var BIT7 = 64;
var BIT8 = 128;
var BIT18 = 1 << 17;
var BIT19 = 1 << 18;
var BIT20 = 1 << 19;
var BIT21 = 1 << 20;
var BIT22 = 1 << 21;
var BIT23 = 1 << 22;
var BIT24 = 1 << 23;
var BIT25 = 1 << 24;
var BIT26 = 1 << 25;
var BIT27 = 1 << 26;
var BIT28 = 1 << 27;
var BIT29 = 1 << 28;
var BIT30 = 1 << 29;
var BIT31 = 1 << 30;
var BIT32 = 1 << 31;
var BITS5 = 31;
var BITS6 = 63;
var BITS7 = 127;
var BITS17 = BIT18 - 1;
var BITS18 = BIT19 - 1;
var BITS19 = BIT20 - 1;
var BITS20 = BIT21 - 1;
var BITS21 = BIT22 - 1;
var BITS22 = BIT23 - 1;
var BITS23 = BIT24 - 1;
var BITS24 = BIT25 - 1;
var BITS25 = BIT26 - 1;
var BITS26 = BIT27 - 1;
var BITS27 = BIT28 - 1;
var BITS28 = BIT29 - 1;
var BITS29 = BIT30 - 1;
var BITS30 = BIT31 - 1;
var BITS31 = 2147483647;

// node_modules/lib0/number.js
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
var LOWEST_INT32 = 1 << 31;
var isInteger = Number.isInteger || ((num) => typeof num === "number" && isFinite(num) && floor(num) === num);
var isNaN3 = Number.isNaN;
var parseInt2 = Number.parseInt;

// node_modules/lib0/string.js
var fromCharCode = String.fromCharCode;
var fromCodePoint = String.fromCodePoint;
var MAX_UTF16_CHARACTER = fromCharCode(65535);
var toLowerCase = (s) => s.toLowerCase();
var trimLeftRegex = /^\s*/g;
var trimLeft = (s) => s.replace(trimLeftRegex, "");
var fromCamelCaseRegex = /([A-Z])/g;
var fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, (match) => `${separator}${toLowerCase(match)}`));
var _encodeUtf8Polyfill = (str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  const buf = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    buf[i] = /** @type {number} */
    encodedString.codePointAt(i);
  }
  return buf;
};
var utf8TextEncoder = (
  /** @type {TextEncoder} */
  typeof TextEncoder !== "undefined" ? new TextEncoder() : null
);
var _encodeUtf8Native = (str) => utf8TextEncoder.encode(str);
var encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill;
var utf8TextDecoder = typeof TextDecoder === "undefined" ? null : new TextDecoder("utf-8", { fatal: true, ignoreBOM: true });
if (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {
  utf8TextDecoder = null;
}

// node_modules/lib0/encoding.js
var Encoder = class {
  constructor() {
    this.cpos = 0;
    this.cbuf = new Uint8Array(100);
    this.bufs = [];
  }
};
var createEncoder = () => new Encoder();
var length = (encoder) => {
  let len = encoder.cpos;
  for (let i = 0; i < encoder.bufs.length; i++) {
    len += encoder.bufs[i].length;
  }
  return len;
};
var toUint8Array = (encoder) => {
  const uint8arr = new Uint8Array(length(encoder));
  let curPos = 0;
  for (let i = 0; i < encoder.bufs.length; i++) {
    const d = encoder.bufs[i];
    uint8arr.set(d, curPos);
    curPos += d.length;
  }
  uint8arr.set(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
  return uint8arr;
};
var verifyLen = (encoder, len) => {
  const bufferLen = encoder.cbuf.length;
  if (bufferLen - encoder.cpos < len) {
    encoder.bufs.push(new Uint8Array(encoder.cbuf.buffer, 0, encoder.cpos));
    encoder.cbuf = new Uint8Array(max(bufferLen, len) * 2);
    encoder.cpos = 0;
  }
};
var write = (encoder, num) => {
  const bufferLen = encoder.cbuf.length;
  if (encoder.cpos === bufferLen) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(bufferLen * 2);
    encoder.cpos = 0;
  }
  encoder.cbuf[encoder.cpos++] = num;
};
var writeUint8 = write;
var writeVarUint = (encoder, num) => {
  while (num > BITS7) {
    write(encoder, BIT8 | BITS7 & num);
    num = floor(num / 128);
  }
  write(encoder, BITS7 & num);
};
var writeVarInt = (encoder, num) => {
  const isNegative = isNegativeZero(num);
  if (isNegative) {
    num = -num;
  }
  write(encoder, (num > BITS6 ? BIT8 : 0) | (isNegative ? BIT7 : 0) | BITS6 & num);
  num = floor(num / 64);
  while (num > 0) {
    write(encoder, (num > BITS7 ? BIT8 : 0) | BITS7 & num);
    num = floor(num / 128);
  }
};
var _strBuffer = new Uint8Array(3e4);
var _maxStrBSize = _strBuffer.length / 3;
var _writeVarStringNative = (encoder, str) => {
  if (str.length < _maxStrBSize) {
    const written = utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
    writeVarUint(encoder, written);
    for (let i = 0; i < written; i++) {
      write(encoder, _strBuffer[i]);
    }
  } else {
    writeVarUint8Array(encoder, encodeUtf8(str));
  }
};
var _writeVarStringPolyfill = (encoder, str) => {
  const encodedString = unescape(encodeURIComponent(str));
  const len = encodedString.length;
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    write(
      encoder,
      /** @type {number} */
      encodedString.codePointAt(i)
    );
  }
};
var writeVarString = utf8TextEncoder && /** @type {any} */
utf8TextEncoder.encodeInto ? _writeVarStringNative : _writeVarStringPolyfill;
var writeUint8Array = (encoder, uint8Array) => {
  const bufferLen = encoder.cbuf.length;
  const cpos = encoder.cpos;
  const leftCopyLen = min(bufferLen - cpos, uint8Array.length);
  const rightCopyLen = uint8Array.length - leftCopyLen;
  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
  encoder.cpos += leftCopyLen;
  if (rightCopyLen > 0) {
    encoder.bufs.push(encoder.cbuf);
    encoder.cbuf = new Uint8Array(max(bufferLen * 2, rightCopyLen));
    encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
    encoder.cpos = rightCopyLen;
  }
};
var writeVarUint8Array = (encoder, uint8Array) => {
  writeVarUint(encoder, uint8Array.byteLength);
  writeUint8Array(encoder, uint8Array);
};
var writeOnDataView = (encoder, len) => {
  verifyLen(encoder, len);
  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
  encoder.cpos += len;
  return dview;
};
var writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num, false);
var writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num, false);
var writeBigInt64 = (encoder, num) => (
  /** @type {any} */
  writeOnDataView(encoder, 8).setBigInt64(0, num, false)
);
var floatTestBed = new DataView(new ArrayBuffer(4));
var isFloat32 = (num) => {
  floatTestBed.setFloat32(0, num);
  return floatTestBed.getFloat32(0) === num;
};
var writeAny = (encoder, data) => {
  switch (typeof data) {
    case "string":
      write(encoder, 119);
      writeVarString(encoder, data);
      break;
    case "number":
      if (isInteger(data) && abs(data) <= BITS31) {
        write(encoder, 125);
        writeVarInt(encoder, data);
      } else if (isFloat32(data)) {
        write(encoder, 124);
        writeFloat32(encoder, data);
      } else {
        write(encoder, 123);
        writeFloat64(encoder, data);
      }
      break;
    case "bigint":
      write(encoder, 122);
      writeBigInt64(encoder, data);
      break;
    case "object":
      if (data === null) {
        write(encoder, 126);
      } else if (isArray(data)) {
        write(encoder, 117);
        writeVarUint(encoder, data.length);
        for (let i = 0; i < data.length; i++) {
          writeAny(encoder, data[i]);
        }
      } else if (data instanceof Uint8Array) {
        write(encoder, 116);
        writeVarUint8Array(encoder, data);
      } else {
        write(encoder, 118);
        const keys3 = Object.keys(data);
        writeVarUint(encoder, keys3.length);
        for (let i = 0; i < keys3.length; i++) {
          const key = keys3[i];
          writeVarString(encoder, key);
          writeAny(encoder, data[key]);
        }
      }
      break;
    case "boolean":
      write(encoder, data ? 120 : 121);
      break;
    default:
      write(encoder, 127);
  }
};
var RleEncoder = class extends Encoder {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(writer) {
    super();
    this.w = writer;
    this.s = null;
    this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      if (this.count > 0) {
        writeVarUint(this, this.count - 1);
      }
      this.count = 1;
      this.w(this, v);
      this.s = v;
    }
  }
};
var flushUintOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var UintOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.s === v) {
      this.count++;
    } else {
      flushUintOptRleEncoder(this);
      this.count = 1;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushUintOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var flushIntDiffOptRleEncoder = (encoder) => {
  if (encoder.count > 0) {
    const encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
    writeVarInt(encoder.encoder, encodedDiff);
    if (encoder.count > 1) {
      writeVarUint(encoder.encoder, encoder.count - 2);
    }
  }
};
var IntDiffOptRleEncoder = class {
  constructor() {
    this.encoder = new Encoder();
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(v) {
    if (this.diff === v - this.s) {
      this.s = v;
      this.count++;
    } else {
      flushIntDiffOptRleEncoder(this);
      this.count = 1;
      this.diff = v - this.s;
      this.s = v;
    }
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    flushIntDiffOptRleEncoder(this);
    return toUint8Array(this.encoder);
  }
};
var StringEncoder = class {
  constructor() {
    this.sarr = [];
    this.s = "";
    this.lensE = new UintOptRleEncoder();
  }
  /**
   * @param {string} string
   */
  write(string) {
    this.s += string;
    if (this.s.length > 19) {
      this.sarr.push(this.s);
      this.s = "";
    }
    this.lensE.write(string.length);
  }
  toUint8Array() {
    const encoder = new Encoder();
    this.sarr.push(this.s);
    this.s = "";
    writeVarString(encoder, this.sarr.join(""));
    writeUint8Array(encoder, this.lensE.toUint8Array());
    return toUint8Array(encoder);
  }
};

// node_modules/lib0/error.js
var create3 = (s) => new Error(s);
var methodUnimplemented = () => {
  throw create3("Method unimplemented");
};
var unexpectedCase = () => {
  throw create3("Unexpected case");
};

// node_modules/lib0/decoding.js
var errorUnexpectedEndOfArray = create3("Unexpected end of array");
var errorIntegerOutOfRange = create3("Integer out of Range");
var Decoder = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(uint8Array) {
    this.arr = uint8Array;
    this.pos = 0;
  }
};
var createDecoder = (uint8Array) => new Decoder(uint8Array);
var hasContent = (decoder) => decoder.pos !== decoder.arr.length;
var readUint8Array = (decoder, len) => {
  const view = new Uint8Array(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
  decoder.pos += len;
  return view;
};
var readVarUint8Array = (decoder) => readUint8Array(decoder, readVarUint(decoder));
var readUint8 = (decoder) => decoder.arr[decoder.pos++];
var readVarUint = (decoder) => {
  let num = 0;
  let mult = 1;
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    const r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var readVarInt = (decoder) => {
  let r = decoder.arr[decoder.pos++];
  let num = r & BITS6;
  let mult = 64;
  const sign = (r & BIT7) > 0 ? -1 : 1;
  if ((r & BIT8) === 0) {
    return sign * num;
  }
  const len = decoder.arr.length;
  while (decoder.pos < len) {
    r = decoder.arr[decoder.pos++];
    num = num + (r & BITS7) * mult;
    mult *= 128;
    if (r < BIT8) {
      return sign * num;
    }
    if (num > MAX_SAFE_INTEGER) {
      throw errorIntegerOutOfRange;
    }
  }
  throw errorUnexpectedEndOfArray;
};
var _readVarStringPolyfill = (decoder) => {
  let remainingLen = readVarUint(decoder);
  if (remainingLen === 0) {
    return "";
  } else {
    let encodedString = String.fromCodePoint(readUint8(decoder));
    if (--remainingLen < 100) {
      while (remainingLen--) {
        encodedString += String.fromCodePoint(readUint8(decoder));
      }
    } else {
      while (remainingLen > 0) {
        const nextLen = remainingLen < 1e4 ? remainingLen : 1e4;
        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
        decoder.pos += nextLen;
        encodedString += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          bytes
        );
        remainingLen -= nextLen;
      }
    }
    return decodeURIComponent(escape(encodedString));
  }
};
var _readVarStringNative = (decoder) => (
  /** @type any */
  utf8TextDecoder.decode(readVarUint8Array(decoder))
);
var readVarString = utf8TextDecoder ? _readVarStringNative : _readVarStringPolyfill;
var readFromDataView = (decoder, len) => {
  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
  decoder.pos += len;
  return dv;
};
var readFloat32 = (decoder) => readFromDataView(decoder, 4).getFloat32(0, false);
var readFloat64 = (decoder) => readFromDataView(decoder, 8).getFloat64(0, false);
var readBigInt64 = (decoder) => (
  /** @type {any} */
  readFromDataView(decoder, 8).getBigInt64(0, false)
);
var readAnyLookupTable = [
  (decoder) => void 0,
  // CASE 127: undefined
  (decoder) => null,
  // CASE 126: null
  readVarInt,
  // CASE 125: integer
  readFloat32,
  // CASE 124: float32
  readFloat64,
  // CASE 123: float64
  readBigInt64,
  // CASE 122: bigint
  (decoder) => false,
  // CASE 121: boolean (false)
  (decoder) => true,
  // CASE 120: boolean (true)
  readVarString,
  // CASE 119: string
  (decoder) => {
    const len = readVarUint(decoder);
    const obj = {};
    for (let i = 0; i < len; i++) {
      const key = readVarString(decoder);
      obj[key] = readAny(decoder);
    }
    return obj;
  },
  (decoder) => {
    const len = readVarUint(decoder);
    const arr = [];
    for (let i = 0; i < len; i++) {
      arr.push(readAny(decoder));
    }
    return arr;
  },
  readVarUint8Array
  // CASE 116: Uint8Array
];
var readAny = (decoder) => readAnyLookupTable[127 - readUint8(decoder)](decoder);
var RleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(uint8Array, reader) {
    super(uint8Array);
    this.reader = reader;
    this.s = null;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = this.reader(this);
      if (hasContent(this)) {
        this.count = readVarUint(this) + 1;
      } else {
        this.count = -1;
      }
    }
    this.count--;
    return (
      /** @type {T} */
      this.s
    );
  }
};
var UintOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = readVarInt(this);
      const isNegative = isNegativeZero(this.s);
      this.count = 1;
      if (isNegative) {
        this.s = -this.s;
        this.count = readVarUint(this) + 2;
      }
    }
    this.count--;
    return (
      /** @type {number} */
      this.s
    );
  }
};
var IntDiffOptRleDecoder = class extends Decoder {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    super(uint8Array);
    this.s = 0;
    this.count = 0;
    this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const diff = readVarInt(this);
      const hasCount = diff & 1;
      this.diff = floor(diff / 2);
      this.count = 1;
      if (hasCount) {
        this.count = readVarUint(this) + 2;
      }
    }
    this.s += this.diff;
    this.count--;
    return this.s;
  }
};
var StringDecoder = class {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(uint8Array) {
    this.decoder = new UintOptRleDecoder(uint8Array);
    this.str = readVarString(this.decoder);
    this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const end = this.spos + this.decoder.read();
    const res = this.str.slice(this.spos, end);
    this.spos = end;
    return res;
  }
};

// node_modules/lib0/webcrypto.js
var subtle = crypto.subtle;
var getRandomValues = crypto.getRandomValues.bind(crypto);

// node_modules/lib0/random.js
var rand = Math.random;
var uint32 = () => getRandomValues(new Uint32Array(1))[0];
var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;
var uuidv4 = () => uuidv4Template.replace(
  /[018]/g,
  /** @param {number} c */
  (c) => (c ^ uint32() & 15 >> c / 4).toString(16)
);

// node_modules/lib0/promise.js
var create4 = (f) => (
  /** @type {Promise<T>} */
  new Promise(f)
);
var all = Promise.all.bind(Promise);
var reject = (reason) => Promise.reject(reason);
var resolve = (res) => Promise.resolve(res);

// node_modules/lib0/conditions.js
var undefinedToNull = (v) => v === void 0 ? null : v;

// node_modules/lib0/storage.js
var VarStoragePolyfill = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(key, newValue) {
    this.map.set(key, newValue);
  }
  /**
   * @param {string} key
   */
  getItem(key) {
    return this.map.get(key);
  }
};
var _localStorage = new VarStoragePolyfill();
var usePolyfill = true;
try {
  if (typeof localStorage !== "undefined" && localStorage) {
    _localStorage = localStorage;
    usePolyfill = false;
  }
} catch (e) {
}
var varStorage = _localStorage;
var onChange = (eventHandler) => usePolyfill || addEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);
var offChange = (eventHandler) => usePolyfill || removeEventListener(
  "storage",
  /** @type {any} */
  eventHandler
);

// node_modules/lib0/object.js
var assign = Object.assign;
var keys = Object.keys;
var forEach = (obj, f) => {
  for (const key in obj) {
    f(obj[key], key);
  }
};
var length2 = (obj) => keys(obj).length;
var size = (obj) => keys(obj).length;
var isEmpty = (obj) => {
  for (const _k in obj) {
    return false;
  }
  return true;
};
var every = (obj, f) => {
  for (const key in obj) {
    if (!f(obj[key], key)) {
      return false;
    }
  }
  return true;
};
var hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var equalFlat = (a, b) => a === b || size(a) === size(b) && every(a, (val, key) => (val !== void 0 || hasProperty(b, key)) && b[key] === val);

// node_modules/lib0/function.js
var callAll = (fs, args2, i = 0) => {
  try {
    for (; i < fs.length; i++) {
      fs[i](...args2);
    }
  } finally {
    if (i < fs.length) {
      callAll(fs, args2, i + 1);
    }
  }
};
var nop = () => {
};
var id = (a) => a;
var equalityStrict = (a, b) => a === b;
var equalityDeep = (a, b) => {
  if (a == null || b == null) {
    return equalityStrict(a, b);
  }
  if (a.constructor !== b.constructor) {
    return false;
  }
  if (a === b) {
    return true;
  }
  switch (a.constructor) {
    case ArrayBuffer:
      a = new Uint8Array(a);
      b = new Uint8Array(b);
    case Uint8Array: {
      if (a.byteLength !== b.byteLength) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (a[i] !== b[i]) {
          return false;
        }
      }
      break;
    }
    case Set: {
      if (a.size !== b.size) {
        return false;
      }
      for (const value of a) {
        if (!b.has(value)) {
          return false;
        }
      }
      break;
    }
    case Map: {
      if (a.size !== b.size) {
        return false;
      }
      for (const key of a.keys()) {
        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {
          return false;
        }
      }
      break;
    }
    case Object:
      if (length2(a) !== length2(b)) {
        return false;
      }
      for (const key in a) {
        if (!hasProperty(a, key) || !equalityDeep(a[key], b[key])) {
          return false;
        }
      }
      break;
    case Array:
      if (a.length !== b.length) {
        return false;
      }
      for (let i = 0; i < a.length; i++) {
        if (!equalityDeep(a[i], b[i])) {
          return false;
        }
      }
      break;
    default:
      return false;
  }
  return true;
};
var isOneOf = (value, options) => options.includes(value);

// node_modules/lib0/environment.js
var isNode = typeof process !== "undefined" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]";
var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && !isNode;
var isMac = typeof navigator !== "undefined" ? /Mac/.test(navigator.platform) : false;
var params;
var args = [];
var computeParams = () => {
  if (params === void 0) {
    if (isNode) {
      params = create();
      const pargs = process.argv;
      let currParamName = null;
      for (let i = 0; i < pargs.length; i++) {
        const parg = pargs[i];
        if (parg[0] === "-") {
          if (currParamName !== null) {
            params.set(currParamName, "");
          }
          currParamName = parg;
        } else {
          if (currParamName !== null) {
            params.set(currParamName, parg);
            currParamName = null;
          } else {
            args.push(parg);
          }
        }
      }
      if (currParamName !== null) {
        params.set(currParamName, "");
      }
    } else if (typeof location === "object") {
      params = create();
      (location.search || "?").slice(1).split("&").forEach((kv) => {
        if (kv.length !== 0) {
          const [key, value] = kv.split("=");
          params.set(`--${fromCamelCase(key, "-")}`, value);
          params.set(`-${fromCamelCase(key, "-")}`, value);
        }
      });
    } else {
      params = create();
    }
  }
  return params;
};
var hasParam = (name) => computeParams().has(name);
var getVariable = (name) => isNode ? undefinedToNull(process.env[name.toUpperCase().replaceAll("-", "_")]) : undefinedToNull(varStorage.getItem(name));
var hasConf = (name) => hasParam("--" + name) || getVariable(name) !== null;
var production = hasConf("production");
var forceColor = isNode && isOneOf(process.env.FORCE_COLOR, ["true", "1", "2"]);
var supportsColor = !hasParam("--no-colors") && (!isNode || process.stdout.isTTY || forceColor) && (!isNode || hasParam("--color") || forceColor || getVariable("COLORTERM") !== null || (getVariable("TERM") || "").includes("color"));

// node_modules/lib0/buffer.js
var createUint8ArrayFromLen = (len) => new Uint8Array(len);
var createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length3) => new Uint8Array(buffer, byteOffset, length3);
var createUint8ArrayFromArrayBuffer = (buffer) => new Uint8Array(buffer);
var toBase64Browser = (bytes) => {
  let s = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    s += fromCharCode(bytes[i]);
  }
  return btoa(s);
};
var toBase64Node = (bytes) => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString("base64");
var fromBase64Browser = (s) => {
  const a = atob(s);
  const bytes = createUint8ArrayFromLen(a.length);
  for (let i = 0; i < a.length; i++) {
    bytes[i] = a.charCodeAt(i);
  }
  return bytes;
};
var fromBase64Node = (s) => {
  const buf = Buffer.from(s, "base64");
  return createUint8ArrayViewFromArrayBuffer(buf.buffer, buf.byteOffset, buf.byteLength);
};
var toBase64 = isBrowser ? toBase64Browser : toBase64Node;
var fromBase64 = isBrowser ? fromBase64Browser : fromBase64Node;
var copyUint8Array = (uint8Array) => {
  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength);
  newBuf.set(uint8Array);
  return newBuf;
};

// node_modules/lib0/pair.js
var Pair = class {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(left, right) {
    this.left = left;
    this.right = right;
  }
};
var create5 = (left, right) => new Pair(left, right);
var forEach2 = (arr, f) => arr.forEach((p) => f(p.left, p.right));

// node_modules/lib0/dom.js
var doc = (
  /** @type {Document} */
  typeof document !== "undefined" ? document : {}
);
var createElement = (name) => doc.createElement(name);
var createDocumentFragment = () => doc.createDocumentFragment();
var createTextNode = (text2) => doc.createTextNode(text2);
var domParser = (
  /** @type {DOMParser} */
  typeof DOMParser !== "undefined" ? new DOMParser() : null
);
var setAttributes = (el, attrs) => {
  forEach2(attrs, (key, value) => {
    if (value === false) {
      el.removeAttribute(key);
    } else if (value === true) {
      el.setAttribute(key, "");
    } else {
      el.setAttribute(key, value);
    }
  });
  return el;
};
var fragment = (children) => {
  const fragment2 = createDocumentFragment();
  for (let i = 0; i < children.length; i++) {
    appendChild(fragment2, children[i]);
  }
  return fragment2;
};
var append = (parent, nodes) => {
  appendChild(parent, fragment(nodes));
  return parent;
};
var element = (name, attrs = [], children = []) => append(setAttributes(createElement(name), attrs), children);
var text = createTextNode;
var mapToStyleString = (m) => map(m, (value, key) => `${key}:${value};`).join("");
var appendChild = (parent, child) => parent.appendChild(child);
var ELEMENT_NODE = doc.ELEMENT_NODE;
var TEXT_NODE = doc.TEXT_NODE;
var CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE;
var COMMENT_NODE = doc.COMMENT_NODE;
var DOCUMENT_NODE = doc.DOCUMENT_NODE;
var DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE;
var DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE;

// node_modules/lib0/json.js
var stringify = JSON.stringify;

// node_modules/lib0/symbol.js
var create6 = Symbol;

// node_modules/lib0/logging.common.js
var BOLD = create6();
var UNBOLD = create6();
var BLUE = create6();
var GREY = create6();
var GREEN = create6();
var RED = create6();
var PURPLE = create6();
var ORANGE = create6();
var UNCOLOR = create6();
var computeNoColorLoggingArgs = (args2) => {
  var _a;
  if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (arg === void 0) {
      strBuilder.push("undefined");
    } else if (arg.constructor === String || arg.constructor === Number) {
      strBuilder.push(arg);
    } else if (arg.constructor === Object) {
      logArgs.push(JSON.stringify(arg));
    }
  }
  return logArgs;
};
var loggingColors = [GREEN, PURPLE, ORANGE, BLUE];
var nextColor = 0;
var lastLoggingTime = getUnixTime();
var createModuleLogger = (_print, moduleName) => {
  const color = loggingColors[nextColor];
  const debugRegexVar = getVariable("log");
  const doLogging = debugRegexVar !== null && (debugRegexVar === "*" || debugRegexVar === "true" || new RegExp(debugRegexVar, "gi").test(moduleName));
  nextColor = (nextColor + 1) % loggingColors.length;
  moduleName += ": ";
  return !doLogging ? nop : (...args2) => {
    var _a;
    if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
      args2 = args2[0]();
    }
    const timeNow = getUnixTime();
    const timeDiff = timeNow - lastLoggingTime;
    lastLoggingTime = timeNow;
    _print(
      color,
      moduleName,
      UNCOLOR,
      ...args2.map((arg) => {
        if (arg != null && arg.constructor === Uint8Array) {
          arg = Array.from(arg);
        }
        const t = typeof arg;
        switch (t) {
          case "string":
          case "symbol":
            return arg;
          default: {
            return stringify(arg);
          }
        }
      }),
      color,
      " +" + timeDiff + "ms"
    );
  };
};

// node_modules/lib0/logging.js
var _browserStyleMap = {
  [BOLD]: create5("font-weight", "bold"),
  [UNBOLD]: create5("font-weight", "normal"),
  [BLUE]: create5("color", "blue"),
  [GREEN]: create5("color", "green"),
  [GREY]: create5("color", "grey"),
  [RED]: create5("color", "red"),
  [PURPLE]: create5("color", "purple"),
  [ORANGE]: create5("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [UNCOLOR]: create5("color", "black")
};
var computeBrowserLoggingArgs = (args2) => {
  var _a;
  if (args2.length === 1 && ((_a = args2[0]) == null ? void 0 : _a.constructor) === Function) {
    args2 = /** @type {Array<string|Symbol|Object|number>} */
    /** @type {[function]} */
    args2[0]();
  }
  const strBuilder = [];
  const styles = [];
  const currentStyle = create();
  let logArgs = [];
  let i = 0;
  for (; i < args2.length; i++) {
    const arg = args2[i];
    const style = _browserStyleMap[arg];
    if (style !== void 0) {
      currentStyle.set(style.left, style.right);
    } else {
      if (arg === void 0) {
        break;
      }
      if (arg.constructor === String || arg.constructor === Number) {
        const style2 = mapToStyleString(currentStyle);
        if (i > 0 || style2.length > 0) {
          strBuilder.push("%c" + arg);
          styles.push(style2);
        } else {
          strBuilder.push(arg);
        }
      } else {
        break;
      }
    }
  }
  if (i > 0) {
    logArgs = styles;
    logArgs.unshift(strBuilder.join(""));
  }
  for (; i < args2.length; i++) {
    const arg = args2[i];
    if (!(arg instanceof Symbol)) {
      logArgs.push(arg);
    }
  }
  return logArgs;
};
var computeLoggingArgs = supportsColor ? computeBrowserLoggingArgs : computeNoColorLoggingArgs;
var print = (...args2) => {
  console.log(...computeLoggingArgs(args2));
  vconsoles.forEach((vc) => vc.print(args2));
};
var warn = (...args2) => {
  console.warn(...computeLoggingArgs(args2));
  args2.unshift(ORANGE);
  vconsoles.forEach((vc) => vc.print(args2));
};
var vconsoles = create2();
var createModuleLogger2 = (moduleName) => createModuleLogger(print, moduleName);

// node_modules/lib0/iterator.js
var createIterator = (next) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next
});
var iteratorFilter = (iterator, filter) => createIterator(() => {
  let res;
  do {
    res = iterator.next();
  } while (!res.done && !filter(res.value));
  return res;
});
var iteratorMap = (iterator, fmap) => createIterator(() => {
  const { done, value } = iterator.next();
  return { done, value: done ? void 0 : fmap(value) };
});

// node_modules/yjs/dist/yjs.mjs
var DeleteItem = class {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(clock, len) {
    this.clock = clock;
    this.len = len;
  }
};
var DeleteSet = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
};
var iterateDeletedStructs = (transaction, ds, f) => ds.clients.forEach((deletes, clientid) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    transaction.doc.store.clients.get(clientid)
  );
  for (let i = 0; i < deletes.length; i++) {
    const del2 = deletes[i];
    iterateStructs(transaction, structs, del2.clock, del2.len, f);
  }
});
var findIndexDS = (dis, clock) => {
  let left = 0;
  let right = dis.length - 1;
  while (left <= right) {
    const midindex = floor((left + right) / 2);
    const mid = dis[midindex];
    const midclock = mid.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.len) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
  }
  return null;
};
var isDeleted = (ds, id2) => {
  const dis = ds.clients.get(id2.client);
  return dis !== void 0 && findIndexDS(dis, id2.clock) !== null;
};
var sortAndMergeDeleteSet = (ds) => {
  ds.clients.forEach((dels) => {
    dels.sort((a, b) => a.clock - b.clock);
    let i, j;
    for (i = 1, j = 1; i < dels.length; i++) {
      const left = dels[j - 1];
      const right = dels[i];
      if (left.clock + left.len >= right.clock) {
        left.len = max(left.len, right.clock + right.len - left.clock);
      } else {
        if (j < i) {
          dels[j] = right;
        }
        j++;
      }
    }
    dels.length = j;
  });
};
var mergeDeleteSets = (dss) => {
  const merged = new DeleteSet();
  for (let dssI = 0; dssI < dss.length; dssI++) {
    dss[dssI].clients.forEach((delsLeft, client) => {
      if (!merged.clients.has(client)) {
        const dels = delsLeft.slice();
        for (let i = dssI + 1; i < dss.length; i++) {
          appendTo(dels, dss[i].clients.get(client) || []);
        }
        merged.clients.set(client, dels);
      }
    });
  }
  sortAndMergeDeleteSet(merged);
  return merged;
};
var addToDeleteSet = (ds, client, clock, length3) => {
  setIfUndefined(ds.clients, client, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new DeleteItem(clock, length3));
};
var createDeleteSet = () => new DeleteSet();
var createDeleteSetFromStructStore = (ss) => {
  const ds = createDeleteSet();
  ss.clients.forEach((structs, client) => {
    const dsitems = [];
    for (let i = 0; i < structs.length; i++) {
      const struct = structs[i];
      if (struct.deleted) {
        const clock = struct.id.clock;
        let len = struct.length;
        if (i + 1 < structs.length) {
          for (let next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
            len += next.length;
          }
        }
        dsitems.push(new DeleteItem(clock, len));
      }
    }
    if (dsitems.length > 0) {
      ds.clients.set(client, dsitems);
    }
  });
  return ds;
};
var writeDeleteSet = (encoder, ds) => {
  writeVarUint(encoder.restEncoder, ds.clients.size);
  from(ds.clients.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, dsitems]) => {
    encoder.resetDsCurVal();
    writeVarUint(encoder.restEncoder, client);
    const len = dsitems.length;
    writeVarUint(encoder.restEncoder, len);
    for (let i = 0; i < len; i++) {
      const item = dsitems[i];
      encoder.writeDsClock(item.clock);
      encoder.writeDsLen(item.len);
    }
  });
};
var readDeleteSet = (decoder) => {
  const ds = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    if (numberOfDeletes > 0) {
      const dsField = setIfUndefined(ds.clients, client, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let i2 = 0; i2 < numberOfDeletes; i2++) {
        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
      }
    }
  }
  return ds;
};
var readAndApplyDeleteSet = (decoder, transaction, store) => {
  const unappliedDS = new DeleteSet();
  const numClients = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numClients; i++) {
    decoder.resetDsCurVal();
    const client = readVarUint(decoder.restDecoder);
    const numberOfDeletes = readVarUint(decoder.restDecoder);
    const structs = store.clients.get(client) || [];
    const state = getState(store, client);
    for (let i2 = 0; i2 < numberOfDeletes; i2++) {
      const clock = decoder.readDsClock();
      const clockEnd = clock + decoder.readDsLen();
      if (clock < state) {
        if (state < clockEnd) {
          addToDeleteSet(unappliedDS, client, state, clockEnd - state);
        }
        let index = findIndexSS(structs, clock);
        let struct = structs[index];
        if (!struct.deleted && struct.id.clock < clock) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          index++;
        }
        while (index < structs.length) {
          struct = structs[index++];
          if (struct.id.clock < clockEnd) {
            if (!struct.deleted) {
              if (clockEnd < struct.id.clock + struct.length) {
                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
              }
              struct.delete(transaction);
            }
          } else {
            break;
          }
        }
      } else {
        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
      }
    }
  }
  if (unappliedDS.clients.size > 0) {
    const ds = new UpdateEncoderV2();
    writeVarUint(ds.restEncoder, 0);
    writeDeleteSet(ds, unappliedDS);
    return ds.toUint8Array();
  }
  return null;
};
var generateNewClientId = uint32;
var Doc = class extends ObservableV2 {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid = uuidv4(), collectionid = null, gc = true, gcFilter = () => true, meta = null, autoLoad = false, shouldLoad = true } = {}) {
    super();
    this.gc = gc;
    this.gcFilter = gcFilter;
    this.clientID = generateNewClientId();
    this.guid = guid;
    this.collectionid = collectionid;
    this.share = /* @__PURE__ */ new Map();
    this.store = new StructStore();
    this._transaction = null;
    this._transactionCleanups = [];
    this.subdocs = /* @__PURE__ */ new Set();
    this._item = null;
    this.shouldLoad = shouldLoad;
    this.autoLoad = autoLoad;
    this.meta = meta;
    this.isLoaded = false;
    this.isSynced = false;
    this.whenLoaded = create4((resolve2) => {
      this.on("load", () => {
        this.isLoaded = true;
        resolve2(this);
      });
    });
    const provideSyncedPromise = () => create4((resolve2) => {
      const eventHandler = (isSynced) => {
        if (isSynced === void 0 || isSynced === true) {
          this.off("sync", eventHandler);
          resolve2();
        }
      };
      this.on("sync", eventHandler);
    });
    this.on("sync", (isSynced) => {
      if (isSynced === false && this.isSynced) {
        this.whenSynced = provideSyncedPromise();
      }
      this.isSynced = isSynced === void 0 || isSynced === true;
      if (this.isSynced && !this.isLoaded) {
        this.emit("load", [this]);
      }
    });
    this.whenSynced = provideSyncedPromise();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const item = this._item;
    if (item !== null && !this.shouldLoad) {
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          transaction.subdocsLoaded.add(this);
        },
        null,
        true
      );
    }
    this.shouldLoad = true;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(from(this.subdocs).map((doc2) => doc2.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(f, origin = null) {
    return transact(this, f, origin);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(name, TypeConstructor = (
    /** @type {any} */
    AbstractType
  )) {
    const type2 = setIfUndefined(this.share, name, () => {
      const t = new TypeConstructor();
      t._integrate(this, null);
      return t;
    });
    const Constr = type2.constructor;
    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {
      if (Constr === AbstractType) {
        const t = new TypeConstructor();
        t._map = type2._map;
        type2._map.forEach(
          /** @param {Item?} n */
          (n) => {
            for (; n !== null; n = n.left) {
              n.parent = t;
            }
          }
        );
        t._start = type2._start;
        for (let n = t._start; n !== null; n = n.right) {
          n.parent = t;
        }
        t._length = type2._length;
        this.share.set(name, t);
        t._integrate(this, null);
        return (
          /** @type {InstanceType<Type>} */
          t
        );
      } else {
        throw new Error(`Type with the name ${name} has already been defined with a different constructor`);
      }
    }
    return (
      /** @type {InstanceType<Type>} */
      type2
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(name = "") {
    return (
      /** @type {YArray<T>} */
      this.get(name, YArray)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(name = "") {
    return this.get(name, YText);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(name = "") {
    return (
      /** @type {YMap<T>} */
      this.get(name, YMap)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(name = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(name, YXmlElement)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(name = "") {
    return this.get(name, YXmlFragment);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const doc2 = {};
    this.share.forEach((value, key) => {
      doc2[key] = value.toJSON();
    });
    return doc2;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    from(this.subdocs).forEach((subdoc) => subdoc.destroy());
    const item = this._item;
    if (item !== null) {
      this._item = null;
      const content = (
        /** @type {ContentDoc} */
        item.content
      );
      content.doc = new Doc({ guid: this.guid, ...content.opts, shouldLoad: false });
      content.doc._item = item;
      transact(
        /** @type {any} */
        item.parent.doc,
        (transaction) => {
          const doc2 = content.doc;
          if (!item.deleted) {
            transaction.subdocsAdded.add(doc2);
          }
          transaction.subdocsRemoved.add(this);
        },
        null,
        true
      );
    }
    this.emit("destroyed", [true]);
    this.emit("destroy", [this]);
    super.destroy();
  }
};
var DSDecoderV1 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return readVarUint(this.restDecoder);
  }
};
var UpdateDecoderV1 = class extends DSDecoderV1 {
  /**
   * @return {ID}
   */
  readLeftID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return createID(readVarUint(this.restDecoder), readVarUint(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return readUint8(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return readVarString(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return readVarUint(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return readVarUint(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return readVarUint(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return copyUint8Array(readVarUint8Array(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(readVarString(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return readVarString(this.restDecoder);
  }
};
var DSDecoderV2 = class {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    this.dsCurrVal = 0;
    this.restDecoder = decoder;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    this.dsCurrVal += readVarUint(this.restDecoder);
    return this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const diff = readVarUint(this.restDecoder) + 1;
    this.dsCurrVal += diff;
    return diff;
  }
};
var UpdateDecoderV2 = class extends DSDecoderV2 {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(decoder) {
    super(decoder);
    this.keys = [];
    readVarUint(decoder);
    this.keyClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.clientDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.leftClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.rightClockDecoder = new IntDiffOptRleDecoder(readVarUint8Array(decoder));
    this.infoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.stringDecoder = new StringDecoder(readVarUint8Array(decoder));
    this.parentInfoDecoder = new RleDecoder(readVarUint8Array(decoder), readUint8);
    this.typeRefDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
    this.lenDecoder = new UintOptRleDecoder(readVarUint8Array(decoder));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return readVarUint8Array(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return readAny(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const keyClock = this.keyClockDecoder.read();
    if (keyClock < this.keys.length) {
      return this.keys[keyClock];
    } else {
      const key = this.stringDecoder.read();
      this.keys.push(key);
      return key;
    }
  }
};
var DSEncoderV1 = class {
  constructor() {
    this.restEncoder = createEncoder();
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    writeVarUint(this.restEncoder, clock);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    writeVarUint(this.restEncoder, len);
  }
};
var UpdateEncoderV1 = class extends DSEncoderV1 {
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    writeVarUint(this.restEncoder, id2.client);
    writeVarUint(this.restEncoder, id2.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(client) {
    writeVarUint(this.restEncoder, client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    writeUint8(this.restEncoder, info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    writeVarString(this.restEncoder, s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    writeVarUint(this.restEncoder, isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    writeVarUint(this.restEncoder, info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    writeVarUint(this.restEncoder, len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * @param {any} embed
   */
  writeJSON(embed) {
    writeVarString(this.restEncoder, JSON.stringify(embed));
  }
  /**
   * @param {string} key
   */
  writeKey(key) {
    writeVarString(this.restEncoder, key);
  }
};
var DSEncoderV2 = class {
  constructor() {
    this.restEncoder = createEncoder();
    this.dsCurrVal = 0;
  }
  toUint8Array() {
    return toUint8Array(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(clock) {
    const diff = clock - this.dsCurrVal;
    this.dsCurrVal = clock;
    writeVarUint(this.restEncoder, diff);
  }
  /**
   * @param {number} len
   */
  writeDsLen(len) {
    if (len === 0) {
      unexpectedCase();
    }
    writeVarUint(this.restEncoder, len - 1);
    this.dsCurrVal += len;
  }
};
var UpdateEncoderV2 = class extends DSEncoderV2 {
  constructor() {
    super();
    this.keyMap = /* @__PURE__ */ new Map();
    this.keyClock = 0;
    this.keyClockEncoder = new IntDiffOptRleEncoder();
    this.clientEncoder = new UintOptRleEncoder();
    this.leftClockEncoder = new IntDiffOptRleEncoder();
    this.rightClockEncoder = new IntDiffOptRleEncoder();
    this.infoEncoder = new RleEncoder(writeUint8);
    this.stringEncoder = new StringEncoder();
    this.parentInfoEncoder = new RleEncoder(writeUint8);
    this.typeRefEncoder = new UintOptRleEncoder();
    this.lenEncoder = new UintOptRleEncoder();
  }
  toUint8Array() {
    const encoder = createEncoder();
    writeVarUint(encoder, 0);
    writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.infoEncoder));
    writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
    writeVarUint8Array(encoder, toUint8Array(this.parentInfoEncoder));
    writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
    writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
    writeUint8Array(encoder, toUint8Array(this.restEncoder));
    return toUint8Array(encoder);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(id2) {
    this.clientEncoder.write(id2.client);
    this.leftClockEncoder.write(id2.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(id2) {
    this.clientEncoder.write(id2.client);
    this.rightClockEncoder.write(id2.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(client) {
    this.clientEncoder.write(client);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(info) {
    this.infoEncoder.write(info);
  }
  /**
   * @param {string} s
   */
  writeString(s) {
    this.stringEncoder.write(s);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(isYKey) {
    this.parentInfoEncoder.write(isYKey ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(info) {
    this.typeRefEncoder.write(info);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(len) {
    this.lenEncoder.write(len);
  }
  /**
   * @param {any} any
   */
  writeAny(any2) {
    writeAny(this.restEncoder, any2);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(buf) {
    writeVarUint8Array(this.restEncoder, buf);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(embed) {
    writeAny(this.restEncoder, embed);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(key) {
    const clock = this.keyMap.get(key);
    if (clock === void 0) {
      this.keyClockEncoder.write(this.keyClock++);
      this.stringEncoder.write(key);
    } else {
      this.keyClockEncoder.write(clock);
    }
  }
};
var writeStructs = (encoder, structs, client, clock) => {
  clock = max(clock, structs[0].id.clock);
  const startNewStructs = findIndexSS(structs, clock);
  writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
  encoder.writeClient(client);
  writeVarUint(encoder.restEncoder, clock);
  const firstStruct = structs[startNewStructs];
  firstStruct.write(encoder, clock - firstStruct.id.clock);
  for (let i = startNewStructs + 1; i < structs.length; i++) {
    structs[i].write(encoder, 0);
  }
};
var writeClientsStructs = (encoder, store, _sm) => {
  const sm = /* @__PURE__ */ new Map();
  _sm.forEach((clock, client) => {
    if (getState(store, client) > clock) {
      sm.set(client, clock);
    }
  });
  getStateVector(store).forEach((_clock, client) => {
    if (!_sm.has(client)) {
      sm.set(client, 0);
    }
  });
  writeVarUint(encoder.restEncoder, sm.size);
  from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeStructs(
      encoder,
      /** @type {Array<GC|Item>} */
      store.clients.get(client),
      client,
      clock
    );
  });
};
var readClientsStructRefs = (decoder, doc2) => {
  const clientRefs = create();
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const refs = new Array(numberOfStructs);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    clientRefs.set(client, { i: 0, refs });
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      switch (BITS5 & info) {
        case 0: {
          const len = decoder.readLen();
          refs[i2] = new GC(createID(client, clock), len);
          clock += len;
          break;
        }
        case 10: {
          const len = readVarUint(decoder.restDecoder);
          refs[i2] = new Skip(createID(client, clock), len);
          clock += len;
          break;
        }
        default: {
          const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
          const struct = new Item(
            createID(client, clock),
            null,
            // left
            (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
            // origin
            null,
            // right
            (info & BIT7) === BIT7 ? decoder.readRightID() : null,
            // right origin
            cantCopyParentInfo ? decoder.readParentInfo() ? doc2.get(decoder.readString()) : decoder.readLeftID() : null,
            // parent
            cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
            // parentSub
            readItemContent(decoder, info)
            // item content
          );
          refs[i2] = struct;
          clock += struct.length;
        }
      }
    }
  }
  return clientRefs;
};
var integrateStructs = (transaction, store, clientsStructRefs) => {
  const stack = [];
  let clientsStructRefsIds = from(clientsStructRefs.keys()).sort((a, b) => a - b);
  if (clientsStructRefsIds.length === 0) {
    return null;
  }
  const getNextStructTarget = () => {
    if (clientsStructRefsIds.length === 0) {
      return null;
    }
    let nextStructsTarget = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1])
    );
    while (nextStructsTarget.refs.length === nextStructsTarget.i) {
      clientsStructRefsIds.pop();
      if (clientsStructRefsIds.length > 0) {
        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */
        clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
      } else {
        return null;
      }
    }
    return nextStructsTarget;
  };
  let curStructsTarget = getNextStructTarget();
  if (curStructsTarget === null) {
    return null;
  }
  const restStructs = new StructStore();
  const missingSV = /* @__PURE__ */ new Map();
  const updateMissingSv = (client, clock) => {
    const mclock = missingSV.get(client);
    if (mclock == null || mclock > clock) {
      missingSV.set(client, clock);
    }
  };
  let stackHead = (
    /** @type {any} */
    curStructsTarget.refs[
      /** @type {any} */
      curStructsTarget.i++
    ]
  );
  const state = /* @__PURE__ */ new Map();
  const addStackToRestSS = () => {
    for (const item of stack) {
      const client = item.id.client;
      const unapplicableItems = clientsStructRefs.get(client);
      if (unapplicableItems) {
        unapplicableItems.i--;
        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
        clientsStructRefs.delete(client);
        unapplicableItems.i = 0;
        unapplicableItems.refs = [];
      } else {
        restStructs.clients.set(client, [item]);
      }
      clientsStructRefsIds = clientsStructRefsIds.filter((c) => c !== client);
    }
    stack.length = 0;
  };
  while (true) {
    if (stackHead.constructor !== Skip) {
      const localClock = setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client));
      const offset = localClock - stackHead.id.clock;
      if (offset < 0) {
        stack.push(stackHead);
        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
        addStackToRestSS();
      } else {
        const missing = stackHead.getMissing(transaction, store);
        if (missing !== null) {
          stack.push(stackHead);
          const structRefs = clientsStructRefs.get(
            /** @type {number} */
            missing
          ) || { refs: [], i: 0 };
          if (structRefs.refs.length === structRefs.i) {
            updateMissingSv(
              /** @type {number} */
              missing,
              getState(store, missing)
            );
            addStackToRestSS();
          } else {
            stackHead = structRefs.refs[structRefs.i++];
            continue;
          }
        } else if (offset === 0 || offset < stackHead.length) {
          stackHead.integrate(transaction, offset);
          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
        }
      }
    }
    if (stack.length > 0) {
      stackHead = /** @type {GC|Item} */
      stack.pop();
    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
      stackHead = /** @type {GC|Item} */
      curStructsTarget.refs[curStructsTarget.i++];
    } else {
      curStructsTarget = getNextStructTarget();
      if (curStructsTarget === null) {
        break;
      } else {
        stackHead = /** @type {GC|Item} */
        curStructsTarget.refs[curStructsTarget.i++];
      }
    }
  }
  if (restStructs.clients.size > 0) {
    const encoder = new UpdateEncoderV2();
    writeClientsStructs(encoder, restStructs, /* @__PURE__ */ new Map());
    writeVarUint(encoder.restEncoder, 0);
    return { missing: missingSV, update: encoder.toUint8Array() };
  }
  return null;
};
var writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
var readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) => transact(ydoc, (transaction) => {
  transaction.local = false;
  let retry = false;
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ss = readClientsStructRefs(structDecoder, doc2);
  const restStructs = integrateStructs(transaction, store, ss);
  const pending = store.pendingStructs;
  if (pending) {
    for (const [client, clock] of pending.missing) {
      if (clock < getState(store, client)) {
        retry = true;
        break;
      }
    }
    if (restStructs) {
      for (const [client, clock] of restStructs.missing) {
        const mclock = pending.missing.get(client);
        if (mclock == null || mclock > clock) {
          pending.missing.set(client, clock);
        }
      }
      pending.update = mergeUpdatesV2([pending.update, restStructs.update]);
    }
  } else {
    store.pendingStructs = restStructs;
  }
  const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
  if (store.pendingDs) {
    const pendingDSUpdate = new UpdateDecoderV2(createDecoder(store.pendingDs));
    readVarUint(pendingDSUpdate.restDecoder);
    const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
    if (dsRest && dsRest2) {
      store.pendingDs = mergeUpdatesV2([dsRest, dsRest2]);
    } else {
      store.pendingDs = dsRest || dsRest2;
    }
  } else {
    store.pendingDs = dsRest;
  }
  if (retry) {
    const update = (
      /** @type {{update: Uint8Array}} */
      store.pendingStructs.update
    );
    store.pendingStructs = null;
    applyUpdateV2(transaction.doc, update);
  }
}, transactionOrigin, false);
var applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {
  const decoder = createDecoder(update);
  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
};
var applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1);
var writeStateAsUpdate = (encoder, doc2, targetStateVector = /* @__PURE__ */ new Map()) => {
  writeClientsStructs(encoder, doc2.store, targetStateVector);
  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc2.store));
};
var encodeStateAsUpdateV2 = (doc2, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {
  const targetStateVector = decodeStateVector(encodedTargetStateVector);
  writeStateAsUpdate(encoder, doc2, targetStateVector);
  const updates = [encoder.toUint8Array()];
  if (doc2.store.pendingDs) {
    updates.push(doc2.store.pendingDs);
  }
  if (doc2.store.pendingStructs) {
    updates.push(diffUpdateV2(doc2.store.pendingStructs.update, encodedTargetStateVector));
  }
  if (updates.length > 1) {
    if (encoder.constructor === UpdateEncoderV1) {
      return mergeUpdates(updates.map((update, i) => i === 0 ? update : convertUpdateFormatV2ToV1(update)));
    } else if (encoder.constructor === UpdateEncoderV2) {
      return mergeUpdatesV2(updates);
    }
  }
  return updates[0];
};
var encodeStateAsUpdate = (doc2, encodedTargetStateVector) => encodeStateAsUpdateV2(doc2, encodedTargetStateVector, new UpdateEncoderV1());
var readStateVector = (decoder) => {
  const ss = /* @__PURE__ */ new Map();
  const ssLength = readVarUint(decoder.restDecoder);
  for (let i = 0; i < ssLength; i++) {
    const client = readVarUint(decoder.restDecoder);
    const clock = readVarUint(decoder.restDecoder);
    ss.set(client, clock);
  }
  return ss;
};
var decodeStateVector = (decodedState) => readStateVector(new DSDecoderV1(createDecoder(decodedState)));
var writeStateVector = (encoder, sv) => {
  writeVarUint(encoder.restEncoder, sv.size);
  from(sv.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {
    writeVarUint(encoder.restEncoder, client);
    writeVarUint(encoder.restEncoder, clock);
  });
  return encoder;
};
var writeDocumentStateVector = (encoder, doc2) => writeStateVector(encoder, getStateVector(doc2.store));
var encodeStateVectorV2 = (doc2, encoder = new DSEncoderV2()) => {
  if (doc2 instanceof Map) {
    writeStateVector(encoder, doc2);
  } else {
    writeDocumentStateVector(encoder, doc2);
  }
  return encoder.toUint8Array();
};
var encodeStateVector = (doc2) => encodeStateVectorV2(doc2, new DSEncoderV1());
var EventHandler = class {
  constructor() {
    this.l = [];
  }
};
var createEventHandler = () => new EventHandler();
var addEventHandlerListener = (eventHandler, f) => eventHandler.l.push(f);
var removeEventHandlerListener = (eventHandler, f) => {
  const l = eventHandler.l;
  const len = l.length;
  eventHandler.l = l.filter((g) => f !== g);
  if (len === eventHandler.l.length) {
    console.error("[yjs] Tried to remove event handler that doesn't exist.");
  }
};
var callEventHandlerListeners = (eventHandler, arg0, arg1) => callAll(eventHandler.l, [arg0, arg1]);
var ID = class {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(client, clock) {
    this.client = client;
    this.clock = clock;
  }
};
var compareIDs = (a, b) => a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
var createID = (client, clock) => new ID(client, clock);
var findRootTypeKey = (type2) => {
  for (const [key, value] of type2.doc.share.entries()) {
    if (value === type2) {
      return key;
    }
  }
  throw unexpectedCase();
};
var isParentOf = (parent, child) => {
  while (child !== null) {
    if (child.parent === parent) {
      return true;
    }
    child = /** @type {AbstractType<any>} */
    child.parent._item;
  }
  return false;
};
var RelativePosition = class {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(type2, tname, item, assoc = 0) {
    this.type = type2;
    this.tname = tname;
    this.item = item;
    this.assoc = assoc;
  }
};
var relativePositionToJSON = (rpos) => {
  const json = {};
  if (rpos.type) {
    json.type = rpos.type;
  }
  if (rpos.tname) {
    json.tname = rpos.tname;
  }
  if (rpos.item) {
    json.item = rpos.item;
  }
  if (rpos.assoc != null) {
    json.assoc = rpos.assoc;
  }
  return json;
};
var createRelativePositionFromJSON = (json) => {
  var _a;
  return new RelativePosition(json.type == null ? null : createID(json.type.client, json.type.clock), (_a = json.tname) != null ? _a : null, json.item == null ? null : createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
};
var AbsolutePosition = class {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(type2, index, assoc = 0) {
    this.type = type2;
    this.index = index;
    this.assoc = assoc;
  }
};
var createAbsolutePosition = (type2, index, assoc = 0) => new AbsolutePosition(type2, index, assoc);
var createRelativePosition = (type2, item, assoc) => {
  let typeid = null;
  let tname = null;
  if (type2._item === null) {
    tname = findRootTypeKey(type2);
  } else {
    typeid = createID(type2._item.id.client, type2._item.id.clock);
  }
  return new RelativePosition(typeid, tname, item, assoc);
};
var createRelativePositionFromTypeIndex = (type2, index, assoc = 0) => {
  let t = type2._start;
  if (assoc < 0) {
    if (index === 0) {
      return createRelativePosition(type2, null, assoc);
    }
    index--;
  }
  while (t !== null) {
    if (!t.deleted && t.countable) {
      if (t.length > index) {
        return createRelativePosition(type2, createID(t.id.client, t.id.clock + index), assoc);
      }
      index -= t.length;
    }
    if (t.right === null && assoc < 0) {
      return createRelativePosition(type2, t.lastId, assoc);
    }
    t = t.right;
  }
  return createRelativePosition(type2, null, assoc);
};
var createAbsolutePositionFromRelativePosition = (rpos, doc2, followUndoneDeletions = true) => {
  const store = doc2.store;
  const rightID = rpos.item;
  const typeID = rpos.type;
  const tname = rpos.tname;
  const assoc = rpos.assoc;
  let type2 = null;
  let index = 0;
  if (rightID !== null) {
    if (getState(store, rightID.client) <= rightID.clock) {
      return null;
    }
    const res = followUndoneDeletions ? followRedone(store, rightID) : { item: getItem(store, rightID), diff: 0 };
    const right = res.item;
    if (!(right instanceof Item)) {
      return null;
    }
    type2 = /** @type {AbstractType<any>} */
    right.parent;
    if (type2._item === null || !type2._item.deleted) {
      index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1);
      let n = right.left;
      while (n !== null) {
        if (!n.deleted && n.countable) {
          index += n.length;
        }
        n = n.left;
      }
    }
  } else {
    if (tname !== null) {
      type2 = doc2.get(tname);
    } else if (typeID !== null) {
      if (getState(store, typeID.client) <= typeID.clock) {
        return null;
      }
      const { item } = followUndoneDeletions ? followRedone(store, typeID) : { item: getItem(store, typeID) };
      if (item instanceof Item && item.content instanceof ContentType) {
        type2 = item.content.type;
      } else {
        return null;
      }
    } else {
      throw unexpectedCase();
    }
    if (assoc >= 0) {
      index = type2._length;
    } else {
      index = 0;
    }
  }
  return createAbsolutePosition(type2, index, rpos.assoc);
};
var compareRelativePositions = (a, b) => a === b || a !== null && b !== null && a.tname === b.tname && compareIDs(a.item, b.item) && compareIDs(a.type, b.type) && a.assoc === b.assoc;
var Snapshot = class {
  /**
   * @param {DeleteSet} ds
   * @param {Map<number,number>} sv state map
   */
  constructor(ds, sv) {
    this.ds = ds;
    this.sv = sv;
  }
};
var createSnapshot = (ds, sm) => new Snapshot(ds, sm);
var emptySnapshot = createSnapshot(createDeleteSet(), /* @__PURE__ */ new Map());
var isVisible = (item, snapshot) => snapshot === void 0 ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id);
var splitSnapshotAffectedStructs = (transaction, snapshot) => {
  const meta = setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, create2);
  const store = transaction.doc.store;
  if (!meta.has(snapshot)) {
    snapshot.sv.forEach((clock, client) => {
      if (clock < getState(store, client)) {
        getItemCleanStart(transaction, createID(client, clock));
      }
    });
    iterateDeletedStructs(transaction, snapshot.ds, (_item) => {
    });
    meta.add(snapshot);
  }
};
var StructStore = class {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
    this.pendingStructs = null;
    this.pendingDs = null;
  }
};
var getStateVector = (store) => {
  const sm = /* @__PURE__ */ new Map();
  store.clients.forEach((structs, client) => {
    const struct = structs[structs.length - 1];
    sm.set(client, struct.id.clock + struct.length);
  });
  return sm;
};
var getState = (store, client) => {
  const structs = store.clients.get(client);
  if (structs === void 0) {
    return 0;
  }
  const lastStruct = structs[structs.length - 1];
  return lastStruct.id.clock + lastStruct.length;
};
var addStruct = (store, struct) => {
  let structs = store.clients.get(struct.id.client);
  if (structs === void 0) {
    structs = [];
    store.clients.set(struct.id.client, structs);
  } else {
    const lastStruct = structs[structs.length - 1];
    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
      throw unexpectedCase();
    }
  }
  structs.push(struct);
};
var findIndexSS = (structs, clock) => {
  let left = 0;
  let right = structs.length - 1;
  let mid = structs[right];
  let midclock = mid.id.clock;
  if (midclock === clock) {
    return right;
  }
  let midindex = floor(clock / (midclock + mid.length - 1) * right);
  while (left <= right) {
    mid = structs[midindex];
    midclock = mid.id.clock;
    if (midclock <= clock) {
      if (clock < midclock + mid.length) {
        return midindex;
      }
      left = midindex + 1;
    } else {
      right = midindex - 1;
    }
    midindex = floor((left + right) / 2);
  }
  throw unexpectedCase();
};
var find = (store, id2) => {
  const structs = store.clients.get(id2.client);
  return structs[findIndexSS(structs, id2.clock)];
};
var getItem = (
  /** @type {function(StructStore,ID):Item} */
  find
);
var findIndexCleanStart = (transaction, structs, clock) => {
  const index = findIndexSS(structs, clock);
  const struct = structs[index];
  if (struct.id.clock < clock && struct instanceof Item) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
    return index + 1;
  }
  return index;
};
var getItemCleanStart = (transaction, id2) => {
  const structs = (
    /** @type {Array<Item>} */
    transaction.doc.store.clients.get(id2.client)
  );
  return structs[findIndexCleanStart(transaction, structs, id2.clock)];
};
var getItemCleanEnd = (transaction, store, id2) => {
  const structs = store.clients.get(id2.client);
  const index = findIndexSS(structs, id2.clock);
  const struct = structs[index];
  if (id2.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {
    structs.splice(index + 1, 0, splitItem(transaction, struct, id2.clock - struct.id.clock + 1));
  }
  return struct;
};
var replaceStruct = (store, struct, newStruct) => {
  const structs = (
    /** @type {Array<GC|Item>} */
    store.clients.get(struct.id.client)
  );
  structs[findIndexSS(structs, struct.id.clock)] = newStruct;
};
var iterateStructs = (transaction, structs, clockStart, len, f) => {
  if (len === 0) {
    return;
  }
  const clockEnd = clockStart + len;
  let index = findIndexCleanStart(transaction, structs, clockStart);
  let struct;
  do {
    struct = structs[index++];
    if (clockEnd < struct.id.clock + struct.length) {
      findIndexCleanStart(transaction, structs, clockEnd);
    }
    f(struct);
  } while (index < structs.length && structs[index].id.clock < clockEnd);
};
var Transaction = class {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(doc2, origin, local) {
    this.doc = doc2;
    this.deleteSet = new DeleteSet();
    this.beforeState = getStateVector(doc2.store);
    this.afterState = /* @__PURE__ */ new Map();
    this.changed = /* @__PURE__ */ new Map();
    this.changedParentTypes = /* @__PURE__ */ new Map();
    this._mergeStructs = [];
    this.origin = origin;
    this.meta = /* @__PURE__ */ new Map();
    this.local = local;
    this.subdocsAdded = /* @__PURE__ */ new Set();
    this.subdocsRemoved = /* @__PURE__ */ new Set();
    this.subdocsLoaded = /* @__PURE__ */ new Set();
    this._needFormattingCleanup = false;
  }
};
var writeUpdateMessageFromTransaction = (encoder, transaction) => {
  if (transaction.deleteSet.clients.size === 0 && !any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {
    return false;
  }
  sortAndMergeDeleteSet(transaction.deleteSet);
  writeStructsFromTransaction(encoder, transaction);
  writeDeleteSet(encoder, transaction.deleteSet);
  return true;
};
var addChangedTypeToTransaction = (transaction, type2, parentSub) => {
  const item = type2._item;
  if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
    setIfUndefined(transaction.changed, type2, create2).add(parentSub);
  }
};
var tryToMergeWithLefts = (structs, pos) => {
  let right = structs[pos];
  let left = structs[pos - 1];
  let i = pos;
  for (; i > 0; right = left, left = structs[--i - 1]) {
    if (left.deleted === right.deleted && left.constructor === right.constructor) {
      if (left.mergeWith(right)) {
        if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */
        right.parent._map.get(right.parentSub) === right) {
          right.parent._map.set(
            right.parentSub,
            /** @type {Item} */
            left
          );
        }
        continue;
      }
    }
    break;
  }
  const merged = pos - i;
  if (merged) {
    structs.splice(pos + 1 - merged, merged);
  }
  return merged;
};
var tryGcDeleteSet = (ds, store, gcFilter) => {
  for (const [client, deleteItems] of ds.clients.entries()) {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const endDeleteItemClock = deleteItem.clock + deleteItem.len;
      for (let si = findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
        const struct2 = structs[si];
        if (deleteItem.clock + deleteItem.len <= struct2.id.clock) {
          break;
        }
        if (struct2 instanceof Item && struct2.deleted && !struct2.keep && gcFilter(struct2)) {
          struct2.gc(store, false);
        }
      }
    }
  }
};
var tryMergeDeleteSet = (ds, store) => {
  ds.clients.forEach((deleteItems, client) => {
    const structs = (
      /** @type {Array<GC|Item>} */
      store.clients.get(client)
    );
    for (let di = deleteItems.length - 1; di >= 0; di--) {
      const deleteItem = deleteItems[di];
      const mostRightIndexToCheck = min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
      for (let si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
        si -= 1 + tryToMergeWithLefts(structs, si);
      }
    }
  });
};
var cleanupTransactions = (transactionCleanups, i) => {
  if (i < transactionCleanups.length) {
    const transaction = transactionCleanups[i];
    const doc2 = transaction.doc;
    const store = doc2.store;
    const ds = transaction.deleteSet;
    const mergeStructs = transaction._mergeStructs;
    try {
      sortAndMergeDeleteSet(ds);
      transaction.afterState = getStateVector(transaction.doc.store);
      doc2.emit("beforeObserverCalls", [transaction, doc2]);
      const fs = [];
      transaction.changed.forEach(
        (subs, itemtype) => fs.push(() => {
          if (itemtype._item === null || !itemtype._item.deleted) {
            itemtype._callObserver(transaction, subs);
          }
        })
      );
      fs.push(() => {
        transaction.changedParentTypes.forEach((events, type2) => {
          if (type2._dEH.l.length > 0 && (type2._item === null || !type2._item.deleted)) {
            events = events.filter(
              (event) => event.target._item === null || !event.target._item.deleted
            );
            events.forEach((event) => {
              event.currentTarget = type2;
              event._path = null;
            });
            events.sort((event1, event2) => event1.path.length - event2.path.length);
            callEventHandlerListeners(type2._dEH, events, transaction);
          }
        });
      });
      fs.push(() => doc2.emit("afterTransaction", [transaction, doc2]));
      callAll(fs, []);
      if (transaction._needFormattingCleanup) {
        cleanupYTextAfterTransaction(transaction);
      }
    } finally {
      if (doc2.gc) {
        tryGcDeleteSet(ds, store, doc2.gcFilter);
      }
      tryMergeDeleteSet(ds, store);
      transaction.afterState.forEach((clock, client) => {
        const beforeClock = transaction.beforeState.get(client) || 0;
        if (beforeClock !== clock) {
          const structs = (
            /** @type {Array<GC|Item>} */
            store.clients.get(client)
          );
          const firstChangePos = max(findIndexSS(structs, beforeClock), 1);
          for (let i2 = structs.length - 1; i2 >= firstChangePos; ) {
            i2 -= 1 + tryToMergeWithLefts(structs, i2);
          }
        }
      });
      for (let i2 = mergeStructs.length - 1; i2 >= 0; i2--) {
        const { client, clock } = mergeStructs[i2].id;
        const structs = (
          /** @type {Array<GC|Item>} */
          store.clients.get(client)
        );
        const replacedStructPos = findIndexSS(structs, clock);
        if (replacedStructPos + 1 < structs.length) {
          if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
            continue;
          }
        }
        if (replacedStructPos > 0) {
          tryToMergeWithLefts(structs, replacedStructPos);
        }
      }
      if (!transaction.local && transaction.afterState.get(doc2.clientID) !== transaction.beforeState.get(doc2.clientID)) {
        print(ORANGE, BOLD, "[yjs] ", UNBOLD, RED, "Changed the client-id because another client seems to be using it.");
        doc2.clientID = generateNewClientId();
      }
      doc2.emit("afterTransactionCleanup", [transaction, doc2]);
      if (doc2._observers.has("update")) {
        const encoder = new UpdateEncoderV1();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("update", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      if (doc2._observers.has("updateV2")) {
        const encoder = new UpdateEncoderV2();
        const hasContent2 = writeUpdateMessageFromTransaction(encoder, transaction);
        if (hasContent2) {
          doc2.emit("updateV2", [encoder.toUint8Array(), transaction.origin, doc2, transaction]);
        }
      }
      const { subdocsAdded, subdocsLoaded, subdocsRemoved } = transaction;
      if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
        subdocsAdded.forEach((subdoc) => {
          subdoc.clientID = doc2.clientID;
          if (subdoc.collectionid == null) {
            subdoc.collectionid = doc2.collectionid;
          }
          doc2.subdocs.add(subdoc);
        });
        subdocsRemoved.forEach((subdoc) => doc2.subdocs.delete(subdoc));
        doc2.emit("subdocs", [{ loaded: subdocsLoaded, added: subdocsAdded, removed: subdocsRemoved }, doc2, transaction]);
        subdocsRemoved.forEach((subdoc) => subdoc.destroy());
      }
      if (transactionCleanups.length <= i + 1) {
        doc2._transactionCleanups = [];
        doc2.emit("afterAllTransactions", [doc2, transactionCleanups]);
      } else {
        cleanupTransactions(transactionCleanups, i + 1);
      }
    }
  }
};
var transact = (doc2, f, origin = null, local = true) => {
  const transactionCleanups = doc2._transactionCleanups;
  let initialCall = false;
  let result = null;
  if (doc2._transaction === null) {
    initialCall = true;
    doc2._transaction = new Transaction(doc2, origin, local);
    transactionCleanups.push(doc2._transaction);
    if (transactionCleanups.length === 1) {
      doc2.emit("beforeAllTransactions", [doc2]);
    }
    doc2.emit("beforeTransaction", [doc2._transaction, doc2]);
  }
  try {
    result = f(doc2._transaction);
  } finally {
    if (initialCall) {
      const finishCleanup = doc2._transaction === transactionCleanups[0];
      doc2._transaction = null;
      if (finishCleanup) {
        cleanupTransactions(transactionCleanups, 0);
      }
    }
  }
  return result;
};
var StackItem = class {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(deletions, insertions) {
    this.insertions = insertions;
    this.deletions = deletions;
    this.meta = /* @__PURE__ */ new Map();
  }
};
var clearUndoManagerStackItem = (tr, um, stackItem) => {
  iterateDeletedStructs(tr, stackItem.deletions, (item) => {
    if (item instanceof Item && um.scope.some((type2) => isParentOf(type2, item))) {
      keepItem(item, false);
    }
  });
};
var popStackItem = (undoManager, stack, eventType) => {
  let _tr = null;
  const doc2 = undoManager.doc;
  const scope = undoManager.scope;
  transact(doc2, (transaction) => {
    while (stack.length > 0 && undoManager.currStackItem === null) {
      const store = doc2.store;
      const stackItem = (
        /** @type {StackItem} */
        stack.pop()
      );
      const itemsToRedo = /* @__PURE__ */ new Set();
      const itemsToDelete = [];
      let performedChange = false;
      iterateDeletedStructs(transaction, stackItem.insertions, (struct) => {
        if (struct instanceof Item) {
          if (struct.redone !== null) {
            let { item, diff } = followRedone(store, struct.id);
            if (diff > 0) {
              item = getItemCleanStart(transaction, createID(item.id.client, item.id.clock + diff));
            }
            struct = item;
          }
          if (!struct.deleted && scope.some((type2) => isParentOf(
            type2,
            /** @type {Item} */
            struct
          ))) {
            itemsToDelete.push(struct);
          }
        }
      });
      iterateDeletedStructs(transaction, stackItem.deletions, (struct) => {
        if (struct instanceof Item && scope.some((type2) => isParentOf(type2, struct)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !isDeleted(stackItem.insertions, struct.id)) {
          itemsToRedo.add(struct);
        }
      });
      itemsToRedo.forEach((struct) => {
        performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
      });
      for (let i = itemsToDelete.length - 1; i >= 0; i--) {
        const item = itemsToDelete[i];
        if (undoManager.deleteFilter(item)) {
          item.delete(transaction);
          performedChange = true;
        }
      }
      undoManager.currStackItem = performedChange ? stackItem : null;
    }
    transaction.changed.forEach((subProps, type2) => {
      if (subProps.has(null) && type2._searchMarker) {
        type2._searchMarker.length = 0;
      }
    });
    _tr = transaction;
  }, undoManager);
  const res = undoManager.currStackItem;
  if (res != null) {
    const changedParentTypes = _tr.changedParentTypes;
    undoManager.emit("stack-item-popped", [{ stackItem: res, type: eventType, changedParentTypes, origin: undoManager }, undoManager]);
    undoManager.currStackItem = null;
  }
  return res;
};
var UndoManager = class extends ObservableV2 {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(typeScope, {
    captureTimeout = 500,
    captureTransaction = (_tr) => true,
    deleteFilter = () => true,
    trackedOrigins = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges = false,
    doc: doc2 = (
      /** @type {Doc} */
      isArray(typeScope) ? typeScope[0].doc : typeScope.doc
    )
  } = {}) {
    super();
    this.scope = [];
    this.doc = doc2;
    this.addToScope(typeScope);
    this.deleteFilter = deleteFilter;
    trackedOrigins.add(this);
    this.trackedOrigins = trackedOrigins;
    this.captureTransaction = captureTransaction;
    this.undoStack = [];
    this.redoStack = [];
    this.undoing = false;
    this.redoing = false;
    this.currStackItem = null;
    this.lastChange = 0;
    this.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
    this.captureTimeout = captureTimeout;
    this.afterTransactionHandler = (transaction) => {
      if (!this.captureTransaction(transaction) || !this.scope.some((type2) => transaction.changedParentTypes.has(type2)) || !this.trackedOrigins.has(transaction.origin) && (!transaction.origin || !this.trackedOrigins.has(transaction.origin.constructor))) {
        return;
      }
      const undoing = this.undoing;
      const redoing = this.redoing;
      const stack = undoing ? this.redoStack : this.undoStack;
      if (undoing) {
        this.stopCapturing();
      } else if (!redoing) {
        this.clear(false, true);
      }
      const insertions = new DeleteSet();
      transaction.afterState.forEach((endClock, client) => {
        const startClock = transaction.beforeState.get(client) || 0;
        const len = endClock - startClock;
        if (len > 0) {
          addToDeleteSet(insertions, client, startClock, len);
        }
      });
      const now = getUnixTime();
      let didAdd = false;
      if (this.lastChange > 0 && now - this.lastChange < this.captureTimeout && stack.length > 0 && !undoing && !redoing) {
        const lastOp = stack[stack.length - 1];
        lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
        lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
      } else {
        stack.push(new StackItem(transaction.deleteSet, insertions));
        didAdd = true;
      }
      if (!undoing && !redoing) {
        this.lastChange = now;
      }
      iterateDeletedStructs(
        transaction,
        transaction.deleteSet,
        /** @param {Item|GC} item */
        (item) => {
          if (item instanceof Item && this.scope.some((type2) => isParentOf(type2, item))) {
            keepItem(item, true);
          }
        }
      );
      const changeEvent = [{ stackItem: stack[stack.length - 1], origin: transaction.origin, type: undoing ? "redo" : "undo", changedParentTypes: transaction.changedParentTypes }, this];
      if (didAdd) {
        this.emit("stack-item-added", changeEvent);
      } else {
        this.emit("stack-item-updated", changeEvent);
      }
    };
    this.doc.on("afterTransaction", this.afterTransactionHandler);
    this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(ytypes) {
    ytypes = isArray(ytypes) ? ytypes : [ytypes];
    ytypes.forEach((ytype) => {
      if (this.scope.every((yt) => yt !== ytype)) {
        if (ytype.doc !== this.doc)
          warn("[yjs#509] Not same Y.Doc");
        this.scope.push(ytype);
      }
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.trackedOrigins.add(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.trackedOrigins.delete(origin);
  }
  clear(clearUndoStack = true, clearRedoStack = true) {
    if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
      this.doc.transact((tr) => {
        if (clearUndoStack) {
          this.undoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.undoStack = [];
        }
        if (clearRedoStack) {
          this.redoStack.forEach((item) => clearUndoManagerStackItem(tr, this, item));
          this.redoStack = [];
        }
        this.emit("stack-cleared", [{ undoStackCleared: clearUndoStack, redoStackCleared: clearRedoStack }]);
      });
    }
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = true;
    let res;
    try {
      res = popStackItem(this, this.undoStack, "undo");
    } finally {
      this.undoing = false;
    }
    return res;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = true;
    let res;
    try {
      res = popStackItem(this, this.redoStack, "redo");
    } finally {
      this.redoing = false;
    }
    return res;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this);
    this.doc.off("afterTransaction", this.afterTransactionHandler);
    super.destroy();
  }
};
function* lazyStructReaderGenerator(decoder) {
  const numOfStateUpdates = readVarUint(decoder.restDecoder);
  for (let i = 0; i < numOfStateUpdates; i++) {
    const numberOfStructs = readVarUint(decoder.restDecoder);
    const client = decoder.readClient();
    let clock = readVarUint(decoder.restDecoder);
    for (let i2 = 0; i2 < numberOfStructs; i2++) {
      const info = decoder.readInfo();
      if (info === 10) {
        const len = readVarUint(decoder.restDecoder);
        yield new Skip(createID(client, clock), len);
        clock += len;
      } else if ((BITS5 & info) !== 0) {
        const cantCopyParentInfo = (info & (BIT7 | BIT8)) === 0;
        const struct = new Item(
          createID(client, clock),
          null,
          // left
          (info & BIT8) === BIT8 ? decoder.readLeftID() : null,
          // origin
          null,
          // right
          (info & BIT7) === BIT7 ? decoder.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
          // parent
          cantCopyParentInfo && (info & BIT6) === BIT6 ? decoder.readString() : null,
          // parentSub
          readItemContent(decoder, info)
          // item content
        );
        yield struct;
        clock += struct.length;
      } else {
        const len = decoder.readLen();
        yield new GC(createID(client, clock), len);
        clock += len;
      }
    }
  }
}
var LazyStructReader = class {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(decoder, filterSkips) {
    this.gen = lazyStructReaderGenerator(decoder);
    this.curr = null;
    this.done = false;
    this.filterSkips = filterSkips;
    this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do {
      this.curr = this.gen.next().value || null;
    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
    return this.curr;
  }
};
var LazyStructWriter = class {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(encoder) {
    this.currClient = 0;
    this.startClock = 0;
    this.written = 0;
    this.encoder = encoder;
    this.clientStructs = [];
  }
};
var mergeUpdates = (updates) => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1);
var sliceStruct = (left, diff) => {
  if (left.constructor === GC) {
    const { client, clock } = left.id;
    return new GC(createID(client, clock + diff), left.length - diff);
  } else if (left.constructor === Skip) {
    const { client, clock } = left.id;
    return new Skip(createID(client, clock + diff), left.length - diff);
  } else {
    const leftItem = (
      /** @type {Item} */
      left
    );
    const { client, clock } = leftItem.id;
    return new Item(
      createID(client, clock + diff),
      null,
      createID(client, clock + diff - 1),
      null,
      leftItem.rightOrigin,
      leftItem.parent,
      leftItem.parentSub,
      leftItem.content.splice(diff)
    );
  }
};
var mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  if (updates.length === 1) {
    return updates[0];
  }
  const updateDecoders = updates.map((update) => new YDecoder(createDecoder(update)));
  let lazyStructDecoders = updateDecoders.map((decoder) => new LazyStructReader(decoder, true));
  let currWrite = null;
  const updateEncoder = new YEncoder();
  const lazyStructEncoder = new LazyStructWriter(updateEncoder);
  while (true) {
    lazyStructDecoders = lazyStructDecoders.filter((dec) => dec.curr !== null);
    lazyStructDecoders.sort(
      /** @type {function(any,any):number} */
      (dec1, dec2) => {
        if (dec1.curr.id.client === dec2.curr.id.client) {
          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
          if (clockDiff === 0) {
            return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1;
          } else {
            return clockDiff;
          }
        } else {
          return dec2.curr.id.client - dec1.curr.id.client;
        }
      }
    );
    if (lazyStructDecoders.length === 0) {
      break;
    }
    const currDecoder = lazyStructDecoders[0];
    const firstClient = (
      /** @type {Item | GC} */
      currDecoder.curr.id.client
    );
    if (currWrite !== null) {
      let curr = (
        /** @type {Item | GC | null} */
        currDecoder.curr
      );
      let iterated = false;
      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
        curr = currDecoder.next();
        iterated = true;
      }
      if (curr === null || // current decoder is empty
      curr.id.client !== firstClient || // check whether there is another decoder that has has updates from `firstClient`
      iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length) {
        continue;
      }
      if (firstClient !== currWrite.struct.id.client) {
        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
        currWrite = { struct: curr, offset: 0 };
        currDecoder.next();
      } else {
        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
          if (currWrite.struct.constructor === Skip) {
            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
          } else {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
            currWrite = { struct, offset: 0 };
          }
        } else {
          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
          if (diff > 0) {
            if (currWrite.struct.constructor === Skip) {
              currWrite.struct.length -= diff;
            } else {
              curr = sliceStruct(curr, diff);
            }
          }
          if (!currWrite.struct.mergeWith(
            /** @type {any} */
            curr
          )) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = { struct: curr, offset: 0 };
            currDecoder.next();
          }
        }
      }
    } else {
      currWrite = { struct: (
        /** @type {Item | GC} */
        currDecoder.curr
      ), offset: 0 };
      currDecoder.next();
    }
    for (let next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
      currWrite = { struct: next, offset: 0 };
    }
  }
  if (currWrite !== null) {
    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
    currWrite = null;
  }
  finishLazyStructWriting(lazyStructEncoder);
  const dss = updateDecoders.map((decoder) => readDeleteSet(decoder));
  const ds = mergeDeleteSets(dss);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {
  const state = decodeStateVector(sv);
  const encoder = new YEncoder();
  const lazyStructWriter = new LazyStructWriter(encoder);
  const decoder = new YDecoder(createDecoder(update));
  const reader = new LazyStructReader(decoder, false);
  while (reader.curr) {
    const curr = reader.curr;
    const currClient = curr.id.client;
    const svClock = state.get(currClient) || 0;
    if (reader.curr.constructor === Skip) {
      reader.next();
      continue;
    }
    if (curr.id.clock + curr.length > svClock) {
      writeStructToLazyStructWriter(lazyStructWriter, curr, max(svClock - curr.id.clock, 0));
      reader.next();
      while (reader.curr && reader.curr.id.client === currClient) {
        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
        reader.next();
      }
    } else {
      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
        reader.next();
      }
    }
  }
  finishLazyStructWriting(lazyStructWriter);
  const ds = readDeleteSet(decoder);
  writeDeleteSet(encoder, ds);
  return encoder.toUint8Array();
};
var flushLazyStructWriter = (lazyWriter) => {
  if (lazyWriter.written > 0) {
    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: toUint8Array(lazyWriter.encoder.restEncoder) });
    lazyWriter.encoder.restEncoder = createEncoder();
    lazyWriter.written = 0;
  }
};
var writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {
  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
    flushLazyStructWriter(lazyWriter);
  }
  if (lazyWriter.written === 0) {
    lazyWriter.currClient = struct.id.client;
    lazyWriter.encoder.writeClient(struct.id.client);
    writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
  }
  struct.write(lazyWriter.encoder, offset);
  lazyWriter.written++;
};
var finishLazyStructWriting = (lazyWriter) => {
  flushLazyStructWriter(lazyWriter);
  const restEncoder = lazyWriter.encoder.restEncoder;
  writeVarUint(restEncoder, lazyWriter.clientStructs.length);
  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {
    const partStructs = lazyWriter.clientStructs[i];
    writeVarUint(restEncoder, partStructs.written);
    writeUint8Array(restEncoder, partStructs.restEncoder);
  }
};
var convertUpdateFormat = (update, blockTransformer, YDecoder, YEncoder) => {
  const updateDecoder = new YDecoder(createDecoder(update));
  const lazyDecoder = new LazyStructReader(updateDecoder, false);
  const updateEncoder = new YEncoder();
  const lazyWriter = new LazyStructWriter(updateEncoder);
  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
    writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
  }
  finishLazyStructWriting(lazyWriter);
  const ds = readDeleteSet(updateDecoder);
  writeDeleteSet(updateEncoder, ds);
  return updateEncoder.toUint8Array();
};
var convertUpdateFormatV2ToV1 = (update) => convertUpdateFormat(update, id, UpdateDecoderV2, UpdateEncoderV1);
var errorComputeChanges = "You must not compute changes after the event-handler fired.";
var YEvent = class {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(target, transaction) {
    this.target = target;
    this.currentTarget = target;
    this.transaction = transaction;
    this._changes = null;
    this._keys = null;
    this._delta = null;
    this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = getPathTo(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(struct) {
    return isDeleted(this.transaction.deleteSet, struct.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const keys3 = /* @__PURE__ */ new Map();
      const target = this.target;
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      changed.forEach((key) => {
        if (key !== null) {
          const item = (
            /** @type {Item} */
            target._map.get(key)
          );
          let action;
          let oldValue;
          if (this.adds(item)) {
            let prev = item.left;
            while (prev !== null && this.adds(prev)) {
              prev = prev.left;
            }
            if (this.deletes(item)) {
              if (prev !== null && this.deletes(prev)) {
                action = "delete";
                oldValue = last(prev.content.getContent());
              } else {
                return;
              }
            } else {
              if (prev !== null && this.deletes(prev)) {
                action = "update";
                oldValue = last(prev.content.getContent());
              } else {
                action = "add";
                oldValue = void 0;
              }
            }
          } else {
            if (this.deletes(item)) {
              action = "delete";
              oldValue = last(
                /** @type {Item} */
                item.content.getContent()
              );
            } else {
              return;
            }
          }
          keys3.set(key, { action, oldValue });
        }
      });
      this._keys = keys3;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(struct) {
    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let changes = this._changes;
    if (changes === null) {
      if (this.transaction.doc._transactionCleanups.length === 0) {
        throw create3(errorComputeChanges);
      }
      const target = this.target;
      const added = create2();
      const deleted = create2();
      const delta = [];
      changes = {
        added,
        deleted,
        delta,
        keys: this.keys
      };
      const changed = (
        /** @type Set<string|null> */
        this.transaction.changed.get(target)
      );
      if (changed.has(null)) {
        let lastOp = null;
        const packOp = () => {
          if (lastOp) {
            delta.push(lastOp);
          }
        };
        for (let item = target._start; item !== null; item = item.right) {
          if (item.deleted) {
            if (this.deletes(item) && !this.adds(item)) {
              if (lastOp === null || lastOp.delete === void 0) {
                packOp();
                lastOp = { delete: 0 };
              }
              lastOp.delete += item.length;
              deleted.add(item);
            }
          } else {
            if (this.adds(item)) {
              if (lastOp === null || lastOp.insert === void 0) {
                packOp();
                lastOp = { insert: [] };
              }
              lastOp.insert = lastOp.insert.concat(item.content.getContent());
              added.add(item);
            } else {
              if (lastOp === null || lastOp.retain === void 0) {
                packOp();
                lastOp = { retain: 0 };
              }
              lastOp.retain += item.length;
            }
          }
        }
        if (lastOp !== null && lastOp.retain === void 0) {
          packOp();
        }
      }
      this._changes = changes;
    }
    return (
      /** @type {any} */
      changes
    );
  }
};
var getPathTo = (parent, child) => {
  const path4 = [];
  while (child._item !== null && child !== parent) {
    if (child._item.parentSub !== null) {
      path4.unshift(child._item.parentSub);
    } else {
      let i = 0;
      let c = (
        /** @type {AbstractType<any>} */
        child._item.parent._start
      );
      while (c !== child._item && c !== null) {
        if (!c.deleted && c.countable) {
          i += c.length;
        }
        c = c.right;
      }
      path4.unshift(i);
    }
    child = /** @type {AbstractType<any>} */
    child._item.parent;
  }
  return path4;
};
var maxSearchMarker = 80;
var globalSearchMarkerTimestamp = 0;
var ArraySearchMarker = class {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(p, index) {
    p.marker = true;
    this.p = p;
    this.index = index;
    this.timestamp = globalSearchMarkerTimestamp++;
  }
};
var refreshMarkerTimestamp = (marker) => {
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var overwriteMarker = (marker, p, index) => {
  marker.p.marker = false;
  marker.p = p;
  p.marker = true;
  marker.index = index;
  marker.timestamp = globalSearchMarkerTimestamp++;
};
var markPosition = (searchMarker, p, index) => {
  if (searchMarker.length >= maxSearchMarker) {
    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b);
    overwriteMarker(marker, p, index);
    return marker;
  } else {
    const pm = new ArraySearchMarker(p, index);
    searchMarker.push(pm);
    return pm;
  }
};
var findMarker = (yarray, index) => {
  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
    return null;
  }
  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => abs(index - a.index) < abs(index - b.index) ? a : b);
  let p = yarray._start;
  let pindex = 0;
  if (marker !== null) {
    p = marker.p;
    pindex = marker.index;
    refreshMarkerTimestamp(marker);
  }
  while (p.right !== null && pindex < index) {
    if (!p.deleted && p.countable) {
      if (index < pindex + p.length) {
        break;
      }
      pindex += p.length;
    }
    p = p.right;
  }
  while (p.left !== null && pindex > index) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
    p = p.left;
    if (!p.deleted && p.countable) {
      pindex -= p.length;
    }
  }
  if (marker !== null && abs(marker.index - pindex) < /** @type {YText|YArray<any>} */
  p.parent.length / maxSearchMarker) {
    overwriteMarker(marker, p, pindex);
    return marker;
  } else {
    return markPosition(yarray._searchMarker, p, pindex);
  }
};
var updateMarkerChanges = (searchMarker, index, len) => {
  for (let i = searchMarker.length - 1; i >= 0; i--) {
    const m = searchMarker[i];
    if (len > 0) {
      let p = m.p;
      p.marker = false;
      while (p && (p.deleted || !p.countable)) {
        p = p.left;
        if (p && !p.deleted && p.countable) {
          m.index -= p.length;
        }
      }
      if (p === null || p.marker === true) {
        searchMarker.splice(i, 1);
        continue;
      }
      m.p = p;
      p.marker = true;
    }
    if (index < m.index || len > 0 && index === m.index) {
      m.index = max(index, m.index + len);
    }
  }
};
var callTypeObservers = (type2, transaction, event) => {
  const changedType = type2;
  const changedParentTypes = transaction.changedParentTypes;
  while (true) {
    setIfUndefined(changedParentTypes, type2, () => []).push(event);
    if (type2._item === null) {
      break;
    }
    type2 = /** @type {AbstractType<any>} */
    type2._item.parent;
  }
  callEventHandlerListeners(changedType._eH, event, transaction);
};
var AbstractType = class {
  constructor() {
    this._item = null;
    this._map = /* @__PURE__ */ new Map();
    this._start = null;
    this.doc = null;
    this._length = 0;
    this._eH = createEventHandler();
    this._dEH = createEventHandler();
    this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(y, item) {
    this.doc = y;
    this._item = item;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw methodUnimplemented();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw methodUnimplemented();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(_encoder) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let n = this._start;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, _parentSubs) {
    if (!transaction.local && this._searchMarker) {
      this._searchMarker.length = 0;
    }
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(f) {
    addEventHandlerListener(this._eH, f);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(f) {
    addEventHandlerListener(this._dEH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(f) {
    removeEventHandlerListener(this._eH, f);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(f) {
    removeEventHandlerListener(this._dEH, f);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
};
var typeListSlice = (type2, start, end) => {
  if (start < 0) {
    start = type2._length + start;
  }
  if (end < 0) {
    end = type2._length + end;
  }
  let len = end - start;
  const cs = [];
  let n = type2._start;
  while (n !== null && len > 0) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      if (c.length <= start) {
        start -= c.length;
      } else {
        for (let i = start; i < c.length && len > 0; i++) {
          cs.push(c[i]);
          len--;
        }
        start = 0;
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListToArray = (type2) => {
  const cs = [];
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        cs.push(c[i]);
      }
    }
    n = n.right;
  }
  return cs;
};
var typeListForEach = (type2, f) => {
  let index = 0;
  let n = type2._start;
  while (n !== null) {
    if (n.countable && !n.deleted) {
      const c = n.content.getContent();
      for (let i = 0; i < c.length; i++) {
        f(c[i], index++, type2);
      }
    }
    n = n.right;
  }
};
var typeListMap = (type2, f) => {
  const result = [];
  typeListForEach(type2, (c, i) => {
    result.push(f(c, i, type2));
  });
  return result;
};
var typeListCreateIterator = (type2) => {
  let n = type2._start;
  let currentContent = null;
  let currentContentIndex = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (currentContent === null) {
        while (n !== null && n.deleted) {
          n = n.right;
        }
        if (n === null) {
          return {
            done: true,
            value: void 0
          };
        }
        currentContent = n.content.getContent();
        currentContentIndex = 0;
        n = n.right;
      }
      const value = currentContent[currentContentIndex++];
      if (currentContent.length <= currentContentIndex) {
        currentContent = null;
      }
      return {
        done: false,
        value
      };
    }
  };
};
var typeListGet = (type2, index) => {
  const marker = findMarker(type2, index);
  let n = type2._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        return n.content.getContent()[index];
      }
      index -= n.length;
    }
  }
};
var typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {
  let left = referenceItem;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const store = doc2.store;
  const right = referenceItem === null ? parent._start : referenceItem.right;
  let jsonContent = [];
  const packJsonContent = () => {
    if (jsonContent.length > 0) {
      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent));
      left.integrate(transaction, 0);
      jsonContent = [];
    }
  };
  content.forEach((c) => {
    if (c === null) {
      jsonContent.push(c);
    } else {
      switch (c.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          jsonContent.push(c);
          break;
        default:
          packJsonContent();
          switch (c.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(
                /** @type {Uint8Array} */
                c
              )));
              left.integrate(transaction, 0);
              break;
            case Doc:
              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(
                /** @type {Doc} */
                c
              ));
              left.integrate(transaction, 0);
              break;
            default:
              if (c instanceof AbstractType) {
                left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c));
                left.integrate(transaction, 0);
              } else {
                throw new Error("Unexpected content type in insert operation");
              }
          }
      }
    }
  });
  packJsonContent();
};
var lengthExceeded = () => create3("Length exceeded!");
var typeListInsertGenerics = (transaction, parent, index, content) => {
  if (index > parent._length) {
    throw lengthExceeded();
  }
  if (index === 0) {
    if (parent._searchMarker) {
      updateMarkerChanges(parent._searchMarker, index, content.length);
    }
    return typeListInsertGenericsAfter(transaction, parent, null, content);
  }
  const startIndex = index;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
    if (index === 0) {
      n = n.prev;
      index += n && n.countable && !n.deleted ? n.length : 0;
    }
  }
  for (; n !== null; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index <= n.length) {
        if (index < n.length) {
          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
        }
        break;
      }
      index -= n.length;
    }
  }
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, startIndex, content.length);
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListPushGenerics = (transaction, parent, content) => {
  const marker = (parent._searchMarker || []).reduce((maxMarker, currMarker) => currMarker.index > maxMarker.index ? currMarker : maxMarker, { index: 0, p: parent._start });
  let n = marker.p;
  if (n) {
    while (n.right) {
      n = n.right;
    }
  }
  return typeListInsertGenericsAfter(transaction, parent, n, content);
};
var typeListDelete = (transaction, parent, index, length3) => {
  if (length3 === 0) {
    return;
  }
  const startIndex = index;
  const startLength = length3;
  const marker = findMarker(parent, index);
  let n = parent._start;
  if (marker !== null) {
    n = marker.p;
    index -= marker.index;
  }
  for (; n !== null && index > 0; n = n.right) {
    if (!n.deleted && n.countable) {
      if (index < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index));
      }
      index -= n.length;
    }
  }
  while (length3 > 0 && n !== null) {
    if (!n.deleted) {
      if (length3 < n.length) {
        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length3));
      }
      n.delete(transaction);
      length3 -= n.length;
    }
    n = n.right;
  }
  if (length3 > 0) {
    throw lengthExceeded();
  }
  if (parent._searchMarker) {
    updateMarkerChanges(
      parent._searchMarker,
      startIndex,
      -startLength + length3
      /* in case we remove the above exception */
    );
  }
};
var typeMapDelete = (transaction, parent, key) => {
  const c = parent._map.get(key);
  if (c !== void 0) {
    c.delete(transaction);
  }
};
var typeMapSet = (transaction, parent, key, value) => {
  const left = parent._map.get(key) || null;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  let content;
  if (value == null) {
    content = new ContentAny([value]);
  } else {
    switch (value.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        content = new ContentAny([value]);
        break;
      case Uint8Array:
        content = new ContentBinary(
          /** @type {Uint8Array} */
          value
        );
        break;
      case Doc:
        content = new ContentDoc(
          /** @type {Doc} */
          value
        );
        break;
      default:
        if (value instanceof AbstractType) {
          content = new ContentType(value);
        } else {
          throw new Error("Unexpected content type");
        }
    }
  }
  new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
};
var typeMapGet = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted ? val.content.getContent()[val.length - 1] : void 0;
};
var typeMapGetAll = (parent) => {
  const res = {};
  parent._map.forEach((value, key) => {
    if (!value.deleted) {
      res[key] = value.content.getContent()[value.length - 1];
    }
  });
  return res;
};
var typeMapHas = (parent, key) => {
  const val = parent._map.get(key);
  return val !== void 0 && !val.deleted;
};
var typeMapGetAllSnapshot = (parent, snapshot) => {
  const res = {};
  parent._map.forEach((value, key) => {
    let v = value;
    while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
      v = v.left;
    }
    if (v !== null && isVisible(v, snapshot)) {
      res[key] = v.content.getContent()[v.length - 1];
    }
  });
  return res;
};
var createMapIterator = (map2) => iteratorFilter(
  map2.entries(),
  /** @param {any} entry */
  (entry) => !entry[1].deleted
);
var YArrayEvent = class extends YEvent {
};
var YArray = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
    this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(items) {
    const a = new YArray();
    a.push(items);
    return a;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new YArray();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const arr = new YArray();
    arr.insert(0, this.toArray().map(
      (el) => el instanceof AbstractType ? (
        /** @type {typeof el} */
        el.clone()
      ) : el
    ));
    return arr;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    callTypeObservers(this, transaction, new YArrayEvent(this, transaction));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(
          transaction,
          this,
          index,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListPushGenerics(
          transaction,
          this,
          /** @type {any} */
          content
        );
      });
    } else {
      this._prelimContent.push(...content);
    }
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((c) => c instanceof AbstractType ? c.toJSON() : c);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(f) {
    return typeListMap(
      this,
      /** @type {any} */
      f
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return typeListCreateIterator(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YArrayRefID);
  }
};
var readYArray = (_decoder) => new YArray();
var YMapEvent = class extends YEvent {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(ymap, transaction, subs) {
    super(ymap, transaction);
    this.keysChanged = subs;
  }
};
var YMap = class extends AbstractType {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(entries) {
    super();
    this._prelimContent = null;
    if (entries === void 0) {
      this._prelimContent = /* @__PURE__ */ new Map();
    } else {
      this._prelimContent = new Map(entries);
    }
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this._prelimContent.forEach((value, key) => {
      this.set(key, value);
    });
    this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new YMap();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const map2 = new YMap();
    this.forEach((value, key) => {
      map2.set(key, value instanceof AbstractType ? (
        /** @type {typeof value} */
        value.clone()
      ) : value);
    });
    return map2;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const map2 = {};
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        const v = item.content.getContent()[item.length - 1];
        map2[key] = v instanceof AbstractType ? v.toJSON() : v;
      }
    });
    return map2;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...createMapIterator(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => v[1].content.getContent()[v[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return iteratorMap(
      createMapIterator(this._map),
      /** @param {any} v */
      (v) => (
        /** @type {any} */
        [v[0], v[1].content.getContent()[v[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    this._map.forEach((item, key) => {
      if (!item.deleted) {
        f(item.content.getContent()[item.length - 1], key, this);
      }
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(key) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, key);
      });
    } else {
      this._prelimContent.delete(key);
    }
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(key, value) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(
          transaction,
          this,
          key,
          /** @type {any} */
          value
        );
      });
    } else {
      this._prelimContent.set(key, value);
    }
    return value;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(key) {
    return (
      /** @type {any} */
      typeMapGet(this, key)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(key) {
    return typeMapHas(this, key);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        this.forEach(function(_value, key, map2) {
          typeMapDelete(transaction, map2, key);
        });
      });
    } else {
      this._prelimContent.clear();
    }
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YMapRefID);
  }
};
var readYMap = (_decoder) => new YMap();
var equalAttrs = (a, b) => a === b || typeof a === "object" && typeof b === "object" && a && b && equalFlat(a, b);
var ItemTextListPosition = class {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(left, right, index, currentAttributes) {
    this.left = left;
    this.right = right;
    this.index = index;
    this.currentAttributes = currentAttributes;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    if (this.right === null) {
      unexpectedCase();
    }
    switch (this.right.content.constructor) {
      case ContentFormat:
        if (!this.right.deleted) {
          updateCurrentAttributes(
            this.currentAttributes,
            /** @type {ContentFormat} */
            this.right.content
          );
        }
        break;
      default:
        if (!this.right.deleted) {
          this.index += this.right.length;
        }
        break;
    }
    this.left = this.right;
    this.right = this.right.right;
  }
};
var findNextPosition = (transaction, pos, count2) => {
  while (pos.right !== null && count2 > 0) {
    switch (pos.right.content.constructor) {
      case ContentFormat:
        if (!pos.right.deleted) {
          updateCurrentAttributes(
            pos.currentAttributes,
            /** @type {ContentFormat} */
            pos.right.content
          );
        }
        break;
      default:
        if (!pos.right.deleted) {
          if (count2 < pos.right.length) {
            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count2));
          }
          pos.index += pos.right.length;
          count2 -= pos.right.length;
        }
        break;
    }
    pos.left = pos.right;
    pos.right = pos.right.right;
  }
  return pos;
};
var findPosition = (transaction, parent, index, useSearchMarker) => {
  const currentAttributes = /* @__PURE__ */ new Map();
  const marker = useSearchMarker ? findMarker(parent, index) : null;
  if (marker) {
    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
    return findNextPosition(transaction, pos, index - marker.index);
  } else {
    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
    return findNextPosition(transaction, pos, index);
  }
};
var insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {
  while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === ContentFormat && equalAttrs(
    negatedAttributes.get(
      /** @type {ContentFormat} */
      currPos.right.content.key
    ),
    /** @type {ContentFormat} */
    currPos.right.content.value
  ))) {
    if (!currPos.right.deleted) {
      negatedAttributes.delete(
        /** @type {ContentFormat} */
        currPos.right.content.key
      );
    }
    currPos.forward();
  }
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  negatedAttributes.forEach((val, key) => {
    const left = currPos.left;
    const right = currPos.right;
    const nextFormat = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
    nextFormat.integrate(transaction, 0);
    currPos.right = nextFormat;
    currPos.forward();
  });
};
var updateCurrentAttributes = (currentAttributes, format) => {
  const { key, value } = format;
  if (value === null) {
    currentAttributes.delete(key);
  } else {
    currentAttributes.set(key, value);
  }
};
var minimizeAttributeChanges = (currPos, attributes) => {
  var _a;
  while (true) {
    if (currPos.right === null) {
      break;
    } else if (currPos.right.deleted || currPos.right.content.constructor === ContentFormat && equalAttrs(
      (_a = attributes[
        /** @type {ContentFormat} */
        currPos.right.content.key
      ]) != null ? _a : null,
      /** @type {ContentFormat} */
      currPos.right.content.value
    ))
      ;
    else {
      break;
    }
    currPos.forward();
  }
};
var insertAttributes = (transaction, parent, currPos, attributes) => {
  var _a;
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  const negatedAttributes = /* @__PURE__ */ new Map();
  for (const key in attributes) {
    const val = attributes[key];
    const currentVal = (_a = currPos.currentAttributes.get(key)) != null ? _a : null;
    if (!equalAttrs(currentVal, val)) {
      negatedAttributes.set(key, currentVal);
      const { left, right } = currPos;
      currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val));
      currPos.right.integrate(transaction, 0);
      currPos.forward();
    }
  }
  return negatedAttributes;
};
var insertText = (transaction, parent, currPos, text2, attributes) => {
  currPos.currentAttributes.forEach((_val, key) => {
    if (attributes[key] === void 0) {
      attributes[key] = null;
    }
  });
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  const content = text2.constructor === String ? new ContentString(
    /** @type {string} */
    text2
  ) : text2 instanceof AbstractType ? new ContentType(text2) : new ContentEmbed(text2);
  let { left, right, index } = currPos;
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
  }
  right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
  right.integrate(transaction, 0);
  currPos.right = right;
  currPos.index = index;
  currPos.forward();
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var formatText = (transaction, parent, currPos, length3, attributes) => {
  const doc2 = transaction.doc;
  const ownClientId = doc2.clientID;
  minimizeAttributeChanges(currPos, attributes);
  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
  iterationLoop:
    while (currPos.right !== null && (length3 > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === ContentFormat))) {
      if (!currPos.right.deleted) {
        switch (currPos.right.content.constructor) {
          case ContentFormat: {
            const { key, value } = (
              /** @type {ContentFormat} */
              currPos.right.content
            );
            const attr = attributes[key];
            if (attr !== void 0) {
              if (equalAttrs(attr, value)) {
                negatedAttributes.delete(key);
              } else {
                if (length3 === 0) {
                  break iterationLoop;
                }
                negatedAttributes.set(key, value);
              }
              currPos.right.delete(transaction);
            } else {
              currPos.currentAttributes.set(key, value);
            }
            break;
          }
          default:
            if (length3 < currPos.right.length) {
              getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
            }
            length3 -= currPos.right.length;
            break;
        }
      }
      currPos.forward();
    }
  if (length3 > 0) {
    let newlines = "";
    for (; length3 > 0; length3--) {
      newlines += "\n";
    }
    currPos.right = new Item(createID(ownClientId, getState(doc2.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines));
    currPos.right.integrate(transaction, 0);
    currPos.forward();
  }
  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
};
var cleanupFormattingGap = (transaction, start, curr, startAttributes, currAttributes) => {
  var _a, _b;
  let end = start;
  const endFormats = create();
  while (end && (!end.countable || end.deleted)) {
    if (!end.deleted && end.content.constructor === ContentFormat) {
      const cf = (
        /** @type {ContentFormat} */
        end.content
      );
      endFormats.set(cf.key, cf);
    }
    end = end.right;
  }
  let cleanups = 0;
  let reachedCurr = false;
  while (start !== end) {
    if (curr === start) {
      reachedCurr = true;
    }
    if (!start.deleted) {
      const content = start.content;
      switch (content.constructor) {
        case ContentFormat: {
          const { key, value } = (
            /** @type {ContentFormat} */
            content
          );
          const startAttrValue = (_a = startAttributes.get(key)) != null ? _a : null;
          if (endFormats.get(key) !== content || startAttrValue === value) {
            start.delete(transaction);
            cleanups++;
            if (!reachedCurr && ((_b = currAttributes.get(key)) != null ? _b : null) === value && startAttrValue !== value) {
              if (startAttrValue === null) {
                currAttributes.delete(key);
              } else {
                currAttributes.set(key, startAttrValue);
              }
            }
          }
          if (!reachedCurr && !start.deleted) {
            updateCurrentAttributes(
              currAttributes,
              /** @type {ContentFormat} */
              content
            );
          }
          break;
        }
      }
    }
    start = /** @type {Item} */
    start.right;
  }
  return cleanups;
};
var cleanupContextlessFormattingGap = (transaction, item) => {
  while (item && item.right && (item.right.deleted || !item.right.countable)) {
    item = item.right;
  }
  const attrs = /* @__PURE__ */ new Set();
  while (item && (item.deleted || !item.countable)) {
    if (!item.deleted && item.content.constructor === ContentFormat) {
      const key = (
        /** @type {ContentFormat} */
        item.content.key
      );
      if (attrs.has(key)) {
        item.delete(transaction);
      } else {
        attrs.add(key);
      }
    }
    item = item.left;
  }
};
var cleanupYTextFormatting = (type2) => {
  let res = 0;
  transact(
    /** @type {Doc} */
    type2.doc,
    (transaction) => {
      let start = (
        /** @type {Item} */
        type2._start
      );
      let end = type2._start;
      let startAttributes = create();
      const currentAttributes = copy(startAttributes);
      while (end) {
        if (end.deleted === false) {
          switch (end.content.constructor) {
            case ContentFormat:
              updateCurrentAttributes(
                currentAttributes,
                /** @type {ContentFormat} */
                end.content
              );
              break;
            default:
              res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
              startAttributes = copy(currentAttributes);
              start = end;
              break;
          }
        }
        end = end.right;
      }
    }
  );
  return res;
};
var cleanupYTextAfterTransaction = (transaction) => {
  const needFullCleanup = /* @__PURE__ */ new Set();
  const doc2 = transaction.doc;
  for (const [client, afterClock] of transaction.afterState.entries()) {
    const clock = transaction.beforeState.get(client) || 0;
    if (afterClock === clock) {
      continue;
    }
    iterateStructs(
      transaction,
      /** @type {Array<Item|GC>} */
      doc2.store.clients.get(client),
      clock,
      afterClock,
      (item) => {
        if (!item.deleted && /** @type {Item} */
        item.content.constructor === ContentFormat && item.constructor !== GC) {
          needFullCleanup.add(
            /** @type {any} */
            item.parent
          );
        }
      }
    );
  }
  transact(doc2, (t) => {
    iterateDeletedStructs(transaction, transaction.deleteSet, (item) => {
      if (item instanceof GC || !/** @type {YText} */
      item.parent._hasFormatting || needFullCleanup.has(
        /** @type {YText} */
        item.parent
      )) {
        return;
      }
      const parent = (
        /** @type {YText} */
        item.parent
      );
      if (item.content.constructor === ContentFormat) {
        needFullCleanup.add(parent);
      } else {
        cleanupContextlessFormattingGap(t, item);
      }
    });
    for (const yText of needFullCleanup) {
      cleanupYTextFormatting(yText);
    }
  });
};
var deleteText = (transaction, currPos, length3) => {
  const startLength = length3;
  const startAttrs = copy(currPos.currentAttributes);
  const start = currPos.right;
  while (length3 > 0 && currPos.right !== null) {
    if (currPos.right.deleted === false) {
      switch (currPos.right.content.constructor) {
        case ContentType:
        case ContentEmbed:
        case ContentString:
          if (length3 < currPos.right.length) {
            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length3));
          }
          length3 -= currPos.right.length;
          currPos.right.delete(transaction);
          break;
      }
    }
    currPos.forward();
  }
  if (start) {
    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
  }
  const parent = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (currPos.left || currPos.right).parent
  );
  if (parent._searchMarker) {
    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length3);
  }
  return currPos;
};
var YTextEvent = class extends YEvent {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(ytext, transaction, subs) {
    super(ytext, transaction);
    this.childListChanged = false;
    this.keysChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.keysChanged.add(sub);
      }
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const changes = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = changes;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const y = (
        /** @type {Doc} */
        this.target.doc
      );
      const delta = [];
      transact(y, (transaction) => {
        var _a, _b, _c;
        const currentAttributes = /* @__PURE__ */ new Map();
        const oldAttributes = /* @__PURE__ */ new Map();
        let item = this.target._start;
        let action = null;
        const attributes = {};
        let insert = "";
        let retain = 0;
        let deleteLen = 0;
        const addOp = () => {
          if (action !== null) {
            let op = null;
            switch (action) {
              case "delete":
                if (deleteLen > 0) {
                  op = { delete: deleteLen };
                }
                deleteLen = 0;
                break;
              case "insert":
                if (typeof insert === "object" || insert.length > 0) {
                  op = { insert };
                  if (currentAttributes.size > 0) {
                    op.attributes = {};
                    currentAttributes.forEach((value, key) => {
                      if (value !== null) {
                        op.attributes[key] = value;
                      }
                    });
                  }
                }
                insert = "";
                break;
              case "retain":
                if (retain > 0) {
                  op = { retain };
                  if (!isEmpty(attributes)) {
                    op.attributes = assign({}, attributes);
                  }
                }
                retain = 0;
                break;
            }
            if (op)
              delta.push(op);
            action = null;
          }
        };
        while (item !== null) {
          switch (item.content.constructor) {
            case ContentType:
            case ContentEmbed:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  addOp();
                  action = "insert";
                  insert = item.content.getContent()[0];
                  addOp();
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += 1;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += 1;
              }
              break;
            case ContentString:
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  if (action !== "insert") {
                    addOp();
                    action = "insert";
                  }
                  insert += /** @type {ContentString} */
                  item.content.str;
                }
              } else if (this.deletes(item)) {
                if (action !== "delete") {
                  addOp();
                  action = "delete";
                }
                deleteLen += item.length;
              } else if (!item.deleted) {
                if (action !== "retain") {
                  addOp();
                  action = "retain";
                }
                retain += item.length;
              }
              break;
            case ContentFormat: {
              const { key, value } = (
                /** @type {ContentFormat} */
                item.content
              );
              if (this.adds(item)) {
                if (!this.deletes(item)) {
                  const curVal = (_a = currentAttributes.get(key)) != null ? _a : null;
                  if (!equalAttrs(curVal, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (equalAttrs(value, (_b = oldAttributes.get(key)) != null ? _b : null)) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (value !== null) {
                    item.delete(transaction);
                  }
                }
              } else if (this.deletes(item)) {
                oldAttributes.set(key, value);
                const curVal = (_c = currentAttributes.get(key)) != null ? _c : null;
                if (!equalAttrs(curVal, value)) {
                  if (action === "retain") {
                    addOp();
                  }
                  attributes[key] = curVal;
                }
              } else if (!item.deleted) {
                oldAttributes.set(key, value);
                const attr = attributes[key];
                if (attr !== void 0) {
                  if (!equalAttrs(attr, value)) {
                    if (action === "retain") {
                      addOp();
                    }
                    if (value === null) {
                      delete attributes[key];
                    } else {
                      attributes[key] = value;
                    }
                  } else if (attr !== null) {
                    item.delete(transaction);
                  }
                }
              }
              if (!item.deleted) {
                if (action === "insert") {
                  addOp();
                }
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  item.content
                );
              }
              break;
            }
          }
          item = item.right;
        }
        addOp();
        while (delta.length > 0) {
          const lastOp = delta[delta.length - 1];
          if (lastOp.retain !== void 0 && lastOp.attributes === void 0) {
            delta.pop();
          } else {
            break;
          }
        }
      });
      this._delta = delta;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
};
var YText = class extends AbstractType {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(string) {
    super();
    this._pending = string !== void 0 ? [() => this.insert(0, string)] : [];
    this._searchMarker = [];
    this._hasFormatting = false;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    try {
      this._pending.forEach((f) => f());
    } catch (e) {
      console.error(e);
    }
    this._pending = null;
  }
  _copy() {
    return new YText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const text2 = new YText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    super._callObserver(transaction, parentSubs);
    const event = new YTextEvent(this, transaction, parentSubs);
    callTypeObservers(this, transaction, event);
    if (!transaction.local && this._hasFormatting) {
      transaction._needFormattingCleanup = true;
    }
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let str = "";
    let n = this._start;
    while (n !== null) {
      if (!n.deleted && n.countable && n.content.constructor === ContentString) {
        str += /** @type {ContentString} */
        n.content.str;
      }
      n = n.right;
    }
    return str;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(delta, { sanitize = true } = {}) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const currPos = new ItemTextListPosition(null, this._start, 0, /* @__PURE__ */ new Map());
        for (let i = 0; i < delta.length; i++) {
          const op = delta[i];
          if (op.insert !== void 0) {
            const ins = !sanitize && typeof op.insert === "string" && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === "\n" ? op.insert.slice(0, -1) : op.insert;
            if (typeof ins !== "string" || ins.length > 0) {
              insertText(transaction, this, currPos, ins, op.attributes || {});
            }
          } else if (op.retain !== void 0) {
            formatText(transaction, this, currPos, op.retain, op.attributes || {});
          } else if (op.delete !== void 0) {
            deleteText(transaction, currPos, op.delete);
          }
        }
      });
    } else {
      this._pending.push(() => this.applyDelta(delta));
    }
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(snapshot, prevSnapshot, computeYChange) {
    const ops = [];
    const currentAttributes = /* @__PURE__ */ new Map();
    const doc2 = (
      /** @type {Doc} */
      this.doc
    );
    let str = "";
    let n = this._start;
    function packStr() {
      if (str.length > 0) {
        const attributes = {};
        let addAttributes = false;
        currentAttributes.forEach((value, key) => {
          addAttributes = true;
          attributes[key] = value;
        });
        const op = { insert: str };
        if (addAttributes) {
          op.attributes = attributes;
        }
        ops.push(op);
        str = "";
      }
    }
    const computeDelta = () => {
      while (n !== null) {
        if (isVisible(n, snapshot) || prevSnapshot !== void 0 && isVisible(n, prevSnapshot)) {
          switch (n.content.constructor) {
            case ContentString: {
              const cur = currentAttributes.get("ychange");
              if (snapshot !== void 0 && !isVisible(n, snapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "removed") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("removed", n.id) : { type: "removed" });
                }
              } else if (prevSnapshot !== void 0 && !isVisible(n, prevSnapshot)) {
                if (cur === void 0 || cur.user !== n.id.client || cur.type !== "added") {
                  packStr();
                  currentAttributes.set("ychange", computeYChange ? computeYChange("added", n.id) : { type: "added" });
                }
              } else if (cur !== void 0) {
                packStr();
                currentAttributes.delete("ychange");
              }
              str += /** @type {ContentString} */
              n.content.str;
              break;
            }
            case ContentType:
            case ContentEmbed: {
              packStr();
              const op = {
                insert: n.content.getContent()[0]
              };
              if (currentAttributes.size > 0) {
                const attrs = (
                  /** @type {Object<string,any>} */
                  {}
                );
                op.attributes = attrs;
                currentAttributes.forEach((value, key) => {
                  attrs[key] = value;
                });
              }
              ops.push(op);
              break;
            }
            case ContentFormat:
              if (isVisible(n, snapshot)) {
                packStr();
                updateCurrentAttributes(
                  currentAttributes,
                  /** @type {ContentFormat} */
                  n.content
                );
              }
              break;
          }
        }
        n = n.right;
      }
      packStr();
    };
    if (snapshot || prevSnapshot) {
      transact(doc2, (transaction) => {
        if (snapshot) {
          splitSnapshotAffectedStructs(transaction, snapshot);
        }
        if (prevSnapshot) {
          splitSnapshotAffectedStructs(transaction, prevSnapshot);
        }
        computeDelta();
      }, "cleanup");
    } else {
      computeDelta();
    }
    return ops;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(index, text2, attributes) {
    if (text2.length <= 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        if (!attributes) {
          attributes = {};
          pos.currentAttributes.forEach((v, k) => {
            attributes[k] = v;
          });
        }
        insertText(transaction, this, pos, text2, attributes);
      });
    } else {
      this._pending.push(() => this.insert(index, text2, attributes));
    }
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(index, embed, attributes) {
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, !attributes);
        insertText(transaction, this, pos, embed, attributes || {});
      });
    } else {
      this._pending.push(() => this.insertEmbed(index, embed, attributes || {}));
    }
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(index, length3) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        deleteText(transaction, findPosition(transaction, this, index, true), length3);
      });
    } else {
      this._pending.push(() => this.delete(index, length3));
    }
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(index, length3, attributes) {
    if (length3 === 0) {
      return;
    }
    const y = this.doc;
    if (y !== null) {
      transact(y, (transaction) => {
        const pos = findPosition(transaction, this, index, false);
        if (pos.right === null) {
          return;
        }
        formatText(transaction, this, pos, length3, attributes);
      });
    } else {
      this._pending.push(() => this.format(index, length3, attributes));
    }
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._pending.push(() => this.removeAttribute(attributeName));
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._pending.push(() => this.setAttribute(attributeName, attributeValue));
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return typeMapGetAll(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YTextRefID);
  }
};
var readYText = (_decoder) => new YText();
var YXmlTreeWalker = class {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(root, f = () => true) {
    this._filter = f;
    this._root = root;
    this._currentNode = /** @type {Item} */
    root._start;
    this._firstCall = true;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let n = this._currentNode;
    let type2 = n && n.content && /** @type {any} */
    n.content.type;
    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type2))) {
      do {
        type2 = /** @type {any} */
        n.content.type;
        if (!n.deleted && (type2.constructor === YXmlElement || type2.constructor === YXmlFragment) && type2._start !== null) {
          n = type2._start;
        } else {
          while (n !== null) {
            if (n.right !== null) {
              n = n.right;
              break;
            } else if (n.parent === this._root) {
              n = null;
            } else {
              n = /** @type {AbstractType<any>} */
              n.parent._item;
            }
          }
        }
      } while (n !== null && (n.deleted || !this._filter(
        /** @type {ContentType} */
        n.content.type
      )));
    }
    this._firstCall = false;
    if (n === null) {
      return { value: void 0, done: true };
    }
    this._currentNode = n;
    return { value: (
      /** @type {any} */
      n.content.type
    ), done: false };
  }
};
var YXmlFragment = class extends AbstractType {
  constructor() {
    super();
    this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const first = this._first;
    return first ? first.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    );
    this._prelimContent = null;
  }
  _copy() {
    return new YXmlFragment();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const el = new YXmlFragment();
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(filter) {
    return new YXmlTreeWalker(this, filter);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(query) {
    query = query.toUpperCase();
    const iterator = new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query);
    const next = iterator.next();
    if (next.done) {
      return null;
    } else {
      return next.value;
    }
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(query) {
    query = query.toUpperCase();
    return from(new YXmlTreeWalker(this, (element2) => element2.nodeName && element2.nodeName.toUpperCase() === query));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(transaction, parentSubs) {
    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return typeListMap(this, (xml) => xml.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const fragment2 = _document.createDocumentFragment();
    if (binding !== void 0) {
      binding._createAssociation(fragment2, this);
    }
    typeListForEach(this, (xmlType) => {
      fragment2.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
    });
    return fragment2;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(index, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListInsertGenerics(transaction, this, index, content);
      });
    } else {
      this._prelimContent.splice(index, 0, ...content);
    }
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(ref, content) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        const refItem = ref && ref instanceof AbstractType ? ref._item : ref;
        typeListInsertGenericsAfter(transaction, this, refItem, content);
      });
    } else {
      const pc = (
        /** @type {Array<any>} */
        this._prelimContent
      );
      const index = ref === null ? 0 : pc.findIndex((el) => el === ref) + 1;
      if (index === 0 && ref !== null) {
        throw create3("Reference item not found");
      }
      pc.splice(index, 0, ...content);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(index, length3 = 1) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeListDelete(transaction, this, index, length3);
      });
    } else {
      this._prelimContent.splice(index, length3);
    }
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return typeListToArray(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(content) {
    this.insert(this.length, content);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(content) {
    this.insert(0, content);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(index) {
    return typeListGet(this, index);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(start = 0, end = this.length) {
    return typeListSlice(this, start, end);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(f) {
    typeListForEach(this, f);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlFragmentRefID);
  }
};
var readYXmlFragment = (_decoder) => new YXmlFragment();
var YXmlElement = class extends YXmlFragment {
  constructor(nodeName = "UNDEFINED") {
    super();
    this.nodeName = nodeName;
    this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(y, item) {
    super._integrate(y, item);
    /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((value, key) => {
      this.setAttribute(key, value);
    });
    this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new YXmlElement(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const el = new YXmlElement(this.nodeName);
    const attrs = this.getAttributes();
    forEach(attrs, (value, key) => {
      if (typeof value === "string") {
        el.setAttribute(key, value);
      }
    });
    el.insert(0, this.toArray().map((item) => item instanceof AbstractType ? item.clone() : item));
    return el;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const attrs = this.getAttributes();
    const stringBuilder = [];
    const keys3 = [];
    for (const key in attrs) {
      keys3.push(key);
    }
    keys3.sort();
    const keysLen = keys3.length;
    for (let i = 0; i < keysLen; i++) {
      const key = keys3[i];
      stringBuilder.push(key + '="' + attrs[key] + '"');
    }
    const nodeName = this.nodeName.toLocaleLowerCase();
    const attrsString = stringBuilder.length > 0 ? " " + stringBuilder.join(" ") : "";
    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`;
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(attributeName) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapDelete(transaction, this, attributeName);
      });
    } else {
      this._prelimAttrs.delete(attributeName);
    }
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(attributeName, attributeValue) {
    if (this.doc !== null) {
      transact(this.doc, (transaction) => {
        typeMapSet(transaction, this, attributeName, attributeValue);
      });
    } else {
      this._prelimAttrs.set(attributeName, attributeValue);
    }
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapGet(this, attributeName)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(attributeName) {
    return (
      /** @type {any} */
      typeMapHas(this, attributeName)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(snapshot) {
    return (
      /** @type {any} */
      snapshot ? typeMapGetAllSnapshot(this, snapshot) : typeMapGetAll(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const dom = _document.createElement(this.nodeName);
    const attrs = this.getAttributes();
    for (const key in attrs) {
      const value = attrs[key];
      if (typeof value === "string") {
        dom.setAttribute(key, value);
      }
    }
    typeListForEach(this, (yxml) => {
      dom.appendChild(yxml.toDOM(_document, hooks, binding));
    });
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlElementRefID);
    encoder.writeKey(this.nodeName);
  }
};
var readYXmlElement = (decoder) => new YXmlElement(decoder.readKey());
var YXmlEvent = class extends YEvent {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(target, subs, transaction) {
    super(target, transaction);
    this.childListChanged = false;
    this.attributesChanged = /* @__PURE__ */ new Set();
    subs.forEach((sub) => {
      if (sub === null) {
        this.childListChanged = true;
      } else {
        this.attributesChanged.add(sub);
      }
    });
  }
};
var YXmlHook = class extends YMap {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(hookName) {
    super();
    this.hookName = hookName;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new YXmlHook(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const el = new YXmlHook(this.hookName);
    this.forEach((value, key) => {
      el.set(key, value);
    });
    return el;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks = {}, binding) {
    const hook = hooks[this.hookName];
    let dom;
    if (hook !== void 0) {
      dom = hook.createDom(this);
    } else {
      dom = document.createElement(this.hookName);
    }
    dom.setAttribute("data-yjs-hook", this.hookName);
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlHookRefID);
    encoder.writeKey(this.hookName);
  }
};
var readYXmlHook = (decoder) => new YXmlHook(decoder.readKey());
var YXmlText = class extends YText {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const n = this._item ? this._item.next : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const n = this._item ? this._item.prev : null;
    return n ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      n.content.type
    ) : null;
  }
  _copy() {
    return new YXmlText();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const text2 = new YXmlText();
    text2.applyDelta(this.toDelta());
    return text2;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(_document = document, hooks, binding) {
    const dom = _document.createTextNode(this.toString());
    if (binding !== void 0) {
      binding._createAssociation(dom, this);
    }
    return dom;
  }
  toString() {
    return this.toDelta().map((delta) => {
      const nestedNodes = [];
      for (const nodeName in delta.attributes) {
        const attrs = [];
        for (const key in delta.attributes[nodeName]) {
          attrs.push({ key, value: delta.attributes[nodeName][key] });
        }
        attrs.sort((a, b) => a.key < b.key ? -1 : 1);
        nestedNodes.push({ nodeName, attrs });
      }
      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1);
      let str = "";
      for (let i = 0; i < nestedNodes.length; i++) {
        const node = nestedNodes[i];
        str += `<${node.nodeName}`;
        for (let j = 0; j < node.attrs.length; j++) {
          const attr = node.attrs[j];
          str += ` ${attr.key}="${attr.value}"`;
        }
        str += ">";
      }
      str += delta.insert;
      for (let i = nestedNodes.length - 1; i >= 0; i--) {
        str += `</${nestedNodes[i].nodeName}>`;
      }
      return str;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(encoder) {
    encoder.writeTypeRef(YXmlTextRefID);
  }
};
var readYXmlText = (decoder) => new YXmlText();
var AbstractStruct = class {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(id2, length3) {
    this.id = id2;
    this.length = length3;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw methodUnimplemented();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(encoder, offset, encodingRef) {
    throw methodUnimplemented();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    throw methodUnimplemented();
  }
};
var structGCRefNumber = 0;
var GC = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.length -= offset;
    }
    addStruct(transaction.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structGCRefNumber);
    encoder.writeLen(this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var ContentBinary = class {
  /**
   * @param {Uint8Array} content
   */
  constructor(content) {
    this.content = content;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ContentBinary(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
};
var readContentBinary = (decoder) => new ContentBinary(decoder.readBuf());
var ContentDeleted = class {
  /**
   * @param {number} len
   */
  constructor(len) {
    this.len = len;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new ContentDeleted(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(offset) {
    const right = new ContentDeleted(this.len - offset);
    this.len = offset;
    return right;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.len += right.len;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
    item.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeLen(this.len - offset);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
};
var readContentDeleted = (decoder) => new ContentDeleted(decoder.readLen());
var createDocFromOpts = (guid, opts) => new Doc({ guid, ...opts, shouldLoad: opts.shouldLoad || opts.autoLoad || false });
var ContentDoc = class {
  /**
   * @param {Doc} doc
   */
  constructor(doc2) {
    if (doc2._item) {
      console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid.");
    }
    this.doc = doc2;
    const opts = {};
    this.opts = opts;
    if (!doc2.gc) {
      opts.gc = false;
    }
    if (doc2.autoLoad) {
      opts.autoLoad = true;
    }
    if (doc2.meta !== null) {
      opts.meta = doc2.meta;
    }
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.doc._item = item;
    transaction.subdocsAdded.add(this.doc);
    if (this.doc.shouldLoad) {
      transaction.subdocsLoaded.add(this.doc);
    }
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (transaction.subdocsAdded.has(this.doc)) {
      transaction.subdocsAdded.delete(this.doc);
    } else {
      transaction.subdocsRemoved.add(this.doc);
    }
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(this.doc.guid);
    encoder.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
};
var readContentDoc = (decoder) => new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
var ContentEmbed = class {
  /**
   * @param {Object} embed
   */
  constructor(embed) {
    this.embed = embed;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ContentEmbed(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
};
var readContentEmbed = (decoder) => new ContentEmbed(decoder.readJSON());
var ContentFormat = class {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(key, value) {
    this.key = key;
    this.value = value;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return false;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new ContentFormat(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(_offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(_right) {
    return false;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(_transaction, item) {
    const p = (
      /** @type {YText} */
      item.parent
    );
    p._searchMarker = null;
    p._hasFormatting = true;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeKey(this.key);
    encoder.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
};
var readContentFormat = (decoder) => new ContentFormat(decoder.readKey(), decoder.readJSON());
var ContentJSON = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new ContentJSON(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(offset) {
    const right = new ContentJSON(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeString(c === void 0 ? "undefined" : JSON.stringify(c));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
};
var readContentJSON = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    const c = decoder.readString();
    if (c === "undefined") {
      cs.push(void 0);
    } else {
      cs.push(JSON.parse(c));
    }
  }
  return new ContentJSON(cs);
};
var ContentAny = class {
  /**
   * @param {Array<any>} arr
   */
  constructor(arr) {
    this.arr = arr;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ContentAny(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(offset) {
    const right = new ContentAny(this.arr.slice(offset));
    this.arr = this.arr.slice(0, offset);
    return right;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.arr = this.arr.concat(right.arr);
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    const len = this.arr.length;
    encoder.writeLen(len - offset);
    for (let i = offset; i < len; i++) {
      const c = this.arr[i];
      encoder.writeAny(c);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
};
var readContentAny = (decoder) => {
  const len = decoder.readLen();
  const cs = [];
  for (let i = 0; i < len; i++) {
    cs.push(decoder.readAny());
  }
  return new ContentAny(cs);
};
var ContentString = class {
  /**
   * @param {string} str
   */
  constructor(str) {
    this.str = str;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new ContentString(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(offset) {
    const right = new ContentString(this.str.slice(offset));
    this.str = this.str.slice(0, offset);
    const firstCharCode = this.str.charCodeAt(offset - 1);
    if (firstCharCode >= 55296 && firstCharCode <= 56319) {
      this.str = this.str.slice(0, offset - 1) + "\uFFFD";
      right.str = "\uFFFD" + right.str.slice(1);
    }
    return right;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(right) {
    this.str += right.str;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
};
var readContentString = (decoder) => new ContentString(decoder.readString());
var typeRefs = [
  readYArray,
  readYMap,
  readYText,
  readYXmlElement,
  readYXmlFragment,
  readYXmlHook,
  readYXmlText
];
var YArrayRefID = 0;
var YMapRefID = 1;
var YTextRefID = 2;
var YXmlElementRefID = 3;
var YXmlFragmentRefID = 4;
var YXmlHookRefID = 5;
var YXmlTextRefID = 6;
var ContentType = class {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(type2) {
    this.type = type2;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return true;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new ContentType(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(offset) {
    throw methodUnimplemented();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(right) {
    return false;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(transaction, item) {
    this.type._integrate(transaction.doc, item);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(transaction) {
    let item = this.type._start;
    while (item !== null) {
      if (!item.deleted) {
        item.delete(transaction);
      } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
        transaction._mergeStructs.push(item);
      }
      item = item.right;
    }
    this.type._map.forEach((item2) => {
      if (!item2.deleted) {
        item2.delete(transaction);
      } else if (item2.id.clock < (transaction.beforeState.get(item2.id.client) || 0)) {
        transaction._mergeStructs.push(item2);
      }
    });
    transaction.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(store) {
    let item = this.type._start;
    while (item !== null) {
      item.gc(store, true);
      item = item.right;
    }
    this.type._start = null;
    this.type._map.forEach(
      /** @param {Item | null} item */
      (item2) => {
        while (item2 !== null) {
          item2.gc(store, true);
          item2 = item2.left;
        }
      }
    );
    this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    this.type._write(encoder);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
};
var readContentType = (decoder) => new ContentType(typeRefs[decoder.readTypeRef()](decoder));
var followRedone = (store, id2) => {
  let nextID = id2;
  let diff = 0;
  let item;
  do {
    if (diff > 0) {
      nextID = createID(nextID.client, nextID.clock + diff);
    }
    item = getItem(store, nextID);
    diff = nextID.clock - item.id.clock;
    nextID = item.redone;
  } while (nextID !== null && item instanceof Item);
  return {
    item,
    diff
  };
};
var keepItem = (item, keep) => {
  while (item !== null && item.keep !== keep) {
    item.keep = keep;
    item = /** @type {AbstractType<any>} */
    item.parent._item;
  }
};
var splitItem = (transaction, leftItem, diff) => {
  const { client, clock } = leftItem.id;
  const rightItem = new Item(
    createID(client, clock + diff),
    leftItem,
    createID(client, clock + diff - 1),
    leftItem.right,
    leftItem.rightOrigin,
    leftItem.parent,
    leftItem.parentSub,
    leftItem.content.splice(diff)
  );
  if (leftItem.deleted) {
    rightItem.markDeleted();
  }
  if (leftItem.keep) {
    rightItem.keep = true;
  }
  if (leftItem.redone !== null) {
    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff);
  }
  leftItem.right = rightItem;
  if (rightItem.right !== null) {
    rightItem.right.left = rightItem;
  }
  transaction._mergeStructs.push(rightItem);
  if (rightItem.parentSub !== null && rightItem.right === null) {
    rightItem.parent._map.set(rightItem.parentSub, rightItem);
  }
  leftItem.length = diff;
  return rightItem;
};
var isDeletedByUndoStack = (stack, id2) => some(
  stack,
  /** @param {StackItem} s */
  (s) => isDeleted(s.deletions, id2)
);
var redoItem = (transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) => {
  const doc2 = transaction.doc;
  const store = doc2.store;
  const ownClientID = doc2.clientID;
  const redone = item.redone;
  if (redone !== null) {
    return getItemCleanStart(transaction, redone);
  }
  let parentItem = (
    /** @type {AbstractType<any>} */
    item.parent._item
  );
  let left = null;
  let right;
  if (parentItem !== null && parentItem.deleted === true) {
    if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
      return null;
    }
    while (parentItem.redone !== null) {
      parentItem = getItemCleanStart(transaction, parentItem.redone);
    }
  }
  const parentType = parentItem === null ? (
    /** @type {AbstractType<any>} */
    item.parent
  ) : (
    /** @type {ContentType} */
    parentItem.content.type
  );
  if (item.parentSub === null) {
    left = item.left;
    right = item;
    while (left !== null) {
      let leftTrace = left;
      while (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item !== parentItem) {
        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
      }
      if (leftTrace !== null && /** @type {AbstractType<any>} */
      leftTrace.parent._item === parentItem) {
        left = leftTrace;
        break;
      }
      left = left.left;
    }
    while (right !== null) {
      let rightTrace = right;
      while (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item !== parentItem) {
        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
      }
      if (rightTrace !== null && /** @type {AbstractType<any>} */
      rightTrace.parent._item === parentItem) {
        right = rightTrace;
        break;
      }
      right = right.right;
    }
  } else {
    right = null;
    if (item.right && !ignoreRemoteMapChanges) {
      left = item;
      while (left !== null && left.right !== null && (left.right.redone || isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
        left = left.right;
        while (left.redone)
          left = getItemCleanStart(transaction, left.redone);
      }
      if (left && left.right !== null) {
        return null;
      }
    } else {
      left = parentType._map.get(item.parentSub) || null;
    }
  }
  const nextClock = getState(store, ownClientID);
  const nextId = createID(ownClientID, nextClock);
  const redoneItem = new Item(
    nextId,
    left,
    left && left.lastId,
    right,
    right && right.id,
    parentType,
    item.parentSub,
    item.content.copy()
  );
  item.redone = nextId;
  keepItem(redoneItem, true);
  redoneItem.integrate(transaction, 0);
  return redoneItem;
};
var Item = class extends AbstractStruct {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(id2, left, origin, right, rightOrigin, parent, parentSub, content) {
    super(id2, content.getLength());
    this.origin = origin;
    this.left = left;
    this.right = right;
    this.rightOrigin = rightOrigin;
    this.parent = parent;
    this.parentSub = parentSub;
    this.redone = null;
    this.content = content;
    this.info = this.content.isCountable() ? BIT2 : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(isMarked) {
    if ((this.info & BIT4) > 0 !== isMarked) {
      this.info ^= BIT4;
    }
  }
  get marker() {
    return (this.info & BIT4) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & BIT1) > 0;
  }
  set keep(doKeep) {
    if (this.keep !== doKeep) {
      this.info ^= BIT1;
    }
  }
  get countable() {
    return (this.info & BIT2) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & BIT3) > 0;
  }
  set deleted(doDelete) {
    if (this.deleted !== doDelete) {
      this.info ^= BIT3;
    }
  }
  markDeleted() {
    this.info |= BIT3;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {
      return this.origin.client;
    }
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {
      return this.rightOrigin.client;
    }
    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {
      return this.parent.client;
    }
    if (this.origin) {
      this.left = getItemCleanEnd(transaction, store, this.origin);
      this.origin = this.left.lastId;
    }
    if (this.rightOrigin) {
      this.right = getItemCleanStart(transaction, this.rightOrigin);
      this.rightOrigin = this.right.id;
    }
    if (this.left && this.left.constructor === GC || this.right && this.right.constructor === GC) {
      this.parent = null;
    } else if (!this.parent) {
      if (this.left && this.left.constructor === Item) {
        this.parent = this.left.parent;
        this.parentSub = this.left.parentSub;
      }
      if (this.right && this.right.constructor === Item) {
        this.parent = this.right.parent;
        this.parentSub = this.right.parentSub;
      }
    } else if (this.parent.constructor === ID) {
      const parentItem = getItem(store, this.parent);
      if (parentItem.constructor === GC) {
        this.parent = null;
      } else {
        this.parent = /** @type {ContentType} */
        parentItem.content.type;
      }
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    if (offset > 0) {
      this.id.clock += offset;
      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1));
      this.origin = this.left.lastId;
      this.content = this.content.splice(offset);
      this.length -= offset;
    }
    if (this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let left = this.left;
        let o;
        if (left !== null) {
          o = left.right;
        } else if (this.parentSub !== null) {
          o = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (o !== null && o.left !== null) {
            o = o.left;
          }
        } else {
          o = /** @type {AbstractType<any>} */
          this.parent._start;
        }
        const conflictingItems = /* @__PURE__ */ new Set();
        const itemsBeforeOrigin = /* @__PURE__ */ new Set();
        while (o !== null && o !== this.right) {
          itemsBeforeOrigin.add(o);
          conflictingItems.add(o);
          if (compareIDs(this.origin, o.origin)) {
            if (o.id.client < this.id.client) {
              left = o;
              conflictingItems.clear();
            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {
              break;
            }
          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) {
            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {
              left = o;
              conflictingItems.clear();
            }
          } else {
            break;
          }
          o = o.right;
        }
        this.left = left;
      }
      if (this.left !== null) {
        const right = this.left.right;
        this.right = right;
        this.left.right = this;
      } else {
        let r;
        if (this.parentSub !== null) {
          r = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null;
          while (r !== null && r.left !== null) {
            r = r.left;
          }
        } else {
          r = /** @type {AbstractType<any>} */
          this.parent._start;
          this.parent._start = this;
        }
        this.right = r;
      }
      if (this.right !== null) {
        this.right.left = this;
      } else if (this.parentSub !== null) {
        this.parent._map.set(this.parentSub, this);
        if (this.left !== null) {
          this.left.delete(transaction);
        }
      }
      if (this.parentSub === null && this.countable && !this.deleted) {
        this.parent._length += this.length;
      }
      addStruct(transaction.doc.store, this);
      this.content.integrate(transaction, this);
      addChangedTypeToTransaction(
        transaction,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      );
      if (
        /** @type {AbstractType<any>} */
        this.parent._item !== null && /** @type {AbstractType<any>} */
        this.parent._item.deleted || this.parentSub !== null && this.right !== null
      ) {
        this.delete(transaction);
      }
    } else {
      new GC(this.id, this.length).integrate(transaction, 0);
    }
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let n = this.right;
    while (n !== null && n.deleted) {
      n = n.right;
    }
    return n;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let n = this.left;
    while (n !== null && n.deleted) {
      n = n.left;
    }
    return n;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor === right.constructor && compareIDs(right.origin, this.lastId) && this.right === right && compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
      const searchMarker = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      if (searchMarker) {
        searchMarker.forEach((marker) => {
          if (marker.p === right) {
            marker.p = this;
            if (!this.deleted && this.countable) {
              marker.index -= this.length;
            }
          }
        });
      }
      if (right.keep) {
        this.keep = true;
      }
      this.right = right.right;
      if (this.right !== null) {
        this.right.left = this;
      }
      this.length += right.length;
      return true;
    }
    return false;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(transaction) {
    if (!this.deleted) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (this.countable && this.parentSub === null) {
        parent._length -= this.length;
      }
      this.markDeleted();
      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
      addChangedTypeToTransaction(transaction, parent, this.parentSub);
      this.content.delete(transaction);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(store, parentGCd) {
    if (!this.deleted) {
      throw unexpectedCase();
    }
    this.content.gc(store);
    if (parentGCd) {
      replaceStruct(store, this, new GC(this.id, this.length));
    } else {
      this.content = new ContentDeleted(this.length);
    }
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(encoder, offset) {
    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin;
    const rightOrigin = this.rightOrigin;
    const parentSub = this.parentSub;
    const info = this.content.getRef() & BITS5 | (origin === null ? 0 : BIT8) | // origin is defined
    (rightOrigin === null ? 0 : BIT7) | // right origin is defined
    (parentSub === null ? 0 : BIT6);
    encoder.writeInfo(info);
    if (origin !== null) {
      encoder.writeLeftID(origin);
    }
    if (rightOrigin !== null) {
      encoder.writeRightID(rightOrigin);
    }
    if (origin === null && rightOrigin === null) {
      const parent = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (parent._item !== void 0) {
        const parentItem = parent._item;
        if (parentItem === null) {
          const ykey = findRootTypeKey(parent);
          encoder.writeParentInfo(true);
          encoder.writeString(ykey);
        } else {
          encoder.writeParentInfo(false);
          encoder.writeLeftID(parentItem.id);
        }
      } else if (parent.constructor === String) {
        encoder.writeParentInfo(true);
        encoder.writeString(parent);
      } else if (parent.constructor === ID) {
        encoder.writeParentInfo(false);
        encoder.writeLeftID(parent);
      } else {
        unexpectedCase();
      }
      if (parentSub !== null) {
        encoder.writeString(parentSub);
      }
    }
    this.content.write(encoder, offset);
  }
};
var readItemContent = (decoder, info) => contentRefs[info & BITS5](decoder);
var contentRefs = [
  () => {
    unexpectedCase();
  },
  // GC is not ItemContent
  readContentDeleted,
  // 1
  readContentJSON,
  // 2
  readContentBinary,
  // 3
  readContentString,
  // 4
  readContentEmbed,
  // 5
  readContentFormat,
  // 6
  readContentType,
  // 7
  readContentAny,
  // 8
  readContentDoc,
  // 9
  () => {
    unexpectedCase();
  }
  // 10 - Skip is not ItemContent
];
var structSkipRefNumber = 10;
var Skip = class extends AbstractStruct {
  get deleted() {
    return true;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(right) {
    if (this.constructor !== right.constructor) {
      return false;
    }
    this.length += right.length;
    return true;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(transaction, offset) {
    unexpectedCase();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(encoder, offset) {
    encoder.writeInfo(structSkipRefNumber);
    writeVarUint(encoder.restEncoder, this.length - offset);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(transaction, store) {
    return null;
  }
};
var glo = (
  /** @type {any} */
  typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {}
);
var importIdentifier = "__ $YJS$ __";
if (glo[importIdentifier] === true) {
  console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
}
glo[importIdentifier] = true;

// src/tools.ts
var XXH = __toESM(require_lib());
var createRandomId = () => {
  return window.crypto.randomUUID();
};
var randomUint32 = () => {
  return window.crypto.getRandomValues(new Uint32Array(1))[0];
};
var generateRandomString = function() {
  return Math.random().toString(20).substring(2, 8);
};
var calculateHash = (text2) => {
  return XXH.h32(text2, 43981).toString(16);
};
var serialize = (obj) => {
  if (Array.isArray(obj)) {
    return `[${obj.map((el) => serialize(el)).join(",")}]`;
  } else if (typeof obj === "object" && obj !== null) {
    let acc = "";
    const keys3 = Object.keys(obj).sort();
    acc += `{${JSON.stringify(keys3)}`;
    for (let i = 0; i < keys3.length; i++) {
      acc += `${serialize(obj[keys3[i]])},`;
    }
    return `${acc}}`;
  }
  return `${JSON.stringify(obj)}`;
};

// src/sharedEntities/sharedDocument.ts
var import_state = require("@codemirror/state");

// src/ui.ts
var import_obsidian = require("obsidian");
var ShowTextModal = class extends import_obsidian.Modal {
  constructor(app, title, message) {
    super(app);
    this.message = message;
    this.title = title;
  }
  onOpen() {
    this.titleEl.setText(this.title);
    this.contentEl.setText(this.message);
  }
  onClose() {
    this.containerEl.empty();
  }
};
var showTextModal = (app, title, text2) => {
  new ShowTextModal(app, title, text2).open();
};
var showNotice = (text2, duration) => {
  return new import_obsidian.Notice(text2, duration);
};
var openFileInNewTab = async (file, workspace) => {
  const leaf = workspace.getLeaf("tab");
  await leaf.openFile(file);
  return leaf;
};
var pinLeaf = (leaf) => {
  leaf.setPinned(true);
  showNotice(`auto-pinned "${leaf.getDisplayText()}"`);
};
var usercolors = [
  { dark: "#30bced", light: "#30bced33" },
  { dark: "#6eeb83", light: "#6eeb8333" },
  { dark: "#ffbc42", light: "#ffbc4233" },
  { dark: "#ecd444", light: "#ecd44433" },
  { dark: "#ee6352", light: "#ee635233" },
  { dark: "#9ac2c9", light: "#9ac2c933" },
  { dark: "#8acb88", light: "#8acb8833" },
  { dark: "#1be7ff", light: "#1be7ff33" }
];

// node_modules/y-codemirror.next/src/index.js
var cmView4 = __toESM(require("@codemirror/view"), 1);
var cmState4 = __toESM(require("@codemirror/state"), 1);

// node_modules/y-codemirror.next/src/y-range.js
var YRange = class {
  /**
   * @param {Y.RelativePosition} yanchor
   * @param {Y.RelativePosition} yhead
   */
  constructor(yanchor, yhead) {
    this.yanchor = yanchor;
    this.yhead = yhead;
  }
  /**
   * @returns {any}
   */
  toJSON() {
    return {
      yanchor: relativePositionToJSON(this.yanchor),
      yhead: relativePositionToJSON(this.yhead)
    };
  }
  /**
   * @param {any} json
   * @return {YRange}
   */
  static fromJSON(json) {
    return new YRange(createRelativePositionFromJSON(json.yanchor), createRelativePositionFromJSON(json.yhead));
  }
};

// node_modules/y-codemirror.next/src/y-sync.js
var cmState = __toESM(require("@codemirror/state"), 1);
var cmView = __toESM(require("@codemirror/view"), 1);
var YSyncConfig = class {
  constructor(ytext, awareness) {
    this.ytext = ytext;
    this.awareness = awareness;
    this.undoManager = new UndoManager(ytext);
  }
  /**
   * Helper function to transform an absolute index position to a Yjs-based relative position
   * (https://docs.yjs.dev/api/relative-positions).
   *
   * A relative position can be transformed back to an absolute position even after the document has changed. The position is
   * automatically adapted. This does not require any position transformations. Relative positions are computed based on
   * the internal Yjs document model. Peers that share content through Yjs are guaranteed that their positions will always
   * synced up when using relatve positions.
   *
   * ```js
   * import { ySyncFacet } from 'y-codemirror'
   *
   * ..
   * const ysync = view.state.facet(ySyncFacet)
   * // transform an absolute index position to a ypos
   * const ypos = ysync.getYPos(3)
   * // transform the ypos back to an absolute position
   * ysync.fromYPos(ypos) // => 3
   * ```
   *
   * It cannot be guaranteed that absolute index positions can be synced up between peers.
   * This might lead to undesired behavior when implementing features that require that all peers see the
   * same marked range (e.g. a comment plugin).
   *
   * @param {number} pos
   * @param {number} [assoc]
   */
  toYPos(pos, assoc = 0) {
    return createRelativePositionFromTypeIndex(this.ytext, pos, assoc);
  }
  /**
   * @param {Y.RelativePosition | Object} rpos
   */
  fromYPos(rpos) {
    const pos = createAbsolutePositionFromRelativePosition(createRelativePositionFromJSON(rpos), this.ytext.doc);
    if (pos == null || pos.type !== this.ytext) {
      throw new Error("[y-codemirror] The position you want to retrieve was created by a different document");
    }
    return {
      pos: pos.index,
      assoc: pos.assoc
    };
  }
  /**
   * @param {cmState.SelectionRange} range
   * @return {YRange}
   */
  toYRange(range) {
    const assoc = range.assoc;
    const yanchor = this.toYPos(range.anchor, assoc);
    const yhead = this.toYPos(range.head, assoc);
    return new YRange(yanchor, yhead);
  }
  /**
   * @param {YRange} yrange
   */
  fromYRange(yrange) {
    const anchor = this.fromYPos(yrange.yanchor);
    const head = this.fromYPos(yrange.yhead);
    if (anchor.pos === head.pos) {
      return cmState.EditorSelection.cursor(head.pos, head.assoc);
    }
    return cmState.EditorSelection.range(anchor.pos, head.pos);
  }
};
var ySyncFacet = cmState.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var ySyncAnnotation = cmState.Annotation.define();
var YSyncPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(ySyncFacet);
    this._observer = (event, tr) => {
      if (tr.origin !== this.conf) {
        const delta = event.delta;
        const changes = [];
        let pos = 0;
        for (let i = 0; i < delta.length; i++) {
          const d = delta[i];
          if (d.insert != null) {
            changes.push({ from: pos, to: pos, insert: d.insert });
          } else if (d.delete != null) {
            changes.push({ from: pos, to: pos + d.delete, insert: "" });
            pos += d.delete;
          } else {
            pos += d.retain;
          }
        }
        view.dispatch({ changes, annotations: [ySyncAnnotation.of(this.conf)] });
      }
    };
    this._ytext = this.conf.ytext;
    this._ytext.observe(this._observer);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (!update.docChanged || update.transactions.length > 0 && update.transactions[0].annotation(ySyncAnnotation) === this.conf) {
      return;
    }
    const ytext = this.conf.ytext;
    ytext.doc.transact(() => {
      let adj = 0;
      update.changes.iterChanges((fromA, toA, fromB, toB, insert) => {
        const insertText2 = insert.sliceString(0, insert.length, "\n");
        if (fromA !== toA) {
          ytext.delete(fromA + adj, toA - fromA);
        }
        if (insertText2.length > 0) {
          ytext.insert(fromA + adj, insertText2);
        }
        adj += insertText2.length - (toA - fromA);
      });
    }, this.conf);
  }
  destroy() {
    this._ytext.unobserve(this._observer);
  }
};
var ySync = cmView.ViewPlugin.fromClass(YSyncPluginValue);

// node_modules/y-codemirror.next/src/y-remote-selections.js
var cmView2 = __toESM(require("@codemirror/view"), 1);
var cmState2 = __toESM(require("@codemirror/state"), 1);
var yRemoteSelectionsTheme = cmView2.EditorView.baseTheme({
  ".cm-ySelection": {},
  ".cm-yLineSelection": {
    padding: 0,
    margin: "0px 2px 0px 4px"
  },
  ".cm-ySelectionCaret": {
    position: "relative",
    borderLeft: "1px solid black",
    borderRight: "1px solid black",
    marginLeft: "-1px",
    marginRight: "-1px",
    boxSizing: "border-box",
    display: "inline"
  },
  ".cm-ySelectionCaretDot": {
    borderRadius: "50%",
    position: "absolute",
    width: ".4em",
    height: ".4em",
    top: "-.2em",
    left: "-.2em",
    backgroundColor: "inherit",
    transition: "transform .3s ease-in-out",
    boxSizing: "border-box"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionCaretDot": {
    transformOrigin: "bottom center",
    transform: "scale(0)"
  },
  ".cm-ySelectionInfo": {
    position: "absolute",
    top: "-1.05em",
    left: "-1px",
    fontSize: ".75em",
    fontFamily: "serif",
    fontStyle: "normal",
    fontWeight: "normal",
    lineHeight: "normal",
    userSelect: "none",
    color: "white",
    paddingLeft: "2px",
    paddingRight: "2px",
    zIndex: 101,
    transition: "opacity .3s ease-in-out",
    backgroundColor: "inherit",
    // these should be separate
    opacity: 0,
    transitionDelay: "0s",
    whiteSpace: "nowrap"
  },
  ".cm-ySelectionCaret:hover > .cm-ySelectionInfo": {
    opacity: 1,
    transitionDelay: "0s"
  }
});
var yRemoteSelectionsAnnotation = cmState2.Annotation.define();
var YRemoteCaretWidget = class extends cmView2.WidgetType {
  /**
   * @param {string} color
   * @param {string} name
   */
  constructor(color, name) {
    super();
    this.color = color;
    this.name = name;
  }
  toDOM() {
    return (
      /** @type {HTMLElement} */
      element("span", [create5("class", "cm-ySelectionCaret"), create5("style", `background-color: ${this.color}; border-color: ${this.color}`)], [
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionCaretDot")
        ]),
        text("\u2060"),
        element("div", [
          create5("class", "cm-ySelectionInfo")
        ], [
          text(this.name)
        ]),
        text("\u2060")
      ])
    );
  }
  eq(widget) {
    return widget.color === this.color;
  }
  compare(widget) {
    return widget.color === this.color;
  }
  updateDOM() {
    return false;
  }
  get estimatedHeight() {
    return -1;
  }
  ignoreEvent() {
    return true;
  }
};
var YRemoteSelectionsPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.conf = view.state.facet(ySyncFacet);
    this._listener = ({ added, updated, removed }, s, t) => {
      const clients = added.concat(updated).concat(removed);
      if (clients.findIndex((id2) => id2 !== this.conf.awareness.doc.clientID) >= 0) {
        view.dispatch({ annotations: [yRemoteSelectionsAnnotation.of([])] });
      }
    };
    this._awareness = this.conf.awareness;
    this._awareness.on("change", this._listener);
    this.decorations = cmState2.RangeSet.of([]);
  }
  destroy() {
    this._awareness.off("change", this._listener);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    const ytext = this.conf.ytext;
    const ydoc = (
      /** @type {Y.Doc} */
      ytext.doc
    );
    const awareness = this.conf.awareness;
    const decorations = [];
    const localAwarenessState = this.conf.awareness.getLocalState();
    if (localAwarenessState != null) {
      const hasFocus = update.view.hasFocus && update.view.dom.ownerDocument.hasFocus();
      const sel = hasFocus ? update.state.selection.main : null;
      const currentAnchor = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.anchor);
      const currentHead = localAwarenessState.cursor == null ? null : createRelativePositionFromJSON(localAwarenessState.cursor.head);
      if (sel != null) {
        const anchor = createRelativePositionFromTypeIndex(ytext, sel.anchor);
        const head = createRelativePositionFromTypeIndex(ytext, sel.head);
        if (localAwarenessState.cursor == null || !compareRelativePositions(currentAnchor, anchor) || !compareRelativePositions(currentHead, head)) {
          awareness.setLocalStateField("cursor", {
            anchor,
            head
          });
        }
      } else if (localAwarenessState.cursor != null && hasFocus) {
        awareness.setLocalStateField("cursor", null);
      }
    }
    awareness.getStates().forEach((state, clientid) => {
      if (clientid === awareness.doc.clientID) {
        return;
      }
      const cursor = state.cursor;
      if (cursor == null || cursor.anchor == null || cursor.head == null) {
        return;
      }
      const anchor = createAbsolutePositionFromRelativePosition(cursor.anchor, ydoc);
      const head = createAbsolutePositionFromRelativePosition(cursor.head, ydoc);
      if (anchor == null || head == null || anchor.type !== ytext || head.type !== ytext) {
        return;
      }
      const { color = "#30bced", name = "Anonymous" } = state.user || {};
      const colorLight = state.user && state.user.colorLight || color + "33";
      const start = min(anchor.index, head.index);
      const end = max(anchor.index, head.index);
      const startLine = update.view.state.doc.lineAt(start);
      const endLine = update.view.state.doc.lineAt(end);
      if (startLine.number === endLine.number) {
        decorations.push({
          from: start,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
      } else {
        decorations.push({
          from: start,
          to: startLine.from + startLine.length,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        decorations.push({
          from: endLine.from,
          to: end,
          value: cmView2.Decoration.mark({
            attributes: { style: `background-color: ${colorLight}` },
            class: "cm-ySelection"
          })
        });
        for (let i = startLine.number + 1; i < endLine.number; i++) {
          const linePos = update.view.state.doc.line(i).from;
          decorations.push({
            from: linePos,
            to: linePos,
            value: cmView2.Decoration.line({
              attributes: { style: `background-color: ${colorLight}`, class: "cm-yLineSelection" }
            })
          });
        }
      }
      decorations.push({
        from: head.index,
        to: head.index,
        value: cmView2.Decoration.widget({
          side: head.index - anchor.index > 0 ? -1 : 1,
          // the local cursor should be rendered outside the remote selection
          block: false,
          widget: new YRemoteCaretWidget(color, name)
        })
      });
    });
    this.decorations = cmView2.Decoration.set(decorations, true);
  }
};
var yRemoteSelections = cmView2.ViewPlugin.fromClass(YRemoteSelectionsPluginValue, {
  decorations: (v) => v.decorations
});

// node_modules/y-codemirror.next/src/y-undomanager.js
var cmState3 = __toESM(require("@codemirror/state"), 1);
var cmView3 = __toESM(require("@codemirror/view"), 1);

// node_modules/lib0/mutex.js
var createMutex = () => {
  let token = true;
  return (f, g) => {
    if (token) {
      token = false;
      try {
        f();
      } finally {
        token = true;
      }
    } else if (g !== void 0) {
      g();
    }
  };
};

// node_modules/y-codemirror.next/src/y-undomanager.js
var YUndoManagerConfig = class {
  /**
   * @param {Y.UndoManager} undoManager
   */
  constructor(undoManager) {
    this.undoManager = undoManager;
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(origin) {
    this.undoManager.addTrackedOrigin(origin);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(origin) {
    this.undoManager.removeTrackedOrigin(origin);
  }
  /**
   * @return {boolean} Whether a change was undone.
   */
  undo() {
    return this.undoManager.undo() != null;
  }
  /**
   * @return {boolean} Whether a change was redone.
   */
  redo() {
    return this.undoManager.redo() != null;
  }
};
var yUndoManagerFacet = cmState3.Facet.define({
  combine(inputs) {
    return inputs[inputs.length - 1];
  }
});
var yUndoManagerAnnotation = cmState3.Annotation.define();
var YUndoManagerPluginValue = class {
  /**
   * @param {cmView.EditorView} view
   */
  constructor(view) {
    this.view = view;
    this.conf = view.state.facet(yUndoManagerFacet);
    this._undoManager = this.conf.undoManager;
    this.syncConf = view.state.facet(ySyncFacet);
    this._beforeChangeSelection = null;
    this._mux = createMutex();
    this._onStackItemAdded = ({ stackItem, changedParentTypes }) => {
      if (changedParentTypes.has(this.syncConf.ytext) && this._beforeChangeSelection && !stackItem.meta.has(this)) {
        stackItem.meta.set(this, this._beforeChangeSelection);
      }
    };
    this._onStackItemPopped = ({ stackItem }) => {
      const sel = stackItem.meta.get(this);
      if (sel) {
        const selection = this.syncConf.fromYRange(sel);
        view.dispatch(view.state.update({
          selection,
          effects: [cmView3.EditorView.scrollIntoView(selection)]
        }));
        this._storeSelection();
      }
    };
    this._storeSelection = () => {
      this._beforeChangeSelection = this.syncConf.toYRange(this.view.state.selection.main);
    };
    this._undoManager.on("stack-item-added", this._onStackItemAdded);
    this._undoManager.on("stack-item-popped", this._onStackItemPopped);
    this._undoManager.addTrackedOrigin(this.syncConf);
  }
  /**
   * @param {cmView.ViewUpdate} update
   */
  update(update) {
    if (update.selectionSet && (update.transactions.length === 0 || update.transactions[0].annotation(ySyncAnnotation) !== this.syncConf)) {
      this._storeSelection();
    }
  }
  destroy() {
    this._undoManager.off("stack-item-added", this._onStackItemAdded);
    this._undoManager.off("stack-item-popped", this._onStackItemPopped);
    this._undoManager.removeTrackedOrigin(this.syncConf);
  }
};
var yUndoManager = cmView3.ViewPlugin.fromClass(YUndoManagerPluginValue);
var undo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).undo() || true;
var redo = ({ state, dispatch }) => state.facet(yUndoManagerFacet).redo() || true;

// node_modules/y-codemirror.next/src/index.js
var yCollab = (ytext, awareness, { undoManager = new UndoManager(ytext) } = {}) => {
  const ySyncConfig = new YSyncConfig(ytext, awareness);
  const plugins = [
    ySyncFacet.of(ySyncConfig),
    ySync
  ];
  if (awareness) {
    plugins.push(
      yRemoteSelectionsTheme,
      yRemoteSelections
    );
  }
  if (undoManager !== false) {
    plugins.push(
      yUndoManagerFacet.of(new YUndoManagerConfig(undoManager)),
      yUndoManager,
      cmView4.EditorView.domEventHandlers({
        beforeinput(e, view) {
          if (e.inputType === "historyUndo")
            return undo(view);
          if (e.inputType === "historyRedo")
            return redo(view);
          return false;
        }
      })
    );
  }
  return plugins;
};

// src/sharedEntities/sharedDocument.ts
var import_state2 = require("@codemirror/state");

// src/utils/peerdraftRecord.ts
var PeerdraftRecord = class extends ObservableV2 {
  constructor() {
    super(...arguments);
    this.record = {};
  }
  set(key, value) {
    const oldValue = this.record[key];
    this.record[key] = value;
    if (oldValue === void 0) {
      this.emit("add", [key, value]);
    } else if (oldValue != value) {
      this.emit("update", [key, oldValue, value]);
    }
  }
  get(key) {
    return this.record[key];
  }
  delete(key) {
    const oldValue = this.record[key];
    delete this.record[key];
    this.emit("delete", [key, oldValue]);
  }
  get size() {
    return Object.keys(this.record).length;
  }
  get keys() {
    return Object.keys(this.record);
  }
};

// src/workspace/peerdraftLeaf.ts
var PeerdraftLeaf = class extends ObservableV2 {
  constructor(path4, isPreview) {
    super();
    this._isPreview = isPreview, this._path = path4;
  }
  get isPreview() {
    return this._isPreview;
  }
  set isPreview(value) {
    const old = this._isPreview;
    this._isPreview = value;
    if (value != old) {
      this.emit("changeIsPreview", [old, value]);
    }
  }
  get path() {
    return this._path;
  }
  set path(value) {
    const old = this._path;
    this._path = value;
    if (value != old) {
      this.emit("changePath", [old, value]);
    }
  }
};

// src/workspace/peerdraftWorkspace.ts
var import_obsidian2 = require("obsidian");
var updatePeerdraftWorkspace = (ws, pws) => {
  var _a, _b;
  const leafs = ws.getLeavesOfType("markdown");
  const oldLeafIds = pws.keys;
  const existingLeafIds = leafs.map((leaf) => {
    return leaf.id;
  });
  for (const leaf of leafs) {
    const leafId = leaf.id;
    const isPreview = leaf.view.containerEl.getAttribute("data-mode") === "preview";
    const path4 = (_b = (_a = leaf.view.file) == null ? void 0 : _a.path) != null ? _b : "";
    let pleaf = pws.get(leafId);
    if (pleaf) {
      pleaf.isPreview = isPreview;
      pleaf.path = path4;
    } else {
      pleaf = new PeerdraftLeaf(path4, isPreview);
      pws.set(leafId, pleaf);
    }
  }
  for (const oldLeafId of oldLeafIds) {
    if (!existingLeafIds.contains(oldLeafId)) {
      pws.delete(oldLeafId);
    }
  }
};
var getLeafsByPath = (path4, pws) => {
  return pws.keys.map((key) => {
    return pws.get(key);
  }).filter((leaf) => {
    return leaf.path === path4;
  });
};
var getLeafIdsByPath = (path4, pws) => {
  const normalizedPath = (0, import_obsidian2.normalizePath)(path4);
  return pws.keys.filter((key) => {
    return (0, import_obsidian2.normalizePath)(pws.get(key).path) === normalizedPath;
  });
};

// node_modules/lib0/websocket.js
var reconnectTimeoutBase = 1200;
var maxReconnectTimeout = 2500;
var messageReconnectTimeout = 3e4;
var setupWS = (wsclient) => {
  if (wsclient.shouldConnect && wsclient.ws === null) {
    const websocket = new WebSocket(wsclient.url);
    const binaryType = wsclient.binaryType;
    let pingTimeout = null;
    if (binaryType) {
      websocket.binaryType = binaryType;
    }
    wsclient.ws = websocket;
    wsclient.connecting = true;
    wsclient.connected = false;
    websocket.onmessage = (event) => {
      wsclient.lastMessageReceived = getUnixTime();
      const data = event.data;
      const message = typeof data === "string" ? JSON.parse(data) : data;
      if (message && message.type === "pong") {
        clearTimeout(pingTimeout);
        pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
      }
      wsclient.emit("message", [message, wsclient]);
    };
    const onclose = (error) => {
      if (wsclient.ws !== null) {
        wsclient.ws = null;
        wsclient.connecting = false;
        if (wsclient.connected) {
          wsclient.connected = false;
          wsclient.emit("disconnect", [{ type: "disconnect", error }, wsclient]);
        } else {
          wsclient.unsuccessfulReconnects++;
        }
        setTimeout(setupWS, min(log10(wsclient.unsuccessfulReconnects + 1) * reconnectTimeoutBase, maxReconnectTimeout), wsclient);
      }
      clearTimeout(pingTimeout);
    };
    const sendPing = () => {
      if (wsclient.ws === websocket) {
        wsclient.send({
          type: "ping"
        });
      }
    };
    websocket.onclose = () => onclose(null);
    websocket.onerror = (error) => onclose(error);
    websocket.onopen = () => {
      wsclient.lastMessageReceived = getUnixTime();
      wsclient.connecting = false;
      wsclient.connected = true;
      wsclient.unsuccessfulReconnects = 0;
      wsclient.emit("connect", [{ type: "connect" }, wsclient]);
      pingTimeout = setTimeout(sendPing, messageReconnectTimeout / 2);
    };
  }
};
var WebsocketClient = class extends Observable {
  /**
   * @param {string} url
   * @param {object} opts
   * @param {'arraybuffer' | 'blob' | null} [opts.binaryType] Set `ws.binaryType`
   */
  constructor(url, { binaryType } = {}) {
    super();
    this.url = url;
    this.ws = null;
    this.binaryType = binaryType || null;
    this.connected = false;
    this.connecting = false;
    this.unsuccessfulReconnects = 0;
    this.lastMessageReceived = 0;
    this.shouldConnect = true;
    this._checkInterval = setInterval(() => {
      if (this.connected && messageReconnectTimeout < getUnixTime() - this.lastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout / 2);
    setupWS(this);
  }
  /**
   * @param {any} message
   */
  send(message) {
    if (this.ws) {
      this.ws.send(JSON.stringify(message));
    }
  }
  destroy() {
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.connected && this.ws === null) {
      setupWS(this);
    }
  }
};

// node_modules/lib0/broadcastchannel.js
var channels = /* @__PURE__ */ new Map();
var LocalStoragePolyfill = class {
  /**
   * @param {string} room
   */
  constructor(room) {
    this.room = room;
    this.onmessage = null;
    this._onChange = (e) => e.key === room && this.onmessage !== null && this.onmessage({ data: fromBase64(e.newValue || "") });
    onChange(this._onChange);
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(buf) {
    varStorage.setItem(this.room, toBase64(createUint8ArrayFromArrayBuffer(buf)));
  }
  close() {
    offChange(this._onChange);
  }
};
var BC = typeof BroadcastChannel === "undefined" ? LocalStoragePolyfill : BroadcastChannel;
var getChannel = (room) => setIfUndefined(channels, room, () => {
  const subs = create2();
  const bc = new BC(room);
  bc.onmessage = (e) => subs.forEach((sub) => sub(e.data, "broadcastchannel"));
  return {
    bc,
    subs
  };
});
var subscribe = (room, f) => {
  getChannel(room).subs.add(f);
  return f;
};
var unsubscribe = (room, f) => {
  const channel = getChannel(room);
  const unsubscribed = channel.subs.delete(f);
  if (unsubscribed && channel.subs.size === 0) {
    channel.bc.close();
    channels.delete(room);
  }
  return unsubscribed;
};
var publish = (room, data, origin = null) => {
  const c = getChannel(room);
  c.bc.postMessage(data);
  c.subs.forEach((sub) => sub(data, origin));
};

// node_modules/y-webrtc/src/y-webrtc.js
var import_simplepeer_min = __toESM(require_simplepeer_min(), 1);

// node_modules/y-protocols/sync.js
var messageYjsSyncStep1 = 0;
var messageYjsSyncStep2 = 1;
var messageYjsUpdate = 2;
var writeSyncStep1 = (encoder, doc2) => {
  writeVarUint(encoder, messageYjsSyncStep1);
  const sv = encodeStateVector(doc2);
  writeVarUint8Array(encoder, sv);
};
var writeSyncStep2 = (encoder, doc2, encodedStateVector) => {
  writeVarUint(encoder, messageYjsSyncStep2);
  writeVarUint8Array(encoder, encodeStateAsUpdate(doc2, encodedStateVector));
};
var readSyncStep1 = (decoder, encoder, doc2) => writeSyncStep2(encoder, doc2, readVarUint8Array(decoder));
var readSyncStep2 = (decoder, doc2, transactionOrigin) => {
  try {
    applyUpdate(doc2, readVarUint8Array(decoder), transactionOrigin);
  } catch (error) {
    console.error("Caught error while handling a Yjs update", error);
  }
};
var writeUpdate = (encoder, update) => {
  writeVarUint(encoder, messageYjsUpdate);
  writeVarUint8Array(encoder, update);
};
var readUpdate = readSyncStep2;
var readSyncMessage = (decoder, encoder, doc2, transactionOrigin) => {
  const messageType = readVarUint(decoder);
  switch (messageType) {
    case messageYjsSyncStep1:
      readSyncStep1(decoder, encoder, doc2);
      break;
    case messageYjsSyncStep2:
      readSyncStep2(decoder, doc2, transactionOrigin);
      break;
    case messageYjsUpdate:
      readUpdate(decoder, doc2, transactionOrigin);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return messageType;
};

// node_modules/y-protocols/awareness.js
var outdatedTimeout = 3e4;
var Awareness = class extends Observable {
  /**
   * @param {Y.Doc} doc
   */
  constructor(doc2) {
    super();
    this.doc = doc2;
    this.clientID = doc2.clientID;
    this.states = /* @__PURE__ */ new Map();
    this.meta = /* @__PURE__ */ new Map();
    this._checkInterval = /** @type {any} */
    setInterval(() => {
      const now = getUnixTime();
      if (this.getLocalState() !== null && outdatedTimeout / 2 <= now - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated) {
        this.setLocalState(this.getLocalState());
      }
      const remove = [];
      this.meta.forEach((meta, clientid) => {
        if (clientid !== this.clientID && outdatedTimeout <= now - meta.lastUpdated && this.states.has(clientid)) {
          remove.push(clientid);
        }
      });
      if (remove.length > 0) {
        removeAwarenessStates(this, remove, "timeout");
      }
    }, floor(outdatedTimeout / 10));
    doc2.on("destroy", () => {
      this.destroy();
    });
    this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]);
    this.setLocalState(null);
    super.destroy();
    clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(state) {
    const clientID = this.clientID;
    const currLocalMeta = this.meta.get(clientID);
    const clock = currLocalMeta === void 0 ? 0 : currLocalMeta.clock + 1;
    const prevState = this.states.get(clientID);
    if (state === null) {
      this.states.delete(clientID);
    } else {
      this.states.set(clientID, state);
    }
    this.meta.set(clientID, {
      clock,
      lastUpdated: getUnixTime()
    });
    const added = [];
    const updated = [];
    const filteredUpdated = [];
    const removed = [];
    if (state === null) {
      removed.push(clientID);
    } else if (prevState == null) {
      if (state != null) {
        added.push(clientID);
      }
    } else {
      updated.push(clientID);
      if (!equalityDeep(prevState, state)) {
        filteredUpdated.push(clientID);
      }
    }
    if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
      this.emit("change", [{ added, updated: filteredUpdated, removed }, "local"]);
    }
    this.emit("update", [{ added, updated, removed }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(field, value) {
    const state = this.getLocalState();
    if (state !== null) {
      this.setLocalState({
        ...state,
        [field]: value
      });
    }
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
};
var removeAwarenessStates = (awareness, clients, origin) => {
  const removed = [];
  for (let i = 0; i < clients.length; i++) {
    const clientID = clients[i];
    if (awareness.states.has(clientID)) {
      awareness.states.delete(clientID);
      if (clientID === awareness.clientID) {
        const curMeta = (
          /** @type {MetaClientState} */
          awareness.meta.get(clientID)
        );
        awareness.meta.set(clientID, {
          clock: curMeta.clock + 1,
          lastUpdated: getUnixTime()
        });
      }
      removed.push(clientID);
    }
  }
  if (removed.length > 0) {
    awareness.emit("change", [{ added: [], updated: [], removed }, origin]);
    awareness.emit("update", [{ added: [], updated: [], removed }, origin]);
  }
};
var encodeAwarenessUpdate = (awareness, clients, states = awareness.states) => {
  const len = clients.length;
  const encoder = createEncoder();
  writeVarUint(encoder, len);
  for (let i = 0; i < len; i++) {
    const clientID = clients[i];
    const state = states.get(clientID) || null;
    const clock = (
      /** @type {MetaClientState} */
      awareness.meta.get(clientID).clock
    );
    writeVarUint(encoder, clientID);
    writeVarUint(encoder, clock);
    writeVarString(encoder, JSON.stringify(state));
  }
  return toUint8Array(encoder);
};
var applyAwarenessUpdate = (awareness, update, origin) => {
  const decoder = createDecoder(update);
  const timestamp = getUnixTime();
  const added = [];
  const updated = [];
  const filteredUpdated = [];
  const removed = [];
  const len = readVarUint(decoder);
  for (let i = 0; i < len; i++) {
    const clientID = readVarUint(decoder);
    let clock = readVarUint(decoder);
    const state = JSON.parse(readVarString(decoder));
    const clientMeta = awareness.meta.get(clientID);
    const prevState = awareness.states.get(clientID);
    const currClock = clientMeta === void 0 ? 0 : clientMeta.clock;
    if (currClock < clock || currClock === clock && state === null && awareness.states.has(clientID)) {
      if (state === null) {
        if (clientID === awareness.clientID && awareness.getLocalState() != null) {
          clock++;
        } else {
          awareness.states.delete(clientID);
        }
      } else {
        awareness.states.set(clientID, state);
      }
      awareness.meta.set(clientID, {
        clock,
        lastUpdated: timestamp
      });
      if (clientMeta === void 0 && state !== null) {
        added.push(clientID);
      } else if (clientMeta !== void 0 && state === null) {
        removed.push(clientID);
      } else if (state !== null) {
        if (!equalityDeep(state, prevState)) {
          filteredUpdated.push(clientID);
        }
        updated.push(clientID);
      }
    }
  }
  if (added.length > 0 || filteredUpdated.length > 0 || removed.length > 0) {
    awareness.emit("change", [{
      added,
      updated: filteredUpdated,
      removed
    }, origin]);
  }
  if (added.length > 0 || updated.length > 0 || removed.length > 0) {
    awareness.emit("update", [{
      added,
      updated,
      removed
    }, origin]);
  }
};

// node_modules/y-webrtc/src/crypto.js
var deriveKey = (secret, roomName) => {
  const secretBuffer = encodeUtf8(secret).buffer;
  const salt = encodeUtf8(roomName).buffer;
  return crypto.subtle.importKey(
    "raw",
    secretBuffer,
    "PBKDF2",
    false,
    ["deriveKey"]
  ).then(
    (keyMaterial) => crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 1e5,
        hash: "SHA-256"
      },
      keyMaterial,
      {
        name: "AES-GCM",
        length: 256
      },
      true,
      ["encrypt", "decrypt"]
    )
  );
};
var encrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const iv = crypto.getRandomValues(new Uint8Array(12));
  return crypto.subtle.encrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    data
  ).then((cipher) => {
    const encryptedDataEncoder = createEncoder();
    writeVarString(encryptedDataEncoder, "AES-GCM");
    writeVarUint8Array(encryptedDataEncoder, iv);
    writeVarUint8Array(encryptedDataEncoder, new Uint8Array(cipher));
    return toUint8Array(encryptedDataEncoder);
  });
};
var encryptJson = (data, key) => {
  const dataEncoder = createEncoder();
  writeAny(dataEncoder, data);
  return encrypt(toUint8Array(dataEncoder), key);
};
var decrypt = (data, key) => {
  if (!key) {
    return (
      /** @type {PromiseLike<Uint8Array>} */
      resolve(data)
    );
  }
  const dataDecoder = createDecoder(data);
  const algorithm = readVarString(dataDecoder);
  if (algorithm !== "AES-GCM") {
    reject(create3("Unknown encryption algorithm"));
  }
  const iv = readVarUint8Array(dataDecoder);
  const cipher = readVarUint8Array(dataDecoder);
  return crypto.subtle.decrypt(
    {
      name: "AES-GCM",
      iv
    },
    key,
    cipher
  ).then((data2) => new Uint8Array(data2));
};
var decryptJson = (data, key) => decrypt(data, key).then(
  (decryptedValue) => readAny(createDecoder(new Uint8Array(decryptedValue)))
);

// node_modules/y-webrtc/src/y-webrtc.js
var log = createModuleLogger2("y-webrtc");
var messageSync = 0;
var messageQueryAwareness = 3;
var messageAwareness = 1;
var messageBcPeerId = 4;
var signalingConns = /* @__PURE__ */ new Map();
var rooms = /* @__PURE__ */ new Map();
var checkIsSynced = (room) => {
  let synced = true;
  room.webrtcConns.forEach((peer) => {
    if (!peer.synced) {
      synced = false;
    }
  });
  if (!synced && room.synced || synced && !room.synced) {
    room.synced = synced;
    room.provider.emit("synced", [{ synced }]);
    log("synced ", BOLD, room.name, UNBOLD, " with all peers");
  }
};
var readMessage = (room, buf, syncedCallback) => {
  const decoder = createDecoder(buf);
  const encoder = createEncoder();
  const messageType = readVarUint(decoder);
  if (room === void 0) {
    return null;
  }
  const awareness = room.awareness;
  const doc2 = room.doc;
  let sendReply = false;
  switch (messageType) {
    case messageSync: {
      writeVarUint(encoder, messageSync);
      const syncMessageType = readSyncMessage(decoder, encoder, doc2, room);
      if (syncMessageType === messageYjsSyncStep2 && !room.synced) {
        syncedCallback();
      }
      if (syncMessageType === messageYjsSyncStep1) {
        sendReply = true;
      }
      break;
    }
    case messageQueryAwareness:
      writeVarUint(encoder, messageAwareness);
      writeVarUint8Array(encoder, encodeAwarenessUpdate(awareness, Array.from(awareness.getStates().keys())));
      sendReply = true;
      break;
    case messageAwareness:
      applyAwarenessUpdate(awareness, readVarUint8Array(decoder), room);
      break;
    case messageBcPeerId: {
      const add2 = readUint8(decoder) === 1;
      const peerName = readVarString(decoder);
      if (peerName !== room.peerId && (room.bcConns.has(peerName) && !add2 || !room.bcConns.has(peerName) && add2)) {
        const removed = [];
        const added = [];
        if (add2) {
          room.bcConns.add(peerName);
          added.push(peerName);
        } else {
          room.bcConns.delete(peerName);
          removed.push(peerName);
        }
        room.provider.emit("peers", [{
          added,
          removed,
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
        broadcastBcPeerId(room);
      }
      break;
    }
    default:
      console.error("Unable to compute message");
      return encoder;
  }
  if (!sendReply) {
    return null;
  }
  return encoder;
};
var readPeerMessage = (peerConn, buf) => {
  const room = peerConn.room;
  log("received message from ", BOLD, peerConn.remotePeerId, GREY, " (", room.name, ")", UNBOLD, UNCOLOR);
  return readMessage(room, buf, () => {
    peerConn.synced = true;
    log("synced ", BOLD, room.name, UNBOLD, " with ", BOLD, peerConn.remotePeerId);
    checkIsSynced(room);
  });
};
var sendWebrtcConn = (webrtcConn, encoder) => {
  log("send message to ", BOLD, webrtcConn.remotePeerId, UNBOLD, GREY, " (", webrtcConn.room.name, ")", UNCOLOR);
  try {
    webrtcConn.peer.send(toUint8Array(encoder));
  } catch (e) {
  }
};
var broadcastWebrtcConn = (room, m) => {
  log("broadcast message in ", BOLD, room.name, UNBOLD);
  room.webrtcConns.forEach((conn) => {
    try {
      conn.peer.send(m);
    } catch (e) {
    }
  });
};
var WebrtcConn = class {
  /**
   * @param {SignalingConn} signalingConn
   * @param {boolean} initiator
   * @param {string} remotePeerId
   * @param {Room} room
   */
  constructor(signalingConn, initiator, remotePeerId, room) {
    log("establishing connection to ", BOLD, remotePeerId);
    this.room = room;
    this.remotePeerId = remotePeerId;
    this.glareToken = void 0;
    this.closed = false;
    this.connected = false;
    this.synced = false;
    this.peer = new import_simplepeer_min.default({ initiator, ...room.provider.peerOpts });
    this.peer.on("signal", (signal) => {
      if (this.glareToken === void 0) {
        this.glareToken = Date.now() + Math.random();
      }
      publishSignalingMessage(signalingConn, room, { to: remotePeerId, from: room.peerId, type: "signal", token: this.glareToken, signal });
    });
    this.peer.on("connect", () => {
      log("connected to ", BOLD, remotePeerId);
      this.connected = true;
      const provider = room.provider;
      const doc2 = provider.doc;
      const awareness = room.awareness;
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeSyncStep1(encoder, doc2);
      sendWebrtcConn(this, encoder);
      const awarenessStates = awareness.getStates();
      if (awarenessStates.size > 0) {
        const encoder2 = createEncoder();
        writeVarUint(encoder2, messageAwareness);
        writeVarUint8Array(encoder2, encodeAwarenessUpdate(awareness, Array.from(awarenessStates.keys())));
        sendWebrtcConn(this, encoder2);
      }
    });
    this.peer.on("close", () => {
      this.connected = false;
      this.closed = true;
      if (room.webrtcConns.has(this.remotePeerId)) {
        room.webrtcConns.delete(this.remotePeerId);
        room.provider.emit("peers", [{
          removed: [this.remotePeerId],
          added: [],
          webrtcPeers: Array.from(room.webrtcConns.keys()),
          bcPeers: Array.from(room.bcConns)
        }]);
      }
      checkIsSynced(room);
      this.peer.destroy();
      log("closed connection to ", BOLD, remotePeerId);
      announceSignalingInfo(room);
    });
    this.peer.on("error", (err) => {
      log("Error in connection to ", BOLD, remotePeerId, ": ", err);
      announceSignalingInfo(room);
    });
    this.peer.on("data", (data) => {
      const answer = readPeerMessage(this, data);
      if (answer !== null) {
        sendWebrtcConn(this, answer);
      }
    });
  }
  destroy() {
    this.peer.destroy();
  }
};
var broadcastBcMessage = (room, m) => encrypt(m, room.key).then(
  (data) => room.mux(
    () => publish(room.name, data)
  )
);
var broadcastRoomMessage = (room, m) => {
  if (room.bcconnected) {
    broadcastBcMessage(room, m);
  }
  broadcastWebrtcConn(room, m);
};
var announceSignalingInfo = (room) => {
  signalingConns.forEach((conn) => {
    if (conn.connected) {
      conn.send({ type: "subscribe", topics: [room.name] });
      if (room.webrtcConns.size < room.provider.maxConns) {
        publishSignalingMessage(conn, room, { type: "announce", from: room.peerId });
      }
    }
  });
};
var broadcastBcPeerId = (room) => {
  if (room.provider.filterBcConns) {
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 1);
    writeVarString(encoderPeerIdBc, room.peerId);
    broadcastBcMessage(room, toUint8Array(encoderPeerIdBc));
  }
};
var Room = class {
  /**
   * @param {Y.Doc} doc
   * @param {WebrtcProvider} provider
   * @param {string} name
   * @param {CryptoKey|null} key
   */
  constructor(doc2, provider, name, key) {
    this.peerId = uuidv4();
    this.doc = doc2;
    this.awareness = provider.awareness;
    this.provider = provider;
    this.synced = false;
    this.name = name;
    this.key = key;
    this.webrtcConns = /* @__PURE__ */ new Map();
    this.bcConns = /* @__PURE__ */ new Set();
    this.mux = createMutex();
    this.bcconnected = false;
    this._bcSubscriber = (data) => decrypt(new Uint8Array(data), key).then(
      (m) => this.mux(() => {
        const reply = readMessage(this, m, () => {
        });
        if (reply) {
          broadcastBcMessage(this, toUint8Array(reply));
        }
      })
    );
    this._docUpdateHandler = (update, _origin) => {
      const encoder = createEncoder();
      writeVarUint(encoder, messageSync);
      writeUpdate(encoder, update);
      broadcastRoomMessage(this, toUint8Array(encoder));
    };
    this._awarenessUpdateHandler = ({ added, updated, removed }, _origin) => {
      const changedClients = added.concat(updated).concat(removed);
      const encoderAwareness = createEncoder();
      writeVarUint(encoderAwareness, messageAwareness);
      writeVarUint8Array(encoderAwareness, encodeAwarenessUpdate(this.awareness, changedClients));
      broadcastRoomMessage(this, toUint8Array(encoderAwareness));
    };
    this._beforeUnloadHandler = () => {
      removeAwarenessStates(this.awareness, [doc2.clientID], "window unload");
      rooms.forEach((room) => {
        room.disconnect();
      });
    };
    if (typeof window !== "undefined") {
      window.addEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.on("exit", this._beforeUnloadHandler);
    }
  }
  connect() {
    this.doc.on("update", this._docUpdateHandler);
    this.awareness.on("update", this._awarenessUpdateHandler);
    announceSignalingInfo(this);
    const roomName = this.name;
    subscribe(roomName, this._bcSubscriber);
    this.bcconnected = true;
    broadcastBcPeerId(this);
    const encoderSync = createEncoder();
    writeVarUint(encoderSync, messageSync);
    writeSyncStep1(encoderSync, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderSync));
    const encoderState = createEncoder();
    writeVarUint(encoderState, messageSync);
    writeSyncStep2(encoderState, this.doc);
    broadcastBcMessage(this, toUint8Array(encoderState));
    const encoderAwarenessQuery = createEncoder();
    writeVarUint(encoderAwarenessQuery, messageQueryAwareness);
    broadcastBcMessage(this, toUint8Array(encoderAwarenessQuery));
    const encoderAwarenessState = createEncoder();
    writeVarUint(encoderAwarenessState, messageAwareness);
    writeVarUint8Array(encoderAwarenessState, encodeAwarenessUpdate(this.awareness, [this.doc.clientID]));
    broadcastBcMessage(this, toUint8Array(encoderAwarenessState));
  }
  disconnect() {
    signalingConns.forEach((conn) => {
      if (conn.connected) {
        conn.send({ type: "unsubscribe", topics: [this.name] });
      }
    });
    removeAwarenessStates(this.awareness, [this.doc.clientID], "disconnect");
    const encoderPeerIdBc = createEncoder();
    writeVarUint(encoderPeerIdBc, messageBcPeerId);
    writeUint8(encoderPeerIdBc, 0);
    writeVarString(encoderPeerIdBc, this.peerId);
    broadcastBcMessage(this, toUint8Array(encoderPeerIdBc));
    unsubscribe(this.name, this._bcSubscriber);
    this.bcconnected = false;
    this.doc.off("update", this._docUpdateHandler);
    this.awareness.off("update", this._awarenessUpdateHandler);
    this.webrtcConns.forEach((conn) => conn.destroy());
  }
  destroy() {
    this.disconnect();
    if (typeof window !== "undefined") {
      window.removeEventListener("beforeunload", this._beforeUnloadHandler);
    } else if (typeof process !== "undefined") {
      process.off("exit", this._beforeUnloadHandler);
    }
  }
};
var openRoom = (doc2, provider, name, key) => {
  if (rooms.has(name)) {
    throw create3(`A Yjs Doc connected to room "${name}" already exists!`);
  }
  const room = new Room(doc2, provider, name, key);
  rooms.set(
    name,
    /** @type {Room} */
    room
  );
  return room;
};
var publishSignalingMessage = (conn, room, data) => {
  if (room.key) {
    encryptJson(data, room.key).then((data2) => {
      conn.send({ type: "publish", topic: room.name, data: toBase64(data2) });
    });
  } else {
    conn.send({ type: "publish", topic: room.name, data });
  }
};
var SignalingConn = class extends WebsocketClient {
  constructor(url) {
    super(url);
    this.providers = /* @__PURE__ */ new Set();
    this.on("connect", () => {
      log(`connected (${url})`);
      const topics = Array.from(rooms.keys());
      this.send({ type: "subscribe", topics });
      rooms.forEach(
        (room) => publishSignalingMessage(this, room, { type: "announce", from: room.peerId })
      );
    });
    this.on("message", (m) => {
      switch (m.type) {
        case "publish": {
          const roomName = m.topic;
          const room = rooms.get(roomName);
          if (room == null || typeof roomName !== "string") {
            return;
          }
          const execMessage = (data) => {
            const webrtcConns = room.webrtcConns;
            const peerId = room.peerId;
            if (data == null || data.from === peerId || data.to !== void 0 && data.to !== peerId || room.bcConns.has(data.from)) {
              return;
            }
            const emitPeerChange = webrtcConns.has(data.from) ? () => {
            } : () => room.provider.emit("peers", [{
              removed: [],
              added: [data.from],
              webrtcPeers: Array.from(room.webrtcConns.keys()),
              bcPeers: Array.from(room.bcConns)
            }]);
            switch (data.type) {
              case "announce":
                if (webrtcConns.size < room.provider.maxConns) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, true, data.from, room));
                  emitPeerChange();
                }
                break;
              case "signal":
                if (data.signal.type === "offer") {
                  const existingConn = webrtcConns.get(data.from);
                  if (existingConn) {
                    const remoteToken = data.token;
                    const localToken = existingConn.glareToken;
                    if (localToken && localToken > remoteToken) {
                      log("offer rejected: ", data.from);
                      return;
                    }
                    existingConn.glareToken = void 0;
                  }
                }
                if (data.signal.type === "answer") {
                  log("offer answered by: ", data.from);
                  const existingConn = webrtcConns.get(data.from);
                  existingConn.glareToken = void 0;
                }
                if (data.to === peerId) {
                  setIfUndefined(webrtcConns, data.from, () => new WebrtcConn(this, false, data.from, room)).peer.signal(data.signal);
                  emitPeerChange();
                }
                break;
            }
          };
          if (room.key) {
            if (typeof m.data === "string") {
              decryptJson(fromBase64(m.data), room.key).then(execMessage);
            }
          } else {
            execMessage(m.data);
          }
        }
      }
    });
    this.on("disconnect", () => log(`disconnect (${url})`));
  }
};
var emitStatus = (provider) => {
  provider.emit("status", [{
    connected: provider.connected
  }]);
};
var WebrtcProvider = class extends ObservableV2 {
  /**
   * @param {string} roomName
   * @param {Y.Doc} doc
   * @param {ProviderOptions?} opts
   */
  constructor(roomName, doc2, {
    signaling = ["wss://y-webrtc-eu.fly.dev"],
    password = null,
    awareness = new Awareness(doc2),
    maxConns = 20 + floor(rand() * 15),
    // the random factor reduces the chance that n clients form a cluster
    filterBcConns = true,
    peerOpts = {}
    // simple-peer options. See https://github.com/feross/simple-peer#peer--new-peeropts
  } = {}) {
    super();
    this.roomName = roomName;
    this.doc = doc2;
    this.filterBcConns = filterBcConns;
    this.awareness = awareness;
    this.shouldConnect = false;
    this.signalingUrls = signaling;
    this.signalingConns = [];
    this.maxConns = maxConns;
    this.peerOpts = peerOpts;
    this.key = password ? deriveKey(password, roomName) : (
      /** @type {PromiseLike<null>} */
      resolve(null)
    );
    this.room = null;
    this.key.then((key) => {
      this.room = openRoom(doc2, this, roomName, key);
      if (this.shouldConnect) {
        this.room.connect();
      } else {
        this.room.disconnect();
      }
      emitStatus(this);
    });
    this.connect();
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  /**
   * Indicates whether the provider is looking for other peers.
   *
   * Other peers can be found via signaling servers or via broadcastchannel (cross browser-tab
   * communication). You never know when you are connected to all peers. You also don't know if
   * there are other peers. connected doesn't mean that you are connected to any physical peers
   * working on the same resource as you. It does not change unless you call provider.disconnect()
   *
   * `this.on('status', (event) => { console.log(event.connected) })`
   *
   * @type {boolean}
   */
  get connected() {
    return this.room !== null && this.shouldConnect;
  }
  connect() {
    this.shouldConnect = true;
    this.signalingUrls.forEach((url) => {
      const signalingConn = setIfUndefined(signalingConns, url, () => new SignalingConn(url));
      this.signalingConns.push(signalingConn);
      signalingConn.providers.add(this);
    });
    if (this.room) {
      this.room.connect();
      emitStatus(this);
    }
  }
  disconnect() {
    this.shouldConnect = false;
    this.signalingConns.forEach((conn) => {
      conn.providers.delete(this);
      if (conn.providers.size === 0) {
        conn.destroy();
        signalingConns.delete(conn.url);
      }
    });
    if (this.room) {
      this.room.disconnect();
      emitStatus(this);
    }
  }
  destroy() {
    this.doc.off("destroy", this.destroy);
    this.key.then(() => {
      this.room.destroy();
      rooms.delete(this.roomName);
    });
    super.destroy();
  }
};

// src/sharedEntities/sharedEntity.ts
var import_obsidian3 = require("obsidian");
var SharedEntity = class {
  constructor(plugin) {
    this.plugin = plugin;
    this._webRTCTimeout = null;
  }
  get shareId() {
    return this._shareId;
  }
  get path() {
    return this._path;
  }
  get indexedDBProvider() {
    return this._indexedDBProvider;
  }
  get webRTCProvider() {
    return this._webRTCProvider;
  }
  static findByPath(path4) {
    const normalizedPath = (0, import_obsidian3.normalizePath)(path4);
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.path === normalizedPath;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static findById(id2) {
    const docs = this._sharedEntites.filter((doc2) => {
      return doc2.shareId === id2;
    });
    if (docs.length >= 1) {
      return docs[0];
    } else {
      return;
    }
  }
  static getAll() {
    return Object.assign([], this._sharedEntites);
  }
  initServerYDoc() {
    return new Promise((resolve2) => {
      const tempId = createRandomId();
      const handler = (serverTempId, id2, checksum) => {
        if (serverTempId === tempId) {
          this.plugin.serverSync.off("new-doc-confirmed", handler);
          this._shareId = id2;
          resolve2(checksum);
        }
      };
      this.plugin.serverSync.on("new-doc-confirmed", handler);
      this.plugin.serverSync.sendNewDocument(this, tempId);
    });
  }
  syncWithServer() {
    return new Promise((resolve2) => {
      const handler = async (id2, hash) => {
        if (id2 === this.shareId) {
          this.plugin.serverSync.off("synced", handler);
          this.plugin.log("synced " + this.path);
          resolve2(hash);
        }
      };
      this.plugin.serverSync.on("synced", handler);
      this.plugin.serverSync.sendSyncStep1(this);
      this.plugin.log("syncing " + this.path);
    });
  }
  startWebRTCSync(init) {
    this.plugin.log(`WebRTC for ${this.path}: start`);
    if (!this.shareId)
      return;
    if (this._webRTCProvider) {
      this._webRTCProvider.connect();
      return this._webRTCProvider;
    }
    const webRTCProvider = new WebrtcProvider(this._shareId, this.yDoc, { signaling: [this.plugin.settings.signaling], peerOpts: { iceServers: [{ urls: "stun:freeturn.net:5349" }, { urls: "turns:freeturn.net:5349", username: "free", credential: "free" }, { urls: "stun:stun.l.google.com:19302" }, { urls: "stun:global.stun.twilio.com:3478?transport=udp" }] } });
    this._webRTCProvider = webRTCProvider;
    if (init) {
      init(webRTCProvider);
    }
    return webRTCProvider;
  }
  stopWebRTCSync() {
    var _a, _b, _c;
    if (!this._webRTCProvider)
      return;
    this.plugin.log(`WebRTC for ${this.path}: stop`);
    (_a = this._webRTCProvider) == null ? void 0 : _a.awareness.destroy();
    (_b = this._webRTCProvider) == null ? void 0 : _b.disconnect();
    (_c = this._webRTCProvider) == null ? void 0 : _c.destroy();
    this._webRTCProvider = void 0;
  }
  async stopIndexedDBSync() {
    if (!this._indexedDBProvider)
      return;
    await this._indexedDBProvider.destroy();
  }
  destroy() {
    this.stopWebRTCSync();
  }
};
SharedEntity.DB_PERSISTENCE_PREFIX = "peerdraft_persistence_";

// src/sharedEntities/sharedDocument.ts
var path2 = __toESM(require("path"));

// node_modules/lib0/indexeddb.js
var rtop = (request) => create4((resolve2, reject2) => {
  request.onerror = (event) => reject2(new Error(event.target.error));
  request.onsuccess = (event) => resolve2(event.target.result);
});
var openDB = (name, initDB) => create4((resolve2, reject2) => {
  const request = indexedDB.open(name);
  request.onupgradeneeded = (event) => initDB(event.target.result);
  request.onerror = (event) => reject2(create3(event.target.error));
  request.onsuccess = (event) => {
    const db = event.target.result;
    db.onversionchange = () => {
      db.close();
    };
    resolve2(db);
  };
});
var deleteDB = (name) => rtop(indexedDB.deleteDatabase(name));
var createStores = (db, definitions) => definitions.forEach(
  (d) => (
    // @ts-ignore
    db.createObjectStore.apply(db, d)
  )
);
var transact2 = (db, stores, access = "readwrite") => {
  const transaction = db.transaction(stores, access);
  return stores.map((store) => getStore(transaction, store));
};
var count = (store, range) => rtop(store.count(range));
var get = (store, key) => rtop(store.get(key));
var del = (store, key) => rtop(store.delete(key));
var put = (store, item, key) => rtop(store.put(item, key));
var addAutoKey = (store, item) => rtop(store.add(item));
var getAll = (store, range, limit) => rtop(store.getAll(range, limit));
var queryFirst = (store, query, direction) => {
  let first = null;
  return iterateKeys(store, query, (key) => {
    first = key;
    return false;
  }, direction).then(() => first);
};
var getLastKey = (store, range = null) => queryFirst(store, range, "prev");
var iterateOnRequest = (request, f) => create4((resolve2, reject2) => {
  request.onerror = reject2;
  request.onsuccess = async (event) => {
    const cursor = event.target.result;
    if (cursor === null || await f(cursor) === false) {
      return resolve2();
    }
    cursor.continue();
  };
});
var iterateKeys = (store, keyrange, f, direction = "next") => iterateOnRequest(store.openKeyCursor(keyrange, direction), (cursor) => f(cursor.key));
var getStore = (t, store) => t.objectStore(store);
var createIDBKeyRangeUpperBound = (upper, upperOpen) => IDBKeyRange.upperBound(upper, upperOpen);
var createIDBKeyRangeLowerBound = (lower, lowerOpen) => IDBKeyRange.lowerBound(lower, lowerOpen);

// node_modules/y-indexeddb/src/y-indexeddb.js
var customStoreName = "custom";
var updatesStoreName = "updates";
var PREFERRED_TRIM_SIZE = 500;
var fetchUpdates = (idbPersistence, beforeApplyUpdatesCallback = () => {
}, afterApplyUpdatesCallback = () => {
}) => {
  const [updatesStore] = transact2(
    /** @type {IDBDatabase} */
    idbPersistence.db,
    [updatesStoreName]
  );
  return getAll(updatesStore, createIDBKeyRangeLowerBound(idbPersistence._dbref, false)).then((updates) => {
    if (!idbPersistence._destroyed) {
      beforeApplyUpdatesCallback(updatesStore);
      transact(idbPersistence.doc, () => {
        updates.forEach((val) => applyUpdate(idbPersistence.doc, val));
      }, idbPersistence, false);
      afterApplyUpdatesCallback(updatesStore);
    }
  }).then(() => getLastKey(updatesStore).then((lastKey) => {
    idbPersistence._dbref = lastKey + 1;
  })).then(() => count(updatesStore).then((cnt) => {
    idbPersistence._dbsize = cnt;
  })).then(() => updatesStore);
};
var storeState = (idbPersistence, forceStore = true) => fetchUpdates(idbPersistence).then((updatesStore) => {
  if (forceStore || idbPersistence._dbsize >= PREFERRED_TRIM_SIZE) {
    addAutoKey(updatesStore, encodeStateAsUpdate(idbPersistence.doc)).then(() => del(updatesStore, createIDBKeyRangeUpperBound(idbPersistence._dbref, true))).then(() => count(updatesStore).then((cnt) => {
      idbPersistence._dbsize = cnt;
    }));
  }
});
var IndexeddbPersistence = class extends Observable {
  /**
   * @param {string} name
   * @param {Y.Doc} doc
   */
  constructor(name, doc2) {
    super();
    this.doc = doc2;
    this.name = name;
    this._dbref = 0;
    this._dbsize = 0;
    this._destroyed = false;
    this.db = null;
    this.synced = false;
    this._db = openDB(
      name,
      (db) => createStores(db, [
        ["updates", { autoIncrement: true }],
        ["custom"]
      ])
    );
    this.whenSynced = create4((resolve2) => this.on("synced", () => resolve2(this)));
    this._db.then((db) => {
      this.db = db;
      const beforeApplyUpdatesCallback = (updatesStore) => addAutoKey(updatesStore, encodeStateAsUpdate(doc2));
      const afterApplyUpdatesCallback = () => {
        if (this._destroyed)
          return this;
        this.synced = true;
        this.emit("synced", [this]);
      };
      fetchUpdates(this, beforeApplyUpdatesCallback, afterApplyUpdatesCallback);
    });
    this._storeTimeout = 1e3;
    this._storeTimeoutId = null;
    this._storeUpdate = (update, origin) => {
      if (this.db && origin !== this) {
        const [updatesStore] = transact2(
          /** @type {IDBDatabase} */
          this.db,
          [updatesStoreName]
        );
        addAutoKey(updatesStore, update);
        if (++this._dbsize >= PREFERRED_TRIM_SIZE) {
          if (this._storeTimeoutId !== null) {
            clearTimeout(this._storeTimeoutId);
          }
          this._storeTimeoutId = setTimeout(() => {
            storeState(this, false);
            this._storeTimeoutId = null;
          }, this._storeTimeout);
        }
      }
    };
    doc2.on("update", this._storeUpdate);
    this.destroy = this.destroy.bind(this);
    doc2.on("destroy", this.destroy);
  }
  destroy() {
    if (this._storeTimeoutId) {
      clearTimeout(this._storeTimeoutId);
    }
    this.doc.off("update", this._storeUpdate);
    this.doc.off("destroy", this.destroy);
    this._destroyed = true;
    return this._db.then((db) => {
      db.close();
    });
  }
  /**
   * Destroys this instance and removes all data from indexeddb.
   *
   * @return {Promise<void>}
   */
  clearData() {
    return this.destroy().then(() => {
      deleteDB(this.name);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<String | number | ArrayBuffer | Date | any>}
   */
  get(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName], "readonly");
      return get(custom, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @param {String | number | ArrayBuffer | Date} value
   * @return {Promise<String | number | ArrayBuffer | Date>}
   */
  set(key, value) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return put(custom, value, key);
    });
  }
  /**
   * @param {String | number | ArrayBuffer | Date} key
   * @return {Promise<undefined>}
   */
  del(key) {
    return this._db.then((db) => {
      const [custom] = transact2(db, [customStoreName]);
      return del(custom, key);
    });
  }
};

// src/workspace/explorerView.ts
var addIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.addClass("pd-explorer-shared");
  });
};
var removeIsSharedClass = (path4, plugin) => {
  const fileExplorers = plugin.app.workspace.getLeavesOfType("file-explorer");
  fileExplorers.forEach((fileExplorer) => {
    const fileItem = fileExplorer.view.fileItems[path4];
    if (!fileItem)
      return;
    const el = fileItem.innerEl;
    el.removeClass("pd-explorer-shared");
  });
};

// src/sharedEntities/sharedFolder.ts
var import_obsidian10 = require("obsidian");
var path = __toESM(require("path"));

// src/settings.ts
var import_obsidian7 = require("obsidian");

// src/ui/selectFolder.ts
var import_obsidian4 = require("obsidian");
var SelectFolderModal = class extends import_obsidian4.SuggestModal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
    this.folders = [];
    import_obsidian4.Vault.recurseChildren(app.vault.getRoot(), (file) => {
      if (file instanceof import_obsidian4.TFolder)
        this.folders.push(file);
    });
    this.folders.shift();
    this.folders.sort((a, b) => {
      return a.path.toLocaleLowerCase().localeCompare(b.path.toLocaleLowerCase());
    });
  }
  onOpen() {
    super.onOpen();
    this.inputEl.placeholder = "Choose a location";
  }
  getSuggestions(query) {
    return this.folders.filter((folder) => {
      return folder.path.toLocaleLowerCase().includes(query.toLocaleLowerCase());
    });
  }
  renderSuggestion(value, el) {
    el.setText(value.path);
  }
  selectSuggestion(value, evt) {
    this.selectedFolder = value;
    super.selectSuggestion(value, evt);
  }
  onChooseSuggestion(item, evt) {
  }
  onClose() {
    this.cb(this.selectedFolder);
  }
};
var promptForFolderSelection = async (app) => {
  return new Promise((resolve2) => {
    new SelectFolderModal(app, (folder) => {
      resolve2(folder);
    }).open();
  });
};

// node_modules/dexie/dist/modern/dexie.mjs
var _global = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
var keys2 = Object.keys;
var isArray2 = Array.isArray;
if (typeof Promise !== "undefined" && !_global.Promise) {
  _global.Promise = Promise;
}
function extend(obj, extension) {
  if (typeof extension !== "object")
    return obj;
  keys2(extension).forEach(function(key) {
    obj[key] = extension[key];
  });
  return obj;
}
var getProto = Object.getPrototypeOf;
var _hasOwn = {}.hasOwnProperty;
function hasOwn(obj, prop) {
  return _hasOwn.call(obj, prop);
}
function props(proto, extension) {
  if (typeof extension === "function")
    extension = extension(getProto(proto));
  (typeof Reflect === "undefined" ? keys2 : Reflect.ownKeys)(extension).forEach((key) => {
    setProp(proto, key, extension[key]);
  });
}
var defineProperty = Object.defineProperty;
function setProp(obj, prop, functionOrGetSet, options) {
  defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, "get") && typeof functionOrGetSet.get === "function" ? { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } : { value: functionOrGetSet, configurable: true, writable: true }, options));
}
function derive(Child) {
  return {
    from: function(Parent) {
      Child.prototype = Object.create(Parent.prototype);
      setProp(Child.prototype, "constructor", Child);
      return {
        extend: props.bind(null, Child.prototype)
      };
    }
  };
}
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
function getPropertyDescriptor(obj, prop) {
  const pd = getOwnPropertyDescriptor(obj, prop);
  let proto;
  return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);
}
var _slice = [].slice;
function slice(args2, start, end) {
  return _slice.call(args2, start, end);
}
function override(origFunc, overridedFactory) {
  return overridedFactory(origFunc);
}
function assert(b) {
  if (!b)
    throw new Error("Assertion Failed");
}
function asap$1(fn) {
  if (_global.setImmediate)
    setImmediate(fn);
  else
    setTimeout(fn, 0);
}
function arrayToObject(array, extractor) {
  return array.reduce((result, item, i) => {
    var nameAndValue = extractor(item, i);
    if (nameAndValue)
      result[nameAndValue[0]] = nameAndValue[1];
    return result;
  }, {});
}
function tryCatch(fn, onerror, args2) {
  try {
    fn.apply(null, args2);
  } catch (ex) {
    onerror && onerror(ex);
  }
}
function getByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string" && hasOwn(obj, keyPath))
    return obj[keyPath];
  if (!keyPath)
    return obj;
  if (typeof keyPath !== "string") {
    var rv = [];
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      var val = getByKeyPath(obj, keyPath[i]);
      rv.push(val);
    }
    return rv;
  }
  var period = keyPath.indexOf(".");
  if (period !== -1) {
    var innerObj = obj[keyPath.substr(0, period)];
    return innerObj == null ? void 0 : getByKeyPath(innerObj, keyPath.substr(period + 1));
  }
  return void 0;
}
function setByKeyPath(obj, keyPath, value) {
  if (!obj || keyPath === void 0)
    return;
  if ("isFrozen" in Object && Object.isFrozen(obj))
    return;
  if (typeof keyPath !== "string" && "length" in keyPath) {
    assert(typeof value !== "string" && "length" in value);
    for (var i = 0, l = keyPath.length; i < l; ++i) {
      setByKeyPath(obj, keyPath[i], value[i]);
    }
  } else {
    var period = keyPath.indexOf(".");
    if (period !== -1) {
      var currentKeyPath = keyPath.substr(0, period);
      var remainingKeyPath = keyPath.substr(period + 1);
      if (remainingKeyPath === "")
        if (value === void 0) {
          if (isArray2(obj) && !isNaN(parseInt(currentKeyPath)))
            obj.splice(currentKeyPath, 1);
          else
            delete obj[currentKeyPath];
        } else
          obj[currentKeyPath] = value;
      else {
        var innerObj = obj[currentKeyPath];
        if (!innerObj || !hasOwn(obj, currentKeyPath))
          innerObj = obj[currentKeyPath] = {};
        setByKeyPath(innerObj, remainingKeyPath, value);
      }
    } else {
      if (value === void 0) {
        if (isArray2(obj) && !isNaN(parseInt(keyPath)))
          obj.splice(keyPath, 1);
        else
          delete obj[keyPath];
      } else
        obj[keyPath] = value;
    }
  }
}
function delByKeyPath(obj, keyPath) {
  if (typeof keyPath === "string")
    setByKeyPath(obj, keyPath, void 0);
  else if ("length" in keyPath)
    [].map.call(keyPath, function(kp) {
      setByKeyPath(obj, kp, void 0);
    });
}
function shallowClone(obj) {
  var rv = {};
  for (var m in obj) {
    if (hasOwn(obj, m))
      rv[m] = obj[m];
  }
  return rv;
}
var concat = [].concat;
function flatten(a) {
  return concat.apply([], a);
}
var intrinsicTypeNames = "BigUint64Array,BigInt64Array,Array,Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,FileSystemDirectoryHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey".split(",").concat(flatten([8, 16, 32, 64].map((num) => ["Int", "Uint", "Float"].map((t) => t + num + "Array")))).filter((t) => _global[t]);
var intrinsicTypes = intrinsicTypeNames.map((t) => _global[t]);
arrayToObject(intrinsicTypeNames, (x) => [x, true]);
var circularRefs = null;
function deepClone(any2) {
  circularRefs = typeof WeakMap !== "undefined" && /* @__PURE__ */ new WeakMap();
  const rv = innerDeepClone(any2);
  circularRefs = null;
  return rv;
}
function innerDeepClone(any2) {
  if (!any2 || typeof any2 !== "object")
    return any2;
  let rv = circularRefs && circularRefs.get(any2);
  if (rv)
    return rv;
  if (isArray2(any2)) {
    rv = [];
    circularRefs && circularRefs.set(any2, rv);
    for (var i = 0, l = any2.length; i < l; ++i) {
      rv.push(innerDeepClone(any2[i]));
    }
  } else if (intrinsicTypes.indexOf(any2.constructor) >= 0) {
    rv = any2;
  } else {
    const proto = getProto(any2);
    rv = proto === Object.prototype ? {} : Object.create(proto);
    circularRefs && circularRefs.set(any2, rv);
    for (var prop in any2) {
      if (hasOwn(any2, prop)) {
        rv[prop] = innerDeepClone(any2[prop]);
      }
    }
  }
  return rv;
}
var { toString } = {};
function toStringTag(o) {
  return toString.call(o).slice(8, -1);
}
var iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator : "@@iterator";
var getIteratorOf = typeof iteratorSymbol === "symbol" ? function(x) {
  var i;
  return x != null && (i = x[iteratorSymbol]) && i.apply(x);
} : function() {
  return null;
};
var NO_CHAR_ARRAY = {};
function getArrayOf(arrayLike) {
  var i, a, x, it;
  if (arguments.length === 1) {
    if (isArray2(arrayLike))
      return arrayLike.slice();
    if (this === NO_CHAR_ARRAY && typeof arrayLike === "string")
      return [arrayLike];
    if (it = getIteratorOf(arrayLike)) {
      a = [];
      while (x = it.next(), !x.done)
        a.push(x.value);
      return a;
    }
    if (arrayLike == null)
      return [arrayLike];
    i = arrayLike.length;
    if (typeof i === "number") {
      a = new Array(i);
      while (i--)
        a[i] = arrayLike[i];
      return a;
    }
    return [arrayLike];
  }
  i = arguments.length;
  a = new Array(i);
  while (i--)
    a[i] = arguments[i];
  return a;
}
var isAsyncFunction = typeof Symbol !== "undefined" ? (fn) => fn[Symbol.toStringTag] === "AsyncFunction" : () => false;
var debug = typeof location !== "undefined" && /^(http|https):\/\/(localhost|127\.0\.0\.1)/.test(location.href);
function setDebug(value, filter) {
  debug = value;
  libraryFilter = filter;
}
var libraryFilter = () => true;
var NEEDS_THROW_FOR_STACK = !new Error("").stack;
function getErrorWithStack() {
  if (NEEDS_THROW_FOR_STACK)
    try {
      getErrorWithStack.arguments;
      throw new Error();
    } catch (e) {
      return e;
    }
  return new Error();
}
function prettyStack(exception, numIgnoredFrames) {
  var stack = exception.stack;
  if (!stack)
    return "";
  numIgnoredFrames = numIgnoredFrames || 0;
  if (stack.indexOf(exception.name) === 0)
    numIgnoredFrames += (exception.name + exception.message).split("\n").length;
  return stack.split("\n").slice(numIgnoredFrames).filter(libraryFilter).map((frame) => "\n" + frame).join("");
}
var dexieErrorNames = [
  "Modify",
  "Bulk",
  "OpenFailed",
  "VersionChange",
  "Schema",
  "Upgrade",
  "InvalidTable",
  "MissingAPI",
  "NoSuchDatabase",
  "InvalidArgument",
  "SubTransaction",
  "Unsupported",
  "Internal",
  "DatabaseClosed",
  "PrematureCommit",
  "ForeignAwait"
];
var idbDomErrorNames = [
  "Unknown",
  "Constraint",
  "Data",
  "TransactionInactive",
  "ReadOnly",
  "Version",
  "NotFound",
  "InvalidState",
  "InvalidAccess",
  "Abort",
  "Timeout",
  "QuotaExceeded",
  "Syntax",
  "DataClone"
];
var errorList = dexieErrorNames.concat(idbDomErrorNames);
var defaultTexts = {
  VersionChanged: "Database version changed by other database connection",
  DatabaseClosed: "Database has been closed",
  Abort: "Transaction aborted",
  TransactionInactive: "Transaction has already completed or failed",
  MissingAPI: "IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb"
};
function DexieError(name, msg) {
  this._e = getErrorWithStack();
  this.name = name;
  this.message = msg;
}
derive(DexieError).from(Error).extend({
  stack: {
    get: function() {
      return this._stack || (this._stack = this.name + ": " + this.message + prettyStack(this._e, 2));
    }
  },
  toString: function() {
    return this.name + ": " + this.message;
  }
});
function getMultiErrorMessage(msg, failures) {
  return msg + ". Errors: " + Object.keys(failures).map((key) => failures[key].toString()).filter((v, i, s) => s.indexOf(v) === i).join("\n");
}
function ModifyError(msg, failures, successCount, failedKeys) {
  this._e = getErrorWithStack();
  this.failures = failures;
  this.failedKeys = failedKeys;
  this.successCount = successCount;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(ModifyError).from(DexieError);
function BulkError(msg, failures) {
  this._e = getErrorWithStack();
  this.name = "BulkError";
  this.failures = Object.keys(failures).map((pos) => failures[pos]);
  this.failuresByPos = failures;
  this.message = getMultiErrorMessage(msg, failures);
}
derive(BulkError).from(DexieError);
var errnames = errorList.reduce((obj, name) => (obj[name] = name + "Error", obj), {});
var BaseException = DexieError;
var exceptions = errorList.reduce((obj, name) => {
  var fullName = name + "Error";
  function DexieError2(msgOrInner, inner) {
    this._e = getErrorWithStack();
    this.name = fullName;
    if (!msgOrInner) {
      this.message = defaultTexts[name] || fullName;
      this.inner = null;
    } else if (typeof msgOrInner === "string") {
      this.message = `${msgOrInner}${!inner ? "" : "\n " + inner}`;
      this.inner = inner || null;
    } else if (typeof msgOrInner === "object") {
      this.message = `${msgOrInner.name} ${msgOrInner.message}`;
      this.inner = msgOrInner;
    }
  }
  derive(DexieError2).from(BaseException);
  obj[name] = DexieError2;
  return obj;
}, {});
exceptions.Syntax = SyntaxError;
exceptions.Type = TypeError;
exceptions.Range = RangeError;
var exceptionMap = idbDomErrorNames.reduce((obj, name) => {
  obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
function mapError(domError, message) {
  if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])
    return domError;
  var rv = new exceptionMap[domError.name](message || domError.message, domError);
  if ("stack" in domError) {
    setProp(rv, "stack", { get: function() {
      return this.inner.stack;
    } });
  }
  return rv;
}
var fullNameExceptions = errorList.reduce((obj, name) => {
  if (["Syntax", "Type", "Range"].indexOf(name) === -1)
    obj[name + "Error"] = exceptions[name];
  return obj;
}, {});
fullNameExceptions.ModifyError = ModifyError;
fullNameExceptions.DexieError = DexieError;
fullNameExceptions.BulkError = BulkError;
function nop2() {
}
function mirror(val) {
  return val;
}
function pureFunctionChain(f1, f2) {
  if (f1 == null || f1 === mirror)
    return f2;
  return function(val) {
    return f2(f1(val));
  };
}
function callBoth(on1, on2) {
  return function() {
    on1.apply(this, arguments);
    on2.apply(this, arguments);
  };
}
function hookCreatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res !== void 0)
      arguments[0] = res;
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res2 !== void 0 ? res2 : res;
  };
}
function hookDeletingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    f1.apply(this, arguments);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = this.onerror = null;
    f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
  };
}
function hookUpdatingChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function(modifications) {
    var res = f1.apply(this, arguments);
    extend(modifications, res);
    var onsuccess = this.onsuccess, onerror = this.onerror;
    this.onsuccess = null;
    this.onerror = null;
    var res2 = f2.apply(this, arguments);
    if (onsuccess)
      this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;
    if (onerror)
      this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;
    return res === void 0 ? res2 === void 0 ? void 0 : res2 : extend(res, res2);
  };
}
function reverseStoppableEventChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    if (f2.apply(this, arguments) === false)
      return false;
    return f1.apply(this, arguments);
  };
}
function promisableChain(f1, f2) {
  if (f1 === nop2)
    return f2;
  return function() {
    var res = f1.apply(this, arguments);
    if (res && typeof res.then === "function") {
      var thiz = this, i = arguments.length, args2 = new Array(i);
      while (i--)
        args2[i] = arguments[i];
      return res.then(function() {
        return f2.apply(thiz, args2);
      });
    }
    return f2.apply(this, arguments);
  };
}
var INTERNAL = {};
var LONG_STACKS_CLIP_LIMIT = 100;
var MAX_LONG_STACKS = 20;
var ZONE_ECHO_LIMIT = 100;
var [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === "undefined" ? [] : (() => {
  let globalP = Promise.resolve();
  if (typeof crypto === "undefined" || !crypto.subtle)
    return [globalP, getProto(globalP), globalP];
  const nativeP = crypto.subtle.digest("SHA-512", new Uint8Array([0]));
  return [
    nativeP,
    getProto(nativeP),
    globalP
  ];
})();
var nativePromiseThen = nativePromiseProto && nativePromiseProto.then;
var NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;
var patchGlobalPromise = !!resolvedGlobalPromise;
var stack_being_generated = false;
var schedulePhysicalTick = resolvedGlobalPromise ? () => {
  resolvedGlobalPromise.then(physicalTick);
} : _global.setImmediate ? setImmediate.bind(null, physicalTick) : _global.MutationObserver ? () => {
  var hiddenDiv = document.createElement("div");
  new MutationObserver(() => {
    physicalTick();
    hiddenDiv = null;
  }).observe(hiddenDiv, { attributes: true });
  hiddenDiv.setAttribute("i", "1");
} : () => {
  setTimeout(physicalTick, 0);
};
var asap = function(callback, args2) {
  microtickQueue.push([callback, args2]);
  if (needsNewPhysicalTick) {
    schedulePhysicalTick();
    needsNewPhysicalTick = false;
  }
};
var isOutsideMicroTick = true;
var needsNewPhysicalTick = true;
var unhandledErrors = [];
var rejectingErrors = [];
var currentFulfiller = null;
var rejectionMapper = mirror;
var globalPSD = {
  id: "global",
  global: true,
  ref: 0,
  unhandleds: [],
  onunhandled: globalError,
  pgp: false,
  env: {},
  finalize: function() {
    this.unhandleds.forEach((uh) => {
      try {
        globalError(uh[0], uh[1]);
      } catch (e) {
      }
    });
  }
};
var PSD = globalPSD;
var microtickQueue = [];
var numScheduledCalls = 0;
var tickFinalizers = [];
function DexiePromise(fn) {
  if (typeof this !== "object")
    throw new TypeError("Promises must be constructed via new");
  this._listeners = [];
  this.onuncatched = nop2;
  this._lib = false;
  var psd = this._PSD = PSD;
  if (debug) {
    this._stackHolder = getErrorWithStack();
    this._prev = null;
    this._numPrev = 0;
  }
  if (typeof fn !== "function") {
    if (fn !== INTERNAL)
      throw new TypeError("Not a function");
    this._state = arguments[1];
    this._value = arguments[2];
    if (this._state === false)
      handleRejection(this, this._value);
    return;
  }
  this._state = null;
  this._value = null;
  ++psd.ref;
  executePromiseTask(this, fn);
}
var thenProp = {
  get: function() {
    var psd = PSD, microTaskId = totalEchoes;
    function then(onFulfilled, onRejected) {
      var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);
      const cleanup = possibleAwait && !decrementExpectedAwaits();
      var rv = new DexiePromise((resolve2, reject2) => {
        propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve2, reject2, psd));
      });
      debug && linkToPreviousPromise(rv, this);
      return rv;
    }
    then.prototype = INTERNAL;
    return then;
  },
  set: function(value) {
    setProp(this, "then", value && value.prototype === INTERNAL ? thenProp : {
      get: function() {
        return value;
      },
      set: thenProp.set
    });
  }
};
props(DexiePromise.prototype, {
  then: thenProp,
  _then: function(onFulfilled, onRejected) {
    propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));
  },
  catch: function(onRejected) {
    if (arguments.length === 1)
      return this.then(null, onRejected);
    var type2 = arguments[0], handler = arguments[1];
    return typeof type2 === "function" ? this.then(null, (err) => err instanceof type2 ? handler(err) : PromiseReject(err)) : this.then(null, (err) => err && err.name === type2 ? handler(err) : PromiseReject(err));
  },
  finally: function(onFinally) {
    return this.then((value) => {
      onFinally();
      return value;
    }, (err) => {
      onFinally();
      return PromiseReject(err);
    });
  },
  stack: {
    get: function() {
      if (this._stack)
        return this._stack;
      try {
        stack_being_generated = true;
        var stacks = getStack(this, [], MAX_LONG_STACKS);
        var stack = stacks.join("\nFrom previous: ");
        if (this._state !== null)
          this._stack = stack;
        return stack;
      } finally {
        stack_being_generated = false;
      }
    }
  },
  timeout: function(ms, msg) {
    return ms < Infinity ? new DexiePromise((resolve2, reject2) => {
      var handle = setTimeout(() => reject2(new exceptions.Timeout(msg)), ms);
      this.then(resolve2, reject2).finally(clearTimeout.bind(null, handle));
    }) : this;
  }
});
if (typeof Symbol !== "undefined" && Symbol.toStringTag)
  setProp(DexiePromise.prototype, Symbol.toStringTag, "Dexie.Promise");
globalPSD.env = snapShot();
function Listener(onFulfilled, onRejected, resolve2, reject2, zone) {
  this.onFulfilled = typeof onFulfilled === "function" ? onFulfilled : null;
  this.onRejected = typeof onRejected === "function" ? onRejected : null;
  this.resolve = resolve2;
  this.reject = reject2;
  this.psd = zone;
}
props(DexiePromise, {
  all: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise(function(resolve2, reject2) {
      if (values.length === 0)
        resolve2([]);
      var remaining = values.length;
      values.forEach((a, i) => DexiePromise.resolve(a).then((x) => {
        values[i] = x;
        if (!--remaining)
          resolve2(values);
      }, reject2));
    });
  },
  resolve: (value) => {
    if (value instanceof DexiePromise)
      return value;
    if (value && typeof value.then === "function")
      return new DexiePromise((resolve2, reject2) => {
        value.then(resolve2, reject2);
      });
    var rv = new DexiePromise(INTERNAL, true, value);
    linkToPreviousPromise(rv, currentFulfiller);
    return rv;
  },
  reject: PromiseReject,
  race: function() {
    var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
    return new DexiePromise((resolve2, reject2) => {
      values.map((value) => DexiePromise.resolve(value).then(resolve2, reject2));
    });
  },
  PSD: {
    get: () => PSD,
    set: (value) => PSD = value
  },
  totalEchoes: { get: () => totalEchoes },
  newPSD: newScope,
  usePSD,
  scheduler: {
    get: () => asap,
    set: (value) => {
      asap = value;
    }
  },
  rejectionMapper: {
    get: () => rejectionMapper,
    set: (value) => {
      rejectionMapper = value;
    }
  },
  follow: (fn, zoneProps) => {
    return new DexiePromise((resolve2, reject2) => {
      return newScope((resolve3, reject3) => {
        var psd = PSD;
        psd.unhandleds = [];
        psd.onunhandled = reject3;
        psd.finalize = callBoth(function() {
          run_at_end_of_this_or_next_physical_tick(() => {
            this.unhandleds.length === 0 ? resolve3() : reject3(this.unhandleds[0]);
          });
        }, psd.finalize);
        fn();
      }, zoneProps, resolve2, reject2);
    });
  }
});
if (NativePromise) {
  if (NativePromise.allSettled)
    setProp(DexiePromise, "allSettled", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2) => {
        if (possiblePromises.length === 0)
          resolve2([]);
        let remaining = possiblePromises.length;
        const results = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => results[i] = { status: "fulfilled", value }, (reason) => results[i] = { status: "rejected", reason }).then(() => --remaining || resolve2(results)));
      });
    });
  if (NativePromise.any && typeof AggregateError !== "undefined")
    setProp(DexiePromise, "any", function() {
      const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);
      return new DexiePromise((resolve2, reject2) => {
        if (possiblePromises.length === 0)
          reject2(new AggregateError([]));
        let remaining = possiblePromises.length;
        const failures = new Array(remaining);
        possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then((value) => resolve2(value), (failure) => {
          failures[i] = failure;
          if (!--remaining)
            reject2(new AggregateError(failures));
        }));
      });
    });
}
function executePromiseTask(promise, fn) {
  try {
    fn((value) => {
      if (promise._state !== null)
        return;
      if (value === promise)
        throw new TypeError("A promise cannot be resolved with itself.");
      var shouldExecuteTick = promise._lib && beginMicroTickScope();
      if (value && typeof value.then === "function") {
        executePromiseTask(promise, (resolve2, reject2) => {
          value instanceof DexiePromise ? value._then(resolve2, reject2) : value.then(resolve2, reject2);
        });
      } else {
        promise._state = true;
        promise._value = value;
        propagateAllListeners(promise);
      }
      if (shouldExecuteTick)
        endMicroTickScope();
    }, handleRejection.bind(null, promise));
  } catch (ex) {
    handleRejection(promise, ex);
  }
}
function handleRejection(promise, reason) {
  rejectingErrors.push(reason);
  if (promise._state !== null)
    return;
  var shouldExecuteTick = promise._lib && beginMicroTickScope();
  reason = rejectionMapper(reason);
  promise._state = false;
  promise._value = reason;
  debug && reason !== null && typeof reason === "object" && !reason._promise && tryCatch(() => {
    var origProp = getPropertyDescriptor(reason, "stack");
    reason._promise = promise;
    setProp(reason, "stack", {
      get: () => stack_being_generated ? origProp && (origProp.get ? origProp.get.apply(reason) : origProp.value) : promise.stack
    });
  });
  addPossiblyUnhandledError(promise);
  propagateAllListeners(promise);
  if (shouldExecuteTick)
    endMicroTickScope();
}
function propagateAllListeners(promise) {
  var listeners = promise._listeners;
  promise._listeners = [];
  for (var i = 0, len = listeners.length; i < len; ++i) {
    propagateToListener(promise, listeners[i]);
  }
  var psd = promise._PSD;
  --psd.ref || psd.finalize();
  if (numScheduledCalls === 0) {
    ++numScheduledCalls;
    asap(() => {
      if (--numScheduledCalls === 0)
        finalizePhysicalTick();
    }, []);
  }
}
function propagateToListener(promise, listener) {
  if (promise._state === null) {
    promise._listeners.push(listener);
    return;
  }
  var cb = promise._state ? listener.onFulfilled : listener.onRejected;
  if (cb === null) {
    return (promise._state ? listener.resolve : listener.reject)(promise._value);
  }
  ++listener.psd.ref;
  ++numScheduledCalls;
  asap(callListener, [cb, promise, listener]);
}
function callListener(cb, promise, listener) {
  try {
    currentFulfiller = promise;
    var ret, value = promise._value;
    if (promise._state) {
      ret = cb(value);
    } else {
      if (rejectingErrors.length)
        rejectingErrors = [];
      ret = cb(value);
      if (rejectingErrors.indexOf(value) === -1)
        markErrorAsHandled(promise);
    }
    listener.resolve(ret);
  } catch (e) {
    listener.reject(e);
  } finally {
    currentFulfiller = null;
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
    --listener.psd.ref || listener.psd.finalize();
  }
}
function getStack(promise, stacks, limit) {
  if (stacks.length === limit)
    return stacks;
  var stack = "";
  if (promise._state === false) {
    var failure = promise._value, errorName, message;
    if (failure != null) {
      errorName = failure.name || "Error";
      message = failure.message || failure;
      stack = prettyStack(failure, 0);
    } else {
      errorName = failure;
      message = "";
    }
    stacks.push(errorName + (message ? ": " + message : "") + stack);
  }
  if (debug) {
    stack = prettyStack(promise._stackHolder, 2);
    if (stack && stacks.indexOf(stack) === -1)
      stacks.push(stack);
    if (promise._prev)
      getStack(promise._prev, stacks, limit);
  }
  return stacks;
}
function linkToPreviousPromise(promise, prev) {
  var numPrev = prev ? prev._numPrev + 1 : 0;
  if (numPrev < LONG_STACKS_CLIP_LIMIT) {
    promise._prev = prev;
    promise._numPrev = numPrev;
  }
}
function physicalTick() {
  beginMicroTickScope() && endMicroTickScope();
}
function beginMicroTickScope() {
  var wasRootExec = isOutsideMicroTick;
  isOutsideMicroTick = false;
  needsNewPhysicalTick = false;
  return wasRootExec;
}
function endMicroTickScope() {
  var callbacks, i, l;
  do {
    while (microtickQueue.length > 0) {
      callbacks = microtickQueue;
      microtickQueue = [];
      l = callbacks.length;
      for (i = 0; i < l; ++i) {
        var item = callbacks[i];
        item[0].apply(null, item[1]);
      }
    }
  } while (microtickQueue.length > 0);
  isOutsideMicroTick = true;
  needsNewPhysicalTick = true;
}
function finalizePhysicalTick() {
  var unhandledErrs = unhandledErrors;
  unhandledErrors = [];
  unhandledErrs.forEach((p) => {
    p._PSD.onunhandled.call(null, p._value, p);
  });
  var finalizers = tickFinalizers.slice(0);
  var i = finalizers.length;
  while (i)
    finalizers[--i]();
}
function run_at_end_of_this_or_next_physical_tick(fn) {
  function finalizer() {
    fn();
    tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);
  }
  tickFinalizers.push(finalizer);
  ++numScheduledCalls;
  asap(() => {
    if (--numScheduledCalls === 0)
      finalizePhysicalTick();
  }, []);
}
function addPossiblyUnhandledError(promise) {
  if (!unhandledErrors.some((p) => p._value === promise._value))
    unhandledErrors.push(promise);
}
function markErrorAsHandled(promise) {
  var i = unhandledErrors.length;
  while (i)
    if (unhandledErrors[--i]._value === promise._value) {
      unhandledErrors.splice(i, 1);
      return;
    }
}
function PromiseReject(reason) {
  return new DexiePromise(INTERNAL, false, reason);
}
function wrap(fn, errorCatcher) {
  var psd = PSD;
  return function() {
    var wasRootExec = beginMicroTickScope(), outerScope = PSD;
    try {
      switchToZone(psd, true);
      return fn.apply(this, arguments);
    } catch (e) {
      errorCatcher && errorCatcher(e);
    } finally {
      switchToZone(outerScope, false);
      if (wasRootExec)
        endMicroTickScope();
    }
  };
}
var task = { awaits: 0, echoes: 0, id: 0 };
var taskCounter = 0;
var zoneStack = [];
var zoneEchoes = 0;
var totalEchoes = 0;
var zone_id_counter = 0;
function newScope(fn, props2, a1, a2) {
  var parent = PSD, psd = Object.create(parent);
  psd.parent = parent;
  psd.ref = 0;
  psd.global = false;
  psd.id = ++zone_id_counter;
  var globalEnv = globalPSD.env;
  psd.env = patchGlobalPromise ? {
    Promise: DexiePromise,
    PromiseProp: { value: DexiePromise, configurable: true, writable: true },
    all: DexiePromise.all,
    race: DexiePromise.race,
    allSettled: DexiePromise.allSettled,
    any: DexiePromise.any,
    resolve: DexiePromise.resolve,
    reject: DexiePromise.reject,
    nthen: getPatchedPromiseThen(globalEnv.nthen, psd),
    gthen: getPatchedPromiseThen(globalEnv.gthen, psd)
  } : {};
  if (props2)
    extend(psd, props2);
  ++parent.ref;
  psd.finalize = function() {
    --this.parent.ref || this.parent.finalize();
  };
  var rv = usePSD(psd, fn, a1, a2);
  if (psd.ref === 0)
    psd.finalize();
  return rv;
}
function incrementExpectedAwaits() {
  if (!task.id)
    task.id = ++taskCounter;
  ++task.awaits;
  task.echoes += ZONE_ECHO_LIMIT;
  return task.id;
}
function decrementExpectedAwaits() {
  if (!task.awaits)
    return false;
  if (--task.awaits === 0)
    task.id = 0;
  task.echoes = task.awaits * ZONE_ECHO_LIMIT;
  return true;
}
if (("" + nativePromiseThen).indexOf("[native code]") === -1) {
  incrementExpectedAwaits = decrementExpectedAwaits = nop2;
}
function onPossibleParallellAsync(possiblePromise) {
  if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {
    incrementExpectedAwaits();
    return possiblePromise.then((x) => {
      decrementExpectedAwaits();
      return x;
    }, (e) => {
      decrementExpectedAwaits();
      return rejection(e);
    });
  }
  return possiblePromise;
}
function zoneEnterEcho(targetZone) {
  ++totalEchoes;
  if (!task.echoes || --task.echoes === 0) {
    task.echoes = task.id = 0;
  }
  zoneStack.push(PSD);
  switchToZone(targetZone, true);
}
function zoneLeaveEcho() {
  var zone = zoneStack[zoneStack.length - 1];
  zoneStack.pop();
  switchToZone(zone, false);
}
function switchToZone(targetZone, bEnteringZone) {
  var currentZone = PSD;
  if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {
    enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);
  }
  if (targetZone === PSD)
    return;
  PSD = targetZone;
  if (currentZone === globalPSD)
    globalPSD.env = snapShot();
  if (patchGlobalPromise) {
    var GlobalPromise = globalPSD.env.Promise;
    var targetEnv = targetZone.env;
    nativePromiseProto.then = targetEnv.nthen;
    GlobalPromise.prototype.then = targetEnv.gthen;
    if (currentZone.global || targetZone.global) {
      Object.defineProperty(_global, "Promise", targetEnv.PromiseProp);
      GlobalPromise.all = targetEnv.all;
      GlobalPromise.race = targetEnv.race;
      GlobalPromise.resolve = targetEnv.resolve;
      GlobalPromise.reject = targetEnv.reject;
      if (targetEnv.allSettled)
        GlobalPromise.allSettled = targetEnv.allSettled;
      if (targetEnv.any)
        GlobalPromise.any = targetEnv.any;
    }
  }
}
function snapShot() {
  var GlobalPromise = _global.Promise;
  return patchGlobalPromise ? {
    Promise: GlobalPromise,
    PromiseProp: Object.getOwnPropertyDescriptor(_global, "Promise"),
    all: GlobalPromise.all,
    race: GlobalPromise.race,
    allSettled: GlobalPromise.allSettled,
    any: GlobalPromise.any,
    resolve: GlobalPromise.resolve,
    reject: GlobalPromise.reject,
    nthen: nativePromiseProto.then,
    gthen: GlobalPromise.prototype.then
  } : {};
}
function usePSD(psd, fn, a1, a2, a3) {
  var outerScope = PSD;
  try {
    switchToZone(psd, true);
    return fn(a1, a2, a3);
  } finally {
    switchToZone(outerScope, false);
  }
}
function enqueueNativeMicroTask(job) {
  nativePromiseThen.call(resolvedNativePromise, job);
}
function nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {
  return typeof fn !== "function" ? fn : function() {
    var outerZone = PSD;
    if (possibleAwait)
      incrementExpectedAwaits();
    switchToZone(zone, true);
    try {
      return fn.apply(this, arguments);
    } finally {
      switchToZone(outerZone, false);
      if (cleanup)
        enqueueNativeMicroTask(decrementExpectedAwaits);
    }
  };
}
function getPatchedPromiseThen(origThen, zone) {
  return function(onResolved, onRejected) {
    return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));
  };
}
var UNHANDLEDREJECTION = "unhandledrejection";
function globalError(err, promise) {
  var rv;
  try {
    rv = promise.onuncatched(err);
  } catch (e) {
  }
  if (rv !== false)
    try {
      var event, eventData = { promise, reason: err };
      if (_global.document && document.createEvent) {
        event = document.createEvent("Event");
        event.initEvent(UNHANDLEDREJECTION, true, true);
        extend(event, eventData);
      } else if (_global.CustomEvent) {
        event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });
        extend(event, eventData);
      }
      if (event && _global.dispatchEvent) {
        dispatchEvent(event);
        if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)
          try {
            _global.onunhandledrejection(event);
          } catch (_) {
          }
      }
      if (debug && event && !event.defaultPrevented) {
        console.warn(`Unhandled rejection: ${err.stack || err}`);
      }
    } catch (e) {
    }
}
var rejection = DexiePromise.reject;
function tempTransaction(db, mode, storeNames, fn) {
  if (!db.idbdb || !db._state.openComplete && (!PSD.letThrough && !db._vip)) {
    if (db._state.openComplete) {
      return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));
    }
    if (!db._state.isBeingOpened) {
      if (!db._options.autoOpen)
        return rejection(new exceptions.DatabaseClosed());
      db.open().catch(nop2);
    }
    return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));
  } else {
    var trans = db._createTransaction(mode, storeNames, db._dbSchema);
    try {
      trans.create();
      db._state.PR1398_maxLoop = 3;
    } catch (ex) {
      if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
        console.warn("Dexie: Need to reopen db");
        db._close();
        return db.open().then(() => tempTransaction(db, mode, storeNames, fn));
      }
      return rejection(ex);
    }
    return trans._promise(mode, (resolve2, reject2) => {
      return newScope(() => {
        PSD.trans = trans;
        return fn(resolve2, reject2, trans);
      });
    }).then((result) => {
      return trans._completion.then(() => result);
    });
  }
}
var DEXIE_VERSION = "3.2.7";
var maxString = String.fromCharCode(65535);
var minKey = -Infinity;
var INVALID_KEY_ARGUMENT = "Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.";
var STRING_EXPECTED = "String expected.";
var connections = [];
var isIEOrEdge = typeof navigator !== "undefined" && /(MSIE|Trident|Edge)/.test(navigator.userAgent);
var hasIEDeleteObjectStoreBug = isIEOrEdge;
var hangsOnDeleteLargeKeyRange = isIEOrEdge;
var dexieStackFrameFilter = (frame) => !/(dexie\.js|dexie\.min\.js)/.test(frame);
var DBNAMES_DB = "__dbnames";
var READONLY = "readonly";
var READWRITE = "readwrite";
function combine(filter1, filter2) {
  return filter1 ? filter2 ? function() {
    return filter1.apply(this, arguments) && filter2.apply(this, arguments);
  } : filter1 : filter2;
}
var AnyRange = {
  type: 3,
  lower: -Infinity,
  lowerOpen: false,
  upper: [[]],
  upperOpen: false
};
function workaroundForUndefinedPrimKey(keyPath) {
  return typeof keyPath === "string" && !/\./.test(keyPath) ? (obj) => {
    if (obj[keyPath] === void 0 && keyPath in obj) {
      obj = deepClone(obj);
      delete obj[keyPath];
    }
    return obj;
  } : (obj) => obj;
}
var Table = class {
  _trans(mode, fn, writeLocked) {
    const trans = this._tx || PSD.trans;
    const tableName = this.name;
    function checkTableInTransaction(resolve2, reject2, trans2) {
      if (!trans2.schema[tableName])
        throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
      return fn(trans2.idbtrans, trans2);
    }
    const wasRootExec = beginMicroTickScope();
    try {
      return trans && trans.db === this.db ? trans === PSD.trans ? trans._promise(mode, checkTableInTransaction, writeLocked) : newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans, transless: PSD.transless || PSD }) : tempTransaction(this.db, mode, [this.name], checkTableInTransaction);
    } finally {
      if (wasRootExec)
        endMicroTickScope();
    }
  }
  get(keyOrCrit, cb) {
    if (keyOrCrit && keyOrCrit.constructor === Object)
      return this.where(keyOrCrit).first(cb);
    return this._trans("readonly", (trans) => {
      return this.core.get({ trans, key: keyOrCrit }).then((res) => this.hook.reading.fire(res));
    }).then(cb);
  }
  where(indexOrCrit) {
    if (typeof indexOrCrit === "string")
      return new this.db.WhereClause(this, indexOrCrit);
    if (isArray2(indexOrCrit))
      return new this.db.WhereClause(this, `[${indexOrCrit.join("+")}]`);
    const keyPaths = keys2(indexOrCrit);
    if (keyPaths.length === 1)
      return this.where(keyPaths[0]).equals(indexOrCrit[keyPaths[0]]);
    const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter((ix) => {
      if (ix.compound && keyPaths.every((keyPath) => ix.keyPath.indexOf(keyPath) >= 0)) {
        for (let i = 0; i < keyPaths.length; ++i) {
          if (keyPaths.indexOf(ix.keyPath[i]) === -1)
            return false;
        }
        return true;
      }
      return false;
    }).sort((a, b) => a.keyPath.length - b.keyPath.length)[0];
    if (compoundIndex && this.db._maxKey !== maxString) {
      const keyPathsInValidOrder = compoundIndex.keyPath.slice(0, keyPaths.length);
      return this.where(keyPathsInValidOrder).equals(keyPathsInValidOrder.map((kp) => indexOrCrit[kp]));
    }
    if (!compoundIndex && debug)
      console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a compound index [${keyPaths.join("+")}]`);
    const { idxByName } = this.schema;
    const idb = this.db._deps.indexedDB;
    function equals(a, b) {
      try {
        return idb.cmp(a, b) === 0;
      } catch (e) {
        return false;
      }
    }
    const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {
      const index = idxByName[keyPath];
      const value = indexOrCrit[keyPath];
      return [
        prevIndex || index,
        prevIndex || !index ? combine(prevFilterFn, index && index.multi ? (x) => {
          const prop = getByKeyPath(x, keyPath);
          return isArray2(prop) && prop.some((item) => equals(value, item));
        } : (x) => equals(value, getByKeyPath(x, keyPath))) : prevFilterFn
      ];
    }, [null, null]);
    return idx ? this.where(idx.name).equals(indexOrCrit[idx.keyPath]).filter(filterFunction) : compoundIndex ? this.filter(filterFunction) : this.where(keyPaths).equals("");
  }
  filter(filterFunction) {
    return this.toCollection().and(filterFunction);
  }
  count(thenShortcut) {
    return this.toCollection().count(thenShortcut);
  }
  offset(offset) {
    return this.toCollection().offset(offset);
  }
  limit(numRows) {
    return this.toCollection().limit(numRows);
  }
  each(callback) {
    return this.toCollection().each(callback);
  }
  toArray(thenShortcut) {
    return this.toCollection().toArray(thenShortcut);
  }
  toCollection() {
    return new this.db.Collection(new this.db.WhereClause(this));
  }
  orderBy(index) {
    return new this.db.Collection(new this.db.WhereClause(this, isArray2(index) ? `[${index.join("+")}]` : index));
  }
  reverse() {
    return this.toCollection().reverse();
  }
  mapToClass(constructor) {
    this.schema.mappedClass = constructor;
    const readHook = (obj) => {
      if (!obj)
        return obj;
      const res = Object.create(constructor.prototype);
      for (var m in obj)
        if (hasOwn(obj, m))
          try {
            res[m] = obj[m];
          } catch (_) {
          }
      return res;
    };
    if (this.schema.readHook) {
      this.hook.reading.unsubscribe(this.schema.readHook);
    }
    this.schema.readHook = readHook;
    this.hook("reading", readHook);
    return constructor;
  }
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return this.mapToClass(Class);
  }
  add(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "add", keys: key != null ? [key] : null, values: [objToAdd] });
    }).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  update(keyOrObject, modifications) {
    if (typeof keyOrObject === "object" && !isArray2(keyOrObject)) {
      const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);
      if (key === void 0)
        return rejection(new exceptions.InvalidArgument("Given object does not contain its primary key"));
      try {
        if (typeof modifications !== "function") {
          keys2(modifications).forEach((keyPath) => {
            setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);
          });
        } else {
          modifications(keyOrObject, { value: keyOrObject, primKey: key });
        }
      } catch (_a) {
      }
      return this.where(":id").equals(key).modify(modifications);
    } else {
      return this.where(":id").equals(keyOrObject).modify(modifications);
    }
  }
  put(obj, key) {
    const { auto, keyPath } = this.schema.primKey;
    let objToAdd = obj;
    if (keyPath && auto) {
      objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);
    }
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "put", values: [objToAdd], keys: key != null ? [key] : null })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult).then((lastResult) => {
      if (keyPath) {
        try {
          setByKeyPath(obj, keyPath, lastResult);
        } catch (_) {
        }
      }
      return lastResult;
    });
  }
  delete(key) {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "delete", keys: [key] })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  clear() {
    return this._trans("readwrite", (trans) => this.core.mutate({ trans, type: "deleteRange", range: AnyRange })).then((res) => res.numFailures ? DexiePromise.reject(res.failures[0]) : void 0);
  }
  bulkGet(keys3) {
    return this._trans("readonly", (trans) => {
      return this.core.getMany({
        keys: keys3,
        trans
      }).then((result) => result.map((res) => this.hook.reading.fire(res)));
    });
  }
  bulkAdd(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkAdd(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToAdd = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "add", keys: keys3, values: objectsToAdd, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkPut(objects, keysOrOptions, options) {
    const keys3 = Array.isArray(keysOrOptions) ? keysOrOptions : void 0;
    options = options || (keys3 ? void 0 : keysOrOptions);
    const wantResults = options ? options.allKeys : void 0;
    return this._trans("readwrite", (trans) => {
      const { auto, keyPath } = this.schema.primKey;
      if (keyPath && keys3)
        throw new exceptions.InvalidArgument("bulkPut(): keys argument invalid on tables with inbound keys");
      if (keys3 && keys3.length !== objects.length)
        throw new exceptions.InvalidArgument("Arguments objects and keys must have the same length");
      const numObjects = objects.length;
      let objectsToPut = keyPath && auto ? objects.map(workaroundForUndefinedPrimKey(keyPath)) : objects;
      return this.core.mutate({ trans, type: "put", keys: keys3, values: objectsToPut, wantResults }).then(({ numFailures, results, lastResult, failures }) => {
        const result = wantResults ? results : lastResult;
        if (numFailures === 0)
          return result;
        throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);
      });
    });
  }
  bulkDelete(keys3) {
    const numKeys = keys3.length;
    return this._trans("readwrite", (trans) => {
      return this.core.mutate({ trans, type: "delete", keys: keys3 });
    }).then(({ numFailures, lastResult, failures }) => {
      if (numFailures === 0)
        return lastResult;
      throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);
    });
  }
};
function Events(ctx) {
  var evs = {};
  var rv = function(eventName, subscriber) {
    if (subscriber) {
      var i2 = arguments.length, args2 = new Array(i2 - 1);
      while (--i2)
        args2[i2 - 1] = arguments[i2];
      evs[eventName].subscribe.apply(null, args2);
      return ctx;
    } else if (typeof eventName === "string") {
      return evs[eventName];
    }
  };
  rv.addEventType = add2;
  for (var i = 1, l = arguments.length; i < l; ++i) {
    add2(arguments[i]);
  }
  return rv;
  function add2(eventName, chainFunction, defaultFunction) {
    if (typeof eventName === "object")
      return addConfiguredEvents(eventName);
    if (!chainFunction)
      chainFunction = reverseStoppableEventChain;
    if (!defaultFunction)
      defaultFunction = nop2;
    var context = {
      subscribers: [],
      fire: defaultFunction,
      subscribe: function(cb) {
        if (context.subscribers.indexOf(cb) === -1) {
          context.subscribers.push(cb);
          context.fire = chainFunction(context.fire, cb);
        }
      },
      unsubscribe: function(cb) {
        context.subscribers = context.subscribers.filter(function(fn) {
          return fn !== cb;
        });
        context.fire = context.subscribers.reduce(chainFunction, defaultFunction);
      }
    };
    evs[eventName] = rv[eventName] = context;
    return context;
  }
  function addConfiguredEvents(cfg) {
    keys2(cfg).forEach(function(eventName) {
      var args2 = cfg[eventName];
      if (isArray2(args2)) {
        add2(eventName, cfg[eventName][0], cfg[eventName][1]);
      } else if (args2 === "asap") {
        var context = add2(eventName, mirror, function fire() {
          var i2 = arguments.length, args3 = new Array(i2);
          while (i2--)
            args3[i2] = arguments[i2];
          context.subscribers.forEach(function(fn) {
            asap$1(function fireEvent() {
              fn.apply(null, args3);
            });
          });
        });
      } else
        throw new exceptions.InvalidArgument("Invalid event config");
    });
  }
}
function makeClassConstructor(prototype, constructor) {
  derive(constructor).from({ prototype });
  return constructor;
}
function createTableConstructor(db) {
  return makeClassConstructor(Table.prototype, function Table3(name, tableSchema, trans) {
    this.db = db;
    this._tx = trans;
    this.name = name;
    this.schema = tableSchema;
    this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {
      "creating": [hookCreatingChain, nop2],
      "reading": [pureFunctionChain, mirror],
      "updating": [hookUpdatingChain, nop2],
      "deleting": [hookDeletingChain, nop2]
    });
  });
}
function isPlainKeyRange(ctx, ignoreLimitFilter) {
  return !(ctx.filter || ctx.algorithm || ctx.or) && (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);
}
function addFilter(ctx, fn) {
  ctx.filter = combine(ctx.filter, fn);
}
function addReplayFilter(ctx, factory, isLimitFilter) {
  var curr = ctx.replayFilter;
  ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;
  ctx.justLimit = isLimitFilter && !curr;
}
function addMatchFilter(ctx, fn) {
  ctx.isMatch = combine(ctx.isMatch, fn);
}
function getIndexOrStore(ctx, coreSchema) {
  if (ctx.isPrimKey)
    return coreSchema.primaryKey;
  const index = coreSchema.getIndexByKeyPath(ctx.index);
  if (!index)
    throw new exceptions.Schema("KeyPath " + ctx.index + " on object store " + coreSchema.name + " is not indexed");
  return index;
}
function openCursor(ctx, coreTable, trans) {
  const index = getIndexOrStore(ctx, coreTable.schema);
  return coreTable.openCursor({
    trans,
    values: !ctx.keysOnly,
    reverse: ctx.dir === "prev",
    unique: !!ctx.unique,
    query: {
      index,
      range: ctx.range
    }
  });
}
function iter(ctx, fn, coreTrans, coreTable) {
  const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;
  if (!ctx.or) {
    return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);
  } else {
    const set = {};
    const union = (item, cursor, advance) => {
      if (!filter || filter(cursor, advance, (result) => cursor.stop(result), (err) => cursor.fail(err))) {
        var primaryKey = cursor.primaryKey;
        var key = "" + primaryKey;
        if (key === "[object ArrayBuffer]")
          key = "" + new Uint8Array(primaryKey);
        if (!hasOwn(set, key)) {
          set[key] = true;
          fn(item, cursor, advance);
        }
      }
    };
    return Promise.all([
      ctx.or._iterate(union, coreTrans),
      iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)
    ]);
  }
}
function iterate(cursorPromise, filter, fn, valueMapper) {
  var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;
  var wrappedFn = wrap(mappedFn);
  return cursorPromise.then((cursor) => {
    if (cursor) {
      return cursor.start(() => {
        var c = () => cursor.continue();
        if (!filter || filter(cursor, (advancer) => c = advancer, (val) => {
          cursor.stop(val);
          c = nop2;
        }, (e) => {
          cursor.fail(e);
          c = nop2;
        }))
          wrappedFn(cursor.value, cursor, (advancer) => c = advancer);
        c();
      });
    }
  });
}
function cmp(a, b) {
  try {
    const ta = type(a);
    const tb = type(b);
    if (ta !== tb) {
      if (ta === "Array")
        return 1;
      if (tb === "Array")
        return -1;
      if (ta === "binary")
        return 1;
      if (tb === "binary")
        return -1;
      if (ta === "string")
        return 1;
      if (tb === "string")
        return -1;
      if (ta === "Date")
        return 1;
      if (tb !== "Date")
        return NaN;
      return -1;
    }
    switch (ta) {
      case "number":
      case "Date":
      case "string":
        return a > b ? 1 : a < b ? -1 : 0;
      case "binary": {
        return compareUint8Arrays(getUint8Array(a), getUint8Array(b));
      }
      case "Array":
        return compareArrays(a, b);
    }
  } catch (_a) {
  }
  return NaN;
}
function compareArrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    const res = cmp(a[i], b[i]);
    if (res !== 0)
      return res;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function compareUint8Arrays(a, b) {
  const al = a.length;
  const bl = b.length;
  const l = al < bl ? al : bl;
  for (let i = 0; i < l; ++i) {
    if (a[i] !== b[i])
      return a[i] < b[i] ? -1 : 1;
  }
  return al === bl ? 0 : al < bl ? -1 : 1;
}
function type(x) {
  const t = typeof x;
  if (t !== "object")
    return t;
  if (ArrayBuffer.isView(x))
    return "binary";
  const tsTag = toStringTag(x);
  return tsTag === "ArrayBuffer" ? "binary" : tsTag;
}
function getUint8Array(a) {
  if (a instanceof Uint8Array)
    return a;
  if (ArrayBuffer.isView(a))
    return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);
  return new Uint8Array(a);
}
var Collection = class {
  _read(fn, cb) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readonly", fn).then(cb);
  }
  _write(fn) {
    var ctx = this._ctx;
    return ctx.error ? ctx.table._trans(null, rejection.bind(null, ctx.error)) : ctx.table._trans("readwrite", fn, "locked");
  }
  _addAlgorithm(fn) {
    var ctx = this._ctx;
    ctx.algorithm = combine(ctx.algorithm, fn);
  }
  _iterate(fn, coreTrans) {
    return iter(this._ctx, fn, coreTrans, this._ctx.table.core);
  }
  clone(props2) {
    var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);
    if (props2)
      extend(ctx, props2);
    rv._ctx = ctx;
    return rv;
  }
  raw() {
    this._ctx.valueMapper = null;
    return this;
  }
  each(fn) {
    var ctx = this._ctx;
    return this._read((trans) => iter(ctx, fn, trans, ctx.table.core));
  }
  count(cb) {
    return this._read((trans) => {
      const ctx = this._ctx;
      const coreTable = ctx.table.core;
      if (isPlainKeyRange(ctx, true)) {
        return coreTable.count({
          trans,
          query: {
            index: getIndexOrStore(ctx, coreTable.schema),
            range: ctx.range
          }
        }).then((count3) => Math.min(count3, ctx.limit));
      } else {
        var count2 = 0;
        return iter(ctx, () => {
          ++count2;
          return false;
        }, trans, coreTable).then(() => count2);
      }
    }).then(cb);
  }
  sortBy(keyPath, cb) {
    const parts = keyPath.split(".").reverse(), lastPart = parts[0], lastIndex = parts.length - 1;
    function getval(obj, i) {
      if (i)
        return getval(obj[parts[i]], i - 1);
      return obj[lastPart];
    }
    var order = this._ctx.dir === "next" ? 1 : -1;
    function sorter(a, b) {
      var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);
      return aVal < bVal ? -order : aVal > bVal ? order : 0;
    }
    return this.toArray(function(a) {
      return a.sort(sorter);
    }).then(cb);
  }
  toArray(cb) {
    return this._read((trans) => {
      var ctx = this._ctx;
      if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
        const { valueMapper } = ctx;
        const index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          limit: ctx.limit,
          values: true,
          query: {
            index,
            range: ctx.range
          }
        }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);
      } else {
        const a = [];
        return iter(ctx, (item) => a.push(item), trans, ctx.table.core).then(() => a);
      }
    }, cb);
  }
  offset(offset) {
    var ctx = this._ctx;
    if (offset <= 0)
      return this;
    ctx.offset += offset;
    if (isPlainKeyRange(ctx)) {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return (cursor, advance) => {
          if (offsetLeft === 0)
            return true;
          if (offsetLeft === 1) {
            --offsetLeft;
            return false;
          }
          advance(() => {
            cursor.advance(offsetLeft);
            offsetLeft = 0;
          });
          return false;
        };
      });
    } else {
      addReplayFilter(ctx, () => {
        var offsetLeft = offset;
        return () => --offsetLeft < 0;
      });
    }
    return this;
  }
  limit(numRows) {
    this._ctx.limit = Math.min(this._ctx.limit, numRows);
    addReplayFilter(this._ctx, () => {
      var rowsLeft = numRows;
      return function(cursor, advance, resolve2) {
        if (--rowsLeft <= 0)
          advance(resolve2);
        return rowsLeft >= 0;
      };
    }, true);
    return this;
  }
  until(filterFunction, bIncludeStopEntry) {
    addFilter(this._ctx, function(cursor, advance, resolve2) {
      if (filterFunction(cursor.value)) {
        advance(resolve2);
        return bIncludeStopEntry;
      } else {
        return true;
      }
    });
    return this;
  }
  first(cb) {
    return this.limit(1).toArray(function(a) {
      return a[0];
    }).then(cb);
  }
  last(cb) {
    return this.reverse().first(cb);
  }
  filter(filterFunction) {
    addFilter(this._ctx, function(cursor) {
      return filterFunction(cursor.value);
    });
    addMatchFilter(this._ctx, filterFunction);
    return this;
  }
  and(filter) {
    return this.filter(filter);
  }
  or(indexName) {
    return new this.db.WhereClause(this._ctx.table, indexName, this);
  }
  reverse() {
    this._ctx.dir = this._ctx.dir === "prev" ? "next" : "prev";
    if (this._ondirectionchange)
      this._ondirectionchange(this._ctx.dir);
    return this;
  }
  desc() {
    return this.reverse();
  }
  eachKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.key, cursor);
    });
  }
  eachUniqueKey(cb) {
    this._ctx.unique = "unique";
    return this.eachKey(cb);
  }
  eachPrimaryKey(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    return this.each(function(val, cursor) {
      cb(cursor.primaryKey, cursor);
    });
  }
  keys(cb) {
    var ctx = this._ctx;
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.key);
    }).then(function() {
      return a;
    }).then(cb);
  }
  primaryKeys(cb) {
    var ctx = this._ctx;
    if (ctx.dir === "next" && isPlainKeyRange(ctx, true) && ctx.limit > 0) {
      return this._read((trans) => {
        var index = getIndexOrStore(ctx, ctx.table.core.schema);
        return ctx.table.core.query({
          trans,
          values: false,
          limit: ctx.limit,
          query: {
            index,
            range: ctx.range
          }
        });
      }).then(({ result }) => result).then(cb);
    }
    ctx.keysOnly = !ctx.isMatch;
    var a = [];
    return this.each(function(item, cursor) {
      a.push(cursor.primaryKey);
    }).then(function() {
      return a;
    }).then(cb);
  }
  uniqueKeys(cb) {
    this._ctx.unique = "unique";
    return this.keys(cb);
  }
  firstKey(cb) {
    return this.limit(1).keys(function(a) {
      return a[0];
    }).then(cb);
  }
  lastKey(cb) {
    return this.reverse().firstKey(cb);
  }
  distinct() {
    var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];
    if (!idx || !idx.multi)
      return this;
    var set = {};
    addFilter(this._ctx, function(cursor) {
      var strKey = cursor.primaryKey.toString();
      var found = hasOwn(set, strKey);
      set[strKey] = true;
      return !found;
    });
    return this;
  }
  modify(changes) {
    var ctx = this._ctx;
    return this._write((trans) => {
      var modifyer;
      if (typeof changes === "function") {
        modifyer = changes;
      } else {
        var keyPaths = keys2(changes);
        var numKeys = keyPaths.length;
        modifyer = function(item) {
          var anythingModified = false;
          for (var i = 0; i < numKeys; ++i) {
            var keyPath = keyPaths[i], val = changes[keyPath];
            if (getByKeyPath(item, keyPath) !== val) {
              setByKeyPath(item, keyPath, val);
              anythingModified = true;
            }
          }
          return anythingModified;
        };
      }
      const coreTable = ctx.table.core;
      const { outbound, extractKey } = coreTable.schema.primaryKey;
      const limit = this.db._options.modifyChunkSize || 200;
      const totalFailures = [];
      let successCount = 0;
      const failedKeys = [];
      const applyMutateResult = (expectedCount, res) => {
        const { failures, numFailures } = res;
        successCount += expectedCount - numFailures;
        for (let pos of keys2(failures)) {
          totalFailures.push(failures[pos]);
        }
      };
      return this.clone().primaryKeys().then((keys3) => {
        const nextChunk = (offset) => {
          const count2 = Math.min(limit, keys3.length - offset);
          return coreTable.getMany({
            trans,
            keys: keys3.slice(offset, offset + count2),
            cache: "immutable"
          }).then((values) => {
            const addValues = [];
            const putValues = [];
            const putKeys = outbound ? [] : null;
            const deleteKeys = [];
            for (let i = 0; i < count2; ++i) {
              const origValue = values[i];
              const ctx2 = {
                value: deepClone(origValue),
                primKey: keys3[offset + i]
              };
              if (modifyer.call(ctx2, ctx2.value, ctx2) !== false) {
                if (ctx2.value == null) {
                  deleteKeys.push(keys3[offset + i]);
                } else if (!outbound && cmp(extractKey(origValue), extractKey(ctx2.value)) !== 0) {
                  deleteKeys.push(keys3[offset + i]);
                  addValues.push(ctx2.value);
                } else {
                  putValues.push(ctx2.value);
                  if (outbound)
                    putKeys.push(keys3[offset + i]);
                }
              }
            }
            const criteria = isPlainKeyRange(ctx) && ctx.limit === Infinity && (typeof changes !== "function" || changes === deleteCallback) && {
              index: ctx.index,
              range: ctx.range
            };
            return Promise.resolve(addValues.length > 0 && coreTable.mutate({ trans, type: "add", values: addValues }).then((res) => {
              for (let pos in res.failures) {
                deleteKeys.splice(parseInt(pos), 1);
              }
              applyMutateResult(addValues.length, res);
            })).then(() => (putValues.length > 0 || criteria && typeof changes === "object") && coreTable.mutate({
              trans,
              type: "put",
              keys: putKeys,
              values: putValues,
              criteria,
              changeSpec: typeof changes !== "function" && changes
            }).then((res) => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || criteria && changes === deleteCallback) && coreTable.mutate({
              trans,
              type: "delete",
              keys: deleteKeys,
              criteria
            }).then((res) => applyMutateResult(deleteKeys.length, res))).then(() => {
              return keys3.length > offset + count2 && nextChunk(offset + limit);
            });
          });
        };
        return nextChunk(0).then(() => {
          if (totalFailures.length > 0)
            throw new ModifyError("Error modifying one or more objects", totalFailures, successCount, failedKeys);
          return keys3.length;
        });
      });
    });
  }
  delete() {
    var ctx = this._ctx, range = ctx.range;
    if (isPlainKeyRange(ctx) && (ctx.isPrimKey && !hangsOnDeleteLargeKeyRange || range.type === 3)) {
      return this._write((trans) => {
        const { primaryKey } = ctx.table.core.schema;
        const coreRange = range;
        return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then((count2) => {
          return ctx.table.core.mutate({ trans, type: "deleteRange", range: coreRange }).then(({ failures, lastResult, results, numFailures }) => {
            if (numFailures)
              throw new ModifyError("Could not delete some values", Object.keys(failures).map((pos) => failures[pos]), count2 - numFailures);
            return count2 - numFailures;
          });
        });
      });
    }
    return this.modify(deleteCallback);
  }
};
var deleteCallback = (value, ctx) => ctx.value = null;
function createCollectionConstructor(db) {
  return makeClassConstructor(Collection.prototype, function Collection2(whereClause, keyRangeGenerator) {
    this.db = db;
    let keyRange = AnyRange, error = null;
    if (keyRangeGenerator)
      try {
        keyRange = keyRangeGenerator();
      } catch (ex) {
        error = ex;
      }
    const whereCtx = whereClause._ctx;
    const table = whereCtx.table;
    const readingHook = table.hook.reading.fire;
    this._ctx = {
      table,
      index: whereCtx.index,
      isPrimKey: !whereCtx.index || table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name,
      range: keyRange,
      keysOnly: false,
      dir: "next",
      unique: "",
      algorithm: null,
      filter: null,
      replayFilter: null,
      justLimit: true,
      isMatch: null,
      offset: 0,
      limit: Infinity,
      error,
      or: whereCtx.or,
      valueMapper: readingHook !== mirror ? readingHook : null
    };
  });
}
function simpleCompare(a, b) {
  return a < b ? -1 : a === b ? 0 : 1;
}
function simpleCompareReverse(a, b) {
  return a > b ? -1 : a === b ? 0 : 1;
}
function fail(collectionOrWhereClause, err, T) {
  var collection = collectionOrWhereClause instanceof WhereClause ? new collectionOrWhereClause.Collection(collectionOrWhereClause) : collectionOrWhereClause;
  collection._ctx.error = T ? new T(err) : new TypeError(err);
  return collection;
}
function emptyCollection(whereClause) {
  return new whereClause.Collection(whereClause, () => rangeEqual("")).limit(0);
}
function upperFactory(dir) {
  return dir === "next" ? (s) => s.toUpperCase() : (s) => s.toLowerCase();
}
function lowerFactory(dir) {
  return dir === "next" ? (s) => s.toLowerCase() : (s) => s.toUpperCase();
}
function nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp2, dir) {
  var length3 = Math.min(key.length, lowerNeedle.length);
  var llp = -1;
  for (var i = 0; i < length3; ++i) {
    var lwrKeyChar = lowerKey[i];
    if (lwrKeyChar !== lowerNeedle[i]) {
      if (cmp2(key[i], upperNeedle[i]) < 0)
        return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);
      if (cmp2(key[i], lowerNeedle[i]) < 0)
        return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);
      if (llp >= 0)
        return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);
      return null;
    }
    if (cmp2(key[i], lwrKeyChar) < 0)
      llp = i;
  }
  if (length3 < lowerNeedle.length && dir === "next")
    return key + upperNeedle.substr(key.length);
  if (length3 < key.length && dir === "prev")
    return key.substr(0, upperNeedle.length);
  return llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1);
}
function addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {
  var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;
  if (!needles.every((s) => typeof s === "string")) {
    return fail(whereClause, STRING_EXPECTED);
  }
  function initDirection(dir) {
    upper = upperFactory(dir);
    lower = lowerFactory(dir);
    compare = dir === "next" ? simpleCompare : simpleCompareReverse;
    var needleBounds = needles.map(function(needle) {
      return { lower: lower(needle), upper: upper(needle) };
    }).sort(function(a, b) {
      return compare(a.lower, b.lower);
    });
    upperNeedles = needleBounds.map(function(nb) {
      return nb.upper;
    });
    lowerNeedles = needleBounds.map(function(nb) {
      return nb.lower;
    });
    direction = dir;
    nextKeySuffix = dir === "next" ? "" : suffix;
  }
  initDirection("next");
  var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));
  c._ondirectionchange = function(direction2) {
    initDirection(direction2);
  };
  var firstPossibleNeedle = 0;
  c._addAlgorithm(function(cursor, advance, resolve2) {
    var key = cursor.key;
    if (typeof key !== "string")
      return false;
    var lowerKey = lower(key);
    if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {
      return true;
    } else {
      var lowestPossibleCasing = null;
      for (var i = firstPossibleNeedle; i < needlesLen; ++i) {
        var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);
        if (casing === null && lowestPossibleCasing === null)
          firstPossibleNeedle = i + 1;
        else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {
          lowestPossibleCasing = casing;
        }
      }
      if (lowestPossibleCasing !== null) {
        advance(function() {
          cursor.continue(lowestPossibleCasing + nextKeySuffix);
        });
      } else {
        advance(resolve2);
      }
      return false;
    }
  });
  return c;
}
function createRange(lower, upper, lowerOpen, upperOpen) {
  return {
    type: 2,
    lower,
    upper,
    lowerOpen,
    upperOpen
  };
}
function rangeEqual(value) {
  return {
    type: 1,
    lower: value,
    upper: value
  };
}
var WhereClause = class {
  get Collection() {
    return this._ctx.table.db.Collection;
  }
  between(lower, upper, includeLower, includeUpper) {
    includeLower = includeLower !== false;
    includeUpper = includeUpper === true;
    try {
      if (this._cmp(lower, upper) > 0 || this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper))
        return emptyCollection(this);
      return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
  }
  equals(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => rangeEqual(value));
  }
  above(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, true));
  }
  aboveOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(value, void 0, false));
  }
  below(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value, false, true));
  }
  belowOrEqual(value) {
    if (value == null)
      return fail(this, INVALID_KEY_ARGUMENT);
    return new this.Collection(this, () => createRange(void 0, value));
  }
  startsWith(str) {
    if (typeof str !== "string")
      return fail(this, STRING_EXPECTED);
    return this.between(str, str + maxString, true, true);
  }
  startsWithIgnoreCase(str) {
    if (str === "")
      return this.startsWith(str);
    return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);
  }
  equalsIgnoreCase(str) {
    return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], "");
  }
  anyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, "");
  }
  startsWithAnyOfIgnoreCase() {
    var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return emptyCollection(this);
    return addIgnoreCaseAlgorithm(this, (x, a) => a.some((n) => x.indexOf(n) === 0), set, maxString);
  }
  anyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    let compare = this._cmp;
    try {
      set.sort(compare);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    if (set.length === 0)
      return emptyCollection(this);
    const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));
    c._ondirectionchange = (direction) => {
      compare = direction === "next" ? this._ascending : this._descending;
      set.sort(compare);
    };
    let i = 0;
    c._addAlgorithm((cursor, advance, resolve2) => {
      const key = cursor.key;
      while (compare(key, set[i]) > 0) {
        ++i;
        if (i === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (compare(key, set[i]) === 0) {
        return true;
      } else {
        advance(() => {
          cursor.continue(set[i]);
        });
        return false;
      }
    });
    return c;
  }
  notEqual(value) {
    return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });
  }
  noneOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (set.length === 0)
      return new this.Collection(this);
    try {
      set.sort(this._ascending);
    } catch (e) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    const ranges = set.reduce((res, val) => res ? res.concat([[res[res.length - 1][1], val]]) : [[minKey, val]], null);
    ranges.push([set[set.length - 1], this.db._maxKey]);
    return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });
  }
  inAnyRange(ranges, options) {
    const cmp2 = this._cmp, ascending = this._ascending, descending = this._descending, min2 = this._min, max2 = this._max;
    if (ranges.length === 0)
      return emptyCollection(this);
    if (!ranges.every((range) => range[0] !== void 0 && range[1] !== void 0 && ascending(range[0], range[1]) <= 0)) {
      return fail(this, "First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower", exceptions.InvalidArgument);
    }
    const includeLowers = !options || options.includeLowers !== false;
    const includeUppers = options && options.includeUppers === true;
    function addRange2(ranges2, newRange) {
      let i = 0, l = ranges2.length;
      for (; i < l; ++i) {
        const range = ranges2[i];
        if (cmp2(newRange[0], range[1]) < 0 && cmp2(newRange[1], range[0]) > 0) {
          range[0] = min2(range[0], newRange[0]);
          range[1] = max2(range[1], newRange[1]);
          break;
        }
      }
      if (i === l)
        ranges2.push(newRange);
      return ranges2;
    }
    let sortDirection = ascending;
    function rangeSorter(a, b) {
      return sortDirection(a[0], b[0]);
    }
    let set;
    try {
      set = ranges.reduce(addRange2, []);
      set.sort(rangeSorter);
    } catch (ex) {
      return fail(this, INVALID_KEY_ARGUMENT);
    }
    let rangePos = 0;
    const keyIsBeyondCurrentEntry = includeUppers ? (key) => ascending(key, set[rangePos][1]) > 0 : (key) => ascending(key, set[rangePos][1]) >= 0;
    const keyIsBeforeCurrentEntry = includeLowers ? (key) => descending(key, set[rangePos][0]) > 0 : (key) => descending(key, set[rangePos][0]) >= 0;
    function keyWithinCurrentRange(key) {
      return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);
    }
    let checkKey = keyIsBeyondCurrentEntry;
    const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));
    c._ondirectionchange = (direction) => {
      if (direction === "next") {
        checkKey = keyIsBeyondCurrentEntry;
        sortDirection = ascending;
      } else {
        checkKey = keyIsBeforeCurrentEntry;
        sortDirection = descending;
      }
      set.sort(rangeSorter);
    };
    c._addAlgorithm((cursor, advance, resolve2) => {
      var key = cursor.key;
      while (checkKey(key)) {
        ++rangePos;
        if (rangePos === set.length) {
          advance(resolve2);
          return false;
        }
      }
      if (keyWithinCurrentRange(key)) {
        return true;
      } else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {
        return false;
      } else {
        advance(() => {
          if (sortDirection === ascending)
            cursor.continue(set[rangePos][0]);
          else
            cursor.continue(set[rangePos][1]);
        });
        return false;
      }
    });
    return c;
  }
  startsWithAnyOf() {
    const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);
    if (!set.every((s) => typeof s === "string")) {
      return fail(this, "startsWithAnyOf() only works with strings");
    }
    if (set.length === 0)
      return emptyCollection(this);
    return this.inAnyRange(set.map((str) => [str, str + maxString]));
  }
};
function createWhereClauseConstructor(db) {
  return makeClassConstructor(WhereClause.prototype, function WhereClause2(table, index, orCollection) {
    this.db = db;
    this._ctx = {
      table,
      index: index === ":id" ? null : index,
      or: orCollection
    };
    const indexedDB2 = db._deps.indexedDB;
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    this._cmp = this._ascending = indexedDB2.cmp.bind(indexedDB2);
    this._descending = (a, b) => indexedDB2.cmp(b, a);
    this._max = (a, b) => indexedDB2.cmp(a, b) > 0 ? a : b;
    this._min = (a, b) => indexedDB2.cmp(a, b) < 0 ? a : b;
    this._IDBKeyRange = db._deps.IDBKeyRange;
  });
}
function eventRejectHandler(reject2) {
  return wrap(function(event) {
    preventDefault(event);
    reject2(event.target.error);
    return false;
  });
}
function preventDefault(event) {
  if (event.stopPropagation)
    event.stopPropagation();
  if (event.preventDefault)
    event.preventDefault();
}
var DEXIE_STORAGE_MUTATED_EVENT_NAME = "storagemutated";
var STORAGE_MUTATED_DOM_EVENT_NAME = "x-storagemutated-1";
var globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);
var Transaction2 = class {
  _lock() {
    assert(!PSD.global);
    ++this._reculock;
    if (this._reculock === 1 && !PSD.global)
      PSD.lockOwnerFor = this;
    return this;
  }
  _unlock() {
    assert(!PSD.global);
    if (--this._reculock === 0) {
      if (!PSD.global)
        PSD.lockOwnerFor = null;
      while (this._blockedFuncs.length > 0 && !this._locked()) {
        var fnAndPSD = this._blockedFuncs.shift();
        try {
          usePSD(fnAndPSD[1], fnAndPSD[0]);
        } catch (e) {
        }
      }
    }
    return this;
  }
  _locked() {
    return this._reculock && PSD.lockOwnerFor !== this;
  }
  create(idbtrans) {
    if (!this.mode)
      return this;
    const idbdb = this.db.idbdb;
    const dbOpenError = this.db._state.dbOpenError;
    assert(!this.idbtrans);
    if (!idbtrans && !idbdb) {
      switch (dbOpenError && dbOpenError.name) {
        case "DatabaseClosedError":
          throw new exceptions.DatabaseClosed(dbOpenError);
        case "MissingAPIError":
          throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);
        default:
          throw new exceptions.OpenFailed(dbOpenError);
      }
    }
    if (!this.active)
      throw new exceptions.TransactionInactive();
    assert(this._completion._state === null);
    idbtrans = this.idbtrans = idbtrans || (this.db.core ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }) : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));
    idbtrans.onerror = wrap((ev) => {
      preventDefault(ev);
      this._reject(idbtrans.error);
    });
    idbtrans.onabort = wrap((ev) => {
      preventDefault(ev);
      this.active && this._reject(new exceptions.Abort(idbtrans.error));
      this.active = false;
      this.on("abort").fire(ev);
    });
    idbtrans.oncomplete = wrap(() => {
      this.active = false;
      this._resolve();
      if ("mutatedParts" in idbtrans) {
        globalEvents.storagemutated.fire(idbtrans["mutatedParts"]);
      }
    });
    return this;
  }
  _promise(mode, fn, bWriteLock) {
    if (mode === "readwrite" && this.mode !== "readwrite")
      return rejection(new exceptions.ReadOnly("Transaction is readonly"));
    if (!this.active)
      return rejection(new exceptions.TransactionInactive());
    if (this._locked()) {
      return new DexiePromise((resolve2, reject2) => {
        this._blockedFuncs.push([() => {
          this._promise(mode, fn, bWriteLock).then(resolve2, reject2);
        }, PSD]);
      });
    } else if (bWriteLock) {
      return newScope(() => {
        var p2 = new DexiePromise((resolve2, reject2) => {
          this._lock();
          const rv = fn(resolve2, reject2, this);
          if (rv && rv.then)
            rv.then(resolve2, reject2);
        });
        p2.finally(() => this._unlock());
        p2._lib = true;
        return p2;
      });
    } else {
      var p = new DexiePromise((resolve2, reject2) => {
        var rv = fn(resolve2, reject2, this);
        if (rv && rv.then)
          rv.then(resolve2, reject2);
      });
      p._lib = true;
      return p;
    }
  }
  _root() {
    return this.parent ? this.parent._root() : this;
  }
  waitFor(promiseLike) {
    var root = this._root();
    const promise = DexiePromise.resolve(promiseLike);
    if (root._waitingFor) {
      root._waitingFor = root._waitingFor.then(() => promise);
    } else {
      root._waitingFor = promise;
      root._waitingQueue = [];
      var store = root.idbtrans.objectStore(root.storeNames[0]);
      (function spin() {
        ++root._spinCount;
        while (root._waitingQueue.length)
          root._waitingQueue.shift()();
        if (root._waitingFor)
          store.get(-Infinity).onsuccess = spin;
      })();
    }
    var currentWaitPromise = root._waitingFor;
    return new DexiePromise((resolve2, reject2) => {
      promise.then((res) => root._waitingQueue.push(wrap(resolve2.bind(null, res))), (err) => root._waitingQueue.push(wrap(reject2.bind(null, err)))).finally(() => {
        if (root._waitingFor === currentWaitPromise) {
          root._waitingFor = null;
        }
      });
    });
  }
  abort() {
    if (this.active) {
      this.active = false;
      if (this.idbtrans)
        this.idbtrans.abort();
      this._reject(new exceptions.Abort());
    }
  }
  table(tableName) {
    const memoizedTables = this._memoizedTables || (this._memoizedTables = {});
    if (hasOwn(memoizedTables, tableName))
      return memoizedTables[tableName];
    const tableSchema = this.schema[tableName];
    if (!tableSchema) {
      throw new exceptions.NotFound("Table " + tableName + " not part of transaction");
    }
    const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);
    transactionBoundTable.core = this.db.core.table(tableName);
    memoizedTables[tableName] = transactionBoundTable;
    return transactionBoundTable;
  }
};
function createTransactionConstructor(db) {
  return makeClassConstructor(Transaction2.prototype, function Transaction3(mode, storeNames, dbschema, chromeTransactionDurability, parent) {
    this.db = db;
    this.mode = mode;
    this.storeNames = storeNames;
    this.schema = dbschema;
    this.chromeTransactionDurability = chromeTransactionDurability;
    this.idbtrans = null;
    this.on = Events(this, "complete", "error", "abort");
    this.parent = parent || null;
    this.active = true;
    this._reculock = 0;
    this._blockedFuncs = [];
    this._resolve = null;
    this._reject = null;
    this._waitingFor = null;
    this._waitingQueue = null;
    this._spinCount = 0;
    this._completion = new DexiePromise((resolve2, reject2) => {
      this._resolve = resolve2;
      this._reject = reject2;
    });
    this._completion.then(() => {
      this.active = false;
      this.on.complete.fire();
    }, (e) => {
      var wasActive = this.active;
      this.active = false;
      this.on.error.fire(e);
      this.parent ? this.parent._reject(e) : wasActive && this.idbtrans && this.idbtrans.abort();
      return rejection(e);
    });
  });
}
function createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {
  return {
    name,
    keyPath,
    unique,
    multi,
    auto,
    compound,
    src: (unique && !isPrimKey ? "&" : "") + (multi ? "*" : "") + (auto ? "++" : "") + nameFromKeyPath(keyPath)
  };
}
function nameFromKeyPath(keyPath) {
  return typeof keyPath === "string" ? keyPath : keyPath ? "[" + [].join.call(keyPath, "+") + "]" : "";
}
function createTableSchema(name, primKey, indexes) {
  return {
    name,
    primKey,
    indexes,
    mappedClass: null,
    idxByName: arrayToObject(indexes, (index) => [index.name, index])
  };
}
function safariMultiStoreFix(storeNames) {
  return storeNames.length === 1 ? storeNames[0] : storeNames;
}
var getMaxKey = (IdbKeyRange) => {
  try {
    IdbKeyRange.only([[]]);
    getMaxKey = () => [[]];
    return [[]];
  } catch (e) {
    getMaxKey = () => maxString;
    return maxString;
  }
};
function getKeyExtractor(keyPath) {
  if (keyPath == null) {
    return () => void 0;
  } else if (typeof keyPath === "string") {
    return getSinglePathKeyExtractor(keyPath);
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function getSinglePathKeyExtractor(keyPath) {
  const split = keyPath.split(".");
  if (split.length === 1) {
    return (obj) => obj[keyPath];
  } else {
    return (obj) => getByKeyPath(obj, keyPath);
  }
}
function arrayify(arrayLike) {
  return [].slice.call(arrayLike);
}
var _id_counter = 0;
function getKeyPathAlias(keyPath) {
  return keyPath == null ? ":id" : typeof keyPath === "string" ? keyPath : `[${keyPath.join("+")}]`;
}
function createDBCore(db, IdbKeyRange, tmpTrans) {
  function extractSchema(db2, trans) {
    const tables2 = arrayify(db2.objectStoreNames);
    return {
      schema: {
        name: db2.name,
        tables: tables2.map((table) => trans.objectStore(table)).map((store) => {
          const { keyPath, autoIncrement } = store;
          const compound = isArray2(keyPath);
          const outbound = keyPath == null;
          const indexByKeyPath = {};
          const result = {
            name: store.name,
            primaryKey: {
              name: null,
              isPrimaryKey: true,
              outbound,
              compound,
              keyPath,
              autoIncrement,
              unique: true,
              extractKey: getKeyExtractor(keyPath)
            },
            indexes: arrayify(store.indexNames).map((indexName) => store.index(indexName)).map((index) => {
              const { name, unique, multiEntry, keyPath: keyPath2 } = index;
              const compound2 = isArray2(keyPath2);
              const result2 = {
                name,
                compound: compound2,
                keyPath: keyPath2,
                unique,
                multiEntry,
                extractKey: getKeyExtractor(keyPath2)
              };
              indexByKeyPath[getKeyPathAlias(keyPath2)] = result2;
              return result2;
            }),
            getIndexByKeyPath: (keyPath2) => indexByKeyPath[getKeyPathAlias(keyPath2)]
          };
          indexByKeyPath[":id"] = result.primaryKey;
          if (keyPath != null) {
            indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;
          }
          return result;
        })
      },
      hasGetAll: tables2.length > 0 && "getAll" in trans.objectStore(tables2[0]) && !(typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604)
    };
  }
  function makeIDBKeyRange(range) {
    if (range.type === 3)
      return null;
    if (range.type === 4)
      throw new Error("Cannot convert never type to IDBKeyRange");
    const { lower, upper, lowerOpen, upperOpen } = range;
    const idbRange = lower === void 0 ? upper === void 0 ? null : IdbKeyRange.upperBound(upper, !!upperOpen) : upper === void 0 ? IdbKeyRange.lowerBound(lower, !!lowerOpen) : IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);
    return idbRange;
  }
  function createDbCoreTable(tableSchema) {
    const tableName = tableSchema.name;
    function mutate({ trans, type: type2, keys: keys3, values, range }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const store = trans.objectStore(tableName);
        const outbound = store.keyPath == null;
        const isAddOrPut = type2 === "put" || type2 === "add";
        if (!isAddOrPut && type2 !== "delete" && type2 !== "deleteRange")
          throw new Error("Invalid operation type: " + type2);
        const { length: length3 } = keys3 || values || { length: 1 };
        if (keys3 && values && keys3.length !== values.length) {
          throw new Error("Given keys array must have same length as given values array.");
        }
        if (length3 === 0)
          return resolve2({ numFailures: 0, failures: {}, results: [], lastResult: void 0 });
        let req;
        const reqs = [];
        const failures = [];
        let numFailures = 0;
        const errorHandler = (event) => {
          ++numFailures;
          preventDefault(event);
        };
        if (type2 === "deleteRange") {
          if (range.type === 4)
            return resolve2({ numFailures, failures, results: [], lastResult: void 0 });
          if (range.type === 3)
            reqs.push(req = store.clear());
          else
            reqs.push(req = store.delete(makeIDBKeyRange(range)));
        } else {
          const [args1, args2] = isAddOrPut ? outbound ? [values, keys3] : [values, null] : [keys3, null];
          if (isAddOrPut) {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = args2 && args2[i] !== void 0 ? store[type2](args1[i], args2[i]) : store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          } else {
            for (let i = 0; i < length3; ++i) {
              reqs.push(req = store[type2](args1[i]));
              req.onerror = errorHandler;
            }
          }
        }
        const done = (event) => {
          const lastResult = event.target.result;
          reqs.forEach((req2, i) => req2.error != null && (failures[i] = req2.error));
          resolve2({
            numFailures,
            failures,
            results: type2 === "delete" ? keys3 : reqs.map((req2) => req2.result),
            lastResult
          });
        };
        req.onerror = (event) => {
          errorHandler(event);
          done(event);
        };
        req.onsuccess = done;
      });
    }
    function openCursor2({ trans, values, query: query2, reverse, unique }) {
      return new Promise((resolve2, reject2) => {
        resolve2 = wrap(resolve2);
        const { index, range } = query2;
        const store = trans.objectStore(tableName);
        const source = index.isPrimaryKey ? store : store.index(index.name);
        const direction = reverse ? unique ? "prevunique" : "prev" : unique ? "nextunique" : "next";
        const req = values || !("openKeyCursor" in source) ? source.openCursor(makeIDBKeyRange(range), direction) : source.openKeyCursor(makeIDBKeyRange(range), direction);
        req.onerror = eventRejectHandler(reject2);
        req.onsuccess = wrap((ev) => {
          const cursor = req.result;
          if (!cursor) {
            resolve2(null);
            return;
          }
          cursor.___id = ++_id_counter;
          cursor.done = false;
          const _cursorContinue = cursor.continue.bind(cursor);
          let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;
          if (_cursorContinuePrimaryKey)
            _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);
          const _cursorAdvance = cursor.advance.bind(cursor);
          const doThrowCursorIsNotStarted = () => {
            throw new Error("Cursor not started");
          };
          const doThrowCursorIsStopped = () => {
            throw new Error("Cursor not stopped");
          };
          cursor.trans = trans;
          cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;
          cursor.fail = wrap(reject2);
          cursor.next = function() {
            let gotOne = 1;
            return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);
          };
          cursor.start = (callback) => {
            const iterationPromise = new Promise((resolveIteration, rejectIteration) => {
              resolveIteration = wrap(resolveIteration);
              req.onerror = eventRejectHandler(rejectIteration);
              cursor.fail = rejectIteration;
              cursor.stop = (value) => {
                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;
                resolveIteration(value);
              };
            });
            const guardedCallback = () => {
              if (req.result) {
                try {
                  callback();
                } catch (err) {
                  cursor.fail(err);
                }
              } else {
                cursor.done = true;
                cursor.start = () => {
                  throw new Error("Cursor behind last entry");
                };
                cursor.stop();
              }
            };
            req.onsuccess = wrap((ev2) => {
              req.onsuccess = guardedCallback;
              guardedCallback();
            });
            cursor.continue = _cursorContinue;
            cursor.continuePrimaryKey = _cursorContinuePrimaryKey;
            cursor.advance = _cursorAdvance;
            guardedCallback();
            return iterationPromise;
          };
          resolve2(cursor);
        }, reject2);
      });
    }
    function query(hasGetAll2) {
      return (request) => {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const { trans, values, limit, query: query2 } = request;
          const nonInfinitLimit = limit === Infinity ? void 0 : limit;
          const { index, range } = query2;
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          if (limit === 0)
            return resolve2({ result: [] });
          if (hasGetAll2) {
            const req = values ? source.getAll(idbKeyRange, nonInfinitLimit) : source.getAllKeys(idbKeyRange, nonInfinitLimit);
            req.onsuccess = (event) => resolve2({ result: event.target.result });
            req.onerror = eventRejectHandler(reject2);
          } else {
            let count2 = 0;
            const req = values || !("openKeyCursor" in source) ? source.openCursor(idbKeyRange) : source.openKeyCursor(idbKeyRange);
            const result = [];
            req.onsuccess = (event) => {
              const cursor = req.result;
              if (!cursor)
                return resolve2({ result });
              result.push(values ? cursor.value : cursor.primaryKey);
              if (++count2 === limit)
                return resolve2({ result });
              cursor.continue();
            };
            req.onerror = eventRejectHandler(reject2);
          }
        });
      };
    }
    return {
      name: tableName,
      schema: tableSchema,
      mutate,
      getMany({ trans, keys: keys3 }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const length3 = keys3.length;
          const result = new Array(length3);
          let keyCount = 0;
          let callbackCount = 0;
          let req;
          const successHandler = (event) => {
            const req2 = event.target;
            if ((result[req2._pos] = req2.result) != null)
              ;
            if (++callbackCount === keyCount)
              resolve2(result);
          };
          const errorHandler = eventRejectHandler(reject2);
          for (let i = 0; i < length3; ++i) {
            const key = keys3[i];
            if (key != null) {
              req = store.get(keys3[i]);
              req._pos = i;
              req.onsuccess = successHandler;
              req.onerror = errorHandler;
              ++keyCount;
            }
          }
          if (keyCount === 0)
            resolve2(result);
        });
      },
      get({ trans, key }) {
        return new Promise((resolve2, reject2) => {
          resolve2 = wrap(resolve2);
          const store = trans.objectStore(tableName);
          const req = store.get(key);
          req.onsuccess = (event) => resolve2(event.target.result);
          req.onerror = eventRejectHandler(reject2);
        });
      },
      query: query(hasGetAll),
      openCursor: openCursor2,
      count({ query: query2, trans }) {
        const { index, range } = query2;
        return new Promise((resolve2, reject2) => {
          const store = trans.objectStore(tableName);
          const source = index.isPrimaryKey ? store : store.index(index.name);
          const idbKeyRange = makeIDBKeyRange(range);
          const req = idbKeyRange ? source.count(idbKeyRange) : source.count();
          req.onsuccess = wrap((ev) => resolve2(ev.target.result));
          req.onerror = eventRejectHandler(reject2);
        });
      }
    };
  }
  const { schema, hasGetAll } = extractSchema(db, tmpTrans);
  const tables = schema.tables.map((tableSchema) => createDbCoreTable(tableSchema));
  const tableMap = {};
  tables.forEach((table) => tableMap[table.name] = table);
  return {
    stack: "dbcore",
    transaction: db.transaction.bind(db),
    table(name) {
      const result = tableMap[name];
      if (!result)
        throw new Error(`Table '${name}' not found`);
      return tableMap[name];
    },
    MIN_KEY: -Infinity,
    MAX_KEY: getMaxKey(IdbKeyRange),
    schema
  };
}
function createMiddlewareStack(stackImpl, middlewares) {
  return middlewares.reduce((down, { create: create7 }) => ({ ...down, ...create7(down) }), stackImpl);
}
function createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange: IDBKeyRange2, indexedDB: indexedDB2 }, tmpTrans) {
  const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange2, tmpTrans), middlewares.dbcore);
  return {
    dbcore
  };
}
function generateMiddlewareStacks({ _novip: db }, tmpTrans) {
  const idbdb = tmpTrans.db;
  const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);
  db.core = stacks.dbcore;
  db.tables.forEach((table) => {
    const tableName = table.name;
    if (db.core.schema.tables.some((tbl) => tbl.name === tableName)) {
      table.core = db.core.table(tableName);
      if (db[tableName] instanceof db.Table) {
        db[tableName].core = table.core;
      }
    }
  });
}
function setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {
  tableNames.forEach((tableName) => {
    const schema = dbschema[tableName];
    objs.forEach((obj) => {
      const propDesc = getPropertyDescriptor(obj, tableName);
      if (!propDesc || "value" in propDesc && propDesc.value === void 0) {
        if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {
          setProp(obj, tableName, {
            get() {
              return this.table(tableName);
            },
            set(value) {
              defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });
            }
          });
        } else {
          obj[tableName] = new db.Table(tableName, schema);
        }
      }
    });
  });
}
function removeTablesApi({ _novip: db }, objs) {
  objs.forEach((obj) => {
    for (let key in obj) {
      if (obj[key] instanceof db.Table)
        delete obj[key];
    }
  });
}
function lowerVersionFirst(a, b) {
  return a._cfg.version - b._cfg.version;
}
function runUpgraders(db, oldVersion, idbUpgradeTrans, reject2) {
  const globalSchema = db._dbSchema;
  const trans = db._createTransaction("readwrite", db._storeNames, globalSchema);
  trans.create(idbUpgradeTrans);
  trans._completion.catch(reject2);
  const rejectTransaction = trans._reject.bind(trans);
  const transless = PSD.transless || PSD;
  newScope(() => {
    PSD.trans = trans;
    PSD.transless = transless;
    if (oldVersion === 0) {
      keys2(globalSchema).forEach((tableName) => {
        createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);
      });
      generateMiddlewareStacks(db, idbUpgradeTrans);
      DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);
    } else
      updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);
  });
}
function updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {
  const queue = [];
  const versions = db._versions;
  let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);
  let anyContentUpgraderHasRun = false;
  const versToRun = versions.filter((v) => v._cfg.version >= oldVersion);
  versToRun.forEach((version) => {
    queue.push(() => {
      const oldSchema = globalSchema;
      const newSchema = version._cfg.dbschema;
      adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);
      adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);
      globalSchema = db._dbSchema = newSchema;
      const diff = getSchemaDiff(oldSchema, newSchema);
      diff.add.forEach((tuple) => {
        createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);
      });
      diff.change.forEach((change) => {
        if (change.recreate) {
          throw new exceptions.Upgrade("Not yet support for changing primary key");
        } else {
          const store = idbUpgradeTrans.objectStore(change.name);
          change.add.forEach((idx) => addIndex(store, idx));
          change.change.forEach((idx) => {
            store.deleteIndex(idx.name);
            addIndex(store, idx);
          });
          change.del.forEach((idxName) => store.deleteIndex(idxName));
        }
      });
      const contentUpgrade = version._cfg.contentUpgrade;
      if (contentUpgrade && version._cfg.version > oldVersion) {
        generateMiddlewareStacks(db, idbUpgradeTrans);
        trans._memoizedTables = {};
        anyContentUpgraderHasRun = true;
        let upgradeSchema = shallowClone(newSchema);
        diff.del.forEach((table) => {
          upgradeSchema[table] = oldSchema[table];
        });
        removeTablesApi(db, [db.Transaction.prototype]);
        setApiOnPlace(db, [db.Transaction.prototype], keys2(upgradeSchema), upgradeSchema);
        trans.schema = upgradeSchema;
        const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);
        if (contentUpgradeIsAsync) {
          incrementExpectedAwaits();
        }
        let returnValue;
        const promiseFollowed = DexiePromise.follow(() => {
          returnValue = contentUpgrade(trans);
          if (returnValue) {
            if (contentUpgradeIsAsync) {
              var decrementor = decrementExpectedAwaits.bind(null, null);
              returnValue.then(decrementor, decrementor);
            }
          }
        });
        return returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue);
      }
    });
    queue.push((idbtrans) => {
      if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {
        const newSchema = version._cfg.dbschema;
        deleteRemovedTables(newSchema, idbtrans);
      }
      removeTablesApi(db, [db.Transaction.prototype]);
      setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);
      trans.schema = db._dbSchema;
    });
  });
  function runQueue() {
    return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) : DexiePromise.resolve();
  }
  return runQueue().then(() => {
    createMissingTables(globalSchema, idbUpgradeTrans);
  });
}
function getSchemaDiff(oldSchema, newSchema) {
  const diff = {
    del: [],
    add: [],
    change: []
  };
  let table;
  for (table in oldSchema) {
    if (!newSchema[table])
      diff.del.push(table);
  }
  for (table in newSchema) {
    const oldDef = oldSchema[table], newDef = newSchema[table];
    if (!oldDef) {
      diff.add.push([table, newDef]);
    } else {
      const change = {
        name: table,
        def: newDef,
        recreate: false,
        del: [],
        add: [],
        change: []
      };
      if ("" + (oldDef.primKey.keyPath || "") !== "" + (newDef.primKey.keyPath || "") || oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge) {
        change.recreate = true;
        diff.change.push(change);
      } else {
        const oldIndexes = oldDef.idxByName;
        const newIndexes = newDef.idxByName;
        let idxName;
        for (idxName in oldIndexes) {
          if (!newIndexes[idxName])
            change.del.push(idxName);
        }
        for (idxName in newIndexes) {
          const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];
          if (!oldIdx)
            change.add.push(newIdx);
          else if (oldIdx.src !== newIdx.src)
            change.change.push(newIdx);
        }
        if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {
          diff.change.push(change);
        }
      }
    }
  }
  return diff;
}
function createTable(idbtrans, tableName, primKey, indexes) {
  const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ? { keyPath: primKey.keyPath, autoIncrement: primKey.auto } : { autoIncrement: primKey.auto });
  indexes.forEach((idx) => addIndex(store, idx));
  return store;
}
function createMissingTables(newSchema, idbtrans) {
  keys2(newSchema).forEach((tableName) => {
    if (!idbtrans.db.objectStoreNames.contains(tableName)) {
      createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);
    }
  });
}
function deleteRemovedTables(newSchema, idbtrans) {
  [].slice.call(idbtrans.db.objectStoreNames).forEach((storeName) => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));
}
function addIndex(store, idx) {
  store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });
}
function buildGlobalSchema(db, idbdb, tmpTrans) {
  const globalSchema = {};
  const dbStoreNames = slice(idbdb.objectStoreNames, 0);
  dbStoreNames.forEach((storeName) => {
    const store = tmpTrans.objectStore(storeName);
    let keyPath = store.keyPath;
    const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || "", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== "string", true);
    const indexes = [];
    for (let j = 0; j < store.indexNames.length; ++j) {
      const idbindex = store.index(store.indexNames[j]);
      keyPath = idbindex.keyPath;
      var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== "string", false);
      indexes.push(index);
    }
    globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);
  });
  return globalSchema;
}
function readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {
  db.verno = idbdb.version / 10;
  const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);
  db._storeNames = slice(idbdb.objectStoreNames, 0);
  setApiOnPlace(db, [db._allTables], keys2(globalSchema), globalSchema);
}
function verifyInstalledSchema(db, tmpTrans) {
  const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);
  const diff = getSchemaDiff(installedSchema, db._dbSchema);
  return !(diff.add.length || diff.change.some((ch) => ch.add.length || ch.change.length));
}
function adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {
  const storeNames = idbtrans.db.objectStoreNames;
  for (let i = 0; i < storeNames.length; ++i) {
    const storeName = storeNames[i];
    const store = idbtrans.objectStore(storeName);
    db._hasGetAll = "getAll" in store;
    for (let j = 0; j < store.indexNames.length; ++j) {
      const indexName = store.indexNames[j];
      const keyPath = store.index(indexName).keyPath;
      const dexieName = typeof keyPath === "string" ? keyPath : "[" + slice(keyPath).join("+") + "]";
      if (schema[storeName]) {
        const indexSpec = schema[storeName].idxByName[dexieName];
        if (indexSpec) {
          indexSpec.name = indexName;
          delete schema[storeName].idxByName[dexieName];
          schema[storeName].idxByName[indexName] = indexSpec;
        }
      }
    }
  }
  if (typeof navigator !== "undefined" && /Safari/.test(navigator.userAgent) && !/(Chrome\/|Edge\/)/.test(navigator.userAgent) && _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope && [].concat(navigator.userAgent.match(/Safari\/(\d*)/))[1] < 604) {
    db._hasGetAll = false;
  }
}
function parseIndexSyntax(primKeyAndIndexes) {
  return primKeyAndIndexes.split(",").map((index, indexNum) => {
    index = index.trim();
    const name = index.replace(/([&*]|\+\+)/g, "");
    const keyPath = /^\[/.test(name) ? name.match(/^\[(.*)\]$/)[1].split("+") : name;
    return createIndexSpec(name, keyPath || null, /\&/.test(index), /\*/.test(index), /\+\+/.test(index), isArray2(keyPath), indexNum === 0);
  });
}
var Version = class {
  _parseStoresSpec(stores, outSchema) {
    keys2(stores).forEach((tableName) => {
      if (stores[tableName] !== null) {
        var indexes = parseIndexSyntax(stores[tableName]);
        var primKey = indexes.shift();
        if (primKey.multi)
          throw new exceptions.Schema("Primary key cannot be multi-valued");
        indexes.forEach((idx) => {
          if (idx.auto)
            throw new exceptions.Schema("Only primary key can be marked as autoIncrement (++)");
          if (!idx.keyPath)
            throw new exceptions.Schema("Index must have a name and cannot be an empty string");
        });
        outSchema[tableName] = createTableSchema(tableName, primKey, indexes);
      }
    });
  }
  stores(stores) {
    const db = this.db;
    this._cfg.storesSource = this._cfg.storesSource ? extend(this._cfg.storesSource, stores) : stores;
    const versions = db._versions;
    const storesSpec = {};
    let dbschema = {};
    versions.forEach((version) => {
      extend(storesSpec, version._cfg.storesSource);
      dbschema = version._cfg.dbschema = {};
      version._parseStoresSpec(storesSpec, dbschema);
    });
    db._dbSchema = dbschema;
    removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);
    setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys2(dbschema), dbschema);
    db._storeNames = keys2(dbschema);
    return this;
  }
  upgrade(upgradeFunction) {
    this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop2, upgradeFunction);
    return this;
  }
};
function createVersionConstructor(db) {
  return makeClassConstructor(Version.prototype, function Version2(versionNumber) {
    this.db = db;
    this._cfg = {
      version: versionNumber,
      storesSource: null,
      dbschema: {},
      tables: {},
      contentUpgrade: null
    };
  });
}
function getDbNamesTable(indexedDB2, IDBKeyRange2) {
  let dbNamesDB = indexedDB2["_dbNamesDB"];
  if (!dbNamesDB) {
    dbNamesDB = indexedDB2["_dbNamesDB"] = new Dexie$1(DBNAMES_DB, {
      addons: [],
      indexedDB: indexedDB2,
      IDBKeyRange: IDBKeyRange2
    });
    dbNamesDB.version(1).stores({ dbnames: "name" });
  }
  return dbNamesDB.table("dbnames");
}
function hasDatabasesNative(indexedDB2) {
  return indexedDB2 && typeof indexedDB2.databases === "function";
}
function getDatabaseNames({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }) {
  return hasDatabasesNative(indexedDB2) ? Promise.resolve(indexedDB2.databases()).then((infos) => infos.map((info) => info.name).filter((name) => name !== DBNAMES_DB)) : getDbNamesTable(indexedDB2, IDBKeyRange2).toCollection().primaryKeys();
}
function _onDatabaseCreated({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).put({ name }).catch(nop2);
}
function _onDatabaseDeleted({ indexedDB: indexedDB2, IDBKeyRange: IDBKeyRange2 }, name) {
  !hasDatabasesNative(indexedDB2) && name !== DBNAMES_DB && getDbNamesTable(indexedDB2, IDBKeyRange2).delete(name).catch(nop2);
}
function vip(fn) {
  return newScope(function() {
    PSD.letThrough = true;
    return fn();
  });
}
function idbReady() {
  var isSafari = !navigator.userAgentData && /Safari\//.test(navigator.userAgent) && !/Chrom(e|ium)\//.test(navigator.userAgent);
  if (!isSafari || !indexedDB.databases)
    return Promise.resolve();
  var intervalId;
  return new Promise(function(resolve2) {
    var tryIdb = function() {
      return indexedDB.databases().finally(resolve2);
    };
    intervalId = setInterval(tryIdb, 100);
    tryIdb();
  }).finally(function() {
    return clearInterval(intervalId);
  });
}
function dexieOpen(db) {
  const state = db._state;
  const { indexedDB: indexedDB2 } = db._deps;
  if (state.isBeingOpened || db.idbdb)
    return state.dbReadyPromise.then(() => state.dbOpenError ? rejection(state.dbOpenError) : db);
  debug && (state.openCanceller._stackHolder = getErrorWithStack());
  state.isBeingOpened = true;
  state.dbOpenError = null;
  state.openComplete = false;
  const openCanceller = state.openCanceller;
  function throwIfCancelled() {
    if (state.openCanceller !== openCanceller)
      throw new exceptions.DatabaseClosed("db.open() was cancelled");
  }
  let resolveDbReady = state.dbReadyResolve, upgradeTransaction = null, wasCreated = false;
  const tryOpenDB = () => new DexiePromise((resolve2, reject2) => {
    throwIfCancelled();
    if (!indexedDB2)
      throw new exceptions.MissingAPI();
    const dbName = db.name;
    const req = state.autoSchema ? indexedDB2.open(dbName) : indexedDB2.open(dbName, Math.round(db.verno * 10));
    if (!req)
      throw new exceptions.MissingAPI();
    req.onerror = eventRejectHandler(reject2);
    req.onblocked = wrap(db._fireOnBlocked);
    req.onupgradeneeded = wrap((e) => {
      upgradeTransaction = req.transaction;
      if (state.autoSchema && !db._options.allowEmptyDB) {
        req.onerror = preventDefault;
        upgradeTransaction.abort();
        req.result.close();
        const delreq = indexedDB2.deleteDatabase(dbName);
        delreq.onsuccess = delreq.onerror = wrap(() => {
          reject2(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));
        });
      } else {
        upgradeTransaction.onerror = eventRejectHandler(reject2);
        var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;
        wasCreated = oldVer < 1;
        db._novip.idbdb = req.result;
        runUpgraders(db, oldVer / 10, upgradeTransaction, reject2);
      }
    }, reject2);
    req.onsuccess = wrap(() => {
      upgradeTransaction = null;
      const idbdb = db._novip.idbdb = req.result;
      const objectStoreNames = slice(idbdb.objectStoreNames);
      if (objectStoreNames.length > 0)
        try {
          const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), "readonly");
          if (state.autoSchema)
            readGlobalSchema(db, idbdb, tmpTrans);
          else {
            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);
            if (!verifyInstalledSchema(db, tmpTrans)) {
              console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);
            }
          }
          generateMiddlewareStacks(db, tmpTrans);
        } catch (e) {
        }
      connections.push(db);
      idbdb.onversionchange = wrap((ev) => {
        state.vcFired = true;
        db.on("versionchange").fire(ev);
      });
      idbdb.onclose = wrap((ev) => {
        db.on("close").fire(ev);
      });
      if (wasCreated)
        _onDatabaseCreated(db._deps, dbName);
      resolve2();
    }, reject2);
  }).catch((err) => {
    if (err && err.name === "UnknownError" && state.PR1398_maxLoop > 0) {
      state.PR1398_maxLoop--;
      console.warn("Dexie: Workaround for Chrome UnknownError on open()");
      return tryOpenDB();
    } else {
      return DexiePromise.reject(err);
    }
  });
  return DexiePromise.race([
    openCanceller,
    (typeof navigator === "undefined" ? DexiePromise.resolve() : idbReady()).then(tryOpenDB)
  ]).then(() => {
    throwIfCancelled();
    state.onReadyBeingFired = [];
    return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {
      if (state.onReadyBeingFired.length > 0) {
        let remainders = state.onReadyBeingFired.reduce(promisableChain, nop2);
        state.onReadyBeingFired = [];
        return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);
      }
    });
  }).finally(() => {
    state.onReadyBeingFired = null;
    state.isBeingOpened = false;
  }).then(() => {
    return db;
  }).catch((err) => {
    state.dbOpenError = err;
    try {
      upgradeTransaction && upgradeTransaction.abort();
    } catch (_a) {
    }
    if (openCanceller === state.openCanceller) {
      db._close();
    }
    return rejection(err);
  }).finally(() => {
    state.openComplete = true;
    resolveDbReady();
  });
}
function awaitIterator(iterator) {
  var callNext = (result) => iterator.next(result), doThrow = (error) => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);
  function step(getNext) {
    return (val) => {
      var next = getNext(val), value = next.value;
      return next.done ? value : !value || typeof value.then !== "function" ? isArray2(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) : value.then(onSuccess, onError);
    };
  }
  return step(callNext)();
}
function extractTransactionArgs(mode, _tableArgs_, scopeFunc) {
  var i = arguments.length;
  if (i < 2)
    throw new exceptions.InvalidArgument("Too few arguments");
  var args2 = new Array(i - 1);
  while (--i)
    args2[i - 1] = arguments[i];
  scopeFunc = args2.pop();
  var tables = flatten(args2);
  return [mode, tables, scopeFunc];
}
function enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {
  return DexiePromise.resolve().then(() => {
    const transless = PSD.transless || PSD;
    const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);
    const zoneProps = {
      trans,
      transless
    };
    if (parentTransaction) {
      trans.idbtrans = parentTransaction.idbtrans;
    } else {
      try {
        trans.create();
        db._state.PR1398_maxLoop = 3;
      } catch (ex) {
        if (ex.name === errnames.InvalidState && db.isOpen() && --db._state.PR1398_maxLoop > 0) {
          console.warn("Dexie: Need to reopen db");
          db._close();
          return db.open().then(() => enterTransactionScope(db, mode, storeNames, null, scopeFunc));
        }
        return rejection(ex);
      }
    }
    const scopeFuncIsAsync = isAsyncFunction(scopeFunc);
    if (scopeFuncIsAsync) {
      incrementExpectedAwaits();
    }
    let returnValue;
    const promiseFollowed = DexiePromise.follow(() => {
      returnValue = scopeFunc.call(trans, trans);
      if (returnValue) {
        if (scopeFuncIsAsync) {
          var decrementor = decrementExpectedAwaits.bind(null, null);
          returnValue.then(decrementor, decrementor);
        } else if (typeof returnValue.next === "function" && typeof returnValue.throw === "function") {
          returnValue = awaitIterator(returnValue);
        }
      }
    }, zoneProps);
    return (returnValue && typeof returnValue.then === "function" ? DexiePromise.resolve(returnValue).then((x) => trans.active ? x : rejection(new exceptions.PrematureCommit("Transaction committed too early. See http://bit.ly/2kdckMn"))) : promiseFollowed.then(() => returnValue)).then((x) => {
      if (parentTransaction)
        trans._resolve();
      return trans._completion.then(() => x);
    }).catch((e) => {
      trans._reject(e);
      return rejection(e);
    });
  });
}
function pad(a, value, count2) {
  const result = isArray2(a) ? a.slice() : [a];
  for (let i = 0; i < count2; ++i)
    result.push(value);
  return result;
}
function createVirtualIndexMiddleware(down) {
  return {
    ...down,
    table(tableName) {
      const table = down.table(tableName);
      const { schema } = table;
      const indexLookup = {};
      const allVirtualIndexes = [];
      function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {
        const keyPathAlias = getKeyPathAlias(keyPath);
        const indexList = indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || [];
        const keyLength = keyPath == null ? 0 : typeof keyPath === "string" ? 1 : keyPath.length;
        const isVirtual = keyTail > 0;
        const virtualIndex = {
          ...lowLevelIndex,
          isVirtual,
          keyTail,
          keyLength,
          extractKey: getKeyExtractor(keyPath),
          unique: !isVirtual && lowLevelIndex.unique
        };
        indexList.push(virtualIndex);
        if (!virtualIndex.isPrimaryKey) {
          allVirtualIndexes.push(virtualIndex);
        }
        if (keyLength > 1) {
          const virtualKeyPath = keyLength === 2 ? keyPath[0] : keyPath.slice(0, keyLength - 1);
          addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);
        }
        indexList.sort((a, b) => a.keyTail - b.keyTail);
        return virtualIndex;
      }
      const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);
      indexLookup[":id"] = [primaryKey];
      for (const index of schema.indexes) {
        addVirtualIndexes(index.keyPath, 0, index);
      }
      function findBestIndex(keyPath) {
        const result2 = indexLookup[getKeyPathAlias(keyPath)];
        return result2 && result2[0];
      }
      function translateRange(range, keyTail) {
        return {
          type: range.type === 1 ? 2 : range.type,
          lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),
          lowerOpen: true,
          upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),
          upperOpen: true
        };
      }
      function translateRequest(req) {
        const index = req.query.index;
        return index.isVirtual ? {
          ...req,
          query: {
            index,
            range: translateRange(req.query.range, index.keyTail)
          }
        } : req;
      }
      const result = {
        ...table,
        schema: {
          ...schema,
          primaryKey,
          indexes: allVirtualIndexes,
          getIndexByKeyPath: findBestIndex
        },
        count(req) {
          return table.count(translateRequest(req));
        },
        query(req) {
          return table.query(translateRequest(req));
        },
        openCursor(req) {
          const { keyTail, isVirtual, keyLength } = req.query.index;
          if (!isVirtual)
            return table.openCursor(req);
          function createVirtualCursor(cursor) {
            function _continue(key) {
              key != null ? cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) : req.unique ? cursor.continue(cursor.key.slice(0, keyLength).concat(req.reverse ? down.MIN_KEY : down.MAX_KEY, keyTail)) : cursor.continue();
            }
            const virtualCursor = Object.create(cursor, {
              continue: { value: _continue },
              continuePrimaryKey: {
                value(key, primaryKey2) {
                  cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey2);
                }
              },
              primaryKey: {
                get() {
                  return cursor.primaryKey;
                }
              },
              key: {
                get() {
                  const key = cursor.key;
                  return keyLength === 1 ? key[0] : key.slice(0, keyLength);
                }
              },
              value: {
                get() {
                  return cursor.value;
                }
              }
            });
            return virtualCursor;
          }
          return table.openCursor(translateRequest(req)).then((cursor) => cursor && createVirtualCursor(cursor));
        }
      };
      return result;
    }
  };
}
var virtualIndexMiddleware = {
  stack: "dbcore",
  name: "VirtualIndexMiddleware",
  level: 1,
  create: createVirtualIndexMiddleware
};
function getObjectDiff(a, b, rv, prfx) {
  rv = rv || {};
  prfx = prfx || "";
  keys2(a).forEach((prop) => {
    if (!hasOwn(b, prop)) {
      rv[prfx + prop] = void 0;
    } else {
      var ap = a[prop], bp = b[prop];
      if (typeof ap === "object" && typeof bp === "object" && ap && bp) {
        const apTypeName = toStringTag(ap);
        const bpTypeName = toStringTag(bp);
        if (apTypeName !== bpTypeName) {
          rv[prfx + prop] = b[prop];
        } else if (apTypeName === "Object") {
          getObjectDiff(ap, bp, rv, prfx + prop + ".");
        } else if (ap !== bp) {
          rv[prfx + prop] = b[prop];
        }
      } else if (ap !== bp)
        rv[prfx + prop] = b[prop];
    }
  });
  keys2(b).forEach((prop) => {
    if (!hasOwn(a, prop)) {
      rv[prfx + prop] = b[prop];
    }
  });
  return rv;
}
function getEffectiveKeys(primaryKey, req) {
  if (req.type === "delete")
    return req.keys;
  return req.keys || req.values.map(primaryKey.extractKey);
}
var hooksMiddleware = {
  stack: "dbcore",
  name: "HooksMiddleware",
  level: 2,
  create: (downCore) => ({
    ...downCore,
    table(tableName) {
      const downTable = downCore.table(tableName);
      const { primaryKey } = downTable.schema;
      const tableMiddleware = {
        ...downTable,
        mutate(req) {
          const dxTrans = PSD.trans;
          const { deleting, creating, updating } = dxTrans.table(tableName).hook;
          switch (req.type) {
            case "add":
              if (creating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "put":
              if (creating.fire === nop2 && updating.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "delete":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => addPutOrDelete(req), true);
            case "deleteRange":
              if (deleting.fire === nop2)
                break;
              return dxTrans._promise("readwrite", () => deleteRange(req), true);
          }
          return downTable.mutate(req);
          function addPutOrDelete(req2) {
            const dxTrans2 = PSD.trans;
            const keys3 = req2.keys || getEffectiveKeys(primaryKey, req2);
            if (!keys3)
              throw new Error("Keys missing");
            req2 = req2.type === "add" || req2.type === "put" ? { ...req2, keys: keys3 } : { ...req2 };
            if (req2.type !== "delete")
              req2.values = [...req2.values];
            if (req2.keys)
              req2.keys = [...req2.keys];
            return getExistingValues(downTable, req2, keys3).then((existingValues) => {
              const contexts = keys3.map((key, i) => {
                const existingValue = existingValues[i];
                const ctx = { onerror: null, onsuccess: null };
                if (req2.type === "delete") {
                  deleting.fire.call(ctx, key, existingValue, dxTrans2);
                } else if (req2.type === "add" || existingValue === void 0) {
                  const generatedPrimaryKey = creating.fire.call(ctx, key, req2.values[i], dxTrans2);
                  if (key == null && generatedPrimaryKey != null) {
                    key = generatedPrimaryKey;
                    req2.keys[i] = key;
                    if (!primaryKey.outbound) {
                      setByKeyPath(req2.values[i], primaryKey.keyPath, key);
                    }
                  }
                } else {
                  const objectDiff = getObjectDiff(existingValue, req2.values[i]);
                  const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans2);
                  if (additionalChanges) {
                    const requestedValue = req2.values[i];
                    Object.keys(additionalChanges).forEach((keyPath) => {
                      if (hasOwn(requestedValue, keyPath)) {
                        requestedValue[keyPath] = additionalChanges[keyPath];
                      } else {
                        setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);
                      }
                    });
                  }
                }
                return ctx;
              });
              return downTable.mutate(req2).then(({ failures, results, numFailures, lastResult }) => {
                for (let i = 0; i < keys3.length; ++i) {
                  const primKey = results ? results[i] : keys3[i];
                  const ctx = contexts[i];
                  if (primKey == null) {
                    ctx.onerror && ctx.onerror(failures[i]);
                  } else {
                    ctx.onsuccess && ctx.onsuccess(
                      req2.type === "put" && existingValues[i] ? req2.values[i] : primKey
                    );
                  }
                }
                return { failures, results, numFailures, lastResult };
              }).catch((error) => {
                contexts.forEach((ctx) => ctx.onerror && ctx.onerror(error));
                return Promise.reject(error);
              });
            });
          }
          function deleteRange(req2) {
            return deleteNextChunk(req2.trans, req2.range, 1e4);
          }
          function deleteNextChunk(trans, range, limit) {
            return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit }).then(({ result }) => {
              return addPutOrDelete({ type: "delete", keys: result, trans }).then((res) => {
                if (res.numFailures > 0)
                  return Promise.reject(res.failures[0]);
                if (result.length < limit) {
                  return { failures: [], numFailures: 0, lastResult: void 0 };
                } else {
                  return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);
                }
              });
            });
          }
        }
      };
      return tableMiddleware;
    }
  })
};
function getExistingValues(table, req, effectiveKeys) {
  return req.type === "add" ? Promise.resolve([]) : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: "immutable" });
}
function getFromTransactionCache(keys3, cache, clone) {
  try {
    if (!cache)
      return null;
    if (cache.keys.length < keys3.length)
      return null;
    const result = [];
    for (let i = 0, j = 0; i < cache.keys.length && j < keys3.length; ++i) {
      if (cmp(cache.keys[i], keys3[j]) !== 0)
        continue;
      result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);
      ++j;
    }
    return result.length === keys3.length ? result : null;
  } catch (_a) {
    return null;
  }
}
var cacheExistingValuesMiddleware = {
  stack: "dbcore",
  level: -1,
  create: (core) => {
    return {
      table: (tableName) => {
        const table = core.table(tableName);
        return {
          ...table,
          getMany: (req) => {
            if (!req.cache) {
              return table.getMany(req);
            }
            const cachedResult = getFromTransactionCache(req.keys, req.trans["_cache"], req.cache === "clone");
            if (cachedResult) {
              return DexiePromise.resolve(cachedResult);
            }
            return table.getMany(req).then((res) => {
              req.trans["_cache"] = {
                keys: req.keys,
                values: req.cache === "clone" ? deepClone(res) : res
              };
              return res;
            });
          },
          mutate: (req) => {
            if (req.type !== "add")
              req.trans["_cache"] = null;
            return table.mutate(req);
          }
        };
      }
    };
  }
};
function isEmptyRange(node) {
  return !("from" in node);
}
var RangeSet2 = function(fromOrTree, to) {
  if (this) {
    extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });
  } else {
    const rv = new RangeSet2();
    if (fromOrTree && "d" in fromOrTree) {
      extend(rv, fromOrTree);
    }
    return rv;
  }
};
props(RangeSet2.prototype, {
  add(rangeSet) {
    mergeRanges(this, rangeSet);
    return this;
  },
  addKey(key) {
    addRange(this, key, key);
    return this;
  },
  addKeys(keys3) {
    keys3.forEach((key) => addRange(this, key, key));
    return this;
  },
  [iteratorSymbol]() {
    return getRangeSetIterator(this);
  }
});
function addRange(target, from2, to) {
  const diff = cmp(from2, to);
  if (isNaN(diff))
    return;
  if (diff > 0)
    throw RangeError();
  if (isEmptyRange(target))
    return extend(target, { from: from2, to, d: 1 });
  const left = target.l;
  const right = target.r;
  if (cmp(to, target.from) < 0) {
    left ? addRange(left, from2, to) : target.l = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.to) > 0) {
    right ? addRange(right, from2, to) : target.r = { from: from2, to, d: 1, l: null, r: null };
    return rebalance(target);
  }
  if (cmp(from2, target.from) < 0) {
    target.from = from2;
    target.l = null;
    target.d = right ? right.d + 1 : 1;
  }
  if (cmp(to, target.to) > 0) {
    target.to = to;
    target.r = null;
    target.d = target.l ? target.l.d + 1 : 1;
  }
  const rightWasCutOff = !target.r;
  if (left && !target.l) {
    mergeRanges(target, left);
  }
  if (right && rightWasCutOff) {
    mergeRanges(target, right);
  }
}
function mergeRanges(target, newSet) {
  function _addRangeSet(target2, { from: from2, to, l, r }) {
    addRange(target2, from2, to);
    if (l)
      _addRangeSet(target2, l);
    if (r)
      _addRangeSet(target2, r);
  }
  if (!isEmptyRange(newSet))
    _addRangeSet(target, newSet);
}
function rangesOverlap(rangeSet1, rangeSet2) {
  const i1 = getRangeSetIterator(rangeSet2);
  let nextResult1 = i1.next();
  if (nextResult1.done)
    return false;
  let a = nextResult1.value;
  const i2 = getRangeSetIterator(rangeSet1);
  let nextResult2 = i2.next(a.from);
  let b = nextResult2.value;
  while (!nextResult1.done && !nextResult2.done) {
    if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)
      return true;
    cmp(a.from, b.from) < 0 ? a = (nextResult1 = i1.next(b.from)).value : b = (nextResult2 = i2.next(a.from)).value;
  }
  return false;
}
function getRangeSetIterator(node) {
  let state = isEmptyRange(node) ? null : { s: 0, n: node };
  return {
    next(key) {
      const keyProvided = arguments.length > 0;
      while (state) {
        switch (state.s) {
          case 0:
            state.s = 1;
            if (keyProvided) {
              while (state.n.l && cmp(key, state.n.from) < 0)
                state = { up: state, n: state.n.l, s: 1 };
            } else {
              while (state.n.l)
                state = { up: state, n: state.n.l, s: 1 };
            }
          case 1:
            state.s = 2;
            if (!keyProvided || cmp(key, state.n.to) <= 0)
              return { value: state.n, done: false };
          case 2:
            if (state.n.r) {
              state.s = 3;
              state = { up: state, n: state.n.r, s: 0 };
              continue;
            }
          case 3:
            state = state.up;
        }
      }
      return { done: true };
    }
  };
}
function rebalance(target) {
  var _a, _b;
  const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);
  const r = diff > 1 ? "r" : diff < -1 ? "l" : "";
  if (r) {
    const l = r === "r" ? "l" : "r";
    const rootClone = { ...target };
    const oldRootRight = target[r];
    target.from = oldRootRight.from;
    target.to = oldRootRight.to;
    target[r] = oldRootRight[r];
    rootClone[r] = oldRootRight[l];
    target[l] = rootClone;
    rootClone.d = computeDepth(rootClone);
  }
  target.d = computeDepth(target);
}
function computeDepth({ r, l }) {
  return (r ? l ? Math.max(r.d, l.d) : r.d : l ? l.d : 0) + 1;
}
var observabilityMiddleware = {
  stack: "dbcore",
  level: 0,
  create: (core) => {
    const dbName = core.schema.name;
    const FULL_RANGE = new RangeSet2(core.MIN_KEY, core.MAX_KEY);
    return {
      ...core,
      table: (tableName) => {
        const table = core.table(tableName);
        const { schema } = table;
        const { primaryKey } = schema;
        const { extractKey, outbound } = primaryKey;
        const tableClone = {
          ...table,
          mutate: (req) => {
            const trans = req.trans;
            const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});
            const getRangeSet = (indexName) => {
              const part = `idb://${dbName}/${tableName}/${indexName}`;
              return mutatedParts[part] || (mutatedParts[part] = new RangeSet2());
            };
            const pkRangeSet = getRangeSet("");
            const delsRangeSet = getRangeSet(":dels");
            const { type: type2 } = req;
            let [keys3, newObjs] = req.type === "deleteRange" ? [req.range] : req.type === "delete" ? [req.keys] : req.values.length < 50 ? [[], req.values] : [];
            const oldCache = req.trans["_cache"];
            return table.mutate(req).then((res) => {
              if (isArray2(keys3)) {
                if (type2 !== "delete")
                  keys3 = res.results;
                pkRangeSet.addKeys(keys3);
                const oldObjs = getFromTransactionCache(keys3, oldCache);
                if (!oldObjs && type2 !== "add") {
                  delsRangeSet.addKeys(keys3);
                }
                if (oldObjs || newObjs) {
                  trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);
                }
              } else if (keys3) {
                const range = { from: keys3.lower, to: keys3.upper };
                delsRangeSet.add(range);
                pkRangeSet.add(range);
              } else {
                pkRangeSet.add(FULL_RANGE);
                delsRangeSet.add(FULL_RANGE);
                schema.indexes.forEach((idx) => getRangeSet(idx.name).add(FULL_RANGE));
              }
              return res;
            });
          }
        };
        const getRange = ({ query: { index, range } }) => {
          var _a, _b;
          return [
            index,
            new RangeSet2((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY)
          ];
        };
        const readSubscribers = {
          get: (req) => [primaryKey, new RangeSet2(req.key)],
          getMany: (req) => [primaryKey, new RangeSet2().addKeys(req.keys)],
          count: getRange,
          query: getRange,
          openCursor: getRange
        };
        keys2(readSubscribers).forEach((method) => {
          tableClone[method] = function(req) {
            const { subscr } = PSD;
            if (subscr) {
              const getRangeSet = (indexName) => {
                const part = `idb://${dbName}/${tableName}/${indexName}`;
                return subscr[part] || (subscr[part] = new RangeSet2());
              };
              const pkRangeSet = getRangeSet("");
              const delsRangeSet = getRangeSet(":dels");
              const [queriedIndex, queriedRanges] = readSubscribers[method](req);
              getRangeSet(queriedIndex.name || "").add(queriedRanges);
              if (!queriedIndex.isPrimaryKey) {
                if (method === "count") {
                  delsRangeSet.add(FULL_RANGE);
                } else {
                  const keysPromise = method === "query" && outbound && req.values && table.query({
                    ...req,
                    values: false
                  });
                  return table[method].apply(this, arguments).then((res) => {
                    if (method === "query") {
                      if (outbound && req.values) {
                        return keysPromise.then(({ result: resultingKeys }) => {
                          pkRangeSet.addKeys(resultingKeys);
                          return res;
                        });
                      }
                      const pKeys = req.values ? res.result.map(extractKey) : res.result;
                      if (req.values) {
                        pkRangeSet.addKeys(pKeys);
                      } else {
                        delsRangeSet.addKeys(pKeys);
                      }
                    } else if (method === "openCursor") {
                      const cursor = res;
                      const wantValues = req.values;
                      return cursor && Object.create(cursor, {
                        key: {
                          get() {
                            delsRangeSet.addKey(cursor.primaryKey);
                            return cursor.key;
                          }
                        },
                        primaryKey: {
                          get() {
                            const pkey = cursor.primaryKey;
                            delsRangeSet.addKey(pkey);
                            return pkey;
                          }
                        },
                        value: {
                          get() {
                            wantValues && pkRangeSet.addKey(cursor.primaryKey);
                            return cursor.value;
                          }
                        }
                      });
                    }
                    return res;
                  });
                }
              }
            }
            return table[method].apply(this, arguments);
          };
        });
        return tableClone;
      }
    };
  }
};
function trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {
  function addAffectedIndex(ix) {
    const rangeSet = getRangeSet(ix.name || "");
    function extractKey(obj) {
      return obj != null ? ix.extractKey(obj) : null;
    }
    const addKeyOrKeys = (key) => ix.multiEntry && isArray2(key) ? key.forEach((key2) => rangeSet.addKey(key2)) : rangeSet.addKey(key);
    (oldObjs || newObjs).forEach((_, i) => {
      const oldKey = oldObjs && extractKey(oldObjs[i]);
      const newKey = newObjs && extractKey(newObjs[i]);
      if (cmp(oldKey, newKey) !== 0) {
        if (oldKey != null)
          addKeyOrKeys(oldKey);
        if (newKey != null)
          addKeyOrKeys(newKey);
      }
    });
  }
  schema.indexes.forEach(addAffectedIndex);
}
var Dexie$1 = class {
  constructor(name, options) {
    this._middlewares = {};
    this.verno = 0;
    const deps = Dexie$1.dependencies;
    this._options = options = {
      addons: Dexie$1.addons,
      autoOpen: true,
      indexedDB: deps.indexedDB,
      IDBKeyRange: deps.IDBKeyRange,
      ...options
    };
    this._deps = {
      indexedDB: options.indexedDB,
      IDBKeyRange: options.IDBKeyRange
    };
    const { addons } = options;
    this._dbSchema = {};
    this._versions = [];
    this._storeNames = [];
    this._allTables = {};
    this.idbdb = null;
    this._novip = this;
    const state = {
      dbOpenError: null,
      isBeingOpened: false,
      onReadyBeingFired: null,
      openComplete: false,
      dbReadyResolve: nop2,
      dbReadyPromise: null,
      cancelOpen: nop2,
      openCanceller: null,
      autoSchema: true,
      PR1398_maxLoop: 3
    };
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
    this._state = state;
    this.name = name;
    this.on = Events(this, "populate", "blocked", "versionchange", "close", { ready: [promisableChain, nop2] });
    this.on.ready.subscribe = override(this.on.ready.subscribe, (subscribe2) => {
      return (subscriber, bSticky) => {
        Dexie$1.vip(() => {
          const state2 = this._state;
          if (state2.openComplete) {
            if (!state2.dbOpenError)
              DexiePromise.resolve().then(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else if (state2.onReadyBeingFired) {
            state2.onReadyBeingFired.push(subscriber);
            if (bSticky)
              subscribe2(subscriber);
          } else {
            subscribe2(subscriber);
            const db = this;
            if (!bSticky)
              subscribe2(function unsubscribe2() {
                db.on.ready.unsubscribe(subscriber);
                db.on.ready.unsubscribe(unsubscribe2);
              });
          }
        });
      };
    });
    this.Collection = createCollectionConstructor(this);
    this.Table = createTableConstructor(this);
    this.Transaction = createTransactionConstructor(this);
    this.Version = createVersionConstructor(this);
    this.WhereClause = createWhereClauseConstructor(this);
    this.on("versionchange", (ev) => {
      if (ev.newVersion > 0)
        console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);
      else
        console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);
      this.close();
    });
    this.on("blocked", (ev) => {
      if (!ev.newVersion || ev.newVersion < ev.oldVersion)
        console.warn(`Dexie.delete('${this.name}') was blocked`);
      else
        console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);
    });
    this._maxKey = getMaxKey(options.IDBKeyRange);
    this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);
    this._fireOnBlocked = (ev) => {
      this.on("blocked").fire(ev);
      connections.filter((c) => c.name === this.name && c !== this && !c._state.vcFired).map((c) => c.on("versionchange").fire(ev));
    };
    this.use(virtualIndexMiddleware);
    this.use(hooksMiddleware);
    this.use(observabilityMiddleware);
    this.use(cacheExistingValuesMiddleware);
    this.vip = Object.create(this, { _vip: { value: true } });
    addons.forEach((addon) => addon(this));
  }
  version(versionNumber) {
    if (isNaN(versionNumber) || versionNumber < 0.1)
      throw new exceptions.Type(`Given version is not a positive number`);
    versionNumber = Math.round(versionNumber * 10) / 10;
    if (this.idbdb || this._state.isBeingOpened)
      throw new exceptions.Schema("Cannot add version when database is open");
    this.verno = Math.max(this.verno, versionNumber);
    const versions = this._versions;
    var versionInstance = versions.filter((v) => v._cfg.version === versionNumber)[0];
    if (versionInstance)
      return versionInstance;
    versionInstance = new this.Version(versionNumber);
    versions.push(versionInstance);
    versions.sort(lowerVersionFirst);
    versionInstance.stores({});
    this._state.autoSchema = false;
    return versionInstance;
  }
  _whenReady(fn) {
    return this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip) ? fn() : new DexiePromise((resolve2, reject2) => {
      if (this._state.openComplete) {
        return reject2(new exceptions.DatabaseClosed(this._state.dbOpenError));
      }
      if (!this._state.isBeingOpened) {
        if (!this._options.autoOpen) {
          reject2(new exceptions.DatabaseClosed());
          return;
        }
        this.open().catch(nop2);
      }
      this._state.dbReadyPromise.then(resolve2, reject2);
    }).then(fn);
  }
  use({ stack, create: create7, level, name }) {
    if (name)
      this.unuse({ stack, name });
    const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);
    middlewares.push({ stack, create: create7, level: level == null ? 10 : level, name });
    middlewares.sort((a, b) => a.level - b.level);
    return this;
  }
  unuse({ stack, name, create: create7 }) {
    if (stack && this._middlewares[stack]) {
      this._middlewares[stack] = this._middlewares[stack].filter((mw) => create7 ? mw.create !== create7 : name ? mw.name !== name : false);
    }
    return this;
  }
  open() {
    return dexieOpen(this);
  }
  _close() {
    const state = this._state;
    const idx = connections.indexOf(this);
    if (idx >= 0)
      connections.splice(idx, 1);
    if (this.idbdb) {
      try {
        this.idbdb.close();
      } catch (e) {
      }
      this._novip.idbdb = null;
    }
    state.dbReadyPromise = new DexiePromise((resolve2) => {
      state.dbReadyResolve = resolve2;
    });
    state.openCanceller = new DexiePromise((_, reject2) => {
      state.cancelOpen = reject2;
    });
  }
  close() {
    this._close();
    const state = this._state;
    this._options.autoOpen = false;
    state.dbOpenError = new exceptions.DatabaseClosed();
    if (state.isBeingOpened)
      state.cancelOpen(state.dbOpenError);
  }
  delete() {
    const hasArguments = arguments.length > 0;
    const state = this._state;
    return new DexiePromise((resolve2, reject2) => {
      const doDelete = () => {
        this.close();
        var req = this._deps.indexedDB.deleteDatabase(this.name);
        req.onsuccess = wrap(() => {
          _onDatabaseDeleted(this._deps, this.name);
          resolve2();
        });
        req.onerror = eventRejectHandler(reject2);
        req.onblocked = this._fireOnBlocked;
      };
      if (hasArguments)
        throw new exceptions.InvalidArgument("Arguments not allowed in db.delete()");
      if (state.isBeingOpened) {
        state.dbReadyPromise.then(doDelete);
      } else {
        doDelete();
      }
    });
  }
  backendDB() {
    return this.idbdb;
  }
  isOpen() {
    return this.idbdb !== null;
  }
  hasBeenClosed() {
    const dbOpenError = this._state.dbOpenError;
    return dbOpenError && dbOpenError.name === "DatabaseClosed";
  }
  hasFailed() {
    return this._state.dbOpenError !== null;
  }
  dynamicallyOpened() {
    return this._state.autoSchema;
  }
  get tables() {
    return keys2(this._allTables).map((name) => this._allTables[name]);
  }
  transaction() {
    const args2 = extractTransactionArgs.apply(this, arguments);
    return this._transaction.apply(this, args2);
  }
  _transaction(mode, tables, scopeFunc) {
    let parentTransaction = PSD.trans;
    if (!parentTransaction || parentTransaction.db !== this || mode.indexOf("!") !== -1)
      parentTransaction = null;
    const onlyIfCompatible = mode.indexOf("?") !== -1;
    mode = mode.replace("!", "").replace("?", "");
    let idbMode, storeNames;
    try {
      storeNames = tables.map((table) => {
        var storeName = table instanceof this.Table ? table.name : table;
        if (typeof storeName !== "string")
          throw new TypeError("Invalid table argument to Dexie.transaction(). Only Table or String are allowed");
        return storeName;
      });
      if (mode == "r" || mode === READONLY)
        idbMode = READONLY;
      else if (mode == "rw" || mode == READWRITE)
        idbMode = READWRITE;
      else
        throw new exceptions.InvalidArgument("Invalid transaction mode: " + mode);
      if (parentTransaction) {
        if (parentTransaction.mode === READONLY && idbMode === READWRITE) {
          if (onlyIfCompatible) {
            parentTransaction = null;
          } else
            throw new exceptions.SubTransaction("Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY");
        }
        if (parentTransaction) {
          storeNames.forEach((storeName) => {
            if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {
              if (onlyIfCompatible) {
                parentTransaction = null;
              } else
                throw new exceptions.SubTransaction("Table " + storeName + " not included in parent transaction.");
            }
          });
        }
        if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {
          parentTransaction = null;
        }
      }
    } catch (e) {
      return parentTransaction ? parentTransaction._promise(null, (_, reject2) => {
        reject2(e);
      }) : rejection(e);
    }
    const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);
    return parentTransaction ? parentTransaction._promise(idbMode, enterTransaction, "lock") : PSD.trans ? usePSD(PSD.transless, () => this._whenReady(enterTransaction)) : this._whenReady(enterTransaction);
  }
  table(tableName) {
    if (!hasOwn(this._allTables, tableName)) {
      throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);
    }
    return this._allTables[tableName];
  }
};
var symbolObservable = typeof Symbol !== "undefined" && "observable" in Symbol ? Symbol.observable : "@@observable";
var Observable2 = class {
  constructor(subscribe2) {
    this._subscribe = subscribe2;
  }
  subscribe(x, error, complete) {
    return this._subscribe(!x || typeof x === "function" ? { next: x, error, complete } : x);
  }
  [symbolObservable]() {
    return this;
  }
};
function extendObservabilitySet(target, newSet) {
  keys2(newSet).forEach((part) => {
    const rangeSet = target[part] || (target[part] = new RangeSet2());
    mergeRanges(rangeSet, newSet[part]);
  });
  return target;
}
function liveQuery(querier) {
  let hasValue = false;
  let currentValue = void 0;
  const observable = new Observable2((observer) => {
    const scopeFuncIsAsync = isAsyncFunction(querier);
    function execute(subscr) {
      if (scopeFuncIsAsync) {
        incrementExpectedAwaits();
      }
      const exec = () => newScope(querier, { subscr, trans: null });
      const rv = PSD.trans ? usePSD(PSD.transless, exec) : exec();
      if (scopeFuncIsAsync) {
        rv.then(decrementExpectedAwaits, decrementExpectedAwaits);
      }
      return rv;
    }
    let closed = false;
    let accumMuts = {};
    let currentObs = {};
    const subscription = {
      get closed() {
        return closed;
      },
      unsubscribe: () => {
        closed = true;
        globalEvents.storagemutated.unsubscribe(mutationListener);
      }
    };
    observer.start && observer.start(subscription);
    let querying = false, startedListening = false;
    function shouldNotify() {
      return keys2(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));
    }
    const mutationListener = (parts) => {
      extendObservabilitySet(accumMuts, parts);
      if (shouldNotify()) {
        doQuery();
      }
    };
    const doQuery = () => {
      if (querying || closed)
        return;
      accumMuts = {};
      const subscr = {};
      const ret = execute(subscr);
      if (!startedListening) {
        globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);
        startedListening = true;
      }
      querying = true;
      Promise.resolve(ret).then((result) => {
        hasValue = true;
        currentValue = result;
        querying = false;
        if (closed)
          return;
        if (shouldNotify()) {
          doQuery();
        } else {
          accumMuts = {};
          currentObs = subscr;
          observer.next && observer.next(result);
        }
      }, (err) => {
        querying = false;
        hasValue = false;
        observer.error && observer.error(err);
        subscription.unsubscribe();
      });
    };
    doQuery();
    return subscription;
  });
  observable.hasValue = () => hasValue;
  observable.getValue = () => currentValue;
  return observable;
}
var domDeps;
try {
  domDeps = {
    indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,
    IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange
  };
} catch (e) {
  domDeps = { indexedDB: null, IDBKeyRange: null };
}
var Dexie = Dexie$1;
props(Dexie, {
  ...fullNameExceptions,
  delete(databaseName) {
    const db = new Dexie(databaseName, { addons: [] });
    return db.delete();
  },
  exists(name) {
    return new Dexie(name, { addons: [] }).open().then((db) => {
      db.close();
      return true;
    }).catch("NoSuchDatabaseError", () => false);
  },
  getDatabaseNames(cb) {
    try {
      return getDatabaseNames(Dexie.dependencies).then(cb);
    } catch (_a) {
      return rejection(new exceptions.MissingAPI());
    }
  },
  defineClass() {
    function Class(content) {
      extend(this, content);
    }
    return Class;
  },
  ignoreTransaction(scopeFunc) {
    return PSD.trans ? usePSD(PSD.transless, scopeFunc) : scopeFunc();
  },
  vip,
  async: function(generatorFn) {
    return function() {
      try {
        var rv = awaitIterator(generatorFn.apply(this, arguments));
        if (!rv || typeof rv.then !== "function")
          return DexiePromise.resolve(rv);
        return rv;
      } catch (e) {
        return rejection(e);
      }
    };
  },
  spawn: function(generatorFn, args2, thiz) {
    try {
      var rv = awaitIterator(generatorFn.apply(thiz, args2 || []));
      if (!rv || typeof rv.then !== "function")
        return DexiePromise.resolve(rv);
      return rv;
    } catch (e) {
      return rejection(e);
    }
  },
  currentTransaction: {
    get: () => PSD.trans || null
  },
  waitFor: function(promiseOrFunction, optionalTimeout) {
    const promise = DexiePromise.resolve(typeof promiseOrFunction === "function" ? Dexie.ignoreTransaction(promiseOrFunction) : promiseOrFunction).timeout(optionalTimeout || 6e4);
    return PSD.trans ? PSD.trans.waitFor(promise) : promise;
  },
  Promise: DexiePromise,
  debug: {
    get: () => debug,
    set: (value) => {
      setDebug(value, value === "dexie" ? () => true : dexieStackFrameFilter);
    }
  },
  derive,
  extend,
  props,
  override,
  Events,
  on: globalEvents,
  liveQuery,
  extendObservabilitySet,
  getByKeyPath,
  setByKeyPath,
  delByKeyPath,
  shallowClone,
  deepClone,
  getObjectDiff,
  cmp,
  asap: asap$1,
  minKey,
  addons: [],
  connections,
  errnames,
  dependencies: domDeps,
  semVer: DEXIE_VERSION,
  version: DEXIE_VERSION.split(".").map((n) => parseInt(n)).reduce((p, c, i) => p + c / Math.pow(10, i * 2))
});
Dexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);
if (typeof dispatchEvent !== "undefined" && typeof addEventListener !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (updatedParts) => {
    if (!propagatingLocally) {
      let event;
      if (isIEOrEdge) {
        event = document.createEvent("CustomEvent");
        event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);
      } else {
        event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {
          detail: updatedParts
        });
      }
      propagatingLocally = true;
      dispatchEvent(event);
      propagatingLocally = false;
    }
  });
  addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {
    if (!propagatingLocally) {
      propagateLocally(detail);
    }
  });
}
function propagateLocally(updateParts) {
  let wasMe = propagatingLocally;
  try {
    propagatingLocally = true;
    globalEvents.storagemutated.fire(updateParts);
  } finally {
    propagatingLocally = wasMe;
  }
}
var propagatingLocally = false;
if (typeof BroadcastChannel !== "undefined") {
  const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);
  if (typeof bc.unref === "function") {
    bc.unref();
  }
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    if (!propagatingLocally) {
      bc.postMessage(changedParts);
    }
  });
  bc.onmessage = (ev) => {
    if (ev.data)
      propagateLocally(ev.data);
  };
} else if (typeof self !== "undefined" && typeof navigator !== "undefined") {
  globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {
    try {
      if (!propagatingLocally) {
        if (typeof localStorage !== "undefined") {
          localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({
            trig: Math.random(),
            changedParts
          }));
        }
        if (typeof self["clients"] === "object") {
          [...self["clients"].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({
            type: STORAGE_MUTATED_DOM_EVENT_NAME,
            changedParts
          }));
        }
      }
    } catch (_a) {
    }
  });
  if (typeof addEventListener !== "undefined") {
    addEventListener("storage", (ev) => {
      if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {
        const data = JSON.parse(ev.newValue);
        if (data)
          propagateLocally(data.changedParts);
      }
    });
  }
  const swContainer = self.document && navigator.serviceWorker;
  if (swContainer) {
    swContainer.addEventListener("message", propagateMessageLocally);
  }
}
function propagateMessageLocally({ data }) {
  if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {
    propagateLocally(data.changedParts);
  }
}
DexiePromise.rejectionMapper = mapError;
setDebug(debug, dexieStackFrameFilter);

// src/permanentShareStore.ts
var PermanentShareStoreIndexedDB = class {
  constructor(oid) {
    this.keepOpen = true;
    this.oid = oid;
    this.db = new Dexie$1("peerdraft_" + this.oid);
    this.db.version(2).stores({
      sharedDocs: "path,persistenceId,shareId",
      sharedFolders: "path,persistenceId,shareId"
    });
    this.db.on("close", () => {
      if (this.keepOpen) {
        this.db.open();
      }
    });
    this.documentTable = this.db._allTables["sharedDocs"];
    this.folderTable = this.db._allTables["sharedFolders"];
  }
  close() {
    this.keepOpen = false;
    this.db.close();
  }
  add(doc2) {
    if (doc2 instanceof SharedDocument) {
      return this.documentTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
    if (doc2 instanceof SharedFolder) {
      return this.folderTable.add({
        path: doc2.path,
        shareId: doc2.shareId,
        persistenceId: createRandomId()
      });
    }
  }
  removeDoc(path4) {
    return this.documentTable.delete(path4);
  }
  async getDocByPath(path4) {
    return this.documentTable.get(path4);
  }
  getAllDocs() {
    return this.documentTable.toArray();
  }
  removeFolder(path4) {
    return this.folderTable.delete(path4);
  }
  getAllFolders() {
    return this.folderTable.toArray();
  }
  async getFolderByPath(path4) {
    return this.folderTable.get(path4);
  }
  async deleteDB() {
    window.indexedDB.deleteDatabase(this.folderTable.name);
    window.indexedDB.deleteDatabase(this.documentTable.name);
  }
};

// src/login.ts
var import_obsidian5 = require("obsidian");
var requestLoginCode = async (plugin, email) => {
  const url = new URL("/group/login/send-mail-with-code", plugin.settings.basePath).toString();
  const data = await (0, import_obsidian5.requestUrl)({
    url,
    method: "POST",
    contentType: "application/json",
    body: JSON.stringify({
      email
    })
  }).json;
  if (!data || !data.ok) {
    return;
  }
  return true;
};
var requestWebToken = async (plugin, email, token, longLived) => {
  const url = new URL("/group/login/verify-code", plugin.settings.basePath).toString();
  const data = await (0, import_obsidian5.requestUrl)({
    url,
    method: "POST",
    contentType: "application/json",
    body: JSON.stringify({
      email,
      token,
      longLived
    })
  }).json;
  if (!data || !data.jwt) {
    return;
  }
  return data.jwt;
};
var saveJWT = (oid, jwt) => {
  localStorage.setItem(oid + "-peerdraft-jwt", jwt);
};
var getJWT = (oid) => {
  return localStorage.getItem(oid + "-peerdraft-jwt");
};
var clearJWT = (oid) => {
  localStorage.removeItem(oid + "-peerdraft-jwt");
};
var logout = (plugin) => {
  return new Promise((resolve2) => {
    const server = plugin.serverSync;
    if (server.authenticated) {
      const handler = () => {
        clearJWT(plugin.settings.oid);
        server.jwt = void 0;
        server.off("connection-close", handler);
        showNotice("Logged out of Peerdraft");
        server.connect();
        resolve2();
      };
      server.on("connection-close", handler);
      server.disconnect();
    }
  });
};

// src/ui/login.ts
var import_obsidian6 = require("obsidian");
var LoginModal = class extends import_obsidian6.Modal {
  constructor(plugin, cb) {
    var _a;
    super(plugin.app);
    this.cbCalled = false;
    this.storeJWT = false;
    this.code = "";
    this.email = "";
    this.onClose = () => {
      if (!this.cbCalled) {
        this.cb(false);
        this.cbCalled = true;
      }
    };
    this.plugin = plugin;
    this.cb = cb;
    this.email = (_a = this.plugin.settings.plan.email) != null ? _a : "";
  }
  async onOpen() {
    this.contentEl.empty();
    const heading = this.plugin.settings.plan.email ? "Log in to your Peerdraft account" : "Log in or register with Peerdraft";
    const headerSetting = new import_obsidian6.Setting(this.contentEl).setName(heading);
    const headerDiv = headerSetting.descEl.createDiv();
    headerDiv.createSpan({ text: "To initiate new shared documents or folders you need to have a Peerdraft account. Collaborators can join without registration. If you need any help, " });
    headerDiv.createEl("a", {
      text: "get in touch",
      attr: {
        href: "mailto:dominik@peerdraft.app"
      }
    });
    headerDiv.createSpan({ text: "." });
    const emailSetting = new import_obsidian6.Setting(this.contentEl);
    emailSetting.setName("Your e-mail address");
    emailSetting.descEl.innerHTML = 'By signing up or logging in, you agree to <a href="https://www.peerdraft.app/terms">the Terms of Service</a> and the <a href="https://www.peerdraft.app/privacy">Privacy Policy</a>.';
    emailSetting.addText((text2) => {
      text2.inputEl.setAttr("type", "email");
      text2.setValue(this.email);
      text2.onChange((value) => {
        this.email = value;
      });
    });
    emailSetting.addButton((button) => {
      button.setButtonText("Send Login Code");
      button.onClick(async () => {
        if (!this.email.match(/^\S+@\S+\.\S+$/)) {
          showNotice("Please enter a valid email address.");
        } else {
          const code = await requestLoginCode(this.plugin, this.email);
          if (code) {
            showNotice("Code sent to " + this.email + ".");
          } else {
            showNotice("Something went wrong. Please try again or get in touch with peerdraft support.");
          }
        }
      });
    });
    const rememberSetting = new import_obsidian6.Setting(this.contentEl);
    rememberSetting.setName("Remember me");
    rememberSetting.setDesc("If disabled, you will be asked to log in on every restart of Obsidian.");
    rememberSetting.addToggle((toggl) => {
      toggl.setValue(this.storeJWT);
      toggl.onChange((value) => {
        this.storeJWT = value;
        this.onOpen();
      });
    });
    const codeSetting = new import_obsidian6.Setting(this.contentEl);
    codeSetting.setName("Login Code");
    codeSetting.setDesc("Enter the code you received via email.");
    codeSetting.addText((text2) => {
      text2.inputEl.setAttr("type", "password");
      text2.setValue(this.code);
      text2.onChange((value) => {
        this.code = value;
      });
    });
    codeSetting.addButton((button) => {
      const text2 = this.storeJWT ? "Log in and remember me" : "Log in for this session only";
      button.setButtonText(text2);
      button.onClick(async () => {
        if (!this.email.match(/^\S+@\S+\.\S+$/)) {
          showNotice("Please enter a valid email address.");
          return;
        }
        if (!this.code) {
          return;
        }
        const jwt = await requestWebToken(this.plugin, this.email, this.code, this.storeJWT);
        if (jwt) {
          this.plugin.settings.plan.email = this.email;
          saveSettings(this.plugin.settings, this.plugin);
          if (await this.plugin.serverSync.authenticate(jwt)) {
            if (this.storeJWT) {
              saveJWT(this.plugin.settings.oid, jwt);
            }
            this.cb(true);
            this.cbCalled = true;
            this.close();
          }
        } else {
          showNotice("Something went wrong. Please try again or get in touch with peerdraft support.");
        }
      });
    });
  }
};
var openLoginModal = (peerdraftPlugin) => {
  return new Promise((resolve2) => {
    new LoginModal(peerdraftPlugin, (cb) => {
      resolve2(cb);
    }).open();
  });
};

// src/settings.ts
var DEFAULT_SETTINGS = {
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives",
  name: "",
  root: "",
  plan: {
    type: "hobby",
    email: ""
  },
  duration: 0,
  debug: false,
  version: "",
  serverShares: {
    files: /* @__PURE__ */ new Map(),
    folders: /* @__PURE__ */ new Map()
  }
};
var FORCE_SETTINGS = {
  /*
    basePath: "http://localhost:5173",
    subscriptionAPI: "http://localhost:5173/subscription",
    connectAPI: "http://localhost:5173/subscription/connect",
    sessionAPI: "http://localhost:5173/session",
    sync: "ws://localhost:5173/sync",
    signaling: "ws://localhost:5173/signal",
    actives: "ws://localhost:5173/actives"
  */
  basePath: "https://www.peerdraft.app",
  subscriptionAPI: "https://www.peerdraft.app/subscription",
  connectAPI: "https://www.peerdraft.app/subscription/connect",
  sessionAPI: "https://www.peerdraft.app/session",
  sync: "wss://www.peerdraft.app/sync",
  signaling: "wss://www.peerdraft.app/signal",
  actives: "wss://www.peerdraft.app/actives"
};
var migrateSettings = async (plugin) => {
  var _a;
  const oldSettings = await getSettings(plugin);
  const newSettings = Object.assign({}, DEFAULT_SETTINGS, oldSettings, FORCE_SETTINGS, {
    version: plugin.manifest.version
  });
  newSettings.oid = (_a = oldSettings == null ? void 0 : oldSettings.oid) != null ? _a : plugin.app.appId;
  const files = newSettings.serverShares.files;
  for (const key of files.keys()) {
    if (key.contains("\\")) {
      files.set((0, import_obsidian7.normalizePath)(key), files.get(key));
      files.delete(key);
    }
  }
  const folders = newSettings.serverShares.folders;
  for (const key of folders.keys()) {
    if (key.contains("\\")) {
      folders.set((0, import_obsidian7.normalizePath)(key), folders.get(key));
      folders.delete(key);
    }
  }
  if ((oldSettings == null ? void 0 : oldSettings.oid) && newSettings.serverShares.files.size === 0 && newSettings.serverShares.folders.size === 0) {
    const db = new PermanentShareStoreIndexedDB(oldSettings.oid);
    const docs = await db.getAllDocs();
    docs.forEach((doc2) => {
      newSettings.serverShares.files.set((0, import_obsidian7.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    const folders2 = await db.getAllFolders();
    folders2.forEach((doc2) => {
      newSettings.serverShares.folders.set((0, import_obsidian7.normalizePath)(doc2.path), { persistenceId: doc2.persistenceId, shareId: doc2.shareId });
    });
    saveSettings(newSettings, plugin);
    await db.deleteDB();
  }
  saveSettings(newSettings, plugin);
  if (oldSettings && oldSettings.version != newSettings.version) {
    showTextModal(plugin.app, "Peerdraft updated", "A new version of Peerdraft was installed. Please restart Obsidian before you use Peerdraft again.");
  }
  return newSettings;
};
var getSettings = async (plugin) => {
  var _a, _b;
  const settings = await plugin.loadData();
  if (settings) {
    settings.serverShares = {
      files: new Map((_a = settings.serverShares) == null ? void 0 : _a.files),
      folders: new Map((_b = settings.serverShares) == null ? void 0 : _b.folders)
    };
  }
  return settings;
};
var saveSettings = (0, import_obsidian7.debounce)(async (settings, plugin) => {
  const serialized = JSON.parse(JSON.stringify(settings));
  serialized.serverShares = {
    files: Array.from(settings.serverShares.files.entries()),
    folders: Array.from(settings.serverShares.folders.entries())
  };
  await plugin.saveData(serialized);
}, 1e3, true);
var renderSettings = async (el, plugin) => {
  el.empty();
  const settings = plugin.settings;
  el.createEl("h1", { text: "General" });
  new import_obsidian7.Setting(el).setName("Display Name").setDesc("This name will be shown to your collaborators").addText((text2) => {
    text2.setValue(settings.name);
    text2.onChange(async (value) => {
      settings.name = value;
      saveSettings(settings, plugin);
    });
  });
  const pathSetting = new import_obsidian7.Setting(el);
  pathSetting.setName("Root Folder");
  pathSetting.setDesc("When you import a share from someone else it will be created in this folder.");
  pathSetting.addText((text2) => {
    text2.setValue(settings.root);
    text2.onChange(async (value) => {
      settings.root = value;
      saveSettings(settings, plugin);
    });
    pathSetting.addExtraButton((button) => {
      button.setIcon("search");
      button.onClick(async () => {
        const folder = await promptForFolderSelection(plugin.app);
        if (folder) {
          text2.setValue(folder.path);
          settings.root = folder.path;
          saveSettings(settings, plugin);
        }
      });
    });
  });
  el.createEl("h1", { text: "Your Account" });
  if (plugin.serverSync.authenticated) {
    el.createEl("div", { text: `You are logged in as ${plugin.settings.plan.email}.` });
    el.createEl("p");
    const div2 = el.createEl("div");
    div2.createSpan({ text: "You are on the " }).createEl("b", { text: plugin.settings.plan.type });
    div2.createSpan({ text: " plan." });
    el.createEl("p");
    if (plugin.settings.plan.type === "hobby") {
      new import_obsidian7.Setting(el).setName("Manage your subscription").addButton((button) => {
        button.setButtonText("Upgrade to pro");
        button.setCta();
        button.onClick((e) => {
          window.open(`https://peerdraft.app/checkout?email=${plugin.settings.plan.email}`);
        });
      });
    }
    new import_obsidian7.Setting(el).setName("Log out").addButton((button) => {
      button.setButtonText("Log out");
      button.onClick(async (e) => {
        await logout(plugin);
        renderSettings(el, plugin);
      });
    });
  } else {
    el.createEl("div", { text: `You are not logged in.` });
    el.createEl("p");
    el.createEl("div", { text: `To initiate new shared documents or folders you need to log in to your Peerdraft account. If you only work on shared documents and folders created by others, you don't need an account.` });
    el.createEl("p");
    new import_obsidian7.Setting(el).setName("Log in or create account").addButton((button) => {
      button.setButtonText("Log in or create account");
      button.onClick(async (e) => {
        await openLoginModal(plugin);
        renderSettings(el, plugin);
      });
    });
  }
  el.createEl("h1", { text: "Help" });
  const div = el.createDiv();
  div.createSpan({ text: "If you need any help, " });
  div.createEl("a", {
    text: "get in touch",
    attr: {
      href: "mailto:dominik@peerdraft.app"
    }
  });
  div.createSpan({ text: "." });
};
var createSettingsTab = (plugin) => {
  return new class extends import_obsidian7.PluginSettingTab {
    async display() {
      await renderSettings(this.containerEl, plugin);
    }
  }(plugin.app, plugin);
};

// src/permanentShareStoreFS.ts
var import_obsidian8 = require("obsidian");
var add = async (doc2, plugin) => {
  if (doc2 instanceof SharedDocument) {
    plugin.settings.serverShares.files.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  if (doc2 instanceof SharedFolder) {
    plugin.settings.serverShares.folders.set(doc2.path, {
      shareId: doc2.shareId,
      persistenceId: createRandomId()
    });
  }
  saveSettings(plugin.settings, plugin);
};
var removeDoc = async (path4, plugin) => {
  plugin.settings.serverShares.files.delete((0, import_obsidian8.normalizePath)(path4));
  saveSettings(plugin.settings, plugin);
};
var getDocByPath = (path4, plugin) => {
  return plugin.settings.serverShares.files.get(path4);
};
var moveDoc = async (oldPath, newPath, plugin) => {
  const files = plugin.settings.serverShares.files;
  const entry = files.get(oldPath);
  if (entry) {
    files.delete(oldPath);
    files.set(newPath, entry);
    saveSettings(plugin.settings, plugin);
  }
};
var removeFolder = async (path4, plugin) => {
  plugin.settings.serverShares.folders.delete(path4);
  saveSettings(plugin.settings, plugin);
};
var getFolderByPath = (path4, plugin) => {
  return plugin.settings.serverShares.folders.get(path4);
};
var moveFolder = async (oldPath, newPath, plugin) => {
  const oldPathNormalized = (0, import_obsidian8.normalizePath)(oldPath);
  const newPathNormalized = (0, import_obsidian8.normalizePath)(newPath);
  const files = plugin.settings.serverShares.folders;
  const entry = files.get(oldPathNormalized);
  if (entry) {
    files.delete(oldPathNormalized);
    files.set(newPathNormalized, entry);
    saveSettings(plugin.settings, plugin);
  }
};

// src/ui/folderOptions.ts
var import_obsidian9 = require("obsidian");
var SharedFolderOptionsModal = class extends import_obsidian9.Modal {
  constructor(app, folder) {
    super(app);
    this.folder = folder;
  }
  async onOpen() {
    new import_obsidian9.Setting(this.contentEl).setName(this.folder.getOriginalFolderName()).setHeading();
    const nameSetting = new import_obsidian9.Setting(this.contentEl);
    let tempName = this.folder.getOriginalFolderName();
    nameSetting.setName("Peerdraft folder name");
    nameSetting.addText((text2) => {
      text2.setValue(tempName);
      text2.onChange((value) => {
        tempName = value;
      });
    });
    nameSetting.addButton((button) => {
      button.setButtonText("Update");
      button.onClick(() => {
        if (tempName !== this.folder.getOriginalFolderName()) {
          this.folder.setOriginalFolderName(tempName);
          this.close();
          openFolderOptions(this.app, this.folder);
        }
      });
    });
    const prop = new import_obsidian9.Setting(this.contentEl);
    prop.setName("Auto add property with Peerdraft URL");
    prop.setDesc("Leave empty if no property should be added");
    let tempProp = this.folder.getAutoFillProperty();
    prop.addText((text2) => {
      text2.setValue(tempProp);
      text2.onChange((value) => {
        tempProp = value;
      });
    });
    prop.addButton((button) => {
      button.setButtonText("Update & Apply");
      button.onClick(async () => {
        const oldProperty = this.folder.getAutoFillProperty();
        if (tempProp !== oldProperty) {
          this.folder.setAutoFillProperty(tempProp);
        }
        const notice = showNotice("Updating URLs...");
        await this.folder.updatePropertiesOfAllDocuments(oldProperty);
        notice.hide();
        this.close();
        openFolderOptions(this.app, this.folder);
      });
    });
    const link = new import_obsidian9.Setting(this.contentEl);
    link.setName("Peerdraft URL");
    link.addButton((btn) => {
      btn.setButtonText("Copy Peerdraft URL to clipboard");
      btn.onClick(() => {
        navigator.clipboard.writeText(this.folder.getShareURL());
        showNotice("Link copied to clipboard.");
      });
    });
  }
};
var openFolderOptions = (app, folder) => {
  new SharedFolderOptionsModal(app, folder).open();
};

// src/sharedEntities/sharedFolder.ts
var handleUpdate = (ev, tx, folder, plugin) => {
  var _a;
  if (![plugin.serverSync, (_a = folder.webRTCProvider) == null ? void 0 : _a.room].includes(tx.origin))
    return;
  const changedKeys = ev.changes.keys;
  changedKeys.forEach(async (data, key) => {
    plugin.log("Action: " + data.action + "for " + key + " --> " + tx.doc.getMap("documents").get(key));
    if (data.action === "add") {
      const relativePath = tx.doc.getMap("documents").get(key);
      const absolutePath = path.join(folder.path, relativePath);
      const file = plugin.app.vault.getAbstractFileByPath(absolutePath);
      if (file) {
        const existingDoc = SharedDocument.findById(key);
        if (existingDoc) {
          if (existingDoc.file.path === file.path) {
            plugin.log("Received update, but FS is already in correct state");
          } else {
            showNotice("There is something wrong with your synced file " + file.path + ". Consider re-creating the synced folder from server.");
          }
        } else {
          showNotice("File " + file.path + " already exists. Renaming local file.");
          const alteredPath = path.join(path.dirname(relativePath), path.basename(relativePath, path.extname(relativePath)) + "_" + generateRandomString() + path.extname(relativePath));
          const alteredAbsolutePath = path.join(folder.root.path, alteredPath);
          plugin.app.fileManager.renameFile(file, alteredAbsolutePath);
          SharedDocument.fromIdAndPath(key, absolutePath, plugin);
        }
      } else {
        showNotice("Creating new shared document: " + absolutePath);
        await SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, plugin);
        await SharedDocument.fromIdAndPath(key, absolutePath, plugin);
      }
    } else if (data.action === "update") {
      const newPath = tx.doc.getMap("documents").get(key);
      const document2 = SharedDocument.findById(key);
      if (!document2) {
        showNotice("Document at " + newPath + " doesn't exist in your vault. Consider re-creating the synced folder from server.");
        return;
      }
      plugin.log("Update " + document2.path + "   " + key);
      const folder2 = SharedFolder.getSharedFolderForSubPath(document2.path);
      if (!folder2)
        return;
      let newAbsolutePath = path.join(folder2.root.path, newPath);
      await SharedFolder.getOrCreatePath(path.parse(newAbsolutePath).dir, plugin);
      const alreadyExists = SharedDocument.findByPath(newAbsolutePath);
      if (alreadyExists) {
        if (alreadyExists.shareId === key) {
          plugin.log("Received update, but FS is already in correct state.");
        } else {
          showNotice("File " + newPath + " already exists. Renaming local file.");
          const alteredPath = path.join(path.dirname(newPath), path.basename(newPath, path.extname(newPath)) + "_" + generateRandomString() + path.extname(newPath));
          const alteredAbsolutePath = path.join(folder2.root.path, alteredPath);
          plugin.app.fileManager.renameFile(alreadyExists.file, alteredAbsolutePath);
          SharedDocument.fromIdAndPath(key, alteredAbsolutePath, plugin);
        }
      } else {
        await plugin.app.fileManager.renameFile(document2.file, newAbsolutePath);
      }
    } else if (data.action === "delete") {
      const document2 = SharedDocument.findById(key);
      if (!document2)
        return;
      plugin.log("Delete " + document2.path + "   " + key);
      const file = plugin.app.vault.getAbstractFileByPath(document2.path);
      if (!file)
        return;
      plugin.app.vault.delete(file);
    }
  });
};
var _SharedFolder = class extends SharedEntity {
  constructor(root, plugin, ydoc) {
    super(plugin);
    this.root = root;
    this._path = root.path;
    this.yDoc = ydoc != null ? ydoc : new Doc();
    this.getDocsFragment().observe((ev, tx) => {
      handleUpdate(ev, tx, this, plugin);
    });
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.shareId) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedFolder._sharedEntites.push(this);
    addIsSharedClass(this.path, plugin);
  }
  static async fromTFolder(root, plugin) {
    showNotice(`Inititializing share for ${root.path}.`);
    const files = this.getAllFilesInFolder(root);
    for (const file of files) {
      if (SharedDocument.findByPath(file.path)) {
        showNotice("You can not share a directory that already has shared files in it (right now).");
        return;
      }
    }
    if (!plugin.serverSync.authenticated) {
      showNotice("Please log in to Peerdraft first.");
      const auth = await openLoginModal(plugin);
      if (!auth)
        return;
    }
    const docs = await Promise.all(files.map((file) => {
      return SharedDocument.fromTFile(file, {
        permanent: true
      }, plugin);
    }));
    const folder = new _SharedFolder(root, plugin);
    for (const doc2 of docs) {
      if (doc2) {
        folder.addDocument(doc2);
      }
    }
    folder.yDoc.getText("originalFoldername").insert(0, root.name);
    await folder.initServerYDoc();
    await add(folder, plugin);
    await folder.startIndexedDBSync();
    folder.startWebRTCSync();
    navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + folder.shareId);
    showNotice(`Folder ${folder.path} with ${docs.length} documents shared. URL copied to your clipboard.`, 0);
    openFolderOptions(plugin.app, folder);
    return folder;
  }
  getShareURL() {
    return this.plugin.settings.basePath + "/team/" + this.shareId;
  }
  static async recreate(folder, plugin) {
    const location2 = folder.root.path;
    await folder.unshare();
    await plugin.app.vault.delete(folder.root, true);
    return await this.fromShareURL(plugin.settings.basePath + "/team/" + folder.shareId, plugin, location2);
  }
  static async fromShareURL(url, plugin, location2) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    let folderPath = location2;
    const preFetchedDoc = await plugin.serverSync.requestDocument(id2);
    if (!folderPath) {
      let initialRootName = `_peerdraft_team_folder_${generateRandomString()}`;
      const docFoldername = preFetchedDoc.getText("originalFoldername").toString();
      if (docFoldername != "") {
        const folderExists = plugin.app.vault.getAbstractFileByPath(path.join(plugin.settings.root, docFoldername));
        if (!folderExists) {
          initialRootName = docFoldername;
        } else {
          initialRootName = `_peerdraft_${generateRandomString()}_${docFoldername}`;
        }
      }
      folderPath = path.join(plugin.settings.root, initialRootName);
    }
    const folder = await _SharedFolder.getOrCreatePath(folderPath, plugin);
    if (!folder) {
      showNotice("Could not create folder " + folderPath);
      return;
    }
    ;
    const paths = [];
    const documentMap = preFetchedDoc.getMap("documents");
    for (const entry of documentMap.entries()) {
      let docPath = entry[1];
      const absPath = path.join(folderPath, docPath);
      if (docPath && paths.includes((0, import_obsidian10.normalizePath)(docPath))) {
        const existingDoc = SharedDocument.findById(entry[0]);
        if (existingDoc) {
          if (existingDoc.path === absPath) {
            plugin.log("already synced");
          } else {
            plugin.app.fileManager.renameFile(existingDoc.file, absPath);
          }
        } else {
          docPath = (0, import_obsidian10.normalizePath)(path.join(path.dirname(docPath), path.basename(docPath, path.extname(docPath)) + "_" + generateRandomString() + path.extname(docPath)));
          documentMap.set(entry[0], docPath);
        }
      }
      await SharedDocument.fromIdAndPath(entry[0], absPath, plugin);
      paths.push((0, import_obsidian10.normalizePath)(docPath));
    }
    const sFolder = new _SharedFolder(folder, plugin, preFetchedDoc);
    sFolder._shareId = id2;
    await add(sFolder, plugin);
    await sFolder.startIndexedDBSync();
    if (sFolder.indexedDBProvider) {
      if (!sFolder.indexedDBProvider.synced)
        await sFolder.indexedDBProvider.whenSynced;
      sFolder.syncWithServer();
      sFolder.startWebRTCSync();
    }
    return sFolder;
  }
  static async fromPermanentShareFolder(psf, plugin) {
    if (this.findByPath(psf.path))
      return;
    let tFolder;
    tFolder = plugin.app.vault.getAbstractFileByPath(psf.path);
    if (tFolder instanceof import_obsidian10.TFile) {
      showNotice("Expected " + psf.path + " to be a folder, but it is a file?");
      return;
    }
    if (!(tFolder instanceof import_obsidian10.TFolder)) {
      showNotice("Shared folder " + psf.path + " not found. Creating it now.");
      tFolder = await this.getOrCreatePath(psf.path, plugin);
    }
    if (!(tFolder instanceof import_obsidian10.TFolder)) {
      showNotice("Could not create folder " + psf.path + ".");
      return;
    }
    const folder = new _SharedFolder(tFolder, plugin);
    folder._shareId = psf.shareId;
    const local = await folder.startIndexedDBSync();
    if (local) {
      if (local.synced || await local.whenSynced) {
        folder.syncWithServer();
        folder.startWebRTCSync();
      }
    }
    return folder;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  static getSharedFolderForSubPath(dir) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(dir);
    const folders = this.getAll();
    for (const folder of folders) {
      if (folder.root.path === normalizedPath)
        return;
      if (folder.isPathSubPath(normalizedPath))
        return folder;
    }
  }
  getDocsFragment() {
    return this.yDoc.getMap("documents");
  }
  getDocByRelativePath(dir) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(dir);
    for (const entry of this.getDocsFragment().entries()) {
      if (entry[1] === normalizedPath)
        return entry[0];
    }
  }
  updatePath(oldPath, newPath) {
    const oldPathRelative = path.relative(this.root.path, oldPath);
    const newPathRelative = path.relative(this.root.path, newPath);
    const id2 = this.getDocByRelativePath(oldPathRelative);
    if (id2) {
      this.getDocsFragment().set(id2, (0, import_obsidian10.normalizePath)(newPathRelative));
    }
    return id2;
  }
  calculateHash() {
    const serialized = serialize(Array.from(this.getDocsFragment()));
    return calculateHash(serialized);
  }
  getOriginalFolderName() {
    return this.yDoc.getText("originalFoldername").toString();
  }
  setOriginalFolderName(name) {
    const text2 = this.yDoc.getText("originalFoldername");
    text2.delete(0, text2.length);
    text2.insert(0, name);
  }
  getAutoFillProperty() {
    return this.yDoc.getText("autoFillProperty").toString();
  }
  setAutoFillProperty(property) {
    const prop = this.yDoc.getText("autoFillProperty");
    prop.delete(0, prop.length);
    prop.insert(0, property);
  }
  async updatePropertiesOfAllDocuments(oldPropertyName) {
    const prop = this.getAutoFillProperty();
    if (!prop || prop === "")
      return;
    const docs = this.getDocsFragment();
    for (const entry of docs) {
      const doc2 = SharedDocument.findById(entry[0]);
      if (!doc2)
        return;
      doc2.updateProperty(prop, doc2.getShareURL(), oldPropertyName);
    }
  }
  addDocument(doc2) {
    if (this.getDocsFragment().get(doc2.shareId))
      return;
    const relativePath = path.relative(this.root.path, doc2.path);
    if (relativePath.startsWith(".."))
      return;
    this.getDocsFragment().set(doc2.shareId, relativePath);
  }
  removeDocument(doc2) {
    this.getDocsFragment().delete(doc2.shareId);
    const deleted = this.yDoc.getArray("deleted");
    if (!deleted.toArray().includes(doc2.shareId)) {
      deleted.push([doc2.shareId]);
    }
  }
  isPathSubPath(folder) {
    const relativePath = path.relative(this.root.path, folder);
    return !relativePath.startsWith("..");
  }
  static getAllFilesInFolder(folder) {
    const files = folder.children.flatMap((child) => {
      if (child instanceof import_obsidian10.TFile) {
        if (child.extension === "md") {
          return child;
        }
      }
      if (child instanceof import_obsidian10.TFolder) {
        return this.getAllFilesInFolder(child);
      }
      return [];
    });
    return files;
  }
  async setNewFolderLocation(folder) {
    const oldPath = this._path;
    this.root = folder;
    this._path = (0, import_obsidian10.normalizePath)(folder.path);
    moveFolder(oldPath, folder.path, this.plugin);
  }
  async getOrCreateFile(relativePath) {
    const absolutePath = path.join(this.root.path, relativePath);
    let file = this.plugin.app.vault.getAbstractFileByPath(absolutePath);
    if (file && file instanceof import_obsidian10.TFile)
      return file;
    const folder = await _SharedFolder.getOrCreatePath(path.parse(absolutePath).dir, this.plugin);
    if (!folder) {
      showNotice("Error creating shares");
      return;
    }
    return await this.plugin.app.vault.create(absolutePath, "");
  }
  static async getOrCreatePath(absolutePath, plugin) {
    let folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian10.normalizePath)(absolutePath));
    if (folder && folder instanceof import_obsidian10.TFolder)
      return folder;
    const segments = absolutePath.split(path.sep);
    for (let index = 0; index < segments.length; index++) {
      const subPath = segments.slice(0, index + 1).join(path.sep);
      folder = plugin.app.vault.getAbstractFileByPath((0, import_obsidian10.normalizePath)(subPath));
      if (!folder) {
        folder = await plugin.app.vault.createFolder((0, import_obsidian10.normalizePath)(subPath));
      }
    }
    return folder;
  }
  isFileInSyncObject(file) {
    const normalizedPath = (0, import_obsidian10.normalizePath)(file.path);
    for (const value of this.getDocsFragment().values()) {
      if (normalizedPath === path.join(this.root.path, value))
        return true;
    }
    return false;
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      const handleTimeout = () => {
      };
      this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      provider.doc.on("update", async (update, origin, doc2, tr) => {
        if (this._webRTCTimeout != null) {
          window.clearTimeout(this._webRTCTimeout);
        }
        this._webRTCTimeout = window.setTimeout(handleTimeout, 6e4);
      });
    });
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getFolderByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    this._indexedDBProvider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    return this._indexedDBProvider;
  }
  async unshare() {
    const dbEntry = getFolderByPath(this.path, this.plugin);
    if (dbEntry) {
      removeFolder(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
      await this._indexedDBProvider.destroy();
    }
    this.getDocsFragment().forEach((path4, shareId) => {
      var _a;
      (_a = SharedDocument.findById(shareId)) == null ? void 0 : _a.unshare();
    });
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  destroy() {
    super.destroy();
    _SharedFolder._sharedEntites.splice(_SharedFolder._sharedEntites.indexOf(this), 1);
  }
};
var SharedFolder = _SharedFolder;
SharedFolder._sharedEntites = new Array();

// node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve2, reject2) => {
      const task2 = { resolve: resolve2, reject: reject2, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task2);
      } else {
        this._queue.splice(i + 1, 0, task2);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve2) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve: resolve2, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// node_modules/diff-match-patch-es/dist/index.mjs
var defaultOptions = /* @__PURE__ */ Object.freeze({
  diffTimeout: 1,
  diffEditCost: 4,
  matchThreshold: 0.5,
  matchDistance: 1e3,
  patchDeleteThreshold: 0.5,
  patchMargin: 4,
  matchMaxBits: 32
});
function resolveOptions(options) {
  if (options == null ? void 0 : options.__resolved)
    return options;
  const resolved = {
    ...defaultOptions,
    ...options
  };
  Object.defineProperty(resolved, "__resolved", { value: true, enumerable: false });
  return resolved;
}
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;
function createDiff(op, text2) {
  return [op, text2];
}
function diffMain(text1, text2, options, opt_checklines = true, opt_deadline) {
  const resolved = resolveOptions(options);
  if (typeof opt_deadline == "undefined") {
    if (resolved.diffTimeout <= 0)
      opt_deadline = Number.MAX_VALUE;
    else
      opt_deadline = (/* @__PURE__ */ new Date()).getTime() + resolved.diffTimeout * 1e3;
  }
  const deadline = opt_deadline;
  if (text1 == null || text2 == null)
    throw new Error("Null input. (diff_main)");
  if (text1 === text2) {
    if (text1)
      return [createDiff(DIFF_EQUAL, text1)];
    return [];
  }
  const checklines = opt_checklines;
  let commonlength = diffCommonPrefix(text1, text2);
  const commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);
  commonlength = diffCommonSuffix(text1, text2);
  const commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);
  const diffs = diffCompute(text1, text2, resolved, checklines, deadline);
  if (commonprefix)
    diffs.unshift(createDiff(DIFF_EQUAL, commonprefix));
  if (commonsuffix)
    diffs.push(createDiff(DIFF_EQUAL, commonsuffix));
  diffCleanupMerge(diffs);
  return diffs;
}
function diffCompute(text1, text2, options, checklines, deadline) {
  let diffs;
  if (!text1) {
    return [createDiff(DIFF_INSERT, text2)];
  }
  if (!text2) {
    return [createDiff(DIFF_DELETE, text1)];
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  const i = longtext.indexOf(shorttext);
  if (i !== -1) {
    diffs = [createDiff(DIFF_INSERT, longtext.substring(0, i)), createDiff(DIFF_EQUAL, shorttext), createDiff(DIFF_INSERT, longtext.substring(i + shorttext.length))];
    if (text1.length > text2.length)
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    return diffs;
  }
  if (shorttext.length === 1) {
    return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
  }
  const hm = diffHalfMatch(text1, text2, options);
  if (hm) {
    const text1_a = hm[0];
    const text1_b = hm[1];
    const text2_a = hm[2];
    const text2_b = hm[3];
    const mid_common = hm[4];
    const diffs_a = diffMain(text1_a, text2_a, options, checklines, deadline);
    const diffs_b = diffMain(text1_b, text2_b, options, checklines, deadline);
    return diffs_a.concat([createDiff(DIFF_EQUAL, mid_common)], diffs_b);
  }
  if (checklines && text1.length > 100 && text2.length > 100)
    return diffLineMode(text1, text2, options, deadline);
  return diffBisect(text1, text2, options, deadline);
}
function diffLineMode(text1, text2, options, deadline) {
  const a = diffLinesToChars(text1, text2);
  text1 = a.chars1;
  text2 = a.chars2;
  const linearray = a.lineArray;
  const diffs = diffMain(text1, text2, options, false, deadline);
  diffCharsToLines(diffs, linearray);
  diffCleanupSemantic(diffs);
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        break;
      case DIFF_EQUAL:
        if (count_delete >= 1 && count_insert >= 1) {
          diffs.splice(pointer - count_delete - count_insert, count_delete + count_insert);
          pointer = pointer - count_delete - count_insert;
          const subDiff = diffMain(text_delete, text_insert, options, false, deadline);
          for (let j = subDiff.length - 1; j >= 0; j--)
            diffs.splice(pointer, 0, subDiff[j]);
          pointer = pointer + subDiff.length;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
    pointer++;
  }
  diffs.pop();
  return diffs;
}
function diffBisect(text1, text2, options, deadline) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  const max_d = Math.ceil((text1_length + text2_length) / 2);
  const v_offset = max_d;
  const v_length = 2 * max_d;
  const v1 = new Array(v_length);
  const v2 = new Array(v_length);
  for (let x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  const delta = text1_length - text2_length;
  const front = delta % 2 !== 0;
  let k1start = 0;
  let k1end = 0;
  let k2start = 0;
  let k2end = 0;
  for (let d = 0; d < max_d; d++) {
    if ((/* @__PURE__ */ new Date()).getTime() > deadline)
      break;
    for (let k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      const k1_offset = v_offset + k1;
      let x1;
      if (k1 === -d || k1 !== d && v1[k1_offset - 1] < v1[k1_offset + 1])
        x1 = v1[k1_offset + 1];
      else
        x1 = v1[k1_offset - 1] + 1;
      let y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length && text1.charAt(x1) === text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        k1end += 2;
      } else if (y1 > text2_length) {
        k1start += 2;
      } else if (front) {
        const k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] !== -1) {
          const x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
    for (let k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      const k2_offset = v_offset + k2;
      let x2;
      if (k2 === -d || k2 !== d && v2[k2_offset - 1] < v2[k2_offset + 1])
        x2 = v2[k2_offset + 1];
      else
        x2 = v2[k2_offset - 1] + 1;
      let y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length && text1.charAt(text1_length - x2 - 1) === text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        k2end += 2;
      } else if (y2 > text2_length) {
        k2start += 2;
      } else if (!front) {
        const k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] !== -1) {
          const x1 = v1[k1_offset];
          const y1 = v_offset + x1 - k1_offset;
          x2 = text1_length - x2;
          if (x1 >= x2) {
            return diffBisectSplit(text1, text2, options, x1, y1, deadline);
          }
        }
      }
    }
  }
  return [createDiff(DIFF_DELETE, text1), createDiff(DIFF_INSERT, text2)];
}
function diffBisectSplit(text1, text2, options, x, y, deadline) {
  const text1a = text1.substring(0, x);
  const text2a = text2.substring(0, y);
  const text1b = text1.substring(x);
  const text2b = text2.substring(y);
  const diffs = diffMain(text1a, text2a, options, false, deadline);
  const diffsb = diffMain(text1b, text2b, options, false, deadline);
  return diffs.concat(diffsb);
}
function diffLinesToChars(text1, text2) {
  const lineArray = [];
  const lineHash = {};
  let maxLines = 4e4;
  lineArray[0] = "";
  function diffLinesToCharsMunge(text3) {
    let chars = "";
    let lineStart = 0;
    let lineEnd = -1;
    let lineArrayLength = lineArray.length;
    while (lineEnd < text3.length - 1) {
      lineEnd = text3.indexOf("\n", lineStart);
      if (lineEnd === -1)
        lineEnd = text3.length - 1;
      let line = text3.substring(lineStart, lineEnd + 1);
      if (lineHash.hasOwnProperty ? Object.prototype.hasOwnProperty.call(lineHash, line) : lineHash[line] !== void 0) {
        chars += String.fromCharCode(lineHash[line]);
      } else {
        if (lineArrayLength === maxLines) {
          line = text3.substring(lineStart);
          lineEnd = text3.length;
        }
        chars += String.fromCharCode(lineArrayLength);
        lineHash[line] = lineArrayLength;
        lineArray[lineArrayLength++] = line;
      }
      lineStart = lineEnd + 1;
    }
    return chars;
  }
  const chars1 = diffLinesToCharsMunge(text1);
  maxLines = 65535;
  const chars2 = diffLinesToCharsMunge(text2);
  return { chars1, chars2, lineArray };
}
function diffCharsToLines(diffs, lineArray) {
  for (let i = 0; i < diffs.length; i++) {
    const chars = diffs[i][1];
    const text2 = [];
    for (let j = 0; j < chars.length; j++)
      text2[j] = lineArray[chars.charCodeAt(j)];
    diffs[i][1] = text2.join("");
  }
}
function diffCommonPrefix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(0) !== text2.charAt(0))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) === text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonSuffix(text1, text2) {
  if (!text1 || !text2 || text1.charAt(text1.length - 1) !== text2.charAt(text2.length - 1))
    return 0;
  let pointermin = 0;
  let pointermax = Math.min(text1.length, text2.length);
  let pointermid = pointermax;
  let pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) === text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
}
function diffCommonOverlap(text1, text2) {
  const text1_length = text1.length;
  const text2_length = text2.length;
  if (text1_length === 0 || text2_length === 0)
    return 0;
  if (text1_length > text2_length)
    text1 = text1.substring(text1_length - text2_length);
  else if (text1_length < text2_length)
    text2 = text2.substring(0, text1_length);
  const text_length = Math.min(text1_length, text2_length);
  if (text1 === text2)
    return text_length;
  let best = 0;
  let length3 = 1;
  while (true) {
    const pattern = text1.substring(text_length - length3);
    const found = text2.indexOf(pattern);
    if (found === -1)
      return best;
    length3 += found;
    if (found === 0 || text1.substring(text_length - length3) === text2.substring(0, length3)) {
      best = length3;
      length3++;
    }
  }
}
function diffHalfMatch(text1, text2, options) {
  if (options.diffTimeout <= 0) {
    return null;
  }
  const longtext = text1.length > text2.length ? text1 : text2;
  const shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length)
    return null;
  function diffHalfMatchI(longtext2, shorttext2, i) {
    const seed = longtext2.substring(i, i + Math.floor(longtext2.length / 4));
    let j = -1;
    let best_common = "";
    let best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext2.indexOf(seed, j + 1)) !== -1) {
      const prefixLength = diffCommonPrefix(longtext2.substring(i), shorttext2.substring(j));
      const suffixLength = diffCommonSuffix(longtext2.substring(0, i), shorttext2.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext2.substring(j - suffixLength, j) + shorttext2.substring(j, j + prefixLength);
        best_longtext_a = longtext2.substring(0, i - suffixLength);
        best_longtext_b = longtext2.substring(i + prefixLength);
        best_shorttext_a = shorttext2.substring(0, j - suffixLength);
        best_shorttext_b = shorttext2.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext2.length)
      return [best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common];
    else
      return null;
  }
  const hm1 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 4));
  const hm2 = diffHalfMatchI(longtext, shorttext, Math.ceil(longtext.length / 2));
  let hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }
  let text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  const mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
}
function diffCleanupSemantic(diffs) {
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let length_insertions1 = 0;
  let length_deletions1 = 0;
  let length_insertions2 = 0;
  let length_deletions2 = 0;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      equalities[equalitiesLength++] = pointer;
      length_insertions1 = length_insertions2;
      length_deletions1 = length_deletions2;
      length_insertions2 = 0;
      length_deletions2 = 0;
      lastEquality = diffs[pointer][1];
    } else {
      if (diffs[pointer][0] === DIFF_INSERT)
        length_insertions2 += diffs[pointer][1].length;
      else
        length_deletions2 += diffs[pointer][1].length;
      if (lastEquality && lastEquality.length <= Math.max(length_insertions1, length_deletions1) && lastEquality.length <= Math.max(length_insertions2, length_deletions2)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        equalitiesLength--;
        pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
        length_insertions1 = 0;
        length_deletions1 = 0;
        length_insertions2 = 0;
        length_deletions2 = 0;
        lastEquality = null;
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
  diffCleanupSemanticLossless(diffs);
  pointer = 1;
  while (pointer < diffs.length) {
    if (diffs[pointer - 1][0] === DIFF_DELETE && diffs[pointer][0] === DIFF_INSERT) {
      const deletion = diffs[pointer - 1][1];
      const insertion = diffs[pointer][1];
      const overlap_length1 = diffCommonOverlap(deletion, insertion);
      const overlap_length2 = diffCommonOverlap(insertion, deletion);
      if (overlap_length1 >= overlap_length2) {
        if (overlap_length1 >= deletion.length / 2 || overlap_length1 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, insertion.substring(0, overlap_length1)));
          diffs[pointer - 1][1] = deletion.substring(0, deletion.length - overlap_length1);
          diffs[pointer + 1][1] = insertion.substring(overlap_length1);
          pointer++;
        }
      } else {
        if (overlap_length2 >= deletion.length / 2 || overlap_length2 >= insertion.length / 2) {
          diffs.splice(pointer, 0, createDiff(DIFF_EQUAL, deletion.substring(0, overlap_length2)));
          diffs[pointer - 1][0] = DIFF_INSERT;
          diffs[pointer - 1][1] = insertion.substring(0, insertion.length - overlap_length2);
          diffs[pointer + 1][0] = DIFF_DELETE;
          diffs[pointer + 1][1] = deletion.substring(overlap_length2);
          pointer++;
        }
      }
      pointer++;
    }
    pointer++;
  }
}
var nonAlphaNumericRegex_ = /[^a-zA-Z0-9]/;
var whitespaceRegex_ = /\s/;
var linebreakRegex_ = /[\r\n]/;
var blanklineEndRegex_ = /\n\r?\n$/;
var blanklineStartRegex_ = /^\r?\n\r?\n/;
function diffCleanupSemanticLossless(diffs) {
  function diffCleanupSemanticScore(one, two) {
    if (!one || !two) {
      return 6;
    }
    const char1 = one.charAt(one.length - 1);
    const char2 = two.charAt(0);
    const nonAlphaNumeric1 = char1.match(nonAlphaNumericRegex_);
    const nonAlphaNumeric2 = char2.match(nonAlphaNumericRegex_);
    const whitespace1 = nonAlphaNumeric1 && char1.match(whitespaceRegex_);
    const whitespace2 = nonAlphaNumeric2 && char2.match(whitespaceRegex_);
    const lineBreak1 = whitespace1 && char1.match(linebreakRegex_);
    const lineBreak2 = whitespace2 && char2.match(linebreakRegex_);
    const blankLine1 = lineBreak1 && one.match(blanklineEndRegex_);
    const blankLine2 = lineBreak2 && two.match(blanklineStartRegex_);
    if (blankLine1 || blankLine2) {
      return 5;
    } else if (lineBreak1 || lineBreak2) {
      return 4;
    } else if (nonAlphaNumeric1 && !whitespace1 && whitespace2) {
      return 3;
    } else if (whitespace1 || whitespace2) {
      return 2;
    } else if (nonAlphaNumeric1 || nonAlphaNumeric2) {
      return 1;
    }
    return 0;
  }
  let pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      let equality1 = diffs[pointer - 1][1];
      let edit = diffs[pointer][1];
      let equality2 = diffs[pointer + 1][1];
      const commonOffset = diffCommonSuffix(equality1, edit);
      if (commonOffset) {
        const commonString = edit.substring(edit.length - commonOffset);
        equality1 = equality1.substring(0, equality1.length - commonOffset);
        edit = commonString + edit.substring(0, edit.length - commonOffset);
        equality2 = commonString + equality2;
      }
      let bestEquality1 = equality1;
      let bestEdit = edit;
      let bestEquality2 = equality2;
      let bestScore = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
      while (edit.charAt(0) === equality2.charAt(0)) {
        equality1 += edit.charAt(0);
        edit = edit.substring(1) + equality2.charAt(0);
        equality2 = equality2.substring(1);
        const score = diffCleanupSemanticScore(equality1, edit) + diffCleanupSemanticScore(edit, equality2);
        if (score >= bestScore) {
          bestScore = score;
          bestEquality1 = equality1;
          bestEdit = edit;
          bestEquality2 = equality2;
        }
      }
      if (diffs[pointer - 1][1] !== bestEquality1) {
        if (bestEquality1) {
          diffs[pointer - 1][1] = bestEquality1;
        } else {
          diffs.splice(pointer - 1, 1);
          pointer--;
        }
        diffs[pointer][1] = bestEdit;
        if (bestEquality2) {
          diffs[pointer + 1][1] = bestEquality2;
        } else {
          diffs.splice(pointer + 1, 1);
          pointer--;
        }
      }
    }
    pointer++;
  }
}
function diffCleanupEfficiency(diffs, options = {}) {
  const {
    diffEditCost = defaultOptions.diffEditCost
  } = options;
  let changes = false;
  const equalities = [];
  let equalitiesLength = 0;
  let lastEquality = null;
  let pointer = 0;
  let pre_ins = false;
  let pre_del = false;
  let post_ins = false;
  let post_del = false;
  while (pointer < diffs.length) {
    if (diffs[pointer][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].length < diffEditCost && (post_ins || post_del)) {
        equalities[equalitiesLength++] = pointer;
        pre_ins = post_ins;
        pre_del = post_del;
        lastEquality = diffs[pointer][1];
      } else {
        equalitiesLength = 0;
        lastEquality = null;
      }
      post_ins = post_del = false;
    } else {
      let booleanCount = function(...args2) {
        return args2.filter(Boolean).length;
      };
      if (diffs[pointer][0] === DIFF_DELETE)
        post_del = true;
      else
        post_ins = true;
      if (lastEquality && (pre_ins && pre_del && post_ins && post_del || lastEquality.length < diffEditCost / 2 && booleanCount(pre_ins, pre_del, post_ins, post_del) === 3)) {
        diffs.splice(equalities[equalitiesLength - 1], 0, createDiff(DIFF_DELETE, lastEquality));
        diffs[equalities[equalitiesLength - 1] + 1][0] = DIFF_INSERT;
        equalitiesLength--;
        lastEquality = null;
        if (pre_ins && pre_del) {
          post_ins = post_del = true;
          equalitiesLength = 0;
        } else {
          equalitiesLength--;
          pointer = equalitiesLength > 0 ? equalities[equalitiesLength - 1] : -1;
          post_ins = post_del = false;
        }
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}
function diffCleanupMerge(diffs) {
  diffs.push(createDiff(DIFF_EQUAL, ""));
  let pointer = 0;
  let count_delete = 0;
  let count_insert = 0;
  let text_delete = "";
  let text_insert = "";
  let commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            commonlength = diffCommonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if (pointer - count_delete - count_insert > 0 && diffs[pointer - count_delete - count_insert - 1][0] === DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] += text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, createDiff(DIFF_EQUAL, text_insert.substring(0, commonlength)));
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            commonlength = diffCommonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length - commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length - commonlength);
              text_delete = text_delete.substring(0, text_delete.length - commonlength);
            }
          }
          pointer -= count_delete + count_insert;
          diffs.splice(pointer, count_delete + count_insert);
          if (text_delete.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_DELETE, text_delete));
            pointer++;
          }
          if (text_insert.length) {
            diffs.splice(pointer, 0, createDiff(DIFF_INSERT, text_insert));
            pointer++;
          }
          pointer++;
        } else if (pointer !== 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = "";
        text_insert = "";
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === "")
    diffs.pop();
  let changes = false;
  pointer = 1;
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] === DIFF_EQUAL && diffs[pointer + 1][0] === DIFF_EQUAL) {
      if (diffs[pointer][1].substring(diffs[pointer][1].length - diffs[pointer - 1][1].length) === diffs[pointer - 1][1]) {
        diffs[pointer][1] = diffs[pointer - 1][1] + diffs[pointer][1].substring(0, diffs[pointer][1].length - diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) === diffs[pointer + 1][1]) {
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] = diffs[pointer][1].substring(diffs[pointer + 1][1].length) + diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  if (changes)
    diffCleanupMerge(diffs);
}

// src/sharedEntities/sharedDocument.ts
var _SharedDocument = class extends SharedEntity {
  constructor(opts, plugin) {
    var _a;
    super(plugin);
    this.mutex = new Mutex();
    if (opts.path) {
      this._path = (0, import_obsidian11.normalizePath)(opts.path);
      const file = this.plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(opts.path));
      if (file instanceof import_obsidian11.TFile) {
        this._file = file;
      } else {
        showNotice("ERROR creating sharedDoc");
      }
    }
    if (opts.id) {
      this._shareId = opts.id;
    }
    this.yDoc = (_a = opts.yDoc) != null ? _a : new Doc();
    this.yDoc.on("update", (update, origin, yDoc, tr) => {
      if (tr.local && this.isPermanent) {
        plugin.serverSync.sendUpdate(this, update);
      }
    });
    _SharedDocument._sharedEntites.push(this);
    this._extensions = new PeerdraftRecord();
    this._extensions.on("delete", () => {
      if (this._extensions.size === 0 && this._webRTCProvider) {
        this._webRTCProvider.awareness.setLocalState({});
      }
    });
    this.getContentFragment().observe(async () => {
      if (this._file && this._extensions.size === 0) {
        (0, import_obsidian11.debounce)(() => {
          this.mutex.runExclusive(async () => {
            const yDocContent = this.getValue();
            const fileContent = await this.plugin.app.vault.read(this._file);
            if (yDocContent != fileContent) {
              this.lastUpdateTriggeredByDocChange = new Date().valueOf();
              await this.plugin.app.vault.modify(this._file, yDocContent, {
                mtime: this.lastUpdateTriggeredByDocChange
              });
            }
          });
        }, 1e3, true)();
      }
    });
    this.plugin.registerEvent(this.plugin.app.vault.on("modify", async (file) => {
      if (this.file === file && this._extensions.size === 0 && this.file.stat.mtime != this.lastUpdateTriggeredByDocChange) {
        this.mutex.runExclusive(async () => {
          const yDocContent = this.getValue();
          const fileContent = await this.plugin.app.vault.read(this._file);
          if (yDocContent != fileContent) {
            const diffs = diffMain(yDocContent, fileContent);
            diffCleanupEfficiency(diffs);
            const content = this.getContentFragment();
            let pos = 0;
            this.yDoc.transact(() => {
              for (const diff of diffs) {
                const text2 = diff[1];
                const length3 = text2.length;
                switch (diff[0]) {
                  case 0:
                    {
                      pos += length3;
                    }
                    break;
                  case -1:
                    {
                      content.delete(pos, length3);
                    }
                    break;
                  case 1:
                    {
                      content.insert(pos, text2);
                      pos += length3;
                    }
                    break;
                }
              }
            });
          }
        });
      }
    }));
    addIsSharedClass(this.path, this.plugin);
  }
  static async fromView(view, plugin, opts = { permanent: false }) {
    if (!view.file)
      return;
    if (this.findByPath(view.file.path))
      return;
    const doc2 = await this.fromTFile(view.file, opts, plugin);
    if (doc2) {
      doc2.startWebRTCSync();
      if (doc2.isPermanent && doc2._webRTCProvider) {
        doc2.getOwnerFragment().insert(0, doc2._webRTCProvider.awareness.clientID.toFixed(0));
      } else {
        doc2.addStatusBarEntry();
        pinLeaf(view.leaf);
      }
      navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + doc2.shareId);
      showNotice("Collaboration started for " + doc2.path + ". Link copied to Clipboard.");
    }
    return doc2;
  }
  static async fromPermanentShareDocument(pd, plugin) {
    if (this.findByPath(pd.path))
      return;
    const file = plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(pd.path));
    if (!file) {
      showNotice("File " + pd.path + " not found. Creating it now.");
      await SharedFolder.getOrCreatePath(path2.dirname(pd.path), plugin);
      const file2 = await plugin.app.vault.create(pd.path, "");
      if (!file2) {
        showNotice("Error creating file " + pd.path + ".");
        return;
      }
    }
    const doc2 = new _SharedDocument({
      path: pd.path
    }, plugin);
    doc2._isPermanent = true;
    doc2._shareId = pd.shareId;
    await doc2.startIndexedDBSync();
    doc2.syncWithServer();
    plugin.activeStreamClient.add([doc2.shareId]);
    return doc2;
  }
  static async fromShareURL(url, plugin) {
    const id2 = url.split("/").pop();
    if (!id2 || !id2.match("^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$")) {
      showNotice("No valid peerdraft link");
      return;
    }
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    const isPermanent = await plugin.serverAPI.isSessionPermanent(id2);
    const yDoc = new Doc();
    showNotice("Trying to initiate sync...");
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc
    }, plugin);
    await new Promise((resolve2) => {
      doc2.startWebRTCSync();
      if (isPermanent) {
        doc2.syncWithServer();
      }
      yDoc.once("update", () => {
        resolve2();
      });
    });
    const docFilename = doc2.yDoc.getText("originalFilename").toString();
    let initialFileName = `_peerdraft_session_${id2}_${generateRandomString()}.md`;
    if (docFilename != "") {
      const fileExists = plugin.app.vault.getAbstractFileByPath((0, import_obsidian11.normalizePath)(docFilename));
      if (!fileExists) {
        initialFileName = docFilename;
      } else {
        initialFileName = `_peerdraft_${generateRandomString()}_${docFilename}`;
      }
    }
    const parent = plugin.settings.root || plugin.app.fileManager.getNewFileParent("", initialFileName).path;
    const filePath = path2.join(parent, initialFileName);
    const folder = await SharedFolder.getOrCreatePath(path2.dirname(filePath), plugin);
    const file = await plugin.app.vault.create(filePath, doc2.getValue());
    addIsSharedClass(file.path, plugin);
    doc2._file = file;
    doc2._path = file.path;
    if (isPermanent) {
      doc2._isPermanent = true;
      await add(doc2, plugin);
      await doc2.startIndexedDBSync();
      plugin.activeStreamClient.add([doc2.shareId]);
    }
    const leaf = await openFileInNewTab(file, plugin.app.workspace);
    doc2.addStatusBarEntry();
    doc2.addExtensionToLeaf(leaf.id);
    pinLeaf(leaf);
    showNotice("Joined Session in " + doc2.path + ".");
    return doc2;
  }
  static async fromIdAndPath(id2, location2, plugin) {
    const normalizedPath = (0, import_obsidian11.normalizePath)(location2);
    const existingDoc = _SharedDocument.findById(id2);
    if (existingDoc) {
      showNotice("This share is already active: " + existingDoc.path);
      return;
    }
    await SharedFolder.getOrCreatePath(path2.dirname(normalizedPath), plugin);
    showNotice("Creating new synced file " + normalizedPath);
    const ydoc = await plugin.serverSync.requestDocument(id2);
    const doc2 = new _SharedDocument({
      id: id2,
      yDoc: ydoc
    }, plugin);
    doc2._path = normalizedPath;
    const file = await plugin.app.vault.create(normalizedPath, ydoc.getText("content").toString());
    doc2._file = file;
    doc2.syncWithServer();
    await doc2.setPermanent();
    await doc2.startIndexedDBSync();
    addIsSharedClass(doc2.path, plugin);
  }
  static async fromTFile(file, opts, plugin) {
    var _a;
    if (!["md", "MD"].contains(file.extension))
      return;
    const existing = _SharedDocument.findByPath(file.path);
    if (existing)
      return existing;
    if (!plugin.serverSync.authenticated) {
      showNotice("Please log in to Peerdraft first.");
      const auth = await openLoginModal(plugin);
      if (!auth)
        return;
    }
    const doc2 = new _SharedDocument({ path: file.path }, plugin);
    const leafIds = getLeafIdsByPath(file.path, plugin.pws);
    if (leafIds.length > 0) {
      const content = ((_a = plugin.app.workspace.getLeafById(leafIds[0])) == null ? void 0 : _a.view).editor.getValue();
      doc2.getContentFragment().insert(0, content);
    } else {
      const content = await plugin.app.vault.read(file);
      doc2.getContentFragment().insert(0, content);
    }
    doc2.yDoc.getText("originalFilename").insert(0, file.name);
    if (opts.permanent) {
      await doc2.initServerYDoc();
      await doc2.setPermanent();
      doc2.startIndexedDBSync();
    } else {
      doc2._shareId = createRandomId();
    }
    for (const id2 of leafIds) {
      doc2.addExtensionToLeaf(id2);
    }
    showNotice(`Inititialized share for ${file.path}`);
    return doc2;
  }
  static findByPath(path4) {
    return super.findByPath(path4);
  }
  static findById(id2) {
    return super.findById(id2);
  }
  static getAll() {
    return super.getAll();
  }
  get file() {
    return this._file;
  }
  calculateHash() {
    const text2 = this.getContentFragment().toString();
    return calculateHash(text2);
  }
  startWebRTCSync() {
    return super.startWebRTCSync((provider) => {
      provider.awareness.setLocalStateField("user", {
        name: this.plugin.settings.name,
        color: _SharedDocument._userColor.dark,
        colorLight: _SharedDocument._userColor.light
      });
      provider.awareness.on("update", async (msg) => {
        var _a, _b, _c, _d;
        const removed = (_a = msg.removed) != null ? _a : [];
        if (removed && removed.length > 0) {
          const removedStrings = removed.map((id2) => {
            return id2.toFixed(0);
          });
          const owner = this.getOwnerFragment().toString();
          if (owner != provider.awareness.clientID.toString()) {
            if (removedStrings.includes(owner) && !this.isPermanent) {
              showNotice("Shared session for " + this.path + " stopped by owner");
              await this.unshare();
            }
          }
        }
        const added = (_b = msg.added) != null ? _b : [];
        if (added && added.length > 0) {
          const states = provider.awareness.getStates();
          for (const key of added) {
            const peer = states.get(key);
            if (peer && this.path && key != ((_c = this._webRTCProvider) == null ? void 0 : _c.awareness.clientID)) {
              showNotice(`${(_d = peer.user) == null ? void 0 : _d.name} is working on ${this.path}`, 1e4);
            }
          }
        }
      });
    });
  }
  async setNewFileLocation(file) {
    const oldPath = this._path;
    this._file = file;
    this._path = (0, import_obsidian11.normalizePath)(file.path);
    if (this.statusBarEntry) {
      this.removeStatusStatusBarEntry();
      this.addStatusBarEntry();
    }
    await moveDoc(oldPath, file.path, this.plugin);
    removeIsSharedClass(oldPath, this.plugin);
    addIsSharedClass(this.path, this.plugin);
  }
  async setPermanent() {
    if (!this._isPermanent) {
      this._isPermanent = true;
      await add(this, this.plugin);
      this.plugin.activeStreamClient.add([this.shareId]);
    }
  }
  get isPermanent() {
    return this._isPermanent;
  }
  getValue() {
    return this.getContentFragment().toString();
  }
  getContentFragment() {
    return this.yDoc.getText("content");
  }
  getOwnerFragment() {
    return this.yDoc.getText("owner");
  }
  async startIndexedDBSync() {
    var _a;
    if (this._indexedDBProvider)
      return this._indexedDBProvider;
    const id2 = (_a = getDocByPath(this.path, this.plugin)) == null ? void 0 : _a.persistenceId;
    if (!id2)
      return;
    const provider = new IndexeddbPersistence(SharedEntity.DB_PERSISTENCE_PREFIX + id2, this.yDoc);
    this._indexedDBProvider = provider;
    if (!provider.synced)
      await provider.whenSynced;
    return this._indexedDBProvider;
  }
  addExtensionToLeaf(leafId) {
    const webRTCProvider = this.startWebRTCSync();
    if (!webRTCProvider)
      return;
    if (this._extensions.get(leafId))
      return;
    const pLeaf = this.plugin.pws.get(leafId);
    if (!pLeaf)
      return;
    if (pLeaf.path != this._path)
      return;
    if (pLeaf.isPreview) {
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
      return;
    }
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (!leaf)
      return;
    const view = leaf.view;
    const editor = view.editor;
    editor.setValue(this.getValue());
    const undoManager = new UndoManager(this.getContentFragment());
    const extension = yCollab(this.getContentFragment(), webRTCProvider.awareness, { undoManager });
    const compartment = new import_state.Compartment();
    const editorView = editor.cm;
    editorView.dispatch({
      effects: import_state2.StateEffect.appendConfig.of(compartment.of(extension))
    });
    this._extensions.set(leafId, compartment);
    pLeaf.once("changeIsPreview", () => {
      this.removeExtensionFromLeaf(leafId);
      pLeaf.once("changeIsPreview", () => {
        this.addExtensionToLeaf(leafId);
      });
    });
    return import_state.Compartment;
  }
  removeExtensionFromLeaf(leafId) {
    const leaf = this.plugin.app.workspace.getLeafById(leafId);
    if (leaf) {
      try {
        const editor = leaf.view.editor;
        const editorView = editor.cm;
        const compartment = this._extensions.get(leafId);
        if (compartment) {
          editorView.dispatch({
            effects: compartment.reconfigure([])
          });
        }
      } catch (error) {
        this.plugin.log("editor already gone");
      }
    }
    this._extensions.delete(leafId);
  }
  addStatusBarEntry() {
    if (this.statusBarEntry)
      return;
    const menu = new import_obsidian11.Menu();
    menu.addItem((item) => {
      item.setTitle("Copy link");
      item.onClick(() => {
        navigator.clipboard.writeText(this.plugin.settings.basePath + "/cm/" + this.shareId);
        showNotice("Link copied to clipboard.");
      });
    });
    menu.addItem((item) => {
      item.setTitle("Stop shared session");
      item.onClick(async () => {
        await this.unshare();
      });
    });
    const status = this.plugin.addStatusBarItem();
    status.addClass("mod-clickable");
    status.createEl("span", { text: "Sharing '" + this.path + "'" });
    status.onClickEvent((event) => {
      menu.showAtMouseEvent(event);
    });
    this.statusBarEntry = status;
  }
  removeStatusStatusBarEntry() {
    if (!this.statusBarEntry)
      return;
    this.statusBarEntry.remove();
    this.statusBarEntry = void 0;
  }
  async unshare() {
    const dbEntry = getDocByPath(this.path, this.plugin);
    if (dbEntry) {
      removeDoc(this.path, this.plugin);
    }
    if (this._indexedDBProvider) {
      await this._indexedDBProvider.clearData();
    }
    this.destroy();
    removeIsSharedClass(this.path, this.plugin);
  }
  getShareURL() {
    return this.plugin.settings.basePath + "/cm/" + this.shareId;
  }
  updateProperty(name, value, oldProperty) {
    this.plugin.app.fileManager.processFrontMatter(this.file, (fm) => {
      if (oldProperty) {
        delete fm[oldProperty];
      }
      fm[name] = value;
    });
  }
  destroy() {
    if (!this.isPermanent) {
      showNotice("Stopping collaboration on " + this.path + ".");
    }
    for (const key of this._extensions.keys) {
      this.removeExtensionFromLeaf(key);
    }
    this._extensions.destroy();
    super.destroy();
    this.removeStatusStatusBarEntry();
    _SharedDocument._sharedEntites.splice(_SharedDocument._sharedEntites.indexOf(this), 1);
  }
};
var SharedDocument = _SharedDocument;
SharedDocument._userColor = usercolors[randomUint32() % usercolors.length];
SharedDocument._sharedEntites = new Array();

// src/activeStreamClient.ts
var handleMessage = (data) => {
  var _a, _b;
  const message = JSON.parse(data);
  for (const id2 of message.docs) {
    (_a = SharedDocument.findById(id2)) == null ? void 0 : _a.startWebRTCSync();
    (_b = SharedFolder.findById(id2)) == null ? void 0 : _b.startWebRTCSync();
  }
};
var setupWS2 = (client) => {
  if (client.shouldConnect && client.ws === null) {
    const websocket = new WebSocket(client.url);
    client.ws = websocket;
    client.wsconnecting = true;
    client.wsconnected = false;
    websocket.onmessage = (event) => {
      client.wsLastMessageReceived = getUnixTime();
      handleMessage(event.data);
    };
    websocket.onerror = (event) => {
      client.emit("connection-error", [event, client]);
    };
    websocket.onclose = (event) => {
      client.emit("connection-close", [event, client]);
      client.ws = null;
      client.wsconnecting = false;
      if (client.wsconnected) {
        client.wsconnected = false;
        client.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        client.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS2,
        min(
          pow(2, client.wsUnsuccessfulReconnects) * 100,
          client.maxBackoffTime
        ),
        client
      );
    };
    websocket.onopen = () => {
      client.wsLastMessageReceived = getUnixTime();
      client.wsconnecting = false;
      client.wsconnected = true;
      client.wsUnsuccessfulReconnects = 0;
      client.emit("status", [{
        status: "connected"
      }]);
      client.send(JSON.stringify({
        type: "full",
        docs: Array.from(client.docIds)
      }));
    };
    client.emit("status", [{
      status: "connecting"
    }]);
  }
};
var ActiveStreamClient = class extends ObservableV2 {
  constructor(url, opts = {
    connect: true,
    resyncInterval: -1,
    maxBackoffTime: 2500
  }) {
    super();
    this.maxBackoffTime = opts.maxBackoffTime;
    this.url = url;
    this.wsconnected = false;
    this.wsconnecting = false;
    this.wsUnsuccessfulReconnects = 0;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = opts.connect;
    this._resyncInterval = 0;
    this.docIds = /* @__PURE__ */ new Set();
    if (opts.resyncInterval > 0) {
      this._resyncInterval = window.setInterval(() => {
        if (this.ws && this.ws.readyState === WebSocket.OPEN) {
          this.send(JSON.stringify({
            type: "full",
            docs: Array.from(this.docIds)
          }));
        }
      }, opts.resyncInterval);
    }
    if (opts.connect) {
      this.connect();
    }
  }
  send(data) {
    var _a, _b;
    if (this.ws && this.ws.readyState !== this.ws.CONNECTING && this.ws.readyState !== this.ws.OPEN) {
      this.ws.close();
    }
    try {
      (_a = this.ws) == null ? void 0 : _a.send(data);
    } catch (e) {
      (_b = this.ws) == null ? void 0 : _b.close();
    }
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS2(this);
    }
  }
  add(ids) {
    for (const id2 of ids) {
      this.docIds.add(id2);
    }
    this.send(JSON.stringify({
      type: "add",
      docs: ids
    }));
  }
  remove(ids) {
    for (const id2 of ids) {
      this.docIds.delete(id2);
    }
    this.send(JSON.stringify({
      type: "remove",
      docs: ids
    }));
  }
};

// src/cookie.ts
var import_obsidian12 = require("obsidian");
var import_remote = require("@electron/remote");
var prepareCommunication = async (plugin) => {
  if (import_obsidian12.Platform.isDesktopApp) {
    await import_remote.session.defaultSession.cookies.set({ url: "https://www.peerdraft.app", "name": "oid", "value": plugin.settings.oid, "domain": "www.peerdraft.app", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
    await import_remote.session.defaultSession.cookies.set({ url: "http://localhost:5173", "name": "oid", "value": plugin.settings.oid, "domain": "localhost", "path": "/", "secure": true, "httpOnly": true, "sameSite": "no_restriction" });
  } else if (import_obsidian12.Platform.isMobileApp) {
    const signalingURL = new URL(plugin.settings.signaling);
    signalingURL.searchParams.append("oid", plugin.settings.oid);
    plugin.settings.signaling = signalingURL.toString();
  }
};

// src/serverAPI.ts
var import_obsidian13 = require("obsidian");
var ServerAPI = class {
  constructor(opts) {
    this.opts = opts;
  }
  async createPermanentSession() {
    const data = await (0, import_obsidian13.requestUrl)({
      url: this.opts.permanentSessionUrl,
      method: "POST",
      contentType: "application/json",
      body: JSON.stringify({
        oid: this.opts.oid
      })
    }).json;
    if (!data || !data.id) {
      showNotice("Error creating shared file");
      return;
    }
    return data;
  }
  async isSessionPermanent(id2) {
    const data = await (0, import_obsidian13.requestUrl)({
      url: this.opts.permanentSessionUrl + "/" + id2,
      method: "GET",
      contentType: "application/json"
    }).json;
    if (!data) {
      showNotice("Error creating shared file");
      return;
    }
    return !!data.permanent;
  }
};

// src/sharedEntities/sharedEntityFactory.ts
var fromShareURL = async (url, plugin) => {
  const splittedUrl = url.split("/");
  if (splittedUrl == null ? void 0 : splittedUrl.contains("cm")) {
    return SharedDocument.fromShareURL(url, plugin);
  }
  if (splittedUrl == null ? void 0 : splittedUrl.contains("team")) {
    return SharedFolder.fromShareURL(url, plugin);
  }
};

// src/ui/chooseSessionType.ts
var import_obsidian14 = require("obsidian");
var ChooseSessionTypeModal = class extends import_obsidian14.Modal {
  constructor(app, cb) {
    super(app);
    this.cb = cb;
  }
  async onOpen() {
    new import_obsidian14.Setting(this.contentEl).setName("Start working together").setHeading();
    new import_obsidian14.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Start fleeting session");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: false
        });
      });
    }).setDesc("A fleeting session automatically closes when you close the document or disconnect.");
    new import_obsidian14.Setting(this.contentEl).addButton((button) => {
      button.setButtonText("Share permanently");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb({
          permanent: true
        });
      });
    }).setDesc("The document will be shared permanently until you explicitely stop sharing. This is persisted even if you disconnect or close Obsidian.");
  }
};
var promptForSessionType = (app) => {
  return new Promise((resolve2) => {
    new ChooseSessionTypeModal(app, (result) => {
      resolve2(result);
    }).open();
  });
};

// src/ui/enterText.ts
var import_obsidian15 = require("obsidian");
var EnterTextModal = class extends import_obsidian15.Modal {
  constructor(app, opts, cb) {
    super(app);
    this.cb = cb;
    this.result = opts.initial;
    this.opts = opts;
  }
  async onOpen() {
    new import_obsidian15.Setting(this.contentEl).setName(this.opts.header).setHeading();
    new import_obsidian15.Setting(this.contentEl).addText((text2) => {
      text2.setValue(this.result.text), text2.onChange((value) => {
        this.result.text = value;
      });
      text2.inputEl.onkeydown = (ev) => {
        if (ev.key === "Enter") {
          ev.preventDefault();
          this.close();
          this.cb(this.result);
        }
      };
    }).setDesc(this.opts.description);
    const buttons = new import_obsidian15.Setting(this.contentEl);
    buttons.addButton((button) => {
      button.setButtonText("Cancel");
      button.onClick(() => {
        this.close();
      });
    });
    buttons.addButton((button) => {
      button.setButtonText("OK");
      button.setCta();
      button.onClick(() => {
        this.close();
        this.cb(this.result);
      });
    });
  }
};
var promptForText = (app, opts) => {
  return new Promise((resolve2) => {
    new EnterTextModal(app, opts, (cb) => {
      resolve2(cb);
    }).open();
  });
};
var promptForURL = (app) => {
  return promptForText(app, {
    description: "Enter the URL you received to start working together.",
    header: "Enter your Peerdraft URL",
    initial: {
      text: ""
    }
  });
};
var promptForName = (app) => {
  return promptForText(app, {
    description: "This name will be shown to your collaborators",
    header: "What's your name?",
    initial: {
      text: ""
    }
  });
};

// src/peerdraftWebSocketProvider.ts
var MESSAGE_MULTIPLEX_SYNC = 4;
var SYNC_STEP_1 = 0;
var SYNC_STEP_2 = 1;
var UPDATE = 3;
var NEW_DOCUMENT = 4;
var NEW_DOCUMENT_CONFIRMED = 5;
var GET_DOCUMENT_AS_UPDATE = 6;
var SEND_DOCUMENT_AS_UPDATE = 7;
var MESSAGE_AUTHENTICATION_REQUEST = 5;
var MESSAGE_AUTHENTICATION_RESPONSE = 6;
var messageReconnectTimeout2 = 3e4;
var setupWS3 = (provider) => {
  if (provider.shouldConnect && provider.ws === null) {
    const websocket = new WebSocket(provider.url);
    websocket.binaryType = "arraybuffer";
    provider.ws = websocket;
    provider.wsconnecting = true;
    provider.wsconnected = false;
    websocket.onmessage = (event) => {
      var _a, _b;
      provider.wsLastMessageReceived = getUnixTime();
      const data = new Uint8Array(event.data);
      if (data.length == 0)
        return;
      const decoder = createDecoder(data);
      const messageType = readVarUint(decoder);
      if (messageType === MESSAGE_MULTIPLEX_SYNC) {
        const syncMessageType = readVarUint(decoder);
        switch (syncMessageType) {
          case NEW_DOCUMENT_CONFIRMED:
            {
              const tempId = readVarString(decoder);
              const id2 = readVarString(decoder);
              const checksum = readVarString(decoder);
              provider.emit("new-doc-confirmed", [tempId, id2, checksum]);
            }
            break;
          case SYNC_STEP_1:
            {
              const id2 = readVarString(decoder);
              const vector = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_a = SharedDocument.findById(id2)) != null ? _a : SharedFolder.findById(id2);
              if (doc2 && hash != doc2.calculateHash()) {
                provider.sendSyncStep2(doc2, vector);
              }
            }
            break;
          case SYNC_STEP_2:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const hash = readVarString(decoder);
              const doc2 = (_b = SharedDocument.findById(id2)) != null ? _b : SharedFolder.findById(id2);
              if (doc2) {
                applyUpdate(doc2.yDoc, update, provider);
                provider.emit("synced", [id2, hash]);
              }
            }
            break;
          case SEND_DOCUMENT_AS_UPDATE:
            {
              const id2 = readVarString(decoder);
              const update = readVarUint8Array(decoder);
              const checksum = readVarString(decoder);
              provider.emit("document-received", [id2, update, checksum]);
            }
            break;
          default:
            console.log("unreachable");
            break;
        }
      } else if (messageType === MESSAGE_AUTHENTICATION_RESPONSE) {
        const data2 = JSON.parse(readVarString(decoder));
        provider.authenticated = true;
        provider.emit("authenticated", [data2]);
      }
    };
    websocket.onerror = (event) => {
      provider.emit("connection-error", [event, provider]);
    };
    websocket.onclose = (event) => {
      provider.emit("connection-close", [event, provider]);
      if (provider.authenticated) {
        provider.authenticated = false;
      }
      provider.ws = null;
      provider.wsconnecting = false;
      if (provider.wsconnected) {
        provider.wsconnected = false;
        provider.emit("status", [{
          status: "disconnected"
        }]);
      } else {
        provider.wsUnsuccessfulReconnects++;
      }
      setTimeout(
        setupWS3,
        min(
          pow(2, provider.wsUnsuccessfulReconnects) * 100,
          provider.maxBackoffTime
        ),
        provider
      );
    };
    websocket.onopen = async () => {
      provider.wsLastMessageReceived = getUnixTime();
      provider.wsconnecting = false;
      provider.wsconnected = true;
      provider.wsUnsuccessfulReconnects = 0;
      provider.emit("status", [{
        status: "connected"
      }]);
      if (provider.jwt) {
        provider.authenticate(provider.jwt);
      }
      for (const folder of SharedFolder.getAll()) {
        if (folder.indexedDBProvider) {
          if (!folder.indexedDBProvider.synced)
            await folder.indexedDBProvider.whenSynced;
          folder.syncWithServer();
        }
      }
      for (const doc2 of SharedDocument.getAll()) {
        if (doc2.isPermanent && doc2.indexedDBProvider) {
          if (!doc2.indexedDBProvider.synced)
            await doc2.indexedDBProvider.whenSynced;
          doc2.syncWithServer();
        }
      }
    };
    provider.emit("status", [{
      status: "connecting"
    }]);
  }
};
var PeerdraftWebsocketProvider = class extends ObservableV2 {
  constructor(serverUrl, {
    connect = true,
    resyncInterval = -1,
    maxBackoffTime = 2500,
    jwt = void 0
  } = {}) {
    super();
    this.url = serverUrl;
    this.maxBackoffTime = maxBackoffTime;
    this.wsconnected = false;
    this.wsconnecting = false;
    this._resyncInterval = resyncInterval;
    this.wsUnsuccessfulReconnects = 0;
    this._synced = false;
    this.ws = null;
    this.wsLastMessageReceived = 0;
    this.shouldConnect = connect;
    this._resyncInterval = 0;
    this.authenticated = false;
    this.jwt = jwt;
    this._checkInterval = window.setInterval(() => {
      if (this.wsconnected && messageReconnectTimeout2 < getUnixTime() - this.wsLastMessageReceived) {
        this.ws.close();
      }
    }, messageReconnectTimeout2 / 10);
    if (connect) {
      this.connect();
    }
  }
  sendSyncStep1(doc2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_1);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateVector(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendSyncStep2(doc2, vector) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, SYNC_STEP_2);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc, vector));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdate(doc2, update) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, doc2.shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendUpdateMessage(shareId, update, checksum) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, UPDATE);
    writeVarString(encoder, shareId);
    writeVarUint8Array(encoder, update);
    writeVarString(encoder, checksum);
    this.sendMessage(toUint8Array(encoder));
  }
  sendNewDocument(doc2, tempId) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, NEW_DOCUMENT);
    writeVarString(encoder, tempId);
    writeVarUint8Array(encoder, encodeStateAsUpdate(doc2.yDoc));
    writeVarString(encoder, doc2.calculateHash());
    this.sendMessage(toUint8Array(encoder));
  }
  sendGetDocumentAsUpdate(id2) {
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_MULTIPLEX_SYNC);
    writeVarUint(encoder, GET_DOCUMENT_AS_UPDATE), writeVarString(encoder, id2);
    this.sendMessage(toUint8Array(encoder));
  }
  sendAuthenicationRequest(jwt) {
    this.jwt = jwt;
    const encoder = createEncoder();
    writeVarUint(encoder, MESSAGE_AUTHENTICATION_REQUEST);
    writeVarString(encoder, jwt);
    this.sendMessage(toUint8Array(encoder));
  }
  authenticate(jwt) {
    return new Promise((resolve2) => {
      const handler = async (data) => {
        this.off("authenticated", handler);
        resolve2(data);
      };
      this.on("authenticated", handler);
      this.sendAuthenicationRequest(jwt);
    });
  }
  sendMessage(buf) {
    if (this.wsconnected && this.ws && this.ws.readyState === WebSocket.OPEN) {
      this.ws.send(buf);
    }
  }
  requestDocument(docId) {
    return new Promise((resolve2) => {
      const handler = (serverId, update, checksum) => {
        if (docId === serverId) {
          this.off("document-received", handler);
          const doc2 = new Doc();
          applyUpdate(doc2, update);
          const docs = Array.from(doc2.getMap("documents"));
          if (docs.length > 0) {
            const serialized = serialize(Array.from(docs));
            const calculatedHash = calculateHash(serialized);
            if (calculatedHash != checksum) {
              this.sendUpdateMessage(docId, encodeStateAsUpdate(doc2), calculatedHash);
            }
          }
          resolve2(doc2);
        }
      };
      this.on("document-received", handler);
      this.sendGetDocumentAsUpdate(docId);
    });
  }
  destroy() {
    if (this._resyncInterval !== 0) {
      clearInterval(this._resyncInterval);
    }
    clearInterval(this._checkInterval);
    this.disconnect();
    super.destroy();
  }
  disconnect() {
    this.shouldConnect = false;
    if (this.ws !== null) {
      this.ws.close();
    }
  }
  connect() {
    this.shouldConnect = true;
    if (!this.wsconnected && this.ws === null) {
      setupWS3(this);
    }
  }
};

// src/peerdraftPlugin.ts
var path3 = __toESM(require("path"));
var PeerdraftPlugin = class extends import_obsidian16.Plugin {
  async onload() {
    const plugin = this;
    plugin.settings = await migrateSettings(plugin);
    await prepareCommunication(plugin);
    plugin.pws = new PeerdraftRecord();
    plugin.serverAPI = new ServerAPI({
      oid: plugin.settings.oid,
      permanentSessionUrl: plugin.settings.sessionAPI
    });
    plugin.activeStreamClient = new ActiveStreamClient(plugin.settings.actives, {
      maxBackoffTime: 3e5,
      connect: true,
      resyncInterval: -1
    });
    plugin.pws.on("add", (key, leaf) => {
      var _a;
      (_a = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a.addExtensionToLeaf(key);
      leaf.on("changePath", (oldPath) => {
        var _a2;
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          doc2.removeExtensionFromLeaf(key);
          const leafs = getLeafsByPath(oldPath, plugin.pws);
          if (leafs.length === 0 && !doc2.isPermanent) {
            doc2.unshare();
          }
        }
        (_a2 = SharedDocument.findByPath(leaf.path)) == null ? void 0 : _a2.addExtensionToLeaf(key);
      });
    });
    plugin.pws.on("delete", async (key, leaf) => {
      const doc2 = SharedDocument.findByPath(leaf.path);
      if (!doc2)
        return;
      doc2.removeExtensionFromLeaf(key);
      const leafs = getLeafsByPath(leaf.path, plugin.pws);
      if (leafs.length === 0) {
        if (doc2 && !doc2.isPermanent) {
          await doc2.unshare();
        }
      }
      leaf.destroy();
    });
    plugin.app.workspace.onLayoutReady(
      async () => {
        var _a;
        this.serverSync = new PeerdraftWebsocketProvider(this.settings.sync, { jwt: (_a = getJWT(plugin.settings.oid)) != null ? _a : void 0, connect: false });
        this.serverSync.on("authenticated", (data) => {
          showNotice("Logged in to Peerdraft");
          plugin.settings.plan.type = data.plan.type;
          saveSettings(plugin.settings, plugin);
        });
        this.serverSync.connect();
        for (const docs of plugin.settings.serverShares.files) {
          await SharedDocument.fromPermanentShareDocument({ path: docs[0], persistenceId: docs[1].persistenceId, shareId: docs[1].shareId }, plugin);
        }
        for (const folder of plugin.settings.serverShares.folders) {
          await SharedFolder.fromPermanentShareFolder({ path: folder[0], persistenceId: folder[1].persistenceId, shareId: folder[1].shareId }, plugin);
        }
        updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        plugin.registerEvent(plugin.app.workspace.on("layout-change", () => {
          updatePeerdraftWorkspace(plugin.app.workspace, plugin.pws);
        }));
      }
    );
    plugin.registerEvent(plugin.app.workspace.on("file-menu", (menu, file) => {
      if (file instanceof import_obsidian16.TFolder) {
        const sharedFolder = SharedFolder.findByPath(file.path);
        if (!sharedFolder) {
          if (!SharedFolder.getSharedFolderForSubPath(file.path) && plugin.settings.plan.type === "team") {
            menu.addItem((item) => {
              item.setTitle("Share Folder");
              item.setIcon("users");
              item.onClick(() => {
                SharedFolder.fromTFolder(file, plugin);
              });
            });
          }
        } else {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/team/" + sharedFolder.shareId);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Stop syncing this folder");
            item.setIcon("refresh-cw-off");
            item.onClick(async () => {
              await sharedFolder.unshare();
            });
          });
          menu.addItem((item) => {
            item.setTitle("Re-create sync from server");
            item.setIcon("refresh-cw");
            item.onClick(async () => {
              await SharedFolder.recreate(sharedFolder, plugin);
            });
          });
          menu.addItem((item) => {
            item.setTitle("Show Peerdraft folder options");
            item.setIcon("cog");
            item.onClick(async () => {
              openFolderOptions(this.app, sharedFolder);
            });
          });
        }
      } else {
        const sharedDocument = SharedDocument.findByPath(file.path);
        const sharedFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (sharedDocument) {
          menu.addItem((item) => {
            item.setTitle("Copy Peerdraft URL");
            item.setIcon("users");
            item.onClick(() => {
              navigator.clipboard.writeText(plugin.settings.basePath + "/cm/" + sharedDocument.shareId);
            });
          });
          if (sharedFolder) {
            menu.addItem((item) => {
              item.setTitle("Delete and remove from Shared Folder");
              item.setIcon("trash");
              item.onClick(async () => {
                sharedFolder.removeDocument(sharedDocument);
                sharedDocument.unshare();
                plugin.app.vault.delete(sharedDocument.file);
              });
            });
          } else {
            menu.addItem((item) => {
              item.setTitle("Stop syncing this document");
              item.setIcon("refresh-cw-off");
              item.onClick(async () => {
                await sharedDocument.unshare();
              });
            });
          }
        }
      }
    }));
    plugin.addCommand({
      id: "share",
      name: "Start working together on this document",
      checkCallback(checking) {
        const view = plugin.app.workspace.getActiveViewOfType(import_obsidian16.MarkdownView);
        if (!view)
          return false;
        const file = view.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (doc2)
          return false;
        if (checking)
          return true;
        if (plugin.settings.plan.type === "team") {
          promptForSessionType(plugin.app).then((result) => {
            if (!result)
              return;
            SharedDocument.fromView(view, plugin, { permanent: result.permanent }).then((doc3) => {
              if (!doc3) {
                return showNotice("ERROR creating sharedDoc");
              }
            });
          });
        } else {
          SharedDocument.fromView(view, plugin, { permanent: false }).then((doc3) => {
            if (!doc3) {
              return showNotice("ERROR creating sharedDoc");
            }
          });
        }
      }
    });
    plugin.addCommand({
      id: "stop-session-with-active-document",
      name: "Stop working together on this document",
      editorCheckCallback: (checking, editor, ctx) => {
        const file = ctx.file;
        if (!file)
          return false;
        const doc2 = SharedDocument.findByPath(file.path);
        if (!doc2 || doc2.isPermanent)
          return false;
        if (checking)
          return true;
        doc2.unshare().then(() => {
        });
      }
    });
    plugin.addCommand({
      id: "join",
      name: "Join session and add document from someone else",
      callback: async () => {
        const url = await promptForURL(plugin.app);
        if (url && url.text) {
          await fromShareURL(url.text, plugin);
        }
      }
    });
    if (plugin.settings.debug) {
      plugin.addCommand({
        id: "clearDatabase",
        name: "DEBUG: clear database (Nothing will be shared after this!)",
        callback: async () => {
          var _a;
          const dbs = await window.indexedDB.databases();
          for (const db of dbs) {
            if ((_a = db.name) == null ? void 0 : _a.startsWith("peerdraft_")) {
              window.indexedDB.deleteDatabase(db.name);
            }
          }
        }
      });
    }
    plugin.registerEvent(plugin.app.vault.on("rename", async (file, oldPath) => {
      if (file instanceof import_obsidian16.TFile) {
        const doc2 = SharedDocument.findByPath(oldPath);
        if (doc2) {
          await doc2.setNewFileLocation(file);
        }
        const oldPathInFolder = SharedFolder.getSharedFolderForSubPath(oldPath);
        const newPathInFolder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (oldPathInFolder && newPathInFolder) {
          if (oldPathInFolder === newPathInFolder) {
            oldPathInFolder.updatePath(oldPath, file.path);
          } else {
            const newDoc = await SharedDocument.fromTFile(file, { permanent: true }, plugin);
            if (newDoc) {
              newPathInFolder.addDocument(newDoc);
              const prop = newPathInFolder.getAutoFillProperty();
              if (prop)
                newDoc.updateProperty(prop, newDoc.getShareURL());
            }
            if (doc2) {
            }
          }
        } else if (oldPathInFolder && !newPathInFolder) {
          if (doc2) {
            showNotice("It is not possible to remove a document from a shared folder right now. Created a copy.");
            await SharedFolder.getOrCreatePath(path3.dirname(oldPath), plugin);
            const file2 = await plugin.app.vault.create(oldPath, "");
            if (!file2) {
              showNotice("Error creating file " + oldPath + ".");
              return;
            }
            doc2.setNewFileLocation(file2);
            doc2.syncWithServer();
          }
        } else if (!oldPathInFolder && newPathInFolder) {
          const doc3 = await SharedDocument.fromTFile(file, { permanent: true }, plugin);
          if (doc3) {
            newPathInFolder.addDocument(doc3);
            const prop = newPathInFolder.getAutoFillProperty();
            if (prop)
              doc3.updateProperty(prop, doc3.getShareURL());
          }
        }
      } else if (file instanceof import_obsidian16.TFolder) {
        const folder = SharedFolder.findByPath(oldPath);
        if (folder) {
          await folder.setNewFolderLocation(file);
        }
      }
    }));
    plugin.registerEvent(plugin.app.vault.on("delete", async (file) => {
      plugin.log("register delete for " + file.path);
      if (file instanceof import_obsidian16.TFolder) {
        const folder = SharedFolder.findByPath(file.path);
        folder == null ? void 0 : folder.unshare();
        return;
      } else if (file instanceof import_obsidian16.TFile) {
        const folder = SharedFolder.getSharedFolderForSubPath(file.path);
        if (!folder) {
          const doc2 = SharedDocument.findByPath(file.path);
          if (doc2) {
            await doc2.unshare();
          }
        }
      }
    }));
    plugin.app.workspace.onLayoutReady(
      () => {
        plugin.registerEvent(plugin.app.vault.on("create", async (file) => {
          if (!(file instanceof import_obsidian16.TFile))
            return;
          const folder = SharedFolder.getSharedFolderForSubPath(file.path);
          if (!folder)
            return;
          if (folder.isFileInSyncObject(file))
            return;
          if (SharedDocument.findByPath(file.path))
            return;
          if (plugin.settings.serverShares.files.has((0, import_obsidian16.normalizePath)(file.path)))
            return;
          const doc2 = await SharedDocument.fromTFile(file, {
            permanent: true
          }, plugin);
          if (doc2) {
            folder.addDocument(doc2);
            const prop = folder.getAutoFillProperty();
            if (prop)
              doc2.updateProperty(prop, doc2.getShareURL());
          }
        }));
      }
    );
    const settingsTab = createSettingsTab(plugin);
    if (!plugin.settings.name) {
      const name = await promptForName(plugin.app);
      if (name && name.text) {
        this.settings.name = name.text;
        saveSettings(this.settings, plugin);
      }
    }
    plugin.addSettingTab(settingsTab);
  }
  onunload() {
    SharedDocument.getAll().forEach((doc2) => {
      doc2.destroy();
    });
    SharedFolder.getAll().forEach((folder) => {
      folder.destroy();
    });
    this.activeStreamClient.destroy();
  }
  log(message) {
    if (this.settings.debug) {
      console.log(message);
    }
  }
};

// src/main.ts
var main_default = PeerdraftPlugin;
/*! Bundled license information:

simple-peer/simplepeer.min.js:
  (*!
  * The buffer module from node.js, for the browser.
  *
  * @author   Feross Aboukhadijeh <https://feross.org>
  * @license  MIT
  *)
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50MzIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2xpYi91aW50NjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2N1aW50L2luZGV4LmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy94eGhhc2hqcy9saWIveHhoYXNoNjQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3h4aGFzaGpzL2xpYi9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvc2ltcGxlLXBlZXIvc2ltcGxlcGVlci5taW4uanMiLCAiLi4vc3JjL21haW4udHMiLCAiLi4vc3JjL3BlZXJkcmFmdFBsdWdpbi50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9tYXRoLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3RpbWUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbWFwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3NldC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9hcnJheS5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9vYnNlcnZhYmxlLmpzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudC50cyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9iaW5hcnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbnVtYmVyLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3N0cmluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbmNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lcnJvci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kZWNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC93ZWJjcnlwdG8uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcmFuZG9tLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL3Byb21pc2UuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvY29uZGl0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9zdG9yYWdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL29iamVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9mdW5jdGlvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9lbnZpcm9ubWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9idWZmZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvcGFpci5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9kb20uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvanNvbi5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9zeW1ib2wuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5jb21tb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbG9nZ2luZy5qcyIsICIuLi9ub2RlX21vZHVsZXMvbGliMC9pdGVyYXRvci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9BYnN0cmFjdENvbm5lY3Rvci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9EZWxldGVTZXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvRG9jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1VwZGF0ZURlY29kZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVXBkYXRlRW5jb2Rlci5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9lbmNvZGluZy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9FdmVudEhhbmRsZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvSUQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvaXNQYXJlbnRPZi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9sb2dnaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1Blcm1hbmVudFVzZXJEYXRhLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3V0aWxzL1JlbGF0aXZlUG9zaXRpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvU25hcHNob3QuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvU3RydWN0U3RvcmUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVHJhbnNhY3Rpb24uanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvVW5kb01hbmFnZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdXRpbHMvdXBkYXRlcy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy91dGlscy9ZRXZlbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvQWJzdHJhY3RUeXBlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lBcnJheS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZTWFwLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lUZXh0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3R5cGVzL1lYbWxGcmFnbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZWG1sRWxlbWVudC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy90eXBlcy9ZWG1sRXZlbnQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbEhvb2suanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvdHlwZXMvWVhtbFRleHQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9BYnN0cmFjdFN0cnVjdC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0dDLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudEJpbmFyeS5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnREZWxldGVkLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudERvYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRFbWJlZC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRGb3JtYXQuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50SlNPTi5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9zdHJ1Y3RzL0NvbnRlbnRBbnkuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9Db250ZW50U3RyaW5nLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvQ29udGVudFR5cGUuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3lqcy9zcmMvc3RydWN0cy9JdGVtLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95anMvc3JjL3N0cnVjdHMvU2tpcC5qcyIsICIuLi9ub2RlX21vZHVsZXMveWpzL3NyYy9pbmRleC5qcyIsICIuLi9zcmMvdG9vbHMudHMiLCAiLi4vc3JjL3VpLnRzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMvaW5kZXguanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktY29kZW1pcnJvci5uZXh0L3NyYy95LXJhbmdlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1zeW5jLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWNvZGVtaXJyb3IubmV4dC9zcmMveS1yZW1vdGUtc2VsZWN0aW9ucy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1jb2RlbWlycm9yLm5leHQvc3JjL3ktdW5kb21hbmFnZXIuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvbXV0ZXguanMiLCAiLi4vc3JjL3V0aWxzL3BlZXJkcmFmdFJlY29yZC50cyIsICIuLi9zcmMvd29ya3NwYWNlL3BlZXJkcmFmdExlYWYudHMiLCAiLi4vc3JjL3dvcmtzcGFjZS9wZWVyZHJhZnRXb3Jrc3BhY2UudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvd2Vic29ja2V0LmpzIiwgIi4uL25vZGVfbW9kdWxlcy9saWIwL2Jyb2FkY2FzdGNoYW5uZWwuanMiLCAiLi4vbm9kZV9tb2R1bGVzL3ktd2VicnRjL3NyYy95LXdlYnJ0Yy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvc3luYy5qcyIsICIuLi9ub2RlX21vZHVsZXMveS1wcm90b2NvbHMvYXdhcmVuZXNzLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LXdlYnJ0Yy9zcmMvY3J5cHRvLmpzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2xpYjAvaW5kZXhlZGRiLmpzIiwgIi4uL25vZGVfbW9kdWxlcy95LWluZGV4ZWRkYi9zcmMveS1pbmRleGVkZGIuanMiLCAiLi4vc3JjL3dvcmtzcGFjZS9leHBsb3JlclZpZXcudHMiLCAiLi4vc3JjL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlci50cyIsICIuLi9zcmMvc2V0dGluZ3MudHMiLCAiLi4vc3JjL3VpL3NlbGVjdEZvbGRlci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3V0aWxzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9kZWJ1Zy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Vycm9ycy9lcnJvcnMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9wcm9taXNlLmpzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3RlbXAtdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9nbG9iYWxzL2NvbnN0YW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9jb21iaW5lLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2tleXJhbmdlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL3dvcmthcm91bmQtdW5kZWZpbmVkLXByaW1rZXkudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RhYmxlL3RhYmxlLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9FdmVudHMuanMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdGFibGUvdGFibGUtY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2NvbGxlY3Rpb24vY29sbGVjdGlvbi1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZnVuY3Rpb25zL2NtcC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvY29sbGVjdGlvbi9jb2xsZWN0aW9uLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9jb2xsZWN0aW9uL2NvbGxlY3Rpb24tY29uc3RydWN0b3IudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvY29tcGFyZS1mdW5jdGlvbnMudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3doZXJlLWNsYXVzZS93aGVyZS1jbGF1c2UtaGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3RyYW5zYWN0aW9uL3RyYW5zYWN0aW9uLWNvbnN0cnVjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy9pbmRleC1zcGVjLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvaGVscGVycy90YWJsZS1zY2hlbWEudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvcXVpcmtzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1rZXktZXh0cmFjdG9yLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2RiY29yZS1pbmRleGVkZGIudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2dlbmVyYXRlLW1pZGRsZXdhcmUtc3RhY2tzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3NjaGVtYS1oZWxwZXJzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy92ZXJzaW9uL3ZlcnNpb24udHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL3ZlcnNpb24vdmVyc2lvbi1jb25zdHJ1Y3Rvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvci50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdmlwLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9ub2RlX21vZHVsZXMvc2FmYXJpLTE0LWlkYi1maXgvZGlzdC9pbmRleC5qcyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtb3Blbi50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hlbHBlcnMveWllbGQtc3VwcG9ydC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvdHJhbnNhY3Rpb24taGVscGVycy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2RiY29yZS92aXJ0dWFsLWluZGV4LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9mdW5jdGlvbnMvZ2V0LW9iamVjdC1kaWZmLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2hvb2tzL2hvb2tzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9kYmNvcmUvY2FjaGUtZXhpc3RpbmctdmFsdWVzLW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9oZWxwZXJzL3Jhbmdlc2V0LnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9vYnNlcnZhYmlsaXR5LW1pZGRsZXdhcmUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9jbGFzc2VzL2RleGllL2RleGllLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGUudHMiLCAiLi4vbm9kZV9tb2R1bGVzL2RleGllL3NyYy9saXZlLXF1ZXJ5L2V4dGVuZC1vYnNlcnZhYmlsaXR5LXNldC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtZG9tLWRlcGVuZGVuY2llcy50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2NsYXNzZXMvZGV4aWUvZGV4aWUtc3RhdGljLXByb3BzLnRzIiwgIi4uL25vZGVfbW9kdWxlcy9kZXhpZS9zcmMvbGl2ZS1xdWVyeS9wcm9wYWdhdGUtbG9jYWxseS50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2xpdmUtcXVlcnkvZW5hYmxlLWJyb2FkY2FzdC50cyIsICIuLi9ub2RlX21vZHVsZXMvZGV4aWUvc3JjL2luZGV4LnRzIiwgIi4uL3NyYy9wZXJtYW5lbnRTaGFyZVN0b3JlLnRzIiwgIi4uL3NyYy9sb2dpbi50cyIsICIuLi9zcmMvdWkvbG9naW4udHMiLCAiLi4vc3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGUy50cyIsICIuLi9zcmMvdWkvZm9sZGVyT3B0aW9ucy50cyIsICIuLi9ub2RlX21vZHVsZXMvYXN5bmMtbXV0ZXgvaW5kZXgubWpzIiwgIi4uL25vZGVfbW9kdWxlcy9kaWZmLW1hdGNoLXBhdGNoLWVzL2Rpc3QvaW5kZXgubWpzIiwgIi4uL3NyYy9hY3RpdmVTdHJlYW1DbGllbnQudHMiLCAiLi4vc3JjL2Nvb2tpZS50cyIsICIuLi9zcmMvc2VydmVyQVBJLnRzIiwgIi4uL3NyYy9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlGYWN0b3J5LnRzIiwgIi4uL3NyYy91aS9jaG9vc2VTZXNzaW9uVHlwZS50cyIsICIuLi9zcmMvdWkvZW50ZXJUZXh0LnRzIiwgIi4uL3NyYy9wZWVyZHJhZnRXZWJTb2NrZXRQcm92aWRlci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiLyoqXG5cdEMtbGlrZSB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJzIGluIEphdmFzY3JpcHRcblx0Q29weXJpZ2h0IChDKSAyMDEzLCBQaWVycmUgQ3VydG9cblx0TUlUIGxpY2Vuc2VcbiAqL1xuOyhmdW5jdGlvbiAocm9vdCkge1xuXG5cdC8vIExvY2FsIGNhY2hlIGZvciB0eXBpY2FsIHJhZGljZXNcblx0dmFyIHJhZGl4UG93ZXJDYWNoZSA9IHtcblx0XHQzNjogVUlOVDMyKCBNYXRoLnBvdygzNiwgNSkgKVxuXHQsXHQxNjogVUlOVDMyKCBNYXRoLnBvdygxNiwgNykgKVxuXHQsXHQxMDogVUlOVDMyKCBNYXRoLnBvdygxMCwgOSkgKVxuXHQsXHQyOiAgVUlOVDMyKCBNYXRoLnBvdygyLCAzMCkgKVxuXHR9XG5cdHZhciByYWRpeENhY2hlID0ge1xuXHRcdDM2OiBVSU5UMzIoMzYpXG5cdCxcdDE2OiBVSU5UMzIoMTYpXG5cdCxcdDEwOiBVSU5UMzIoMTApXG5cdCxcdDI6ICBVSU5UMzIoMilcblx0fVxuXG5cdC8qKlxuXHQgKlx0UmVwcmVzZW50cyBhbiB1bnNpZ25lZCAzMiBiaXRzIGludGVnZXJcblx0ICogQGNvbnN0cnVjdG9yXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xOdW1iZXJ9IGxvdyBiaXRzICAgICB8IGludGVnZXIgYXMgYSBzdHJpbmcgXHRcdCB8IGludGVnZXIgYXMgYSBudW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ8TnVtYmVyfFVuZGVmaW5lZH0gaGlnaCBiaXRzIHwgcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDMyIChsLCBoKSB7XG5cdFx0aWYgKCAhKHRoaXMgaW5zdGFuY2VvZiBVSU5UMzIpIClcblx0XHRcdHJldHVybiBuZXcgVUlOVDMyKGwsIGgpXG5cblx0XHR0aGlzLl9sb3cgPSAwXG5cdFx0dGhpcy5faGlnaCA9IDBcblx0XHR0aGlzLnJlbWFpbmRlciA9IG51bGxcblx0XHRpZiAodHlwZW9mIGggPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGwpXG5cblx0XHRpZiAodHlwZW9mIGwgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGwsIGgpXG5cblx0XHRmcm9tQml0cy5jYWxsKHRoaXMsIGwsIGgpXG5cdH1cblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UMzJfIG9iamVjdCB3aXRoIGl0cyBsb3cgYW5kIGhpZ2ggYml0c1xuXHQgKiBAbWV0aG9kIGZyb21CaXRzXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBsb3cgYml0c1xuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChsLCBoKSB7XG5cdFx0dGhpcy5fbG93ID0gbCB8IDBcblx0XHR0aGlzLl9oaWdoID0gaCB8IDBcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDMyLnByb3RvdHlwZS5mcm9tQml0cyA9IGZyb21CaXRzXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIG51bWJlclxuXHQgKiBAbWV0aG9kIGZyb21OdW1iZXJcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlclxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRmdW5jdGlvbiBmcm9tTnVtYmVyICh2YWx1ZSkge1xuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDMyXyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHR2YXIgdmFsdWUgPSBwYXJzZUludChzLCByYWRpeCB8fCAxMClcblxuXHRcdHRoaXMuX2xvdyA9IHZhbHVlICYgMHhGRkZGXG5cdFx0dGhpcy5faGlnaCA9IHZhbHVlID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UMzIucHJvdG90eXBlLmZyb21TdHJpbmcgPSBmcm9tU3RyaW5nXG5cblx0LyoqXG5cdCAqIENvbnZlcnQgdGhpcyBfVUlOVDMyXyB0byBhIG51bWJlclxuXHQgKiBAbWV0aG9kIHRvTnVtYmVyXG5cdCAqIEByZXR1cm4ge051bWJlcn0gdGhlIGNvbnZlcnRlZCBVSU5UMzJcblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9oaWdoICogNjU1MzYpICsgdGhpcy5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UMzJfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXggfHwgMTApXG5cdH1cblxuXHQvKipcblx0ICogQWRkIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBhZGRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3cgKyBvdGhlci5fbG93XG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblxuXHRcdGExNiArPSB0aGlzLl9oaWdoICsgb3RoZXIuX2hpZ2hcblxuXHRcdHRoaXMuX2xvdyA9IGEwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBhMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogU3VidHJhY3QgdHdvIF9VSU5UMzJfLiBUaGUgY3VycmVudCBfVUlOVDMyXyBzdG9yZXMgdGhlIHJlc3VsdFxuXHQgKiBAbWV0aG9kIHN1YnRyYWN0XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5zdWJ0cmFjdCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdC8vVE9ETyBpbmxpbmVcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNlxuXHRcdFx0YiA9IGIwMCArIGIxNlxuXHRcdFx0YSpiID0gKGEwMCArIGExNikoYjAwICsgYjE2KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGExNmIwMCArIGExNmIxNlxuXG5cdFx0XHRhMTZiMTYgb3ZlcmZsb3dzIHRoZSAzMmJpdHNcblx0XHQgKi9cblx0XHR2YXIgYTE2ID0gdGhpcy5faGlnaFxuXHRcdHZhciBhMDAgPSB0aGlzLl9sb3dcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2hpZ2hcblx0XHR2YXIgYjAwID0gb3RoZXIuX2xvd1xuXG4vKiBSZW1vdmVkIHRvIGluY3JlYXNlIHNwZWVkIHVuZGVyIG5vcm1hbCBjaXJjdW1zdGFuY2VzIChpLmUuIG5vdCBtdWx0aXBseWluZyBieSAwIG9yIDEpXG5cdFx0Ly8gdGhpcyA9PSAwIG9yIG90aGVyID09IDE6IG5vdGhpbmcgdG8gZG9cblx0XHRpZiAoKGEwMCA9PSAwICYmIGExNiA9PSAwKSB8fCAoYjAwID09IDEgJiYgYjE2ID09IDApKSByZXR1cm4gdGhpc1xuXG5cdFx0Ly8gb3RoZXIgPT0gMCBvciB0aGlzID09IDE6IHRoaXMgPSBvdGhlclxuXHRcdGlmICgoYjAwID09IDAgJiYgYjE2ID09IDApIHx8IChhMDAgPT0gMSAmJiBhMTYgPT0gMCkpIHtcblx0XHRcdHRoaXMuX2xvdyA9IG90aGVyLl9sb3dcblx0XHRcdHRoaXMuX2hpZ2ggPSBvdGhlci5faGlnaFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG4qL1xuXG5cdFx0dmFyIGMxNiwgYzAwXG5cdFx0YzAwID0gYTAwICogYjAwXG5cdFx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdFx0YzE2ICs9IGExNiAqIGIwMFxuXHRcdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRcdGMxNiArPSBhMDAgKiBiMTZcblxuXHRcdHRoaXMuX2xvdyA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSBjMTYgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRGl2aWRlIHR3byBfVUlOVDMyXy4gVGhlIGN1cnJlbnQgX1VJTlQzMl8gc3RvcmVzIHRoZSByZXN1bHQuXG5cdCAqIFRoZSByZW1haW5kZXIgaXMgbWFkZSBhdmFpbGFibGUgYXMgdGhlIF9yZW1haW5kZXJfIHByb3BlcnR5IG9uXG5cdCAqIHRoZSBfVUlOVDMyXyBvYmplY3QuIEl0IGNhbiBiZSBudWxsLCBtZWFuaW5nIHRoZXJlIGFyZSBubyByZW1haW5kZXIuXG5cdCAqIEBtZXRob2QgZGl2XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAoIChvdGhlci5fbG93ID09IDApICYmIChvdGhlci5faGlnaCA9PSAwKSApIHRocm93IEVycm9yKCdkaXZpc2lvbiBieSB6ZXJvJylcblxuXHRcdC8vIG90aGVyID09IDFcblx0XHRpZiAob3RoZXIuX2hpZ2ggPT0gMCAmJiBvdGhlci5fbG93ID09IDEpIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBvdGhlciA+IHRoaXM6IDBcblx0XHRpZiAoIG90aGVyLmd0KHRoaXMpICkge1xuXHRcdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQzMigwKVxuXHRcdFx0dGhpcy5fbG93ID0gMVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0Ly8gU2hpZnQgdGhlIGRpdmlzb3IgbGVmdCB1bnRpbCBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgZGl2aWRlbmRcblx0XHR2YXIgX290aGVyID0gb3RoZXIuY2xvbmUoKVxuXHRcdHZhciBpID0gLTFcblx0XHR3aGlsZSAoICF0aGlzLmx0KF9vdGhlcikgKSB7XG5cdFx0XHQvLyBIaWdoIGJpdCBjYW4gb3ZlcmZsb3cgdGhlIGRlZmF1bHQgMTZiaXRzXG5cdFx0XHQvLyBJdHMgb2sgc2luY2Ugd2UgcmlnaHQgc2hpZnQgYWZ0ZXIgdGhpcyBsb29wXG5cdFx0XHQvLyBUaGUgb3ZlcmZsb3duIGJpdCBtdXN0IGJlIGtlcHQgdGhvdWdoXG5cdFx0XHRfb3RoZXIuc2hpZnRMZWZ0KDEsIHRydWUpXG5cdFx0XHRpKytcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIHJlbWFpbmRlclxuXHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgY3VycmVudCByZXN1bHQgdG8gMFxuXHRcdHRoaXMuX2xvdyA9IDBcblx0XHR0aGlzLl9oaWdoID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9oaWdoIHw9IDEgPDwgKGkgLSAxNilcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9sb3cgfD0gMSA8PCBpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIE5lZ2F0ZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIG5lZ2F0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLm5lZ2F0ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgdiA9ICggfnRoaXMuX2xvdyAmIDB4RkZGRiApICsgMVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gKH50aGlzLl9oaWdoICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogRXF1YWxzXG5cdCAqIEBtZXRob2QgZXFcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5lcXVhbHMgPSBVSU5UMzIucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9sb3cgPT0gb3RoZXIuX2xvdykgJiYgKHRoaXMuX2hpZ2ggPT0gb3RoZXIuX2hpZ2gpXG5cdH1cblxuXHQvKipcblx0ICogR3JlYXRlciB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgZ3Rcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5ncmVhdGVyVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUuZ3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA+IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoIDwgb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPiBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQzMlxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQzMi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5faGlnaCA8IG90aGVyLl9oaWdoKSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9oaWdoID4gb3RoZXIuX2hpZ2gpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9sb3cgPCBvdGhlci5fbG93XG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBPUlxuXHQgKiBAbWV0aG9kIG9yXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UMzJcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5vciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2xvdyB8PSBvdGhlci5fbG93XG5cdFx0dGhpcy5faGlnaCB8PSBvdGhlci5faGlnaFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93ICY9IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoICY9IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbG93ID0gfnRoaXMuX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB+dGhpcy5faGlnaCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIFhPUlxuXHQgKiBAbWV0aG9kIHhvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDMyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fbG93IF49IG90aGVyLl9sb3dcblx0XHR0aGlzLl9oaWdoIF49IG90aGVyLl9oaWdoXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgcmlnaHRcblx0ICogQG1ldGhvZCBzaGlmdFJpZ2h0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnNoaWZ0UmlnaHQgPSBVSU5UMzIucHJvdG90eXBlLnNoaWZ0ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0aWYgKG4gPiAxNikge1xuXHRcdFx0dGhpcy5fbG93ID0gdGhpcy5faGlnaCA+PiAobiAtIDE2KVxuXHRcdFx0dGhpcy5faGlnaCA9IDBcblx0XHR9IGVsc2UgaWYgKG4gPT0gMTYpIHtcblx0XHRcdHRoaXMuX2xvdyA9IHRoaXMuX2hpZ2hcblx0XHRcdHRoaXMuX2hpZ2ggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPj4gbikgfCAoICh0aGlzLl9oaWdoIDw8ICgxNi1uKSkgJiAweEZGRkYgKVxuXHRcdFx0dGhpcy5faGlnaCA+Pj0gblxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBzaGlmdCBsZWZ0XG5cdCAqIEBtZXRob2Qgc2hpZnRMZWZ0XG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byBzaGlmdFxuXHQgKiBAcGFyYW0ge0Jvb2xlYW59IGFsbG93IG92ZXJmbG93XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQzMi5wcm90b3R5cGUuc2hpZnRMZWZ0ID0gVUlOVDMyLnByb3RvdHlwZS5zaGlmdGwgPSBmdW5jdGlvbiAobiwgYWxsb3dPdmVyZmxvdykge1xuXHRcdGlmIChuID4gMTYpIHtcblx0XHRcdHRoaXMuX2hpZ2ggPSB0aGlzLl9sb3cgPDwgKG4gLSAxNilcblx0XHRcdHRoaXMuX2xvdyA9IDBcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobiA9PSAxNikge1xuXHRcdFx0dGhpcy5faGlnaCA9IHRoaXMuX2xvd1xuXHRcdFx0dGhpcy5fbG93ID0gMFxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9oaWdoID0gKHRoaXMuX2hpZ2ggPDwgbikgfCAodGhpcy5fbG93ID4+ICgxNi1uKSlcblx0XHRcdHRoaXMuX2xvdyA9ICh0aGlzLl9sb3cgPDwgbikgJiAweEZGRkZcblx0XHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0XHQvLyBPdmVyZmxvdyBvbmx5IGFsbG93ZWQgb24gdGhlIGhpZ2ggYml0cy4uLlxuXHRcdFx0XHR0aGlzLl9oaWdoICY9IDB4RkZGRlxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UMzIucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UMzIucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdHZhciB2ID0gKHRoaXMuX2hpZ2ggPDwgMTYpIHwgdGhpcy5fbG93XG5cdFx0diA9ICh2IDw8IG4pIHwgKHYgPj4+ICgzMiAtIG4pKVxuXHRcdHRoaXMuX2xvdyA9IHYgJiAweEZGRkZcblx0XHR0aGlzLl9oaWdoID0gdiA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQzMi5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0dmFyIHYgPSAodGhpcy5faGlnaCA8PCAxNikgfCB0aGlzLl9sb3dcblx0XHR2ID0gKHYgPj4+IG4pIHwgKHYgPDwgKDMyIC0gbikpXG5cdFx0dGhpcy5fbG93ID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2hpZ2ggPSB2ID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDMyX1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQzMlxuXHQgKi9cblx0VUlOVDMyLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQzMih0aGlzLl9sb3csIHRoaXMuX2hpZ2gpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDMyXG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDMyXG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQzMiddID0gVUlOVDMyXG5cdH1cblxufSkodGhpcylcbiIsICIvKipcblx0Qy1saWtlIHVuc2lnbmVkIDY0IGJpdHMgaW50ZWdlcnMgaW4gSmF2YXNjcmlwdFxuXHRDb3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuXHRNSVQgbGljZW5zZVxuICovXG47KGZ1bmN0aW9uIChyb290KSB7XG5cblx0Ly8gTG9jYWwgY2FjaGUgZm9yIHR5cGljYWwgcmFkaWNlc1xuXHR2YXIgcmFkaXhQb3dlckNhY2hlID0ge1xuXHRcdDE2OiBVSU5UNjQoIE1hdGgucG93KDE2LCA1KSApXG5cdCxcdDEwOiBVSU5UNjQoIE1hdGgucG93KDEwLCA1KSApXG5cdCxcdDI6ICBVSU5UNjQoIE1hdGgucG93KDIsIDUpIClcblx0fVxuXHR2YXIgcmFkaXhDYWNoZSA9IHtcblx0XHQxNjogVUlOVDY0KDE2KVxuXHQsXHQxMDogVUlOVDY0KDEwKVxuXHQsXHQyOiAgVUlOVDY0KDIpXG5cdH1cblxuXHQvKipcblx0ICpcdFJlcHJlc2VudHMgYW4gdW5zaWduZWQgNjQgYml0cyBpbnRlZ2VyXG5cdCAqIEBjb25zdHJ1Y3RvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgbG93IGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBmaXJzdCBoaWdoIGJpdHMgKDgpXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmQgaGlnaCBiaXRzICg4KVxuXHQgKiBvclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbG93IGJpdHMgKDMyKVxuXHQgKiBAcGFyYW0ge051bWJlcn0gaGlnaCBiaXRzICgzMilcblx0ICogb3Jcblx0ICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBpbnRlZ2VyIGFzIGEgc3RyaW5nIFx0XHQgfCBpbnRlZ2VyIGFzIGEgbnVtYmVyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfFVuZGVmaW5lZH0gcmFkaXggKG9wdGlvbmFsLCBkZWZhdWx0PTEwKVxuXHQgKiBAcmV0dXJuIFxuXHQgKi9cblx0ZnVuY3Rpb24gVUlOVDY0IChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAoICEodGhpcyBpbnN0YW5jZW9mIFVJTlQ2NCkgKVxuXHRcdFx0cmV0dXJuIG5ldyBVSU5UNjQoYTAwLCBhMTYsIGEzMiwgYTQ4KVxuXG5cdFx0dGhpcy5yZW1haW5kZXIgPSBudWxsXG5cdFx0aWYgKHR5cGVvZiBhMDAgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXR1cm4gZnJvbVN0cmluZy5jYWxsKHRoaXMsIGEwMCwgYTE2KVxuXG5cdFx0aWYgKHR5cGVvZiBhMTYgPT0gJ3VuZGVmaW5lZCcpXG5cdFx0XHRyZXR1cm4gZnJvbU51bWJlci5jYWxsKHRoaXMsIGEwMClcblxuXHRcdGZyb21CaXRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcblx0fVxuXG5cdC8qKlxuXHQgKiBTZXQgdGhlIGN1cnJlbnQgX1VJTlQ2NF8gb2JqZWN0IHdpdGggaXRzIGxvdyBhbmQgaGlnaCBiaXRzXG5cdCAqIEBtZXRob2QgZnJvbUJpdHNcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGZpcnN0IGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGxvdyBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZmlyc3QgaGlnaCBiaXRzICg4KVxuXHQgKiBAcGFyYW0ge051bWJlcn0gc2Vjb25kIGhpZ2ggYml0cyAoOClcblx0ICogb3Jcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGxvdyBiaXRzICgzMilcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGhpZ2ggYml0cyAoMzIpXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21CaXRzIChhMDAsIGExNiwgYTMyLCBhNDgpIHtcblx0XHRpZiAodHlwZW9mIGEzMiA9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSBhMDAgPj4+IDE2XG5cdFx0XHR0aGlzLl9hMzIgPSBhMTYgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9IGExNiA+Pj4gMTZcblx0XHRcdHJldHVybiB0aGlzXG5cdFx0fVxuXG5cdFx0dGhpcy5fYTAwID0gYTAwIHwgMFxuXHRcdHRoaXMuX2ExNiA9IGExNiB8IDBcblx0XHR0aGlzLl9hMzIgPSBhMzIgfCAwXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4IHwgMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21CaXRzID0gZnJvbUJpdHNcblxuXHQvKipcblx0ICogU2V0IHRoZSBjdXJyZW50IF9VSU5UNjRfIG9iamVjdCBmcm9tIGEgbnVtYmVyXG5cdCAqIEBtZXRob2QgZnJvbU51bWJlclxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdGZ1bmN0aW9uIGZyb21OdW1iZXIgKHZhbHVlKSB7XG5cdFx0dGhpcy5fYTAwID0gdmFsdWUgJiAweEZGRkZcblx0XHR0aGlzLl9hMTYgPSB2YWx1ZSA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXHRVSU5UNjQucHJvdG90eXBlLmZyb21OdW1iZXIgPSBmcm9tTnVtYmVyXG5cblx0LyoqXG5cdCAqIFNldCB0aGUgY3VycmVudCBfVUlOVDY0XyBvYmplY3QgZnJvbSBhIHN0cmluZ1xuXHQgKiBAbWV0aG9kIGZyb21TdHJpbmdcblx0ICogQHBhcmFtIHtTdHJpbmd9IGludGVnZXIgYXMgYSBzdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0ZnVuY3Rpb24gZnJvbVN0cmluZyAocywgcmFkaXgpIHtcblx0XHRyYWRpeCA9IHJhZGl4IHx8IDEwXG5cblx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0dGhpcy5fYTE2ID0gMFxuXHRcdHRoaXMuX2EzMiA9IDBcblx0XHR0aGlzLl9hNDggPSAwXG5cblx0XHQvKlxuXHRcdFx0SW4gSmF2YXNjcmlwdCwgYml0d2lzZSBvcGVyYXRvcnMgb25seSBvcGVyYXRlIG9uIHRoZSBmaXJzdCAzMiBiaXRzIFxuXHRcdFx0b2YgYSBudW1iZXIsIGV2ZW4gdGhvdWdoIHBhcnNlSW50KCkgZW5jb2RlcyBudW1iZXJzIHdpdGggYSA1MyBiaXRzIFxuXHRcdFx0bWFudGlzc2EuXG5cdFx0XHRUaGVyZWZvcmUgVUlOVDY0KDxOdW1iZXI+KSBjYW4gb25seSB3b3JrIG9uIDMyIGJpdHMuXG5cdFx0XHRUaGUgcmFkaXggbWF4aW11bSB2YWx1ZSBpcyAzNiAoYXMgcGVyIEVDTUEgc3BlY3MpICgyNiBsZXR0ZXJzICsgMTAgZGlnaXRzKVxuXHRcdFx0bWF4aW11bSBpbnB1dCB2YWx1ZSBpcyBtID0gMzJiaXRzIGFzIDEgPSAyXjMyIC0gMVxuXHRcdFx0U28gdGhlIG1heGltdW0gc3Vic3RyaW5nIGxlbmd0aCBuIGlzOlxuXHRcdFx0MzZeKG4rMSkgLSAxID0gMl4zMiAtIDFcblx0XHRcdDM2XihuKzEpID0gMl4zMlxuXHRcdFx0KG4rMSlsbigzNikgPSAzMmxuKDIpXG5cdFx0XHRuID0gMzJsbigyKS9sbigzNikgLSAxXG5cdFx0XHRuID0gNS4xODk2NDQ5MTU2ODc2OTJcblx0XHRcdG4gPSA1XG5cdFx0ICovXG5cdFx0dmFyIHJhZGl4VWludCA9IHJhZGl4UG93ZXJDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIDUpIClcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBzLmxlbmd0aDsgaSA8IGxlbjsgaSArPSA1KSB7XG5cdFx0XHR2YXIgc2l6ZSA9IE1hdGgubWluKDUsIGxlbiAtIGkpXG5cdFx0XHR2YXIgdmFsdWUgPSBwYXJzZUludCggcy5zbGljZShpLCBpICsgc2l6ZSksIHJhZGl4IClcblx0XHRcdHRoaXMubXVsdGlwbHkoXG5cdFx0XHRcdFx0c2l6ZSA8IDVcblx0XHRcdFx0XHRcdD8gbmV3IFVJTlQ2NCggTWF0aC5wb3cocmFkaXgsIHNpemUpIClcblx0XHRcdFx0XHRcdDogcmFkaXhVaW50XG5cdFx0XHRcdClcblx0XHRcdFx0LmFkZCggbmV3IFVJTlQ2NCh2YWx1ZSkgKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblx0VUlOVDY0LnByb3RvdHlwZS5mcm9tU3RyaW5nID0gZnJvbVN0cmluZ1xuXG5cdC8qKlxuXHQgKiBDb252ZXJ0IHRoaXMgX1VJTlQ2NF8gdG8gYSBudW1iZXIgKGxhc3QgMzIgYml0cyBhcmUgZHJvcHBlZClcblx0ICogQG1ldGhvZCB0b051bWJlclxuXHQgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBjb252ZXJ0ZWQgVUlOVDY0XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiAodGhpcy5fYTE2ICogNjU1MzYpICsgdGhpcy5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydCB0aGlzIF9VSU5UNjRfIHRvIGEgc3RyaW5nXG5cdCAqIEBtZXRob2QgdG9TdHJpbmdcblx0ICogQHBhcmFtIHtOdW1iZXJ9IHJhZGl4IChvcHRpb25hbCwgZGVmYXVsdD0xMClcblx0ICogQHJldHVybiB7U3RyaW5nfSB0aGUgY29udmVydGVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIChyYWRpeCkge1xuXHRcdHJhZGl4ID0gcmFkaXggfHwgMTBcblx0XHR2YXIgcmFkaXhVaW50ID0gcmFkaXhDYWNoZVtyYWRpeF0gfHwgbmV3IFVJTlQ2NChyYWRpeClcblxuXHRcdGlmICggIXRoaXMuZ3QocmFkaXhVaW50KSApIHJldHVybiB0aGlzLnRvTnVtYmVyKCkudG9TdHJpbmcocmFkaXgpXG5cblx0XHR2YXIgc2VsZiA9IHRoaXMuY2xvbmUoKVxuXHRcdHZhciByZXMgPSBuZXcgQXJyYXkoNjQpXG5cdFx0Zm9yICh2YXIgaSA9IDYzOyBpID49IDA7IGktLSkge1xuXHRcdFx0c2VsZi5kaXYocmFkaXhVaW50KVxuXHRcdFx0cmVzW2ldID0gc2VsZi5yZW1haW5kZXIudG9OdW1iZXIoKS50b1N0cmluZyhyYWRpeClcblx0XHRcdGlmICggIXNlbGYuZ3QocmFkaXhVaW50KSApIGJyZWFrXG5cdFx0fVxuXHRcdHJlc1tpLTFdID0gc2VsZi50b051bWJlcigpLnRvU3RyaW5nKHJhZGl4KVxuXG5cdFx0cmV0dXJuIHJlcy5qb2luKCcnKVxuXHR9XG5cblx0LyoqXG5cdCAqIEFkZCB0d28gX1VJTlQ2NF8uIFRoZSBjdXJyZW50IF9VSU5UNjRfIHN0b3JlcyB0aGUgcmVzdWx0XG5cdCAqIEBtZXRob2QgYWRkXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwICsgb3RoZXIuX2EwMFxuXG5cdFx0dmFyIGExNiA9IGEwMCA+Pj4gMTZcblx0XHRhMTYgKz0gdGhpcy5fYTE2ICsgb3RoZXIuX2ExNlxuXG5cdFx0dmFyIGEzMiA9IGExNiA+Pj4gMTZcblx0XHRhMzIgKz0gdGhpcy5fYTMyICsgb3RoZXIuX2EzMlxuXG5cdFx0dmFyIGE0OCA9IGEzMiA+Pj4gMTZcblx0XHRhNDggKz0gdGhpcy5fYTQ4ICsgb3RoZXIuX2E0OFxuXG5cdFx0dGhpcy5fYTAwID0gYTAwICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gYTE2ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTMyID0gYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gYTQ4ICYgMHhGRkZGXG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIFN1YnRyYWN0IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBzdWJ0cmFjdFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIG90aGVyLmNsb25lKCkubmVnYXRlKCkgKVxuXHR9XG5cblx0LyoqXG5cdCAqIE11bHRpcGx5IHR3byBfVUlOVDY0Xy4gVGhlIGN1cnJlbnQgX1VJTlQ2NF8gc3RvcmVzIHRoZSByZXN1bHRcblx0ICogQG1ldGhvZCBtdWx0aXBseVxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubXVsdGlwbHkgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHQvKlxuXHRcdFx0YSA9IGEwMCArIGExNiArIGEzMiArIGE0OFxuXHRcdFx0YiA9IGIwMCArIGIxNiArIGIzMiArIGI0OFxuXHRcdFx0YSpiID0gKGEwMCArIGExNiArIGEzMiArIGE0OCkoYjAwICsgYjE2ICsgYjMyICsgYjQ4KVxuXHRcdFx0XHQ9IGEwMGIwMCArIGEwMGIxNiArIGEwMGIzMiArIGEwMGI0OFxuXHRcdFx0XHQrIGExNmIwMCArIGExNmIxNiArIGExNmIzMiArIGExNmI0OFxuXHRcdFx0XHQrIGEzMmIwMCArIGEzMmIxNiArIGEzMmIzMiArIGEzMmI0OFxuXHRcdFx0XHQrIGE0OGIwMCArIGE0OGIxNiArIGE0OGIzMiArIGE0OGI0OFxuXG5cdFx0XHRhMTZiNDgsIGEzMmIzMiwgYTQ4YjE2LCBhNDhiMzIgYW5kIGE0OGI0OCBvdmVyZmxvdyB0aGUgNjQgYml0c1xuXHRcdFx0c28gaXQgY29tZXMgZG93biB0bzpcblx0XHRcdGEqYlx0PSBhMDBiMDAgKyBhMDBiMTYgKyBhMDBiMzIgKyBhMDBiNDhcblx0XHRcdFx0KyBhMTZiMDAgKyBhMTZiMTYgKyBhMTZiMzJcblx0XHRcdFx0KyBhMzJiMDAgKyBhMzJiMTZcblx0XHRcdFx0KyBhNDhiMDBcblx0XHRcdFx0PSBhMDBiMDBcblx0XHRcdFx0KyBhMDBiMTYgKyBhMTZiMDBcblx0XHRcdFx0KyBhMDBiMzIgKyBhMTZiMTYgKyBhMzJiMDBcblx0XHRcdFx0KyBhMDBiNDggKyBhMTZiMzIgKyBhMzJiMTYgKyBhNDhiMDBcblx0XHQgKi9cblx0XHR2YXIgYTAwID0gdGhpcy5fYTAwXG5cdFx0dmFyIGExNiA9IHRoaXMuX2ExNlxuXHRcdHZhciBhMzIgPSB0aGlzLl9hMzJcblx0XHR2YXIgYTQ4ID0gdGhpcy5fYTQ4XG5cdFx0dmFyIGIwMCA9IG90aGVyLl9hMDBcblx0XHR2YXIgYjE2ID0gb3RoZXIuX2ExNlxuXHRcdHZhciBiMzIgPSBvdGhlci5fYTMyXG5cdFx0dmFyIGI0OCA9IG90aGVyLl9hNDhcblxuXHRcdHZhciBjMDAgPSBhMDAgKiBiMDBcblxuXHRcdHZhciBjMTYgPSBjMDAgPj4+IDE2XG5cdFx0YzE2ICs9IGEwMCAqIGIxNlxuXHRcdHZhciBjMzIgPSBjMTYgPj4+IDE2XG5cdFx0YzE2ICY9IDB4RkZGRlxuXHRcdGMxNiArPSBhMTYgKiBiMDBcblxuXHRcdGMzMiArPSBjMTYgPj4+IDE2XG5cdFx0YzMyICs9IGEwMCAqIGIzMlxuXHRcdHZhciBjNDggPSBjMzIgPj4+IDE2XG5cdFx0YzMyICY9IDB4RkZGRlxuXHRcdGMzMiArPSBhMTYgKiBiMTZcblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGMzMiAmPSAweEZGRkZcblx0XHRjMzIgKz0gYTMyICogYjAwXG5cblx0XHRjNDggKz0gYzMyID4+PiAxNlxuXHRcdGM0OCArPSBhMDAgKiBiNDhcblx0XHRjNDggJj0gMHhGRkZGXG5cdFx0YzQ4ICs9IGExNiAqIGIzMlxuXHRcdGM0OCAmPSAweEZGRkZcblx0XHRjNDggKz0gYTMyICogYjE2XG5cdFx0YzQ4ICY9IDB4RkZGRlxuXHRcdGM0OCArPSBhNDggKiBiMDBcblxuXHRcdHRoaXMuX2EwMCA9IGMwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IGMxNiAmIDB4RkZGRlxuXHRcdHRoaXMuX2EzMiA9IGMzMiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IGM0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBEaXZpZGUgdHdvIF9VSU5UNjRfLiBUaGUgY3VycmVudCBfVUlOVDY0XyBzdG9yZXMgdGhlIHJlc3VsdC5cblx0ICogVGhlIHJlbWFpbmRlciBpcyBtYWRlIGF2YWlsYWJsZSBhcyB0aGUgX3JlbWFpbmRlcl8gcHJvcGVydHkgb25cblx0ICogdGhlIF9VSU5UNjRfIG9iamVjdC4gSXQgY2FuIGJlIG51bGwsIG1lYW5pbmcgdGhlcmUgYXJlIG5vIHJlbWFpbmRlci5cblx0ICogQG1ldGhvZCBkaXZcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmRpdiA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICggKG90aGVyLl9hMTYgPT0gMCkgJiYgKG90aGVyLl9hMzIgPT0gMCkgJiYgKG90aGVyLl9hNDggPT0gMCkgKSB7XG5cdFx0XHRpZiAob3RoZXIuX2EwMCA9PSAwKSB0aHJvdyBFcnJvcignZGl2aXNpb24gYnkgemVybycpXG5cblx0XHRcdC8vIG90aGVyID09IDE6IHRoaXNcblx0XHRcdGlmIChvdGhlci5fYTAwID09IDEpIHtcblx0XHRcdFx0dGhpcy5yZW1haW5kZXIgPSBuZXcgVUlOVDY0KDApXG5cdFx0XHRcdHJldHVybiB0aGlzXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gb3RoZXIgPiB0aGlzOiAwXG5cdFx0aWYgKCBvdGhlci5ndCh0aGlzKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gdGhpcy5jbG9uZSgpXG5cdFx0XHR0aGlzLl9hMDAgPSAwXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0XHRyZXR1cm4gdGhpc1xuXHRcdH1cblx0XHQvLyBvdGhlciA9PSB0aGlzOiAxXG5cdFx0aWYgKCB0aGlzLmVxKG90aGVyKSApIHtcblx0XHRcdHRoaXMucmVtYWluZGVyID0gbmV3IFVJTlQ2NCgwKVxuXHRcdFx0dGhpcy5fYTAwID0gMVxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdFx0cmV0dXJuIHRoaXNcblx0XHR9XG5cblx0XHQvLyBTaGlmdCB0aGUgZGl2aXNvciBsZWZ0IHVudGlsIGl0IGlzIGhpZ2hlciB0aGFuIHRoZSBkaXZpZGVuZFxuXHRcdHZhciBfb3RoZXIgPSBvdGhlci5jbG9uZSgpXG5cdFx0dmFyIGkgPSAtMVxuXHRcdHdoaWxlICggIXRoaXMubHQoX290aGVyKSApIHtcblx0XHRcdC8vIEhpZ2ggYml0IGNhbiBvdmVyZmxvdyB0aGUgZGVmYXVsdCAxNmJpdHNcblx0XHRcdC8vIEl0cyBvayBzaW5jZSB3ZSByaWdodCBzaGlmdCBhZnRlciB0aGlzIGxvb3Bcblx0XHRcdC8vIFRoZSBvdmVyZmxvd24gYml0IG11c3QgYmUga2VwdCB0aG91Z2hcblx0XHRcdF9vdGhlci5zaGlmdExlZnQoMSwgdHJ1ZSlcblx0XHRcdGkrK1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgcmVtYWluZGVyXG5cdFx0dGhpcy5yZW1haW5kZXIgPSB0aGlzLmNsb25lKClcblx0XHQvLyBJbml0aWFsaXplIHRoZSBjdXJyZW50IHJlc3VsdCB0byAwXG5cdFx0dGhpcy5fYTAwID0gMFxuXHRcdHRoaXMuX2ExNiA9IDBcblx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdGZvciAoOyBpID49IDA7IGktLSkge1xuXHRcdFx0X290aGVyLnNoaWZ0UmlnaHQoMSlcblx0XHRcdC8vIElmIHNoaWZ0ZWQgZGl2aXNvciBpcyBzbWFsbGVyIHRoYW4gdGhlIGRpdmlkZW5kXG5cdFx0XHQvLyB0aGVuIHN1YnRyYWN0IGl0IGZyb20gdGhlIGRpdmlkZW5kXG5cdFx0XHRpZiAoICF0aGlzLnJlbWFpbmRlci5sdChfb3RoZXIpICkge1xuXHRcdFx0XHR0aGlzLnJlbWFpbmRlci5zdWJ0cmFjdChfb3RoZXIpXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgY3VycmVudCByZXN1bHRcblx0XHRcdFx0aWYgKGkgPj0gNDgpIHtcblx0XHRcdFx0XHR0aGlzLl9hNDggfD0gMSA8PCAoaSAtIDQ4KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMzIpIHtcblx0XHRcdFx0XHR0aGlzLl9hMzIgfD0gMSA8PCAoaSAtIDMyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGkgPj0gMTYpIHtcblx0XHRcdFx0XHR0aGlzLl9hMTYgfD0gMSA8PCAoaSAtIDE2KVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2EwMCB8PSAxIDw8IGlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogTmVnYXRlIHRoZSBjdXJyZW50IF9VSU5UNjRfXG5cdCAqIEBtZXRob2QgbmVnYXRlXG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubmVnYXRlID0gZnVuY3Rpb24gKCkge1xuXHRcdHZhciB2ID0gKCB+dGhpcy5fYTAwICYgMHhGRkZGICkgKyAxXG5cdFx0dGhpcy5fYTAwID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2ExNiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTE2ID0gdiAmIDB4RkZGRlxuXHRcdHYgPSAofnRoaXMuX2EzMiAmIDB4RkZGRikgKyAodiA+Pj4gMTYpXG5cdFx0dGhpcy5fYTMyID0gdiAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9ICh+dGhpcy5fYTQ4ICsgKHYgPj4+IDE2KSkgJiAweEZGRkZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblxuXHQgKiBAbWV0aG9kIGVxXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBVSU5UNjRcblx0ICogQHJldHVybiB7Qm9vbGVhbn1cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuZXF1YWxzID0gVUlOVDY0LnByb3RvdHlwZS5lcSA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHJldHVybiAodGhpcy5fYTQ4ID09IG90aGVyLl9hNDgpICYmICh0aGlzLl9hMDAgPT0gb3RoZXIuX2EwMClcblx0XHRcdCAmJiAodGhpcy5fYTMyID09IG90aGVyLl9hMzIpICYmICh0aGlzLl9hMTYgPT0gb3RoZXIuX2ExNilcblx0fVxuXG5cdC8qKlxuXHQgKiBHcmVhdGVyIHRoYW4gKHN0cmljdClcblx0ICogQG1ldGhvZCBndFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLmdyZWF0ZXJUaGFuID0gVUlOVDY0LnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdGlmICh0aGlzLl9hNDggPiBvdGhlci5fYTQ4KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hNDggPCBvdGhlci5fYTQ4KSByZXR1cm4gZmFsc2Vcblx0XHRpZiAodGhpcy5fYTMyID4gb3RoZXIuX2EzMikgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTMyIDwgb3RoZXIuX2EzMikgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2ExNiA+IG90aGVyLl9hMTYpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2ExNiA8IG90aGVyLl9hMTYpIHJldHVybiBmYWxzZVxuXHRcdHJldHVybiB0aGlzLl9hMDAgPiBvdGhlci5fYTAwXG5cdH1cblxuXHQvKipcblx0ICogTGVzcyB0aGFuIChzdHJpY3QpXG5cdCAqIEBtZXRob2QgbHRcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIHtCb29sZWFufVxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5sZXNzVGhhbiA9IFVJTlQ2NC5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHRpZiAodGhpcy5fYTQ4IDwgb3RoZXIuX2E0OCkgcmV0dXJuIHRydWVcblx0XHRpZiAodGhpcy5fYTQ4ID4gb3RoZXIuX2E0OCkgcmV0dXJuIGZhbHNlXG5cdFx0aWYgKHRoaXMuX2EzMiA8IG90aGVyLl9hMzIpIHJldHVybiB0cnVlXG5cdFx0aWYgKHRoaXMuX2EzMiA+IG90aGVyLl9hMzIpIHJldHVybiBmYWxzZVxuXHRcdGlmICh0aGlzLl9hMTYgPCBvdGhlci5fYTE2KSByZXR1cm4gdHJ1ZVxuXHRcdGlmICh0aGlzLl9hMTYgPiBvdGhlci5fYTE2KSByZXR1cm4gZmFsc2Vcblx0XHRyZXR1cm4gdGhpcy5fYTAwIDwgb3RoZXIuX2EwMFxuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgT1Jcblx0ICogQG1ldGhvZCBvclxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiAob3RoZXIpIHtcblx0XHR0aGlzLl9hMDAgfD0gb3RoZXIuX2EwMFxuXHRcdHRoaXMuX2ExNiB8PSBvdGhlci5fYTE2XG5cdFx0dGhpcy5fYTMyIHw9IG90aGVyLl9hMzJcblx0XHR0aGlzLl9hNDggfD0gb3RoZXIuX2E0OFxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIEFORFxuXHQgKiBAbWV0aG9kIGFuZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVUlOVDY0XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUuYW5kID0gZnVuY3Rpb24gKG90aGVyKSB7XG5cdFx0dGhpcy5fYTAwICY9IG90aGVyLl9hMDBcblx0XHR0aGlzLl9hMTYgJj0gb3RoZXIuX2ExNlxuXHRcdHRoaXMuX2EzMiAmPSBvdGhlci5fYTMyXG5cdFx0dGhpcy5fYTQ4ICY9IG90aGVyLl9hNDhcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSBYT1Jcblx0ICogQG1ldGhvZCB4b3Jcblx0ICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFVJTlQ2NFxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIChvdGhlcikge1xuXHRcdHRoaXMuX2EwMCBePSBvdGhlci5fYTAwXG5cdFx0dGhpcy5fYTE2IF49IG90aGVyLl9hMTZcblx0XHR0aGlzLl9hMzIgXj0gb3RoZXIuX2EzMlxuXHRcdHRoaXMuX2E0OCBePSBvdGhlci5fYTQ4XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2UgTk9UXG5cdCAqIEBtZXRob2Qgbm90XG5cdCAqIEByZXR1cm4gVGhpc0V4cHJlc3Npb25cblx0ICovXG5cdFVJTlQ2NC5wcm90b3R5cGUubm90ID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYTAwID0gfnRoaXMuX2EwMCAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IH50aGlzLl9hMTYgJiAweEZGRkZcblx0XHR0aGlzLl9hMzIgPSB+dGhpcy5fYTMyICYgMHhGRkZGXG5cdFx0dGhpcy5fYTQ4ID0gfnRoaXMuX2E0OCAmIDB4RkZGRlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBCaXR3aXNlIHNoaWZ0IHJpZ2h0XG5cdCAqIEBtZXRob2Qgc2hpZnRSaWdodFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5zaGlmdFJpZ2h0ID0gVUlOVDY0LnByb3RvdHlwZS5zaGlmdHIgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA+PSA0OCkge1xuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTQ4ID4+IChuIC0gNDgpXG5cdFx0XHR0aGlzLl9hMTYgPSAwXG5cdFx0XHR0aGlzLl9hMzIgPSAwXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIGlmIChuID49IDMyKSB7XG5cdFx0XHRuIC09IDMyXG5cdFx0XHR0aGlzLl9hMDAgPSAoICh0aGlzLl9hMzIgPj4gbikgfCAodGhpcy5fYTQ4IDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gKHRoaXMuX2E0OCA+PiBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTQ4ID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTAwID0gKCAodGhpcy5fYTE2ID4+IG4pIHwgKHRoaXMuX2EzMiA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2EzMiA+PiBuKSB8ICh0aGlzLl9hNDggPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMzIgPSAodGhpcy5fYTQ4ID4+IG4pICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hNDggPSAwXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2EwMCA9ICggKHRoaXMuX2EwMCA+PiBuKSB8ICh0aGlzLl9hMTYgPDwgKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMTYgPSAoICh0aGlzLl9hMTYgPj4gbikgfCAodGhpcy5fYTMyIDw8ICgxNi1uKSkgKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyID4+IG4pIHwgKHRoaXMuX2E0OCA8PCAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2E0OCA9ICh0aGlzLl9hNDggPj4gbikgJiAweEZGRkZcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpdHdpc2Ugc2hpZnQgbGVmdFxuXHQgKiBAbWV0aG9kIHNoaWZ0TGVmdFxuXHQgKiBAcGFyYW0ge051bWJlcn0gbnVtYmVyIG9mIGJpdHMgdG8gc2hpZnRcblx0ICogQHBhcmFtIHtCb29sZWFufSBhbGxvdyBvdmVyZmxvd1xuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnNoaWZ0TGVmdCA9IFVJTlQ2NC5wcm90b3R5cGUuc2hpZnRsID0gZnVuY3Rpb24gKG4sIGFsbG93T3ZlcmZsb3cpIHtcblx0XHRuICU9IDY0XG5cdFx0aWYgKG4gPj0gNDgpIHtcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2EwMCA8PCAobiAtIDQ4KVxuXHRcdFx0dGhpcy5fYTMyID0gMFxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAzMikge1xuXHRcdFx0biAtPSAzMlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKHRoaXMuX2EwMCA8PCBuKSAmIDB4RkZGRlxuXHRcdFx0dGhpcy5fYTE2ID0gMFxuXHRcdFx0dGhpcy5fYTAwID0gMFxuXHRcdH0gZWxzZSBpZiAobiA+PSAxNikge1xuXHRcdFx0biAtPSAxNlxuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2EzMiA8PCBuKSB8ICh0aGlzLl9hMTYgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTE2IDw8IG4pIHwgKHRoaXMuX2EwMCA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICh0aGlzLl9hMDAgPDwgbikgJiAweEZGRkZcblx0XHRcdHRoaXMuX2EwMCA9IDBcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fYTQ4ID0gKHRoaXMuX2E0OCA8PCBuKSB8ICh0aGlzLl9hMzIgPj4gKDE2LW4pKVxuXHRcdFx0dGhpcy5fYTMyID0gKCAodGhpcy5fYTMyIDw8IG4pIHwgKHRoaXMuX2ExNiA+PiAoMTYtbikpICkgJiAweEZGRkZcblx0XHRcdHRoaXMuX2ExNiA9ICggKHRoaXMuX2ExNiA8PCBuKSB8ICh0aGlzLl9hMDAgPj4gKDE2LW4pKSApICYgMHhGRkZGXG5cdFx0XHR0aGlzLl9hMDAgPSAodGhpcy5fYTAwIDw8IG4pICYgMHhGRkZGXG5cdFx0fVxuXHRcdGlmICghYWxsb3dPdmVyZmxvdykge1xuXHRcdFx0dGhpcy5fYTQ4ICY9IDB4RkZGRlxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgbGVmdFxuXHQgKiBAbWV0aG9kIHJvdGxcblx0ICogQHBhcmFtIHtOdW1iZXJ9IG51bWJlciBvZiBiaXRzIHRvIHJvdGF0ZVxuXHQgKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG5cdCAqL1xuXHRVSU5UNjQucHJvdG90eXBlLnJvdGF0ZUxlZnQgPSBVSU5UNjQucHJvdG90eXBlLnJvdGwgPSBmdW5jdGlvbiAobikge1xuXHRcdG4gJT0gNjRcblx0XHRpZiAobiA9PSAwKSByZXR1cm4gdGhpc1xuXHRcdGlmIChuID49IDMyKSB7XG5cdFx0XHQvLyBBLkIuQy5EXG5cdFx0XHQvLyBCLkMuRC5BIHJvdGwoMTYpXG5cdFx0XHQvLyBDLkQuQS5CIHJvdGwoMzIpXG5cdFx0XHR2YXIgdiA9IHRoaXMuX2EwMFxuXHRcdFx0dGhpcy5fYTAwID0gdGhpcy5fYTMyXG5cdFx0XHR0aGlzLl9hMzIgPSB2XG5cdFx0XHR2ID0gdGhpcy5fYTQ4XG5cdFx0XHR0aGlzLl9hNDggPSB0aGlzLl9hMTZcblx0XHRcdHRoaXMuX2ExNiA9IHZcblx0XHRcdGlmIChuID09IDMyKSByZXR1cm4gdGhpc1xuXHRcdFx0biAtPSAzMlxuXHRcdH1cblxuXHRcdHZhciBoaWdoID0gKHRoaXMuX2E0OCA8PCAxNikgfCB0aGlzLl9hMzJcblx0XHR2YXIgbG93ID0gKHRoaXMuX2ExNiA8PCAxNikgfCB0aGlzLl9hMDBcblxuXHRcdHZhciBfaGlnaCA9IChoaWdoIDw8IG4pIHwgKGxvdyA+Pj4gKDMyIC0gbikpXG5cdFx0dmFyIF9sb3cgPSAobG93IDw8IG4pIHwgKGhpZ2ggPj4+ICgzMiAtIG4pKVxuXG5cdFx0dGhpcy5fYTAwID0gX2xvdyAmIDB4RkZGRlxuXHRcdHRoaXMuX2ExNiA9IF9sb3cgPj4+IDE2XG5cdFx0dGhpcy5fYTMyID0gX2hpZ2ggJiAweEZGRkZcblx0XHR0aGlzLl9hNDggPSBfaGlnaCA+Pj4gMTZcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHQvKipcblx0ICogQml0d2lzZSByb3RhdGUgcmlnaHRcblx0ICogQG1ldGhvZCByb3RyXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBudW1iZXIgb2YgYml0cyB0byByb3RhdGVcblx0ICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5yb3RhdGVSaWdodCA9IFVJTlQ2NC5wcm90b3R5cGUucm90ciA9IGZ1bmN0aW9uIChuKSB7XG5cdFx0biAlPSA2NFxuXHRcdGlmIChuID09IDApIHJldHVybiB0aGlzXG5cdFx0aWYgKG4gPj0gMzIpIHtcblx0XHRcdC8vIEEuQi5DLkRcblx0XHRcdC8vIEQuQS5CLkMgcm90cigxNilcblx0XHRcdC8vIEMuRC5BLkIgcm90cigzMilcblx0XHRcdHZhciB2ID0gdGhpcy5fYTAwXG5cdFx0XHR0aGlzLl9hMDAgPSB0aGlzLl9hMzJcblx0XHRcdHRoaXMuX2EzMiA9IHZcblx0XHRcdHYgPSB0aGlzLl9hNDhcblx0XHRcdHRoaXMuX2E0OCA9IHRoaXMuX2ExNlxuXHRcdFx0dGhpcy5fYTE2ID0gdlxuXHRcdFx0aWYgKG4gPT0gMzIpIHJldHVybiB0aGlzXG5cdFx0XHRuIC09IDMyXG5cdFx0fVxuXG5cdFx0dmFyIGhpZ2ggPSAodGhpcy5fYTQ4IDw8IDE2KSB8IHRoaXMuX2EzMlxuXHRcdHZhciBsb3cgPSAodGhpcy5fYTE2IDw8IDE2KSB8IHRoaXMuX2EwMFxuXG5cdFx0dmFyIF9oaWdoID0gKGhpZ2ggPj4+IG4pIHwgKGxvdyA8PCAoMzIgLSBuKSlcblx0XHR2YXIgX2xvdyA9IChsb3cgPj4+IG4pIHwgKGhpZ2ggPDwgKDMyIC0gbikpXG5cblx0XHR0aGlzLl9hMDAgPSBfbG93ICYgMHhGRkZGXG5cdFx0dGhpcy5fYTE2ID0gX2xvdyA+Pj4gMTZcblx0XHR0aGlzLl9hMzIgPSBfaGlnaCAmIDB4RkZGRlxuXHRcdHRoaXMuX2E0OCA9IF9oaWdoID4+PiAxNlxuXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdC8qKlxuXHQgKiBDbG9uZSB0aGUgY3VycmVudCBfVUlOVDY0X1xuXHQgKiBAbWV0aG9kIGNsb25lXG5cdCAqIEByZXR1cm4ge09iamVjdH0gY2xvbmVkIFVJTlQ2NFxuXHQgKi9cblx0VUlOVDY0LnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gbmV3IFVJTlQ2NCh0aGlzLl9hMDAsIHRoaXMuX2ExNiwgdGhpcy5fYTMyLCB0aGlzLl9hNDgpXG5cdH1cblxuXHRpZiAodHlwZW9mIGRlZmluZSAhPSAndW5kZWZpbmVkJyAmJiBkZWZpbmUuYW1kKSB7XG5cdFx0Ly8gQU1EIC8gUmVxdWlyZUpTXG5cdFx0ZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZXR1cm4gVUlOVDY0XG5cdFx0fSlcblx0fSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG5cdFx0Ly8gTm9kZS5qc1xuXHRcdG1vZHVsZS5leHBvcnRzID0gVUlOVDY0XG5cdH0gZWxzZSB7XG5cdFx0Ly8gQnJvd3NlclxuXHRcdHJvb3RbJ1VJTlQ2NCddID0gVUlOVDY0XG5cdH1cblxufSkodGhpcylcbiIsICJleHBvcnRzLlVJTlQzMiA9IHJlcXVpcmUoJy4vbGliL3VpbnQzMicpXG5leHBvcnRzLlVJTlQ2NCA9IHJlcXVpcmUoJy4vbGliL3VpbnQ2NCcpIiwgIi8qKlxueHhIYXNoIGltcGxlbWVudGF0aW9uIGluIHB1cmUgSmF2YXNjcmlwdFxuXG5Db3B5cmlnaHQgKEMpIDIwMTMsIFBpZXJyZSBDdXJ0b1xuTUlUIGxpY2Vuc2VcbiovXG52YXIgVUlOVDMyID0gcmVxdWlyZSgnY3VpbnQnKS5VSU5UMzJcblxuLypcblx0TWVyZ2VkIHRoaXMgc2VxdWVuY2Ugb2YgbWV0aG9kIGNhbGxzIGFzIGl0IHNwZWVkcyB1cFxuXHR0aGUgY2FsY3VsYXRpb25zIGJ5IGEgZmFjdG9yIG9mIDJcbiAqL1xuLy8gdGhpcy52MS5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FMzJfMikgKS5yb3RsKDEzKS5tdWx0aXBseShQUklNRTMyXzEpO1xuVUlOVDMyLnByb3RvdHlwZS54eGhfdXBkYXRlID0gZnVuY3Rpb24gKGxvdywgaGlnaCkge1xuXHR2YXIgYjAwID0gUFJJTUUzMl8yLl9sb3dcblx0dmFyIGIxNiA9IFBSSU1FMzJfMi5faGlnaFxuXG5cdHZhciBjMTYsIGMwMFxuXHRjMDAgPSBsb3cgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBoaWdoICogYjAwXG5cdGMxNiAmPSAweEZGRkZcdFx0Ly8gTm90IHJlcXVpcmVkIGJ1dCBpbXByb3ZlcyBwZXJmb3JtYW5jZVxuXHRjMTYgKz0gbG93ICogYjE2XG5cblx0dmFyIGEwMCA9IHRoaXMuX2xvdyArIChjMDAgJiAweEZGRkYpXG5cdHZhciBhMTYgPSBhMDAgPj4+IDE2XG5cblx0YTE2ICs9IHRoaXMuX2hpZ2ggKyAoYzE2ICYgMHhGRkZGKVxuXG5cdHZhciB2ID0gKGExNiA8PCAxNikgfCAoYTAwICYgMHhGRkZGKVxuXHR2ID0gKHYgPDwgMTMpIHwgKHYgPj4+IDE5KVxuXG5cdGEwMCA9IHYgJiAweEZGRkZcblx0YTE2ID0gdiA+Pj4gMTZcblxuXHRiMDAgPSBQUklNRTMyXzEuX2xvd1xuXHRiMTYgPSBQUklNRTMyXzEuX2hpZ2hcblxuXHRjMDAgPSBhMDAgKiBiMDBcblx0YzE2ID0gYzAwID4+PiAxNlxuXG5cdGMxNiArPSBhMTYgKiBiMDBcblx0YzE2ICY9IDB4RkZGRlx0XHQvLyBOb3QgcmVxdWlyZWQgYnV0IGltcHJvdmVzIHBlcmZvcm1hbmNlXG5cdGMxNiArPSBhMDAgKiBiMTZcblxuXHR0aGlzLl9sb3cgPSBjMDAgJiAweEZGRkZcblx0dGhpcy5faGlnaCA9IGMxNiAmIDB4RkZGRlxufVxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTMyXzEgPSBVSU5UMzIoICcyNjU0NDM1NzYxJyApXG52YXIgUFJJTUUzMl8yID0gVUlOVDMyKCAnMjI0NjgyMjUxOScgKVxudmFyIFBSSU1FMzJfMyA9IFVJTlQzMiggJzMyNjY0ODk5MTcnIClcbnZhciBQUklNRTMyXzQgPSBVSU5UMzIoICAnNjY4MjY1MjYzJyApXG52YXIgUFJJTUUzMl81ID0gVUlOVDMyKCAgJzM3NDc2MTM5MycgKVxuXG4vKipcbiogQ29udmVydCBzdHJpbmcgdG8gcHJvcGVyIFVURi04IGFycmF5XG4qIEBwYXJhbSBzdHIgSW5wdXQgc3RyaW5nXG4qIEByZXR1cm5zIHtVaW50OEFycmF5fSBVVEY4IGFycmF5IGlzIHJldHVybmVkIGFzIHVpbnQ4IGFycmF5XG4qL1xuZnVuY3Rpb24gdG9VVEY4QXJyYXkgKHN0cikge1xuXHR2YXIgdXRmOCA9IFtdXG5cdGZvciAodmFyIGk9MCwgbj1zdHIubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG5cdFx0dmFyIGNoYXJjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSlcblx0XHRpZiAoY2hhcmNvZGUgPCAweDgwKSB1dGY4LnB1c2goY2hhcmNvZGUpXG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweDgwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4YzAgfCAoY2hhcmNvZGUgPj4gNiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdGVsc2UgaWYgKGNoYXJjb2RlIDwgMHhkODAwIHx8IGNoYXJjb2RlID49IDB4ZTAwMCkge1xuXHRcdFx0dXRmOC5wdXNoKDB4ZTAgfCAoY2hhcmNvZGUgPj4gMTIpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHRcdC8vIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0ZWxzZSB7XG5cdFx0XHRpKys7XG5cdFx0XHQvLyBVVEYtMTYgZW5jb2RlcyAweDEwMDAwLTB4MTBGRkZGIGJ5XG5cdFx0XHQvLyBzdWJ0cmFjdGluZyAweDEwMDAwIGFuZCBzcGxpdHRpbmcgdGhlXG5cdFx0XHQvLyAyMCBiaXRzIG9mIDB4MC0weEZGRkZGIGludG8gdHdvIGhhbHZlc1xuXHRcdFx0Y2hhcmNvZGUgPSAweDEwMDAwICsgKCgoY2hhcmNvZGUgJiAweDNmZik8PDEwKVxuXHRcdFx0fCAoc3RyLmNoYXJDb2RlQXQoaSkgJiAweDNmZikpXG5cdFx0XHR1dGY4LnB1c2goMHhmMCB8IChjaGFyY29kZSA+PjE4KSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj4xMikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoKGNoYXJjb2RlPj42KSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8IChjaGFyY29kZSAmIDB4M2YpKVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXcgVWludDhBcnJheSh1dGY4KVxufVxuXG4vKipcbiAqIFhYSCBvYmplY3QgdXNlZCBhcyBhIGNvbnN0cnVjdG9yIG9yIGEgZnVuY3Rpb25cbiAqIEBjb25zdHJ1Y3RvclxuICogb3JcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gaW5wdXQgZGF0YVxuICogQHBhcmFtIHtOdW1iZXJ8VUlOVDMyfSBzZWVkXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKiBvclxuICogQHJldHVybiB7VUlOVDMyfSB4eEhhc2hcbiAqL1xuZnVuY3Rpb24gWFhIICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSCggYXJndW1lbnRzWzFdICkudXBkYXRlKCBhcmd1bWVudHNbMF0gKS5kaWdlc3QoKVxuXG5cdGlmICghKHRoaXMgaW5zdGFuY2VvZiBYWEgpKVxuXHRcdHJldHVybiBuZXcgWFhIKCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhIIGluc3RhbmNlIHdpdGggdGhlIGdpdmVuIHNlZWRcbiAqIEBtZXRob2QgaW5pdFxuICogQHBhcmFtIHtOdW1iZXJ8T2JqZWN0fSBzZWVkIGFzIGEgbnVtYmVyIG9yIGFuIHVuc2lnbmVkIDMyIGJpdHMgaW50ZWdlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG4gZnVuY3Rpb24gaW5pdCAoc2VlZCkge1xuXHR0aGlzLnNlZWQgPSBzZWVkIGluc3RhbmNlb2YgVUlOVDMyID8gc2VlZC5jbG9uZSgpIDogVUlOVDMyKHNlZWQpXG5cdHRoaXMudjEgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUUzMl8xKS5hZGQoUFJJTUUzMl8yKVxuXHR0aGlzLnYyID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKFBSSU1FMzJfMilcblx0dGhpcy52MyA9IHRoaXMuc2VlZC5jbG9uZSgpXG5cdHRoaXMudjQgPSB0aGlzLnNlZWQuY2xvbmUoKS5zdWJ0cmFjdChQUklNRTMyXzEpXG5cdHRoaXMudG90YWxfbGVuID0gMFxuXHR0aGlzLm1lbXNpemUgPSAwXG5cdHRoaXMubWVtb3J5ID0gbnVsbFxuXG5cdHJldHVybiB0aGlzXG59XG5YWEgucHJvdG90eXBlLmluaXQgPSBpbml0XG5cbi8qKlxuICogQWRkIGRhdGEgdG8gYmUgY29tcHV0ZWQgZm9yIHRoZSBYWEggaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIGlzQXJyYXlCdWZmZXJcblxuXHQvLyBDb252ZXJ0IGFsbCBzdHJpbmdzIHRvIHV0Zi04IGZpcnN0IChpc3N1ZSAjNSlcblx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0aW5wdXQgPSB0b1VURjhBcnJheShpbnB1dClcblx0XHRpc1N0cmluZyA9IGZhbHNlXG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0fVxuXG5cdGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09IFwidW5kZWZpbmVkXCIgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcblx0e1xuXHRcdGlzQXJyYXlCdWZmZXIgPSB0cnVlXG5cdFx0aW5wdXQgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG5cdH1cblxuXHR2YXIgcCA9IDBcblx0dmFyIGxlbiA9IGlucHV0Lmxlbmd0aFxuXHR2YXIgYkVuZCA9IHAgKyBsZW5cblxuXHRpZiAobGVuID09IDApIHJldHVybiB0aGlzXG5cblx0dGhpcy50b3RhbF9sZW4gKz0gbGVuXG5cblx0aWYgKHRoaXMubWVtc2l6ZSA9PSAwKVxuXHR7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9ICcnXG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KDE2KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLm1lbW9yeSA9IG5ldyBCdWZmZXIoMTYpXG5cdFx0fVxuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSArIGxlbiA8IDE2KSAgIC8vIGZpbGwgaW4gdG1wIGJ1ZmZlclxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIGxlbilcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ICs9IGlucHV0XG5cdFx0fSBlbHNlIGlmIChpc0FycmF5QnVmZmVyKSB7XG5cdFx0XHR0aGlzLm1lbW9yeS5zZXQoIGlucHV0LnN1YmFycmF5KDAsIGxlbiksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIDAsIGxlbiApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplICs9IGxlblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplID4gMCkgICAvLyBzb21lIGRhdGEgbGVmdCBmcm9tIHByZXZpb3VzIHVwZGF0ZVxuXHR7XG5cdFx0Ly8gWFhIX21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAxNiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMTYgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAxNiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHAzMiA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMudjEueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjQueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDMyKzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIpXG5cdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwMzIrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHAzMisyKVxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnYxLnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0XHRwMzIgKz0gNFxuXHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHQodGhpcy5tZW1vcnlbcDMyKzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyXVxuXHRcdFx0LFx0KHRoaXMubWVtb3J5W3AzMiszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMisyXVxuXHRcdFx0KVxuXHRcdFx0cDMyICs9IDRcblx0XHRcdHRoaXMudjMueHhoX3VwZGF0ZShcblx0XHRcdFx0KHRoaXMubWVtb3J5W3AzMisxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3AzMl1cblx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwMzIrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzIrMl1cblx0XHRcdClcblx0XHRcdHAzMiArPSA0XG5cdFx0XHR0aGlzLnY0Lnh4aF91cGRhdGUoXG5cdFx0XHRcdCh0aGlzLm1lbW9yeVtwMzIrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwMzJdXG5cdFx0XHQsXHQodGhpcy5tZW1vcnlbcDMyKzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDMyKzJdXG5cdFx0XHQpXG5cdFx0fVxuXG5cdFx0cCArPSAxNiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAxNilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAxNlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52Mi54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52My54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArMykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArMilcblx0XHRcdFx0KVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy52MS54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdFx0cCArPSA0XG5cdFx0XHRcdHRoaXMudjIueHhoX3VwZGF0ZShcblx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHQpXG5cdFx0XHRcdHAgKz0gNFxuXHRcdFx0XHR0aGlzLnYzLnh4aF91cGRhdGUoXG5cdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0KVxuXHRcdFx0XHRwICs9IDRcblx0XHRcdFx0dGhpcy52NC54eGhfdXBkYXRlKFxuXHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdClcblx0XHRcdH1cblx0XHRcdHAgKz0gNFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEhfbWVtY3B5KHRoaXMubWVtb3J5LCBwLCBiRW5kLXApO1xuXHRcdGlmIChpc1N0cmluZykge1xuXHRcdFx0dGhpcy5tZW1vcnkgKz0gaW5wdXQuc2xpY2UocClcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkocCwgYkVuZCksIHRoaXMubWVtc2l6ZSApXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlucHV0LmNvcHkoIHRoaXMubWVtb3J5LCB0aGlzLm1lbXNpemUsIHAsIGJFbmQgKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSA9IGJFbmQgLSBwXG5cdH1cblxuXHRyZXR1cm4gdGhpc1xufVxuXG4vKipcbiAqIEZpbmFsaXplIHRoZSBYWEggY29tcHV0YXRpb24uIFRoZSBYWEggaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQzMn0geHhIYXNoXG4gKi9cblhYSC5wcm90b3R5cGUuZGlnZXN0ID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgaW5wdXQgPSB0aGlzLm1lbW9yeVxuXHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgaW5wdXQgPT0gJ3N0cmluZydcblx0dmFyIHAgPSAwXG5cdHZhciBiRW5kID0gdGhpcy5tZW1zaXplXG5cdHZhciBoMzIsIGhcblx0dmFyIHUgPSBuZXcgVUlOVDMyXG5cblx0aWYgKHRoaXMudG90YWxfbGVuID49IDE2KVxuXHR7XG5cdFx0aDMyID0gdGhpcy52MS5yb3RsKDEpLmFkZCggdGhpcy52Mi5yb3RsKDcpLmFkZCggdGhpcy52My5yb3RsKDEyKS5hZGQoIHRoaXMudjQucm90bCgxOCkgKSApIClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoMzIgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTMyXzUgKVxuXHR9XG5cblx0aDMyLmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDQpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0KVxuXHRcdH1cblx0XHRoMzJcblx0XHRcdC5hZGQoIHUubXVsdGlwbHkoUFJJTUUzMl8zKSApXG5cdFx0XHQucm90bCgxNylcblx0XHRcdC5tdWx0aXBseSggUFJJTUUzMl80IClcblx0XHRwICs9IDRcblx0fVxuXG5cdHdoaWxlIChwIDwgYkVuZClcblx0e1xuXHRcdHUuZnJvbUJpdHMoIGlzU3RyaW5nID8gaW5wdXQuY2hhckNvZGVBdChwKyspIDogaW5wdXRbcCsrXSwgMCApXG5cdFx0aDMyXG5cdFx0XHQuYWRkKCB1Lm11bHRpcGx5KFBSSU1FMzJfNSkgKVxuXHRcdFx0LnJvdGwoMTEpXG5cdFx0XHQubXVsdGlwbHkoUFJJTUUzMl8xKVxuXHR9XG5cblx0aCA9IGgzMi5jbG9uZSgpLnNoaWZ0UmlnaHQoMTUpXG5cdGgzMi54b3IoaCkubXVsdGlwbHkoUFJJTUUzMl8yKVxuXG5cdGggPSBoMzIuY2xvbmUoKS5zaGlmdFJpZ2h0KDEzKVxuXHRoMzIueG9yKGgpLm11bHRpcGx5KFBSSU1FMzJfMylcblxuXHRoID0gaDMyLmNsb25lKCkuc2hpZnRSaWdodCgxNilcblx0aDMyLnhvcihoKVxuXG5cdC8vIFJlc2V0IHRoZSBzdGF0ZVxuXHR0aGlzLmluaXQoIHRoaXMuc2VlZCApXG5cblx0cmV0dXJuIGgzMlxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFhYSFxuIiwgIi8qKlxueHhIYXNoNjQgaW1wbGVtZW50YXRpb24gaW4gcHVyZSBKYXZhc2NyaXB0XG5cbkNvcHlyaWdodCAoQykgMjAxNiwgUGllcnJlIEN1cnRvXG5NSVQgbGljZW5zZVxuKi9cbnZhciBVSU5UNjQgPSByZXF1aXJlKCdjdWludCcpLlVJTlQ2NFxuXG4vKlxuICogQ29uc3RhbnRzXG4gKi9cbnZhciBQUklNRTY0XzEgPSBVSU5UNjQoICcxMTQwMDcxNDc4NTA3NDY5NDc5MScgKVxudmFyIFBSSU1FNjRfMiA9IFVJTlQ2NCggJzE0MDI5NDY3MzY2ODk3MDE5NzI3JyApXG52YXIgUFJJTUU2NF8zID0gVUlOVDY0KCAgJzE2MDk1ODc5MjkzOTI4MzkxNjEnIClcbnZhciBQUklNRTY0XzQgPSBVSU5UNjQoICAnOTY1MDAyOTI0MjI4NzgyODU3OScgKVxudmFyIFBSSU1FNjRfNSA9IFVJTlQ2NCggICcyODcwMTc3NDUwMDEyNjAwMjYxJyApXG5cbi8qKlxuKiBDb252ZXJ0IHN0cmluZyB0byBwcm9wZXIgVVRGLTggYXJyYXlcbiogQHBhcmFtIHN0ciBJbnB1dCBzdHJpbmdcbiogQHJldHVybnMge1VpbnQ4QXJyYXl9IFVURjggYXJyYXkgaXMgcmV0dXJuZWQgYXMgdWludDggYXJyYXlcbiovXG5mdW5jdGlvbiB0b1VURjhBcnJheSAoc3RyKSB7XG5cdHZhciB1dGY4ID0gW11cblx0Zm9yICh2YXIgaT0wLCBuPXN0ci5sZW5ndGg7IGkgPCBuOyBpKyspIHtcblx0XHR2YXIgY2hhcmNvZGUgPSBzdHIuY2hhckNvZGVBdChpKVxuXHRcdGlmIChjaGFyY29kZSA8IDB4ODApIHV0ZjgucHVzaChjaGFyY29kZSlcblx0XHRlbHNlIGlmIChjaGFyY29kZSA8IDB4ODAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhjMCB8IChjaGFyY29kZSA+PiA2KSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0ZWxzZSBpZiAoY2hhcmNvZGUgPCAweGQ4MDAgfHwgY2hhcmNvZGUgPj0gMHhlMDAwKSB7XG5cdFx0XHR1dGY4LnB1c2goMHhlMCB8IChjaGFyY29kZSA+PiAxMiksXG5cdFx0XHQweDgwIHwgKChjaGFyY29kZT4+NikgJiAweDNmKSxcblx0XHRcdDB4ODAgfCAoY2hhcmNvZGUgJiAweDNmKSlcblx0XHR9XG5cdFx0Ly8gc3Vycm9nYXRlIHBhaXJcblx0XHRlbHNlIHtcblx0XHRcdGkrKztcblx0XHRcdC8vIFVURi0xNiBlbmNvZGVzIDB4MTAwMDAtMHgxMEZGRkYgYnlcblx0XHRcdC8vIHN1YnRyYWN0aW5nIDB4MTAwMDAgYW5kIHNwbGl0dGluZyB0aGVcblx0XHRcdC8vIDIwIGJpdHMgb2YgMHgwLTB4RkZGRkYgaW50byB0d28gaGFsdmVzXG5cdFx0XHRjaGFyY29kZSA9IDB4MTAwMDAgKyAoKChjaGFyY29kZSAmIDB4M2ZmKTw8MTApXG5cdFx0XHR8IChzdHIuY2hhckNvZGVBdChpKSAmIDB4M2ZmKSlcblx0XHRcdHV0ZjgucHVzaCgweGYwIHwgKGNoYXJjb2RlID4+MTgpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjEyKSAmIDB4M2YpLFxuXHRcdFx0MHg4MCB8ICgoY2hhcmNvZGU+PjYpICYgMHgzZiksXG5cdFx0XHQweDgwIHwgKGNoYXJjb2RlICYgMHgzZikpXG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ldyBVaW50OEFycmF5KHV0ZjgpXG59XG5cbi8qKlxuICogWFhINjQgb2JqZWN0IHVzZWQgYXMgYSBjb25zdHJ1Y3RvciBvciBhIGZ1bmN0aW9uXG4gKiBAY29uc3RydWN0b3JcbiAqIG9yXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGlucHV0IGRhdGFcbiAqIEBwYXJhbSB7TnVtYmVyfFVJTlQ2NH0gc2VlZFxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICogb3JcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cbmZ1bmN0aW9uIFhYSDY0ICgpIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMilcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMV0gKS51cGRhdGUoIGFyZ3VtZW50c1swXSApLmRpZ2VzdCgpXG5cblx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIFhYSDY0KSlcblx0XHRyZXR1cm4gbmV3IFhYSDY0KCBhcmd1bWVudHNbMF0gKVxuXG5cdGluaXQuY2FsbCh0aGlzLCBhcmd1bWVudHNbMF0pXG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSB0aGUgWFhINjQgaW5zdGFuY2Ugd2l0aCB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBpbml0XG4gKiBAcGFyYW0ge051bWJlcnxPYmplY3R9IHNlZWQgYXMgYSBudW1iZXIgb3IgYW4gdW5zaWduZWQgMzIgYml0cyBpbnRlZ2VyXG4gKiBAcmV0dXJuIFRoaXNFeHByZXNzaW9uXG4gKi9cbiBmdW5jdGlvbiBpbml0IChzZWVkKSB7XG5cdHRoaXMuc2VlZCA9IHNlZWQgaW5zdGFuY2VvZiBVSU5UNjQgPyBzZWVkLmNsb25lKCkgOiBVSU5UNjQoc2VlZClcblx0dGhpcy52MSA9IHRoaXMuc2VlZC5jbG9uZSgpLmFkZChQUklNRTY0XzEpLmFkZChQUklNRTY0XzIpXG5cdHRoaXMudjIgPSB0aGlzLnNlZWQuY2xvbmUoKS5hZGQoUFJJTUU2NF8yKVxuXHR0aGlzLnYzID0gdGhpcy5zZWVkLmNsb25lKClcblx0dGhpcy52NCA9IHRoaXMuc2VlZC5jbG9uZSgpLnN1YnRyYWN0KFBSSU1FNjRfMSlcblx0dGhpcy50b3RhbF9sZW4gPSAwXG5cdHRoaXMubWVtc2l6ZSA9IDBcblx0dGhpcy5tZW1vcnkgPSBudWxsXG5cblx0cmV0dXJuIHRoaXNcbn1cblhYSDY0LnByb3RvdHlwZS5pbml0ID0gaW5pdFxuXG4vKipcbiAqIEFkZCBkYXRhIHRvIGJlIGNvbXB1dGVkIGZvciB0aGUgWFhINjQgaGFzaFxuICogQG1ldGhvZCB1cGRhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfEJ1ZmZlcnxBcnJheUJ1ZmZlcn0gaW5wdXQgYXMgYSBzdHJpbmcgb3Igbm9kZWpzIEJ1ZmZlciBvciBBcnJheUJ1ZmZlclxuICogQHJldHVybiBUaGlzRXhwcmVzc2lvblxuICovXG5YWEg2NC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgaXNBcnJheUJ1ZmZlclxuXG5cdC8vIENvbnZlcnQgYWxsIHN0cmluZ3MgdG8gdXRmLTggZmlyc3QgKGlzc3VlICM1KVxuXHRpZiAoaXNTdHJpbmcpIHtcblx0XHRpbnB1dCA9IHRvVVRGOEFycmF5KGlucHV0KVxuXHRcdGlzU3RyaW5nID0gZmFsc2Vcblx0XHRpc0FycmF5QnVmZmVyID0gdHJ1ZVxuXHR9XG5cblx0aWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuXHR7XG5cdFx0aXNBcnJheUJ1ZmZlciA9IHRydWVcblx0XHRpbnB1dCA9IG5ldyBVaW50OEFycmF5KGlucHV0KTtcblx0fVxuXG5cdHZhciBwID0gMFxuXHR2YXIgbGVuID0gaW5wdXQubGVuZ3RoXG5cdHZhciBiRW5kID0gcCArIGxlblxuXG5cdGlmIChsZW4gPT0gMCkgcmV0dXJuIHRoaXNcblxuXHR0aGlzLnRvdGFsX2xlbiArPSBsZW5cblxuXHRpZiAodGhpcy5tZW1zaXplID09IDApXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gJydcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkoMzIpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubWVtb3J5ID0gbmV3IEJ1ZmZlcigzMilcblx0XHR9XG5cdH1cblxuXHRpZiAodGhpcy5tZW1zaXplICsgbGVuIDwgMzIpICAgLy8gZmlsbCBpbiB0bXAgYnVmZmVyXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnkgKyB0aGlzLm1lbXNpemUsIGlucHV0LCBsZW4pXG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dFxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheSgwLCBsZW4pLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCBsZW4gKVxuXHRcdH1cblxuXHRcdHRoaXMubWVtc2l6ZSArPSBsZW5cblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0aWYgKHRoaXMubWVtc2l6ZSA+IDApICAgLy8gc29tZSBkYXRhIGxlZnQgZnJvbSBwcmV2aW91cyB1cGRhdGVcblx0e1xuXHRcdC8vIFhYSDY0X21lbWNweSh0aGlzLm1lbW9yeSArIHRoaXMubWVtc2l6ZSwgaW5wdXQsIDE2LXRoaXMubWVtc2l6ZSk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZSgwLCAzMiAtIHRoaXMubWVtc2l6ZSlcblx0XHR9IGVsc2UgaWYgKGlzQXJyYXlCdWZmZXIpIHtcblx0XHRcdHRoaXMubWVtb3J5LnNldCggaW5wdXQuc3ViYXJyYXkoMCwgMzIgLSB0aGlzLm1lbXNpemUpLCB0aGlzLm1lbXNpemUgKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpbnB1dC5jb3B5KCB0aGlzLm1lbW9yeSwgdGhpcy5tZW1zaXplLCAwLCAzMiAtIHRoaXMubWVtc2l6ZSApXG5cdFx0fVxuXG5cdFx0dmFyIHA2NCA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHZhciBvdGhlclxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzMpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMilcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzUpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNClcblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzcpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNilcblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsxKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrMykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCsyKVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNSkgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs0KVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQrNykgPDwgOCkgfCB0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs2KVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzEpIDw8IDgpIHwgdGhpcy5tZW1vcnkuY2hhckNvZGVBdChwNjQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCszKSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzIpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs1KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzQpXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeS5jaGFyQ29kZUF0KHA2NCs3KSA8PCA4KSB8IHRoaXMubWVtb3J5LmNoYXJDb2RlQXQocDY0KzYpXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG90aGVyXG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnYxLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRwNjQgKz0gOFxuXHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0KHRoaXMubWVtb3J5W3A2NCsxXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCszXSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCsyXVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzVdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrN10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNl1cblx0XHRcdFx0KVxuXHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0cDY0ICs9IDhcblx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdCh0aGlzLm1lbW9yeVtwNjQrMV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjRdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrM10gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrMl1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs1XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzddIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzZdXG5cdFx0XHRcdClcblx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdHA2NCArPSA4XG5cdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHQodGhpcy5tZW1vcnlbcDY0KzFdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0XVxuXHRcdFx0XHQsXHQodGhpcy5tZW1vcnlbcDY0KzNdIDw8IDgpIHwgdGhpcy5tZW1vcnlbcDY0KzJdXG5cdFx0XHRcdCxcdCh0aGlzLm1lbW9yeVtwNjQrNV0gPDwgOCkgfCB0aGlzLm1lbW9yeVtwNjQrNF1cblx0XHRcdFx0LFx0KHRoaXMubWVtb3J5W3A2NCs3XSA8PCA4KSB8IHRoaXMubWVtb3J5W3A2NCs2XVxuXHRcdFx0XHQpXG5cdFx0XHR0aGlzLnY0LmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0fVxuXG5cdFx0cCArPSAzMiAtIHRoaXMubWVtc2l6ZVxuXHRcdHRoaXMubWVtc2l6ZSA9IDBcblx0XHRpZiAoaXNTdHJpbmcpIHRoaXMubWVtb3J5ID0gJydcblx0fVxuXG5cdGlmIChwIDw9IGJFbmQgLSAzMilcblx0e1xuXHRcdHZhciBsaW1pdCA9IGJFbmQgLSAzMlxuXG5cdFx0ZG9cblx0XHR7XG5cdFx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdFx0dmFyIG90aGVyXG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjIuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjMuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0LmNoYXJDb2RlQXQocCsxKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocClcblx0XHRcdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCs1KSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCs0KVxuXHRcdFx0XHRcdCxcdChpbnB1dC5jaGFyQ29kZUF0KHArNykgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHArNilcblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvdGhlclxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjEuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdFx0cCArPSA4XG5cdFx0XHRcdG90aGVyID0gVUlOVDY0KFxuXHRcdFx0XHRcdFx0KGlucHV0W3ArMV0gPDwgOCkgfCBpbnB1dFtwXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzVdIDw8IDgpIHwgaW5wdXRbcCs0XVxuXHRcdFx0XHRcdCxcdChpbnB1dFtwKzddIDw8IDgpIHwgaW5wdXRbcCs2XVxuXHRcdFx0XHRcdClcblx0XHRcdFx0dGhpcy52Mi5hZGQoIG90aGVyLm11bHRpcGx5KFBSSU1FNjRfMikgKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpO1xuXHRcdFx0XHRwICs9IDhcblx0XHRcdFx0b3RoZXIgPSBVSU5UNjQoXG5cdFx0XHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArM10gPDwgOCkgfCBpbnB1dFtwKzJdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHRcdFx0LFx0KGlucHV0W3ArN10gPDwgOCkgfCBpbnB1dFtwKzZdXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHR0aGlzLnYzLmFkZCggb3RoZXIubXVsdGlwbHkoUFJJTUU2NF8yKSApLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSk7XG5cdFx0XHRcdHAgKz0gOFxuXHRcdFx0XHRvdGhlciA9IFVJTlQ2NChcblx0XHRcdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs1XSA8PCA4KSB8IGlucHV0W3ArNF1cblx0XHRcdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdFx0XHQpXG5cdFx0XHRcdHRoaXMudjQuYWRkKCBvdGhlci5tdWx0aXBseShQUklNRTY0XzIpICkucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKTtcblx0XHRcdH1cblx0XHRcdHAgKz0gOFxuXHRcdH0gd2hpbGUgKHAgPD0gbGltaXQpXG5cdH1cblxuXHRpZiAocCA8IGJFbmQpXG5cdHtcblx0XHQvLyBYWEg2NF9tZW1jcHkodGhpcy5tZW1vcnksIHAsIGJFbmQtcCk7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR0aGlzLm1lbW9yeSArPSBpbnB1dC5zbGljZShwKVxuXHRcdH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcikge1xuXHRcdFx0dGhpcy5tZW1vcnkuc2V0KCBpbnB1dC5zdWJhcnJheShwLCBiRW5kKSwgdGhpcy5tZW1zaXplIClcblx0XHR9IGVsc2Uge1xuXHRcdFx0aW5wdXQuY29weSggdGhpcy5tZW1vcnksIHRoaXMubWVtc2l6ZSwgcCwgYkVuZCApXG5cdFx0fVxuXG5cdFx0dGhpcy5tZW1zaXplID0gYkVuZCAtIHBcblx0fVxuXG5cdHJldHVybiB0aGlzXG59XG5cbi8qKlxuICogRmluYWxpemUgdGhlIFhYSDY0IGNvbXB1dGF0aW9uLiBUaGUgWFhINjQgaW5zdGFuY2UgaXMgcmVhZHkgZm9yIHJldXNlIGZvciB0aGUgZ2l2ZW4gc2VlZFxuICogQG1ldGhvZCBkaWdlc3RcbiAqIEByZXR1cm4ge1VJTlQ2NH0geHhIYXNoXG4gKi9cblhYSDY0LnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBpbnB1dCA9IHRoaXMubWVtb3J5XG5cdHZhciBpc1N0cmluZyA9IHR5cGVvZiBpbnB1dCA9PSAnc3RyaW5nJ1xuXHR2YXIgcCA9IDBcblx0dmFyIGJFbmQgPSB0aGlzLm1lbXNpemVcblx0dmFyIGg2NCwgaFxuXHR2YXIgdSA9IG5ldyBVSU5UNjRcblxuXHRpZiAodGhpcy50b3RhbF9sZW4gPj0gMzIpXG5cdHtcblx0XHRoNjQgPSB0aGlzLnYxLmNsb25lKCkucm90bCgxKVxuXHRcdGg2NC5hZGQoIHRoaXMudjIuY2xvbmUoKS5yb3RsKDcpIClcblx0XHRoNjQuYWRkKCB0aGlzLnYzLmNsb25lKCkucm90bCgxMikgKVxuXHRcdGg2NC5hZGQoIHRoaXMudjQuY2xvbmUoKS5yb3RsKDE4KSApXG5cblx0XHRoNjQueG9yKCB0aGlzLnYxLm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblxuXHRcdGg2NC54b3IoIHRoaXMudjIubXVsdGlwbHkoUFJJTUU2NF8yKS5yb3RsKDMxKS5tdWx0aXBseShQUklNRTY0XzEpIClcblx0XHRoNjQubXVsdGlwbHkoUFJJTUU2NF8xKS5hZGQoUFJJTUU2NF80KVxuXG5cdFx0aDY0LnhvciggdGhpcy52My5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdGg2NC5tdWx0aXBseShQUklNRTY0XzEpLmFkZChQUklNRTY0XzQpXG5cblx0XHRoNjQueG9yKCB0aGlzLnY0Lm11bHRpcGx5KFBSSU1FNjRfMikucm90bCgzMSkubXVsdGlwbHkoUFJJTUU2NF8xKSApXG5cdFx0aDY0Lm11bHRpcGx5KFBSSU1FNjRfMSkuYWRkKFBSSU1FNjRfNClcblx0fVxuXHRlbHNlXG5cdHtcblx0XHRoNjQgID0gdGhpcy5zZWVkLmNsb25lKCkuYWRkKCBQUklNRTY0XzUgKVxuXHR9XG5cblx0aDY0LmFkZCggdS5mcm9tTnVtYmVyKHRoaXMudG90YWxfbGVuKSApXG5cblx0d2hpbGUgKHAgPD0gYkVuZCAtIDgpXG5cdHtcblx0XHRpZiAoaXNTdHJpbmcpIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dC5jaGFyQ29kZUF0KHArMSkgPDwgOCkgfCBpbnB1dC5jaGFyQ29kZUF0KHApXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzMpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzIpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzUpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzQpXG5cdFx0XHQsXHQoaW5wdXQuY2hhckNvZGVBdChwKzcpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKzYpXG5cdFx0XHQpXG5cdFx0fSBlbHNlIHtcblx0XHRcdHUuZnJvbUJpdHMoXG5cdFx0XHRcdChpbnB1dFtwKzFdIDw8IDgpIHwgaW5wdXRbcF1cblx0XHRcdCxcdChpbnB1dFtwKzNdIDw8IDgpIHwgaW5wdXRbcCsyXVxuXHRcdFx0LFx0KGlucHV0W3ArNV0gPDwgOCkgfCBpbnB1dFtwKzRdXG5cdFx0XHQsXHQoaW5wdXRbcCs3XSA8PCA4KSB8IGlucHV0W3ArNl1cblx0XHRcdClcblx0XHR9XG5cdFx0dS5tdWx0aXBseShQUklNRTY0XzIpLnJvdGwoMzEpLm11bHRpcGx5KFBSSU1FNjRfMSlcblx0XHRoNjRcblx0XHRcdC54b3IodSlcblx0XHRcdC5yb3RsKDI3KVxuXHRcdFx0Lm11bHRpcGx5KCBQUklNRTY0XzEgKVxuXHRcdFx0LmFkZCggUFJJTUU2NF80IClcblx0XHRwICs9IDhcblx0fVxuXG5cdGlmIChwICsgNCA8PSBiRW5kKSB7XG5cdFx0aWYgKGlzU3RyaW5nKSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXQuY2hhckNvZGVBdChwKzEpIDw8IDgpIHwgaW5wdXQuY2hhckNvZGVBdChwKVxuXHRcdFx0LFx0KGlucHV0LmNoYXJDb2RlQXQocCszKSA8PCA4KSB8IGlucHV0LmNoYXJDb2RlQXQocCsyKVxuXHRcdFx0LFx0MFxuXHRcdFx0LFx0MFxuXHRcdFx0KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR1LmZyb21CaXRzKFxuXHRcdFx0XHQoaW5wdXRbcCsxXSA8PCA4KSB8IGlucHV0W3BdXG5cdFx0XHQsXHQoaW5wdXRbcCszXSA8PCA4KSB8IGlucHV0W3ArMl1cblx0XHRcdCxcdDBcblx0XHRcdCxcdDBcblx0XHRcdClcblx0XHR9XG5cdFx0aDY0XG5cdFx0XHQueG9yKCB1Lm11bHRpcGx5KFBSSU1FNjRfMSkgKVxuXHRcdFx0LnJvdGwoMjMpXG5cdFx0XHQubXVsdGlwbHkoIFBSSU1FNjRfMiApXG5cdFx0XHQuYWRkKCBQUklNRTY0XzMgKVxuXHRcdHAgKz0gNFxuXHR9XG5cblx0d2hpbGUgKHAgPCBiRW5kKVxuXHR7XG5cdFx0dS5mcm9tQml0cyggaXNTdHJpbmcgPyBpbnB1dC5jaGFyQ29kZUF0KHArKykgOiBpbnB1dFtwKytdLCAwLCAwLCAwIClcblx0XHRoNjRcblx0XHRcdC54b3IoIHUubXVsdGlwbHkoUFJJTUU2NF81KSApXG5cdFx0XHQucm90bCgxMSlcblx0XHRcdC5tdWx0aXBseShQUklNRTY0XzEpXG5cdH1cblxuXHRoID0gaDY0LmNsb25lKCkuc2hpZnRSaWdodCgzMylcblx0aDY0LnhvcihoKS5tdWx0aXBseShQUklNRTY0XzIpXG5cblx0aCA9IGg2NC5jbG9uZSgpLnNoaWZ0UmlnaHQoMjkpXG5cdGg2NC54b3IoaCkubXVsdGlwbHkoUFJJTUU2NF8zKVxuXG5cdGggPSBoNjQuY2xvbmUoKS5zaGlmdFJpZ2h0KDMyKVxuXHRoNjQueG9yKGgpXG5cblx0Ly8gUmVzZXQgdGhlIHN0YXRlXG5cdHRoaXMuaW5pdCggdGhpcy5zZWVkIClcblxuXHRyZXR1cm4gaDY0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gWFhINjRcbiIsICJtb2R1bGUuZXhwb3J0cyA9IHtcblx0aDMyOiByZXF1aXJlKFwiLi94eGhhc2hcIilcbixcdGg2NDogcmVxdWlyZShcIi4veHhoYXNoNjRcIilcbn1cbiIsICIoZnVuY3Rpb24oZSl7aWYoXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGUpbW9kdWxlLmV4cG9ydHM9ZSgpO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kKWRlZmluZShbXSxlKTtlbHNle3ZhciB0O3Q9XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9cInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP3RoaXM6c2VsZjpnbG9iYWw6d2luZG93LHQuU2ltcGxlUGVlcj1lKCl9fSkoZnVuY3Rpb24oKXt2YXIgdD1NYXRoLmZsb29yLG49TWF0aC5hYnMscj1NYXRoLnBvdztyZXR1cm4gZnVuY3Rpb24oKXtmdW5jdGlvbiBkKHMsZSxuKXtmdW5jdGlvbiB0KG8saSl7aWYoIWVbb10pe2lmKCFzW29dKXt2YXIgbD1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlO2lmKCFpJiZsKXJldHVybiBsKG8sITApO2lmKHIpcmV0dXJuIHIobywhMCk7dmFyIGM9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBjLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsY312YXIgYT1lW29dPXtleHBvcnRzOnt9fTtzW29dWzBdLmNhbGwoYS5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciByPXNbb11bMV1bZV07cmV0dXJuIHQocnx8ZSl9LGEsYS5leHBvcnRzLGQscyxlLG4pfXJldHVybiBlW29dLmV4cG9ydHN9Zm9yKHZhciByPVwiZnVuY3Rpb25cIj09dHlwZW9mIHJlcXVpcmUmJnJlcXVpcmUsYT0wO2E8bi5sZW5ndGg7YSsrKXQoblthXSk7cmV0dXJuIHR9cmV0dXJuIGR9KCkoezE6W2Z1bmN0aW9uKGUsdCxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXt2YXIgdD1lLmxlbmd0aDtpZigwPHQlNCl0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0XCIpO3ZhciBuPWUuaW5kZXhPZihcIj1cIik7LTE9PT1uJiYobj10KTt2YXIgcj1uPT09dD8wOjQtbiU0O3JldHVybltuLHJdfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiAzKih0K24pLzQtbn1mdW5jdGlvbiBvKGUpe3ZhciB0LG4sbz1yKGUpLGQ9b1swXSxzPW9bMV0sbD1uZXcgcChhKGUsZCxzKSksYz0wLGY9MDxzP2QtNDpkO2ZvcihuPTA7bjxmO24rPTQpdD11W2UuY2hhckNvZGVBdChuKV08PDE4fHVbZS5jaGFyQ29kZUF0KG4rMSldPDwxMnx1W2UuY2hhckNvZGVBdChuKzIpXTw8Nnx1W2UuY2hhckNvZGVBdChuKzMpXSxsW2MrK109MjU1JnQ+PjE2LGxbYysrXT0yNTUmdD4+OCxsW2MrK109MjU1JnQ7cmV0dXJuIDI9PT1zJiYodD11W2UuY2hhckNvZGVBdChuKV08PDJ8dVtlLmNoYXJDb2RlQXQobisxKV0+PjQsbFtjKytdPTI1NSZ0KSwxPT09cyYmKHQ9dVtlLmNoYXJDb2RlQXQobildPDwxMHx1W2UuY2hhckNvZGVBdChuKzEpXTw8NHx1W2UuY2hhckNvZGVBdChuKzIpXT4+MixsW2MrK109MjU1JnQ+PjgsbFtjKytdPTI1NSZ0KSxsfWZ1bmN0aW9uIGQoZSl7cmV0dXJuIGNbNjMmZT4+MThdK2NbNjMmZT4+MTJdK2NbNjMmZT4+Nl0rY1s2MyZlXX1mdW5jdGlvbiBzKGUsdCxuKXtmb3IodmFyIHIsYT1bXSxvPXQ7bzxuO28rPTMpcj0oMTY3MTE2ODAmZVtvXTw8MTYpKyg2NTI4MCZlW28rMV08PDgpKygyNTUmZVtvKzJdKSxhLnB1c2goZChyKSk7cmV0dXJuIGEuam9pbihcIlwiKX1mdW5jdGlvbiBsKGUpe2Zvcih2YXIgdCxuPWUubGVuZ3RoLHI9biUzLGE9W10sbz0xNjM4MyxkPTAsbD1uLXI7ZDxsO2QrPW8pYS5wdXNoKHMoZSxkLGQrbz5sP2w6ZCtvKSk7cmV0dXJuIDE9PT1yPyh0PWVbbi0xXSxhLnB1c2goY1t0Pj4yXStjWzYzJnQ8PDRdK1wiPT1cIikpOjI9PT1yJiYodD0oZVtuLTJdPDw4KStlW24tMV0sYS5wdXNoKGNbdD4+MTBdK2NbNjMmdD4+NF0rY1s2MyZ0PDwyXStcIj1cIikpLGEuam9pbihcIlwiKX1uLmJ5dGVMZW5ndGg9ZnVuY3Rpb24oZSl7dmFyIHQ9cihlKSxuPXRbMF0sYT10WzFdO3JldHVybiAzKihuK2EpLzQtYX0sbi50b0J5dGVBcnJheT1vLG4uZnJvbUJ5dGVBcnJheT1sO2Zvcih2YXIgYz1bXSx1PVtdLHA9XCJ1bmRlZmluZWRcIj09dHlwZW9mIFVpbnQ4QXJyYXk/QXJyYXk6VWludDhBcnJheSxmPVwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLGc9MCxfPWYubGVuZ3RoO2c8XzsrK2cpY1tnXT1mW2ddLHVbZi5jaGFyQ29kZUF0KGcpXT1nO3VbNDVdPTYyLHVbOTVdPTYzfSx7fV0sMjpbZnVuY3Rpb24oKXt9LHt9XSwzOltmdW5jdGlvbihlLHQsbil7KGZ1bmN0aW9uKCl7KGZ1bmN0aW9uKCl7LyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovJ3VzZSBzdHJpY3QnO3ZhciB0PVN0cmluZy5mcm9tQ2hhckNvZGUsbz1NYXRoLm1pbjtmdW5jdGlvbiBkKGUpe2lmKDIxNDc0ODM2NDc8ZSl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIrZStcIlxcXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFxcXCJzaXplXFxcIlwiKTt2YXIgdD1uZXcgVWludDhBcnJheShlKTtyZXR1cm4gdC5fX3Byb3RvX189cy5wcm90b3R5cGUsdH1mdW5jdGlvbiBzKGUsdCxuKXtpZihcIm51bWJlclwiPT10eXBlb2YgZSl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwic3RyaW5nXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlclwiKTtyZXR1cm4gcChlKX1yZXR1cm4gbChlLHQsbil9ZnVuY3Rpb24gbChlLHQsbil7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpcmV0dXJuIGYoZSx0KTtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSkpcmV0dXJuIGcoZSk7aWYobnVsbD09ZSl0aHJvdyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSk7aWYoSyhlLEFycmF5QnVmZmVyKXx8ZSYmSyhlLmJ1ZmZlcixBcnJheUJ1ZmZlcikpcmV0dXJuIF8oZSx0LG4pO2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcInZhbHVlXFxcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXJcIik7dmFyIHI9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihudWxsIT1yJiZyIT09ZSlyZXR1cm4gcy5mcm9tKHIsdCxuKTt2YXIgYT1oKGUpO2lmKGEpcmV0dXJuIGE7aWYoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmbnVsbCE9U3ltYm9sLnRvUHJpbWl0aXZlJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBlW1N5bWJvbC50b1ByaW1pdGl2ZV0pcmV0dXJuIHMuZnJvbShlW1N5bWJvbC50b1ByaW1pdGl2ZV0oXCJzdHJpbmdcIiksdCxuKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWZ1bmN0aW9uIGMoZSl7aWYoXCJudW1iZXJcIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlxcXCJzaXplXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyXCIpO2Vsc2UgaWYoMD5lKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIFxcXCJcIitlK1wiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcInNpemVcXFwiXCIpfWZ1bmN0aW9uIHUoZSx0LG4pe3JldHVybiBjKGUpLDA+PWU/ZChlKTp2b2lkIDA9PT10P2QoZSk6XCJzdHJpbmdcIj09dHlwZW9mIG4/ZChlKS5maWxsKHQsbik6ZChlKS5maWxsKHQpfWZ1bmN0aW9uIHAoZSl7cmV0dXJuIGMoZSksZCgwPmU/MDowfG0oZSkpfWZ1bmN0aW9uIGYoZSx0KXtpZigoXCJzdHJpbmdcIiE9dHlwZW9mIHR8fFwiXCI9PT10KSYmKHQ9XCJ1dGY4XCIpLCFzLmlzRW5jb2RpbmcodCkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlVua25vd24gZW5jb2Rpbmc6IFwiK3QpO3ZhciBuPTB8YihlLHQpLHI9ZChuKSxhPXIud3JpdGUoZSx0KTtyZXR1cm4gYSE9PW4mJihyPXIuc2xpY2UoMCxhKSkscn1mdW5jdGlvbiBnKGUpe2Zvcih2YXIgdD0wPmUubGVuZ3RoPzA6MHxtKGUubGVuZ3RoKSxuPWQodCkscj0wO3I8dDtyKz0xKW5bcl09MjU1JmVbcl07cmV0dXJuIG59ZnVuY3Rpb24gXyhlLHQsbil7aWYoMD50fHxlLmJ5dGVMZW5ndGg8dCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlxcXCJvZmZzZXRcXFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc1wiKTtpZihlLmJ5dGVMZW5ndGg8dCsobnx8MCkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJcXFwibGVuZ3RoXFxcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNcIik7dmFyIHI7cmV0dXJuIHI9dm9pZCAwPT09dCYmdm9pZCAwPT09bj9uZXcgVWludDhBcnJheShlKTp2b2lkIDA9PT1uP25ldyBVaW50OEFycmF5KGUsdCk6bmV3IFVpbnQ4QXJyYXkoZSx0LG4pLHIuX19wcm90b19fPXMucHJvdG90eXBlLHJ9ZnVuY3Rpb24gaChlKXtpZihzLmlzQnVmZmVyKGUpKXt2YXIgdD0wfG0oZS5sZW5ndGgpLG49ZCh0KTtyZXR1cm4gMD09PW4ubGVuZ3RoP246KGUuY29weShuLDAsMCx0KSxuKX1yZXR1cm4gdm9pZCAwPT09ZS5sZW5ndGg/XCJCdWZmZXJcIj09PWUudHlwZSYmQXJyYXkuaXNBcnJheShlLmRhdGEpP2coZS5kYXRhKTp2b2lkIDA6XCJudW1iZXJcIiE9dHlwZW9mIGUubGVuZ3RofHxYKGUubGVuZ3RoKT9kKDApOmcoZSl9ZnVuY3Rpb24gbShlKXtpZihlPj0yMTQ3NDgzNjQ3KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSBzaXplOiAweFwiKzIxNDc0ODM2NDcgLnRvU3RyaW5nKDE2KStcIiBieXRlc1wiKTtyZXR1cm4gMHxlfWZ1bmN0aW9uIGIoZSx0KXtpZihzLmlzQnVmZmVyKGUpKXJldHVybiBlLmxlbmd0aDtpZihBcnJheUJ1ZmZlci5pc1ZpZXcoZSl8fEsoZSxBcnJheUJ1ZmZlcikpcmV0dXJuIGUuYnl0ZUxlbmd0aDtpZihcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJzdHJpbmdcXFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKTt2YXIgbj1lLmxlbmd0aCxyPTI8YXJndW1lbnRzLmxlbmd0aCYmITA9PT1hcmd1bWVudHNbMl07aWYoIXImJjA9PT1uKXJldHVybiAwO2Zvcih2YXIgYT0hMTs7KXN3aXRjaCh0KXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBuO2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiBIKGUpLmxlbmd0aDtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gMipuO2Nhc2VcImhleFwiOnJldHVybiBuPj4+MTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4geihlKS5sZW5ndGg7ZGVmYXVsdDppZihhKXJldHVybiByPy0xOkgoZSkubGVuZ3RoO3Q9KFwiXCIrdCkudG9Mb3dlckNhc2UoKSxhPSEwO319ZnVuY3Rpb24geShlLHQsbil7dmFyIHI9ITE7aWYoKHZvaWQgMD09PXR8fDA+dCkmJih0PTApLHQ+dGhpcy5sZW5ndGgpcmV0dXJuXCJcIjtpZigodm9pZCAwPT09bnx8bj50aGlzLmxlbmd0aCkmJihuPXRoaXMubGVuZ3RoKSwwPj1uKXJldHVyblwiXCI7aWYobj4+Pj0wLHQ+Pj49MCxuPD10KXJldHVyblwiXCI7Zm9yKGV8fChlPVwidXRmOFwiKTs7KXN3aXRjaChlKXtjYXNlXCJoZXhcIjpyZXR1cm4gUCh0aGlzLHQsbik7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHgodGhpcyx0LG4pO2Nhc2VcImFzY2lpXCI6cmV0dXJuIEQodGhpcyx0LG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiBJKHRoaXMsdCxuKTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gQSh0aGlzLHQsbik7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIE0odGhpcyx0LG4pO2RlZmF1bHQ6aWYocil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpLHI9ITA7fX1mdW5jdGlvbiBDKGUsdCxuKXt2YXIgcj1lW3RdO2VbdF09ZVtuXSxlW25dPXJ9ZnVuY3Rpb24gUihlLHQsbixyLGEpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4tMTtpZihcInN0cmluZ1wiPT10eXBlb2Ygbj8ocj1uLG49MCk6MjE0NzQ4MzY0NzxuP249MjE0NzQ4MzY0NzotMjE0NzQ4MzY0OD5uJiYobj0tMjE0NzQ4MzY0OCksbj0rbixYKG4pJiYobj1hPzA6ZS5sZW5ndGgtMSksMD5uJiYobj1lLmxlbmd0aCtuKSxuPj1lLmxlbmd0aCl7aWYoYSlyZXR1cm4tMTtuPWUubGVuZ3RoLTF9ZWxzZSBpZigwPm4paWYoYSluPTA7ZWxzZSByZXR1cm4tMTtpZihcInN0cmluZ1wiPT10eXBlb2YgdCYmKHQ9cy5mcm9tKHQscikpLHMuaXNCdWZmZXIodCkpcmV0dXJuIDA9PT10Lmxlbmd0aD8tMTpFKGUsdCxuLHIsYSk7aWYoXCJudW1iZXJcIj09dHlwZW9mIHQpcmV0dXJuIHQmPTI1NSxcImZ1bmN0aW9uXCI9PXR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mP2E/VWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGUsdCxuKTpVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGUsdCxuKTpFKGUsW3RdLG4scixhKTt0aHJvdyBuZXcgVHlwZUVycm9yKFwidmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyXCIpfWZ1bmN0aW9uIEUoZSx0LG4scixhKXtmdW5jdGlvbiBvKGUsdCl7cmV0dXJuIDE9PT1kP2VbdF06ZS5yZWFkVUludDE2QkUodCpkKX12YXIgZD0xLHM9ZS5sZW5ndGgsbD10Lmxlbmd0aDtpZih2b2lkIDAhPT1yJiYocj0ocitcIlwiKS50b0xvd2VyQ2FzZSgpLFwidWNzMlwiPT09cnx8XCJ1Y3MtMlwiPT09cnx8XCJ1dGYxNmxlXCI9PT1yfHxcInV0Zi0xNmxlXCI9PT1yKSl7aWYoMj5lLmxlbmd0aHx8Mj50Lmxlbmd0aClyZXR1cm4tMTtkPTIscy89MixsLz0yLG4vPTJ9dmFyIGM7aWYoYSl7dmFyIHU9LTE7Zm9yKGM9bjtjPHM7YysrKWlmKG8oZSxjKSE9PW8odCwtMT09PXU/MDpjLXUpKS0xIT09dSYmKGMtPWMtdSksdT0tMTtlbHNlIGlmKC0xPT09dSYmKHU9YyksYy11KzE9PT1sKXJldHVybiB1KmR9ZWxzZSBmb3IobitsPnMmJihuPXMtbCksYz1uOzA8PWM7Yy0tKXtmb3IodmFyIHA9ITAsZj0wO2Y8bDtmKyspaWYobyhlLGMrZikhPT1vKHQsZikpe3A9ITE7YnJlYWt9aWYocClyZXR1cm4gY31yZXR1cm4tMX1mdW5jdGlvbiB3KGUsdCxuLHIpe249K258fDA7dmFyIGE9ZS5sZW5ndGgtbjtyPyhyPStyLHI+YSYmKHI9YSkpOnI9YTt2YXIgbz10Lmxlbmd0aDtyPm8vMiYmKHI9by8yKTtmb3IodmFyIGQscz0wO3M8cjsrK3Mpe2lmKGQ9cGFyc2VJbnQodC5zdWJzdHIoMipzLDIpLDE2KSxYKGQpKXJldHVybiBzO2VbbitzXT1kfXJldHVybiBzfWZ1bmN0aW9uIFMoZSx0LG4scil7cmV0dXJuIEcoSCh0LGUubGVuZ3RoLW4pLGUsbixyKX1mdW5jdGlvbiBUKGUsdCxuLHIpe3JldHVybiBHKFkodCksZSxuLHIpfWZ1bmN0aW9uIHYoZSx0LG4scil7cmV0dXJuIFQoZSx0LG4scil9ZnVuY3Rpb24gayhlLHQsbixyKXtyZXR1cm4gRyh6KHQpLGUsbixyKX1mdW5jdGlvbiBMKGUsdCxuLHIpe3JldHVybiBHKFYodCxlLmxlbmd0aC1uKSxlLG4scil9ZnVuY3Rpb24gQShlLHQsbil7cmV0dXJuIDA9PT10JiZuPT09ZS5sZW5ndGg/JC5mcm9tQnl0ZUFycmF5KGUpOiQuZnJvbUJ5dGVBcnJheShlLnNsaWNlKHQsbikpfWZ1bmN0aW9uIHgoZSx0LG4pe249byhlLmxlbmd0aCxuKTtmb3IodmFyIHI9W10sYT10O2E8bjspe3ZhciBkPWVbYV0scz1udWxsLGw9MjM5PGQ/NDoyMjM8ZD8zOjE5MTxkPzI6MTtpZihhK2w8PW4pe3ZhciBjLHUscCxmOzE9PT1sPzEyOD5kJiYocz1kKToyPT09bD8oYz1lW2ErMV0sMTI4PT0oMTkyJmMpJiYoZj0oMzEmZCk8PDZ8NjMmYywxMjc8ZiYmKHM9ZikpKTozPT09bD8oYz1lW2ErMV0sdT1lW2ErMl0sMTI4PT0oMTkyJmMpJiYxMjg9PSgxOTImdSkmJihmPSgxNSZkKTw8MTJ8KDYzJmMpPDw2fDYzJnUsMjA0NzxmJiYoNTUyOTY+Znx8NTczNDM8ZikmJihzPWYpKSk6ND09PWw/KGM9ZVthKzFdLHU9ZVthKzJdLHA9ZVthKzNdLDEyOD09KDE5MiZjKSYmMTI4PT0oMTkyJnUpJiYxMjg9PSgxOTImcCkmJihmPSgxNSZkKTw8MTh8KDYzJmMpPDwxMnwoNjMmdSk8PDZ8NjMmcCw2NTUzNTxmJiYxMTE0MTEyPmYmJihzPWYpKSk6dm9pZCAwfW51bGw9PT1zPyhzPTY1NTMzLGw9MSk6NjU1MzU8cyYmKHMtPTY1NTM2LHIucHVzaCg1NTI5NnwxMDIzJnM+Pj4xMCkscz01NjMyMHwxMDIzJnMpLHIucHVzaChzKSxhKz1sfXJldHVybiBOKHIpfWZ1bmN0aW9uIE4oZSl7dmFyIG49ZS5sZW5ndGg7aWYobjw9NDA5NilyZXR1cm4gdC5hcHBseShTdHJpbmcsZSk7Zm9yKHZhciByPVwiXCIsYT0wO2E8bjspcis9dC5hcHBseShTdHJpbmcsZS5zbGljZShhLGErPTQwOTYpKTtyZXR1cm4gcn1mdW5jdGlvbiBEKGUsbixyKXt2YXIgYT1cIlwiO3I9byhlLmxlbmd0aCxyKTtmb3IodmFyIGQ9bjtkPHI7KytkKWErPXQoMTI3JmVbZF0pO3JldHVybiBhfWZ1bmN0aW9uIEkoZSxuLHIpe3ZhciBhPVwiXCI7cj1vKGUubGVuZ3RoLHIpO2Zvcih2YXIgZD1uO2Q8cjsrK2QpYSs9dChlW2RdKTtyZXR1cm4gYX1mdW5jdGlvbiBQKGUsdCxuKXt2YXIgcj1lLmxlbmd0aDsoIXR8fDA+dCkmJih0PTApLCghbnx8MD5ufHxuPnIpJiYobj1yKTtmb3IodmFyIGE9XCJcIixvPXQ7bzxuOysrbylhKz1XKGVbb10pO3JldHVybiBhfWZ1bmN0aW9uIE0oZSxuLHIpe2Zvcih2YXIgYT1lLnNsaWNlKG4sciksbz1cIlwiLGQ9MDtkPGEubGVuZ3RoO2QrPTIpbys9dChhW2RdKzI1NiphW2QrMV0pO3JldHVybiBvfWZ1bmN0aW9uIE8oZSx0LG4pe2lmKDAhPWUlMXx8MD5lKXRocm93IG5ldyBSYW5nZUVycm9yKFwib2Zmc2V0IGlzIG5vdCB1aW50XCIpO2lmKGUrdD5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aFwiKX1mdW5jdGlvbiBGKGUsdCxuLHIsYSxvKXtpZighcy5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiXFxcImJ1ZmZlclxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZVwiKTtpZih0PmF8fHQ8byl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIlxcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kc1wiKTtpZihuK3I+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIil9ZnVuY3Rpb24gQihlLHQsbixyKXtpZihuK3I+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoMD5uKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIFUoZSx0LG4scixhKXtyZXR1cm4gdD0rdCxuPj4+PTAsYXx8QihlLHQsbiw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMiksSi53cml0ZShlLHQsbixyLDIzLDQpLG4rNH1mdW5jdGlvbiBqKGUsdCxuLHIsYSl7cmV0dXJuIHQ9K3Qsbj4+Pj0wLGF8fEIoZSx0LG4sOCwxNzk3NjkzMTM0ODYyMzE1N2UyOTIsLTE3OTc2OTMxMzQ4NjIzMTU3ZTI5MiksSi53cml0ZShlLHQsbixyLDUyLDgpLG4rOH1mdW5jdGlvbiBxKGUpe2lmKGU9ZS5zcGxpdChcIj1cIilbMF0sZT1lLnRyaW0oKS5yZXBsYWNlKFEsXCJcIiksMj5lLmxlbmd0aClyZXR1cm5cIlwiO2Zvcig7MCE9ZS5sZW5ndGglNDspZSs9XCI9XCI7cmV0dXJuIGV9ZnVuY3Rpb24gVyhlKXtyZXR1cm4gMTY+ZT9cIjBcIitlLnRvU3RyaW5nKDE2KTplLnRvU3RyaW5nKDE2KX1mdW5jdGlvbiBIKGUsdCl7dD10fHwxLzA7Zm9yKHZhciBuLHI9ZS5sZW5ndGgsYT1udWxsLG89W10sZD0wO2Q8cjsrK2Qpe2lmKG49ZS5jaGFyQ29kZUF0KGQpLDU1Mjk1PG4mJjU3MzQ0Pm4pe2lmKCFhKXtpZig1NjMxOTxuKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9ZWxzZSBpZihkKzE9PT1yKXstMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9YT1uO2NvbnRpbnVlfWlmKDU2MzIwPm4pey0xPCh0LT0zKSYmby5wdXNoKDIzOSwxOTEsMTg5KSxhPW47Y29udGludWV9bj0oYS01NTI5Njw8MTB8bi01NjMyMCkrNjU1MzZ9ZWxzZSBhJiYtMTwodC09MykmJm8ucHVzaCgyMzksMTkxLDE4OSk7aWYoYT1udWxsLDEyOD5uKXtpZigwPih0LT0xKSlicmVhaztvLnB1c2gobil9ZWxzZSBpZigyMDQ4Pm4pe2lmKDA+KHQtPTIpKWJyZWFrO28ucHVzaCgxOTJ8bj4+NiwxMjh8NjMmbil9ZWxzZSBpZig2NTUzNj5uKXtpZigwPih0LT0zKSlicmVhaztvLnB1c2goMjI0fG4+PjEyLDEyOHw2MyZuPj42LDEyOHw2MyZuKX1lbHNlIGlmKDExMTQxMTI+bil7aWYoMD4odC09NCkpYnJlYWs7by5wdXNoKDI0MHxuPj4xOCwxMjh8NjMmbj4+MTIsMTI4fDYzJm4+PjYsMTI4fDYzJm4pfWVsc2UgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjb2RlIHBvaW50XCIpfXJldHVybiBvfWZ1bmN0aW9uIFkoZSl7Zm9yKHZhciB0PVtdLG49MDtuPGUubGVuZ3RoOysrbil0LnB1c2goMjU1JmUuY2hhckNvZGVBdChuKSk7cmV0dXJuIHR9ZnVuY3Rpb24gVihlLHQpe2Zvcih2YXIgbixyLGEsbz1bXSxkPTA7ZDxlLmxlbmd0aCYmISgwPih0LT0yKSk7KytkKW49ZS5jaGFyQ29kZUF0KGQpLHI9bj4+OCxhPW4lMjU2LG8ucHVzaChhKSxvLnB1c2gocik7cmV0dXJuIG99ZnVuY3Rpb24geihlKXtyZXR1cm4gJC50b0J5dGVBcnJheShxKGUpKX1mdW5jdGlvbiBHKGUsdCxuLHIpe2Zvcih2YXIgYT0wO2E8ciYmIShhK24+PXQubGVuZ3RofHxhPj1lLmxlbmd0aCk7KythKXRbYStuXT1lW2FdO3JldHVybiBhfWZ1bmN0aW9uIEsoZSx0KXtyZXR1cm4gZSBpbnN0YW5jZW9mIHR8fG51bGwhPWUmJm51bGwhPWUuY29uc3RydWN0b3ImJm51bGwhPWUuY29uc3RydWN0b3IubmFtZSYmZS5jb25zdHJ1Y3Rvci5uYW1lPT09dC5uYW1lfWZ1bmN0aW9uIFgoZSl7cmV0dXJuIGUhPT1lfXZhciAkPWUoXCJiYXNlNjQtanNcIiksSj1lKFwiaWVlZTc1NFwiKTtuLkJ1ZmZlcj1zLG4uU2xvd0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4rZSE9ZSYmKGU9MCkscy5hbGxvYygrZSl9LG4uSU5TUEVDVF9NQVhfQllURVM9NTA7bi5rTWF4TGVuZ3RoPTIxNDc0ODM2NDcscy5UWVBFRF9BUlJBWV9TVVBQT1JUPWZ1bmN0aW9uKCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3JldHVybiBlLl9fcHJvdG9fXz17X19wcm90b19fOlVpbnQ4QXJyYXkucHJvdG90eXBlLGZvbzpmdW5jdGlvbigpe3JldHVybiA0Mn19LDQyPT09ZS5mb28oKX1jYXRjaCh0KXtyZXR1cm4hMX19KCkscy5UWVBFRF9BUlJBWV9TVVBQT1JUfHxcInVuZGVmaW5lZFwiPT10eXBlb2YgY29uc29sZXx8XCJmdW5jdGlvblwiIT10eXBlb2YgY29uc29sZS5lcnJvcnx8Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LlwiKSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJwYXJlbnRcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5pc0J1ZmZlcih0aGlzKT90aGlzLmJ1ZmZlcjp2b2lkIDB9fSksT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuaXNCdWZmZXIodGhpcyk/dGhpcy5ieXRlT2Zmc2V0OnZvaWQgMH19KSxcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZudWxsIT1TeW1ib2wuc3BlY2llcyYmc1tTeW1ib2wuc3BlY2llc109PT1zJiZPYmplY3QuZGVmaW5lUHJvcGVydHkocyxTeW1ib2wuc3BlY2llcyx7dmFsdWU6bnVsbCxjb25maWd1cmFibGU6ITAsZW51bWVyYWJsZTohMSx3cml0YWJsZTohMX0pLHMucG9vbFNpemU9ODE5MixzLmZyb209ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBsKGUsdCxuKX0scy5wcm90b3R5cGUuX19wcm90b19fPVVpbnQ4QXJyYXkucHJvdG90eXBlLHMuX19wcm90b19fPVVpbnQ4QXJyYXkscy5hbGxvYz1mdW5jdGlvbihlLHQsbil7cmV0dXJuIHUoZSx0LG4pfSxzLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe3JldHVybiBwKGUpfSxzLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtyZXR1cm4gcChlKX0scy5pc0J1ZmZlcj1mdW5jdGlvbihlKXtyZXR1cm4gbnVsbCE9ZSYmITA9PT1lLl9pc0J1ZmZlciYmZSE9PXMucHJvdG90eXBlfSxzLmNvbXBhcmU9ZnVuY3Rpb24oZSx0KXtpZihLKGUsVWludDhBcnJheSkmJihlPXMuZnJvbShlLGUub2Zmc2V0LGUuYnl0ZUxlbmd0aCkpLEsodCxVaW50OEFycmF5KSYmKHQ9cy5mcm9tKHQsdC5vZmZzZXQsdC5ieXRlTGVuZ3RoKSksIXMuaXNCdWZmZXIoZSl8fCFzLmlzQnVmZmVyKHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgXFxcImJ1ZjFcXFwiLCBcXFwiYnVmMlxcXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXlcIik7aWYoZT09PXQpcmV0dXJuIDA7Zm9yKHZhciBuPWUubGVuZ3RoLHI9dC5sZW5ndGgsZD0wLGw9byhuLHIpO2Q8bDsrK2QpaWYoZVtkXSE9PXRbZF0pe249ZVtkXSxyPXRbZF07YnJlYWt9cmV0dXJuIG48cj8tMTpyPG4/MTowfSxzLmlzRW5jb2Rpbmc9ZnVuY3Rpb24oZSl7c3dpdGNoKChlK1wiXCIpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMTt9fSxzLmNvbmNhdD1mdW5jdGlvbihlLHQpe2lmKCFBcnJheS5pc0FycmF5KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzXCIpO2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gcy5hbGxvYygwKTt2YXIgbjtpZih0PT09dm9pZCAwKWZvcih0PTAsbj0wO248ZS5sZW5ndGg7KytuKXQrPWVbbl0ubGVuZ3RoO3ZhciByPXMuYWxsb2NVbnNhZmUodCksYT0wO2ZvcihuPTA7bjxlLmxlbmd0aDsrK24pe3ZhciBvPWVbbl07aWYoSyhvLFVpbnQ4QXJyYXkpJiYobz1zLmZyb20obykpLCFzLmlzQnVmZmVyKG8pKXRocm93IG5ldyBUeXBlRXJyb3IoXCJcXFwibGlzdFxcXCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzXCIpO28uY29weShyLGEpLGErPW8ubGVuZ3RofXJldHVybiByfSxzLmJ5dGVMZW5ndGg9YixzLnByb3RvdHlwZS5faXNCdWZmZXI9ITAscy5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoMCE9ZSUyKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTIpQyh0aGlzLHQsdCsxKTtyZXR1cm4gdGhpc30scy5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoMCE9ZSU0KXRocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIik7Zm9yKHZhciB0PTA7dDxlO3QrPTQpQyh0aGlzLHQsdCszKSxDKHRoaXMsdCsxLHQrMik7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKDAhPWUlOCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpO2Zvcih2YXIgdD0wO3Q8ZTt0Kz04KUModGhpcyx0LHQrNyksQyh0aGlzLHQrMSx0KzYpLEModGhpcyx0KzIsdCs1KSxDKHRoaXMsdCszLHQrNCk7cmV0dXJuIHRoaXN9LHMucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7dmFyIGU9dGhpcy5sZW5ndGg7cmV0dXJuIDA9PT1lP1wiXCI6MD09PWFyZ3VtZW50cy5sZW5ndGg/eCh0aGlzLDAsZSk6eS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LHMucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nPXMucHJvdG90eXBlLnRvU3RyaW5nLHMucHJvdG90eXBlLmVxdWFscz1mdW5jdGlvbihlKXtpZighcy5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlclwiKTtyZXR1cm4gdGhpcz09PWV8fDA9PT1zLmNvbXBhcmUodGhpcyxlKX0scy5wcm90b3R5cGUuaW5zcGVjdD1mdW5jdGlvbigpe3ZhciBlPVwiXCIsdD1uLklOU1BFQ1RfTUFYX0JZVEVTO3JldHVybiBlPXRoaXMudG9TdHJpbmcoXCJoZXhcIiwwLHQpLnJlcGxhY2UoLyguezJ9KS9nLFwiJDEgXCIpLnRyaW0oKSx0aGlzLmxlbmd0aD50JiYoZSs9XCIgLi4uIFwiKSxcIjxCdWZmZXIgXCIrZStcIj5cIn0scy5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbihlLHQsbixyLGEpe2lmKEsoZSxVaW50OEFycmF5KSYmKGU9cy5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKSksIXMuaXNCdWZmZXIoZSkpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwidGFyZ2V0XFxcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKTtpZih2b2lkIDA9PT10JiYodD0wKSx2b2lkIDA9PT1uJiYobj1lP2UubGVuZ3RoOjApLHZvaWQgMD09PXImJihyPTApLHZvaWQgMD09PWEmJihhPXRoaXMubGVuZ3RoKSwwPnR8fG4+ZS5sZW5ndGh8fDA+cnx8YT50aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKTtpZihyPj1hJiZ0Pj1uKXJldHVybiAwO2lmKHI+PWEpcmV0dXJuLTE7aWYodD49bilyZXR1cm4gMTtpZih0Pj4+PTAsbj4+Pj0wLHI+Pj49MCxhPj4+PTAsdGhpcz09PWUpcmV0dXJuIDA7Zm9yKHZhciBkPWEtcixsPW4tdCxjPW8oZCxsKSx1PXRoaXMuc2xpY2UocixhKSxwPWUuc2xpY2UodCxuKSxmPTA7ZjxjOysrZilpZih1W2ZdIT09cFtmXSl7ZD11W2ZdLGw9cFtmXTticmVha31yZXR1cm4gZDxsPy0xOmw8ZD8xOjB9LHMucHJvdG90eXBlLmluY2x1ZGVzPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4tMSE9PXRoaXMuaW5kZXhPZihlLHQsbil9LHMucHJvdG90eXBlLmluZGV4T2Y9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBSKHRoaXMsZSx0LG4sITApfSxzLnByb3RvdHlwZS5sYXN0SW5kZXhPZj1mdW5jdGlvbihlLHQsbil7cmV0dXJuIFIodGhpcyxlLHQsbiwhMSl9LHMucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKHZvaWQgMD09PXQpcj1cInV0ZjhcIixuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKHZvaWQgMD09PW4mJlwic3RyaW5nXCI9PXR5cGVvZiB0KXI9dCxuPXRoaXMubGVuZ3RoLHQ9MDtlbHNlIGlmKGlzRmluaXRlKHQpKXQ+Pj49MCxpc0Zpbml0ZShuKT8obj4+Pj0wLHZvaWQgMD09PXImJihyPVwidXRmOFwiKSk6KHI9bixuPXZvaWQgMCk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKTt2YXIgYT10aGlzLmxlbmd0aC10O2lmKCh2b2lkIDA9PT1ufHxuPmEpJiYobj1hKSwwPGUubGVuZ3RoJiYoMD5ufHwwPnQpfHx0PnRoaXMubGVuZ3RoKXRocm93IG5ldyBSYW5nZUVycm9yKFwiQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHNcIik7cnx8KHI9XCJ1dGY4XCIpO2Zvcih2YXIgbz0hMTs7KXN3aXRjaChyKXtjYXNlXCJoZXhcIjpyZXR1cm4gdyh0aGlzLGUsdCxuKTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gUyh0aGlzLGUsdCxuKTtjYXNlXCJhc2NpaVwiOnJldHVybiBUKHRoaXMsZSx0LG4pO2Nhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB2KHRoaXMsZSx0LG4pO2Nhc2VcImJhc2U2NFwiOnJldHVybiBrKHRoaXMsZSx0LG4pO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiBMKHRoaXMsZSx0LG4pO2RlZmF1bHQ6aWYobyl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7cj0oXCJcIityKS50b0xvd2VyQ2FzZSgpLG89ITA7fX0scy5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6XCJCdWZmZXJcIixkYXRhOkFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2Fycnx8dGhpcywwKX19O3MucHJvdG90eXBlLnNsaWNlPWZ1bmN0aW9uKGUsdCl7dmFyIG49dGhpcy5sZW5ndGg7ZT1+fmUsdD10PT09dm9pZCAwP246fn50LDA+ZT8oZSs9biwwPmUmJihlPTApKTplPm4mJihlPW4pLDA+dD8odCs9biwwPnQmJih0PTApKTp0Pm4mJih0PW4pLHQ8ZSYmKHQ9ZSk7dmFyIHI9dGhpcy5zdWJhcnJheShlLHQpO3JldHVybiByLl9fcHJvdG9fXz1zLnByb3RvdHlwZSxyfSxzLnByb3RvdHlwZS5yZWFkVUludExFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIHI9dGhpc1tlXSxhPTEsbz0wOysrbzx0JiYoYSo9MjU2KTspcis9dGhpc1tlK29dKmE7cmV0dXJuIHJ9LHMucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24oZSx0LG4pe2U+Pj49MCx0Pj4+PTAsbnx8TyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgcj10aGlzW2UrLS10XSxhPTE7MDx0JiYoYSo9MjU2KTspcis9dGhpc1tlKy0tdF0qYTtyZXR1cm4gcn0scy5wcm90b3R5cGUucmVhZFVJbnQ4PWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsMSx0aGlzLmxlbmd0aCksdGhpc1tlXX0scy5wcm90b3R5cGUucmVhZFVJbnQxNkxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsMix0aGlzLmxlbmd0aCksdGhpc1tlXXx0aGlzW2UrMV08PDh9LHMucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDIsdGhpcy5sZW5ndGgpLHRoaXNbZV08PDh8dGhpc1tlKzFdfSxzLnByb3RvdHlwZS5yZWFkVUludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSwodGhpc1tlXXx0aGlzW2UrMV08PDh8dGhpc1tlKzJdPDwxNikrMTY3NzcyMTYqdGhpc1tlKzNdfSxzLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSwxNjc3NzIxNip0aGlzW2VdKyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfSxzLnByb3RvdHlwZS5yZWFkSW50TEU9ZnVuY3Rpb24oZSx0LG4pe2U+Pj49MCx0Pj4+PTAsbnx8TyhlLHQsdGhpcy5sZW5ndGgpO2Zvcih2YXIgYT10aGlzW2VdLG89MSxkPTA7KytkPHQmJihvKj0yNTYpOylhKz10aGlzW2UrZF0qbztyZXR1cm4gbyo9MTI4LGE+PW8mJihhLT1yKDIsOCp0KSksYX0scy5wcm90b3R5cGUucmVhZEludEJFPWZ1bmN0aW9uKGUsdCxuKXtlPj4+PTAsdD4+Pj0wLG58fE8oZSx0LHRoaXMubGVuZ3RoKTtmb3IodmFyIGE9dCxvPTEsZD10aGlzW2UrLS1hXTswPGEmJihvKj0yNTYpOylkKz10aGlzW2UrLS1hXSpvO3JldHVybiBvKj0xMjgsZD49byYmKGQtPXIoMiw4KnQpKSxkfSxzLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDEsdGhpcy5sZW5ndGgpLDEyOCZ0aGlzW2VdPy0xKigyNTUtdGhpc1tlXSsxKTp0aGlzW2VdfSxzLnByb3RvdHlwZS5yZWFkSW50MTZMRT1mdW5jdGlvbihlLHQpe2U+Pj49MCx0fHxPKGUsMix0aGlzLmxlbmd0aCk7dmFyIG49dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIDMyNzY4Jm4/NDI5NDkwMTc2MHxuOm59LHMucHJvdG90eXBlLnJlYWRJbnQxNkJFPWZ1bmN0aW9uKGUsdCl7ZT4+Pj0wLHR8fE8oZSwyLHRoaXMubGVuZ3RoKTt2YXIgbj10aGlzW2UrMV18dGhpc1tlXTw8ODtyZXR1cm4gMzI3Njgmbj80Mjk0OTAxNzYwfG46bn0scy5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZT4+Pj0wLHR8fE8oZSw0LHRoaXMubGVuZ3RoKSx0aGlzW2VdfHRoaXNbZSsxXTw8OHx0aGlzW2UrMl08PDE2fHRoaXNbZSszXTw8MjR9LHMucHJvdG90eXBlLnJlYWRJbnQzMkJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfSxzLnByb3RvdHlwZS5yZWFkRmxvYXRMRT1mdW5jdGlvbihlLHQpe3JldHVybiBlPj4+PTAsdHx8TyhlLDQsdGhpcy5sZW5ndGgpLEoucmVhZCh0aGlzLGUsITAsMjMsNCl9LHMucHJvdG90eXBlLnJlYWRGbG9hdEJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsNCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMSwyMyw0KX0scy5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsOCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMCw1Miw4KX0scy5wcm90b3R5cGUucmVhZERvdWJsZUJFPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGU+Pj49MCx0fHxPKGUsOCx0aGlzLmxlbmd0aCksSi5yZWFkKHRoaXMsZSwhMSw1Miw4KX0scy5wcm90b3R5cGUud3JpdGVVSW50TEU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsbj4+Pj0wLCFhKXt2YXIgbz1yKDIsOCpuKS0xO0YodGhpcyxlLHQsbixvLDApfXZhciBkPTEscz0wO2Zvcih0aGlzW3RdPTI1NSZlOysrczxuJiYoZCo9MjU2KTspdGhpc1t0K3NdPTI1NSZlL2Q7cmV0dXJuIHQrbn0scy5wcm90b3R5cGUud3JpdGVVSW50QkU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsbj4+Pj0wLCFhKXt2YXIgbz1yKDIsOCpuKS0xO0YodGhpcyxlLHQsbixvLDApfXZhciBkPW4tMSxzPTE7Zm9yKHRoaXNbdCtkXT0yNTUmZTswPD0tLWQmJihzKj0yNTYpOyl0aGlzW3QrZF09MjU1JmUvcztyZXR1cm4gdCtufSxzLnByb3RvdHlwZS53cml0ZVVJbnQ4PWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwxLDI1NSwwKSx0aGlzW3RdPTI1NSZlLHQrMX0scy5wcm90b3R5cGUud3JpdGVVSW50MTZMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMiw2NTUzNSwwKSx0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0KzJ9LHMucHJvdG90eXBlLndyaXRlVUludDE2QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDIsNjU1MzUsMCksdGhpc1t0XT1lPj4+OCx0aGlzW3QrMV09MjU1JmUsdCsyfSxzLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCw0LDQyOTQ5NjcyOTUsMCksdGhpc1t0KzNdPWU+Pj4yNCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCsxXT1lPj4+OCx0aGlzW3RdPTI1NSZlLHQrNH0scy5wcm90b3R5cGUud3JpdGVVSW50MzJCRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsNCw0Mjk0OTY3Mjk1LDApLHRoaXNbdF09ZT4+PjI0LHRoaXNbdCsxXT1lPj4+MTYsdGhpc1t0KzJdPWU+Pj44LHRoaXNbdCszXT0yNTUmZSx0KzR9LHMucHJvdG90eXBlLndyaXRlSW50TEU9ZnVuY3Rpb24oZSx0LG4sYSl7aWYoZT0rZSx0Pj4+PTAsIWEpe3ZhciBvPXIoMiw4Km4tMSk7Rih0aGlzLGUsdCxuLG8tMSwtbyl9dmFyIGQ9MCxzPTEsbD0wO2Zvcih0aGlzW3RdPTI1NSZlOysrZDxuJiYocyo9MjU2KTspMD5lJiYwPT09bCYmMCE9PXRoaXNbdCtkLTFdJiYobD0xKSx0aGlzW3QrZF09MjU1JihlL3M+PjApLWw7cmV0dXJuIHQrbn0scy5wcm90b3R5cGUud3JpdGVJbnRCRT1mdW5jdGlvbihlLHQsbixhKXtpZihlPStlLHQ+Pj49MCwhYSl7dmFyIG89cigyLDgqbi0xKTtGKHRoaXMsZSx0LG4sby0xLC1vKX12YXIgZD1uLTEscz0xLGw9MDtmb3IodGhpc1t0K2RdPTI1NSZlOzA8PS0tZCYmKHMqPTI1Nik7KTA+ZSYmMD09PWwmJjAhPT10aGlzW3QrZCsxXSYmKGw9MSksdGhpc1t0K2RdPTI1NSYoZS9zPj4wKS1sO3JldHVybiB0K259LHMucHJvdG90eXBlLndyaXRlSW50OD1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsMSwxMjcsLTEyOCksMD5lJiYoZT0yNTUrZSsxKSx0aGlzW3RdPTI1NSZlLHQrMX0scy5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gZT0rZSx0Pj4+PTAsbnx8Rih0aGlzLGUsdCwyLDMyNzY3LC0zMjc2OCksdGhpc1t0XT0yNTUmZSx0aGlzW3QrMV09ZT4+PjgsdCsyfSxzLnByb3RvdHlwZS53cml0ZUludDE2QkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDIsMzI3NjcsLTMyNzY4KSx0aGlzW3RdPWU+Pj44LHRoaXNbdCsxXT0yNTUmZSx0KzJ9LHMucHJvdG90eXBlLndyaXRlSW50MzJMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGU9K2UsdD4+Pj0wLG58fEYodGhpcyxlLHQsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KSx0aGlzW3RdPTI1NSZlLHRoaXNbdCsxXT1lPj4+OCx0aGlzW3QrMl09ZT4+PjE2LHRoaXNbdCszXT1lPj4+MjQsdCs0fSxzLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBlPStlLHQ+Pj49MCxufHxGKHRoaXMsZSx0LDQsMjE0NzQ4MzY0NywtMjE0NzQ4MzY0OCksMD5lJiYoZT00Mjk0OTY3Mjk1K2UrMSksdGhpc1t0XT1lPj4+MjQsdGhpc1t0KzFdPWU+Pj4xNix0aGlzW3QrMl09ZT4+PjgsdGhpc1t0KzNdPTI1NSZlLHQrNH0scy5wcm90b3R5cGUud3JpdGVGbG9hdExFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVSh0aGlzLGUsdCwhMCxuKX0scy5wcm90b3R5cGUud3JpdGVGbG9hdEJFPWZ1bmN0aW9uKGUsdCxuKXtyZXR1cm4gVSh0aGlzLGUsdCwhMSxuKX0scy5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbihlLHQsbil7cmV0dXJuIGoodGhpcyxlLHQsITAsbil9LHMucHJvdG90eXBlLndyaXRlRG91YmxlQkU9ZnVuY3Rpb24oZSx0LG4pe3JldHVybiBqKHRoaXMsZSx0LCExLG4pfSxzLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uKGUsdCxuLHIpe2lmKCFzLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXJcIik7aWYobnx8KG49MCkscnx8MD09PXJ8fChyPXRoaXMubGVuZ3RoKSx0Pj1lLmxlbmd0aCYmKHQ9ZS5sZW5ndGgpLHR8fCh0PTApLDA8ciYmcjxuJiYocj1uKSxyPT09bilyZXR1cm4gMDtpZigwPT09ZS5sZW5ndGh8fDA9PT10aGlzLmxlbmd0aClyZXR1cm4gMDtpZigwPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJ0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzXCIpO2lmKDA+bnx8bj49dGhpcy5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYoMD5yKXRocm93IG5ldyBSYW5nZUVycm9yKFwic291cmNlRW5kIG91dCBvZiBib3VuZHNcIik7cj50aGlzLmxlbmd0aCYmKHI9dGhpcy5sZW5ndGgpLGUubGVuZ3RoLXQ8ci1uJiYocj1lLmxlbmd0aC10K24pO3ZhciBhPXItbjtpZih0aGlzPT09ZSYmXCJmdW5jdGlvblwiPT10eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbil0aGlzLmNvcHlXaXRoaW4odCxuLHIpO2Vsc2UgaWYodGhpcz09PWUmJm48dCYmdDxyKWZvcih2YXIgbz1hLTE7MDw9bzstLW8pZVtvK3RdPXRoaXNbbytuXTtlbHNlIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKGUsdGhpcy5zdWJhcnJheShuLHIpLHQpO3JldHVybiBhfSxzLnByb3RvdHlwZS5maWxsPWZ1bmN0aW9uKGUsdCxuLHIpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgdD8ocj10LHQ9MCxuPXRoaXMubGVuZ3RoKTpcInN0cmluZ1wiPT10eXBlb2YgbiYmKHI9bixuPXRoaXMubGVuZ3RoKSx2b2lkIDAhPT1yJiZcInN0cmluZ1wiIT10eXBlb2Ygcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZ1wiKTtpZihcInN0cmluZ1wiPT10eXBlb2YgciYmIXMuaXNFbmNvZGluZyhyKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrcik7aWYoMT09PWUubGVuZ3RoKXt2YXIgYT1lLmNoYXJDb2RlQXQoMCk7KFwidXRmOFwiPT09ciYmMTI4PmF8fFwibGF0aW4xXCI9PT1yKSYmKGU9YSl9fWVsc2VcIm51bWJlclwiPT10eXBlb2YgZSYmKGUmPTI1NSk7aWYoMD50fHx0aGlzLmxlbmd0aDx0fHx0aGlzLmxlbmd0aDxuKXRocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpO2lmKG48PXQpcmV0dXJuIHRoaXM7dD4+Pj0wLG49bj09PXZvaWQgMD90aGlzLmxlbmd0aDpuPj4+MCxlfHwoZT0wKTt2YXIgbztpZihcIm51bWJlclwiPT10eXBlb2YgZSlmb3Iobz10O288bjsrK28pdGhpc1tvXT1lO2Vsc2V7dmFyIGQ9cy5pc0J1ZmZlcihlKT9lOnMuZnJvbShlLHIpLGw9ZC5sZW5ndGg7aWYoMD09PWwpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSB2YWx1ZSBcXFwiXCIrZStcIlxcXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXFxcInZhbHVlXFxcIlwiKTtmb3Iobz0wO288bi10Oysrbyl0aGlzW28rdF09ZFtvJWxdfXJldHVybiB0aGlzfTt2YXIgUT0vW14rLzAtOUEtWmEtei1fXS9nfSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiYnVmZmVyXCIpLkJ1ZmZlcil9LHtcImJhc2U2NC1qc1wiOjEsYnVmZmVyOjMsaWVlZTc1NDo5fV0sNDpbZnVuY3Rpb24oZSx0LG4peyhmdW5jdGlvbihhKXsoZnVuY3Rpb24oKXtmdW5jdGlvbiByKCl7bGV0IGU7dHJ5e2U9bi5zdG9yYWdlLmdldEl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaChlKXt9cmV0dXJuIWUmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBhJiZcImVudlwiaW4gYSYmKGU9YS5lbnYuREVCVUcpLGV9bi5mb3JtYXRBcmdzPWZ1bmN0aW9uKGUpe2lmKGVbMF09KHRoaXMudXNlQ29sb3JzP1wiJWNcIjpcIlwiKSt0aGlzLm5hbWVzcGFjZSsodGhpcy51c2VDb2xvcnM/XCIgJWNcIjpcIiBcIikrZVswXSsodGhpcy51c2VDb2xvcnM/XCIlYyBcIjpcIiBcIikrXCIrXCIrdC5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZiksIXRoaXMudXNlQ29sb3JzKXJldHVybjtjb25zdCBuPVwiY29sb3I6IFwiK3RoaXMuY29sb3I7ZS5zcGxpY2UoMSwwLG4sXCJjb2xvcjogaW5oZXJpdFwiKTtsZXQgcj0wLGE9MDtlWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZyxlPT57XCIlJVwiPT09ZXx8KHIrKyxcIiVjXCI9PT1lJiYoYT1yKSl9KSxlLnNwbGljZShhLDAsbil9LG4uc2F2ZT1mdW5jdGlvbihlKXt0cnl7ZT9uLnN0b3JhZ2Uuc2V0SXRlbShcImRlYnVnXCIsZSk6bi5zdG9yYWdlLnJlbW92ZUl0ZW0oXCJkZWJ1Z1wiKX1jYXRjaChlKXt9fSxuLmxvYWQ9cixuLnVzZUNvbG9ycz1mdW5jdGlvbigpe3JldHVybiEhKFwidW5kZWZpbmVkXCIhPXR5cGVvZiB3aW5kb3cmJndpbmRvdy5wcm9jZXNzJiYoXCJyZW5kZXJlclwiPT09d2luZG93LnByb2Nlc3MudHlwZXx8d2luZG93LnByb2Nlc3MuX19ud2pzKSl8fCEoXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLnVzZXJBZ2VudCYmbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSYmKFwidW5kZWZpbmVkXCIhPXR5cGVvZiBkb2N1bWVudCYmZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50JiZkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUmJmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlfHxcInVuZGVmaW5lZFwiIT10eXBlb2Ygd2luZG93JiZ3aW5kb3cuY29uc29sZSYmKHdpbmRvdy5jb25zb2xlLmZpcmVidWd8fHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiYmd2luZG93LmNvbnNvbGUudGFibGUpfHxcInVuZGVmaW5lZFwiIT10eXBlb2YgbmF2aWdhdG9yJiZuYXZpZ2F0b3IudXNlckFnZW50JiZuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSYmMzE8PXBhcnNlSW50KFJlZ0V4cC4kMSwxMCl8fFwidW5kZWZpbmVkXCIhPXR5cGVvZiBuYXZpZ2F0b3ImJm5hdmlnYXRvci51c2VyQWdlbnQmJm5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSl9LG4uc3RvcmFnZT1mdW5jdGlvbigpe3RyeXtyZXR1cm4gbG9jYWxTdG9yYWdlfWNhdGNoKGUpe319KCksbi5kZXN0cm95PSgoKT0+e2xldCBlPSExO3JldHVybigpPT57ZXx8KGU9ITAsY29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKSl9fSkoKSxuLmNvbG9ycz1bXCIjMDAwMENDXCIsXCIjMDAwMEZGXCIsXCIjMDAzM0NDXCIsXCIjMDAzM0ZGXCIsXCIjMDA2NkNDXCIsXCIjMDA2NkZGXCIsXCIjMDA5OUNDXCIsXCIjMDA5OUZGXCIsXCIjMDBDQzAwXCIsXCIjMDBDQzMzXCIsXCIjMDBDQzY2XCIsXCIjMDBDQzk5XCIsXCIjMDBDQ0NDXCIsXCIjMDBDQ0ZGXCIsXCIjMzMwMENDXCIsXCIjMzMwMEZGXCIsXCIjMzMzM0NDXCIsXCIjMzMzM0ZGXCIsXCIjMzM2NkNDXCIsXCIjMzM2NkZGXCIsXCIjMzM5OUNDXCIsXCIjMzM5OUZGXCIsXCIjMzNDQzAwXCIsXCIjMzNDQzMzXCIsXCIjMzNDQzY2XCIsXCIjMzNDQzk5XCIsXCIjMzNDQ0NDXCIsXCIjMzNDQ0ZGXCIsXCIjNjYwMENDXCIsXCIjNjYwMEZGXCIsXCIjNjYzM0NDXCIsXCIjNjYzM0ZGXCIsXCIjNjZDQzAwXCIsXCIjNjZDQzMzXCIsXCIjOTkwMENDXCIsXCIjOTkwMEZGXCIsXCIjOTkzM0NDXCIsXCIjOTkzM0ZGXCIsXCIjOTlDQzAwXCIsXCIjOTlDQzMzXCIsXCIjQ0MwMDAwXCIsXCIjQ0MwMDMzXCIsXCIjQ0MwMDY2XCIsXCIjQ0MwMDk5XCIsXCIjQ0MwMENDXCIsXCIjQ0MwMEZGXCIsXCIjQ0MzMzAwXCIsXCIjQ0MzMzMzXCIsXCIjQ0MzMzY2XCIsXCIjQ0MzMzk5XCIsXCIjQ0MzM0NDXCIsXCIjQ0MzM0ZGXCIsXCIjQ0M2NjAwXCIsXCIjQ0M2NjMzXCIsXCIjQ0M5OTAwXCIsXCIjQ0M5OTMzXCIsXCIjQ0NDQzAwXCIsXCIjQ0NDQzMzXCIsXCIjRkYwMDAwXCIsXCIjRkYwMDMzXCIsXCIjRkYwMDY2XCIsXCIjRkYwMDk5XCIsXCIjRkYwMENDXCIsXCIjRkYwMEZGXCIsXCIjRkYzMzAwXCIsXCIjRkYzMzMzXCIsXCIjRkYzMzY2XCIsXCIjRkYzMzk5XCIsXCIjRkYzM0NDXCIsXCIjRkYzM0ZGXCIsXCIjRkY2NjAwXCIsXCIjRkY2NjMzXCIsXCIjRkY5OTAwXCIsXCIjRkY5OTMzXCIsXCIjRkZDQzAwXCIsXCIjRkZDQzMzXCJdLG4ubG9nPWNvbnNvbGUuZGVidWd8fGNvbnNvbGUubG9nfHwoKCk9Pnt9KSx0LmV4cG9ydHM9ZShcIi4vY29tbW9uXCIpKG4pO2NvbnN0e2Zvcm1hdHRlcnM6b309dC5leHBvcnRzO28uaj1mdW5jdGlvbihlKXt0cnl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGUpfWNhdGNoKGUpe3JldHVyblwiW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06IFwiK2UubWVzc2FnZX19fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIikpfSx7XCIuL2NvbW1vblwiOjUsX3Byb2Nlc3M6MTJ9XSw1OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1mdW5jdGlvbih0KXtmdW5jdGlvbiByKGUpe2Z1bmN0aW9uIHQoLi4uZSl7aWYoIXQuZW5hYmxlZClyZXR1cm47Y29uc3QgYT10LG89K25ldyBEYXRlLGk9by0obnx8byk7YS5kaWZmPWksYS5wcmV2PW4sYS5jdXJyPW8sbj1vLGVbMF09ci5jb2VyY2UoZVswXSksXCJzdHJpbmdcIiE9dHlwZW9mIGVbMF0mJmUudW5zaGlmdChcIiVPXCIpO2xldCBkPTA7ZVswXT1lWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCh0LG4pPT57aWYoXCIlJVwiPT09dClyZXR1cm5cIiVcIjtkKys7Y29uc3Qgbz1yLmZvcm1hdHRlcnNbbl07aWYoXCJmdW5jdGlvblwiPT10eXBlb2Ygbyl7Y29uc3Qgbj1lW2RdO3Q9by5jYWxsKGEsbiksZS5zcGxpY2UoZCwxKSxkLS19cmV0dXJuIHR9KSxyLmZvcm1hdEFyZ3MuY2FsbChhLGUpO2NvbnN0IHM9YS5sb2d8fHIubG9nO3MuYXBwbHkoYSxlKX1sZXQgbixvPW51bGw7cmV0dXJuIHQubmFtZXNwYWNlPWUsdC51c2VDb2xvcnM9ci51c2VDb2xvcnMoKSx0LmNvbG9yPXIuc2VsZWN0Q29sb3IoZSksdC5leHRlbmQ9YSx0LmRlc3Ryb3k9ci5kZXN0cm95LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiZW5hYmxlZFwiLHtlbnVtZXJhYmxlOiEwLGNvbmZpZ3VyYWJsZTohMSxnZXQ6KCk9Pm51bGw9PT1vP3IuZW5hYmxlZChlKTpvLHNldDplPT57bz1lfX0pLFwiZnVuY3Rpb25cIj09dHlwZW9mIHIuaW5pdCYmci5pbml0KHQpLHR9ZnVuY3Rpb24gYShlLHQpe2NvbnN0IG49cih0aGlzLm5hbWVzcGFjZSsoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHQ/XCI6XCI6dCkrZSk7cmV0dXJuIG4ubG9nPXRoaXMubG9nLG59ZnVuY3Rpb24gbyhlKXtyZXR1cm4gZS50b1N0cmluZygpLnN1YnN0cmluZygyLGUudG9TdHJpbmcoKS5sZW5ndGgtMikucmVwbGFjZSgvXFwuXFwqXFw/JC8sXCIqXCIpfXJldHVybiByLmRlYnVnPXIsci5kZWZhdWx0PXIsci5jb2VyY2U9ZnVuY3Rpb24oZSl7cmV0dXJuIGUgaW5zdGFuY2VvZiBFcnJvcj9lLnN0YWNrfHxlLm1lc3NhZ2U6ZX0sci5kaXNhYmxlPWZ1bmN0aW9uKCl7Y29uc3QgZT1bLi4uci5uYW1lcy5tYXAobyksLi4uci5za2lwcy5tYXAobykubWFwKGU9PlwiLVwiK2UpXS5qb2luKFwiLFwiKTtyZXR1cm4gci5lbmFibGUoXCJcIiksZX0sci5lbmFibGU9ZnVuY3Rpb24oZSl7ci5zYXZlKGUpLHIubmFtZXM9W10sci5za2lwcz1bXTtsZXQgdDtjb25zdCBuPShcInN0cmluZ1wiPT10eXBlb2YgZT9lOlwiXCIpLnNwbGl0KC9bXFxzLF0rLyksYT1uLmxlbmd0aDtmb3IodD0wO3Q8YTt0Kyspblt0XSYmKGU9blt0XS5yZXBsYWNlKC9cXCovZyxcIi4qP1wiKSxcIi1cIj09PWVbMF0/ci5za2lwcy5wdXNoKG5ldyBSZWdFeHAoXCJeXCIrZS5zdWJzdHIoMSkrXCIkXCIpKTpyLm5hbWVzLnB1c2gobmV3IFJlZ0V4cChcIl5cIitlK1wiJFwiKSkpfSxyLmVuYWJsZWQ9ZnVuY3Rpb24oZSl7aWYoXCIqXCI9PT1lW2UubGVuZ3RoLTFdKXJldHVybiEwO2xldCB0LG47Zm9yKHQ9MCxuPXIuc2tpcHMubGVuZ3RoO3Q8bjt0KyspaWYoci5za2lwc1t0XS50ZXN0KGUpKXJldHVybiExO2Zvcih0PTAsbj1yLm5hbWVzLmxlbmd0aDt0PG47dCsrKWlmKHIubmFtZXNbdF0udGVzdChlKSlyZXR1cm4hMDtyZXR1cm4hMX0sci5odW1hbml6ZT1lKFwibXNcIiksci5kZXN0cm95PWZ1bmN0aW9uKCl7Y29uc29sZS53YXJuKFwiSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLlwiKX0sT2JqZWN0LmtleXModCkuZm9yRWFjaChlPT57cltlXT10W2VdfSksci5uYW1lcz1bXSxyLnNraXBzPVtdLHIuZm9ybWF0dGVycz17fSxyLnNlbGVjdENvbG9yPWZ1bmN0aW9uKGUpe2xldCB0PTA7Zm9yKGxldCBuPTA7bjxlLmxlbmd0aDtuKyspdD0odDw8NSktdCtlLmNoYXJDb2RlQXQobiksdHw9MDtyZXR1cm4gci5jb2xvcnNbbih0KSVyLmNvbG9ycy5sZW5ndGhdfSxyLmVuYWJsZShyLmxvYWQoKSkscn19LHttczoxMX1dLDY6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXtmb3IoY29uc3QgbiBpbiB0KU9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4se3ZhbHVlOnRbbl0sZW51bWVyYWJsZTohMCxjb25maWd1cmFibGU6ITB9KTtyZXR1cm4gZX10LmV4cG9ydHM9ZnVuY3Rpb24oZSx0LHIpe2lmKCFlfHxcInN0cmluZ1wiPT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGxlYXNlIHBhc3MgYW4gRXJyb3IgdG8gZXJyLWNvZGVcIik7cnx8KHI9e30pLFwib2JqZWN0XCI9PXR5cGVvZiB0JiYocj10LHQ9XCJcIiksdCYmKHIuY29kZT10KTt0cnl7cmV0dXJuIG4oZSxyKX1jYXRjaCh0KXtyLm1lc3NhZ2U9ZS5tZXNzYWdlLHIuc3RhY2s9ZS5zdGFjaztjb25zdCBhPWZ1bmN0aW9uKCl7fTthLnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihlKSk7Y29uc3Qgbz1uKG5ldyBhLHIpO3JldHVybiBvfX19LHt9XSw3OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe2NvbnNvbGUmJmNvbnNvbGUud2FybiYmY29uc29sZS53YXJuKGUpfWZ1bmN0aW9uIHIoKXtyLmluaXQuY2FsbCh0aGlzKX1mdW5jdGlvbiBhKGUpe2lmKFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBcXFwibGlzdGVuZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gdm9pZCAwPT09ZS5fbWF4TGlzdGVuZXJzP3IuZGVmYXVsdE1heExpc3RlbmVyczplLl9tYXhMaXN0ZW5lcnN9ZnVuY3Rpb24gaShlLHQscixpKXt2YXIgZCxzLGw7aWYoYShyKSxzPWUuX2V2ZW50cyx2b2lkIDA9PT1zPyhzPWUuX2V2ZW50cz1PYmplY3QuY3JlYXRlKG51bGwpLGUuX2V2ZW50c0NvdW50PTApOih2b2lkIDAhPT1zLm5ld0xpc3RlbmVyJiYoZS5lbWl0KFwibmV3TGlzdGVuZXJcIix0LHIubGlzdGVuZXI/ci5saXN0ZW5lcjpyKSxzPWUuX2V2ZW50cyksbD1zW3RdKSx2b2lkIDA9PT1sKWw9c1t0XT1yLCsrZS5fZXZlbnRzQ291bnQ7ZWxzZSBpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiBsP2w9c1t0XT1pP1tyLGxdOltsLHJdOmk/bC51bnNoaWZ0KHIpOmwucHVzaChyKSxkPW8oZSksMDxkJiZsLmxlbmd0aD5kJiYhbC53YXJuZWQpe2wud2FybmVkPSEwO3ZhciBjPW5ldyBFcnJvcihcIlBvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gXCIrbC5sZW5ndGgrXCIgXCIrKHQrXCIgbGlzdGVuZXJzIGFkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdFwiKSk7Yy5uYW1lPVwiTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nXCIsYy5lbWl0dGVyPWUsYy50eXBlPXQsYy5jb3VudD1sLmxlbmd0aCxuKGMpfXJldHVybiBlfWZ1bmN0aW9uIGQoKXtpZighdGhpcy5maXJlZClyZXR1cm4gdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLHRoaXMud3JhcEZuKSx0aGlzLmZpcmVkPSEwLDA9PT1hcmd1bWVudHMubGVuZ3RoP3RoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk6dGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCxhcmd1bWVudHMpfWZ1bmN0aW9uIHMoZSx0LG4pe3ZhciByPXtmaXJlZDohMSx3cmFwRm46dm9pZCAwLHRhcmdldDplLHR5cGU6dCxsaXN0ZW5lcjpufSxhPWQuYmluZChyKTtyZXR1cm4gYS5saXN0ZW5lcj1uLHIud3JhcEZuPWEsYX1mdW5jdGlvbiBsKGUsdCxuKXt2YXIgcj1lLl9ldmVudHM7aWYocj09PXZvaWQgMClyZXR1cm5bXTt2YXIgYT1yW3RdO3JldHVybiB2b2lkIDA9PT1hP1tdOlwiZnVuY3Rpb25cIj09dHlwZW9mIGE/bj9bYS5saXN0ZW5lcnx8YV06W2FdOm4/ZihhKTp1KGEsYS5sZW5ndGgpfWZ1bmN0aW9uIGMoZSl7dmFyIHQ9dGhpcy5fZXZlbnRzO2lmKHQhPT12b2lkIDApe3ZhciBuPXRbZV07aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgbilyZXR1cm4gMTtpZih2b2lkIDAhPT1uKXJldHVybiBuLmxlbmd0aH1yZXR1cm4gMH1mdW5jdGlvbiB1KGUsdCl7Zm9yKHZhciBuPUFycmF5KHQpLHI9MDtyPHQ7KytyKW5bcl09ZVtyXTtyZXR1cm4gbn1mdW5jdGlvbiBwKGUsdCl7Zm9yKDt0KzE8ZS5sZW5ndGg7dCsrKWVbdF09ZVt0KzFdO2UucG9wKCl9ZnVuY3Rpb24gZihlKXtmb3IodmFyIHQ9QXJyYXkoZS5sZW5ndGgpLG49MDtuPHQubGVuZ3RoOysrbil0W25dPWVbbl0ubGlzdGVuZXJ8fGVbbl07cmV0dXJuIHR9ZnVuY3Rpb24gZyhlLHQsbil7XCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbiYmXyhlLFwiZXJyb3JcIix0LG4pfWZ1bmN0aW9uIF8oZSx0LG4scil7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5vbilyLm9uY2U/ZS5vbmNlKHQsbik6ZS5vbih0LG4pO2Vsc2UgaWYoXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hZGRFdmVudExpc3RlbmVyKWUuYWRkRXZlbnRMaXN0ZW5lcih0LGZ1bmN0aW9uIGEobyl7ci5vbmNlJiZlLnJlbW92ZUV2ZW50TGlzdGVuZXIodCxhKSxuKG8pfSk7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiVGhlIFxcXCJlbWl0dGVyXFxcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX12YXIgaCxtPVwib2JqZWN0XCI9PXR5cGVvZiBSZWZsZWN0P1JlZmxlY3Q6bnVsbCxiPW0mJlwiZnVuY3Rpb25cIj09dHlwZW9mIG0uYXBwbHk/bS5hcHBseTpmdW5jdGlvbihlLHQsbil7cmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGUsdCxuKX07aD1tJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiBtLm93bktleXM/bS5vd25LZXlzOk9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM/ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpKX06ZnVuY3Rpb24oZSl7cmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpfTt2YXIgeT1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKGUpe3JldHVybiBlIT09ZX07dC5leHBvcnRzPXIsdC5leHBvcnRzLm9uY2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24obixyKXtmdW5jdGlvbiBhKG4pe2UucmVtb3ZlTGlzdGVuZXIodCxvKSxyKG4pfWZ1bmN0aW9uIG8oKXtcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnJlbW92ZUxpc3RlbmVyJiZlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixhKSxuKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSl9XyhlLHQsbyx7b25jZTohMH0pLFwiZXJyb3JcIiE9PXQmJmcoZSxhLHtvbmNlOiEwfSl9KX0sci5FdmVudEVtaXR0ZXI9cixyLnByb3RvdHlwZS5fZXZlbnRzPXZvaWQgMCxyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQ9MCxyLnByb3RvdHlwZS5fbWF4TGlzdGVuZXJzPXZvaWQgMDt2YXIgQz0xMDtPYmplY3QuZGVmaW5lUHJvcGVydHkocixcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIix7ZW51bWVyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gQ30sc2V0OmZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlfHwwPmV8fHkoZSkpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUaGUgdmFsdWUgb2YgXFxcImRlZmF1bHRNYXhMaXN0ZW5lcnNcXFwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkIFwiK2UrXCIuXCIpO0M9ZX19KSxyLmluaXQ9ZnVuY3Rpb24oKXsodGhpcy5fZXZlbnRzPT09dm9pZCAwfHx0aGlzLl9ldmVudHM9PT1PYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykmJih0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKSx0aGlzLl9tYXhMaXN0ZW5lcnM9dGhpcy5fbWF4TGlzdGVuZXJzfHx2b2lkIDB9LHIucHJvdG90eXBlLnNldE1heExpc3RlbmVycz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZXx8MD5lfHx5KGUpKXRocm93IG5ldyBSYW5nZUVycm9yKFwiVGhlIHZhbHVlIG9mIFxcXCJuXFxcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCBcIitlK1wiLlwiKTtyZXR1cm4gdGhpcy5fbWF4TGlzdGVuZXJzPWUsdGhpc30sci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzPWZ1bmN0aW9uKCl7cmV0dXJuIG8odGhpcyl9LHIucHJvdG90eXBlLmVtaXQ9ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PVtdLG49MTtuPGFyZ3VtZW50cy5sZW5ndGg7bisrKXQucHVzaChhcmd1bWVudHNbbl0pO3ZhciByPVwiZXJyb3JcIj09PWUsYT10aGlzLl9ldmVudHM7aWYoYSE9PXZvaWQgMClyPXImJmEuZXJyb3I9PT12b2lkIDA7ZWxzZSBpZighcilyZXR1cm4hMTtpZihyKXt2YXIgbztpZigwPHQubGVuZ3RoJiYobz10WzBdKSxvIGluc3RhbmNlb2YgRXJyb3IpdGhyb3cgbzt2YXIgZD1uZXcgRXJyb3IoXCJVbmhhbmRsZWQgZXJyb3IuXCIrKG8/XCIgKFwiK28ubWVzc2FnZStcIilcIjpcIlwiKSk7dGhyb3cgZC5jb250ZXh0PW8sZH12YXIgcz1hW2VdO2lmKHM9PT12b2lkIDApcmV0dXJuITE7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgcyliKHMsdGhpcyx0KTtlbHNlIGZvcih2YXIgbD1zLmxlbmd0aCxjPXUocyxsKSxuPTA7bjxsOysrbiliKGNbbl0sdGhpcyx0KTtyZXR1cm4hMH0sci5wcm90b3R5cGUuYWRkTGlzdGVuZXI9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gaSh0aGlzLGUsdCwhMSl9LHIucHJvdG90eXBlLm9uPXIucHJvdG90eXBlLmFkZExpc3RlbmVyLHIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiBpKHRoaXMsZSx0LCEwKX0sci5wcm90b3R5cGUub25jZT1mdW5jdGlvbihlLHQpe3JldHVybiBhKHQpLHRoaXMub24oZSxzKHRoaXMsZSx0KSksdGhpc30sci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3JldHVybiBhKHQpLHRoaXMucHJlcGVuZExpc3RlbmVyKGUscyh0aGlzLGUsdCkpLHRoaXN9LHIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyPWZ1bmN0aW9uKGUsdCl7dmFyIG4scixvLGQscztpZihhKHQpLHI9dGhpcy5fZXZlbnRzLHZvaWQgMD09PXIpcmV0dXJuIHRoaXM7aWYobj1yW2VdLHZvaWQgMD09PW4pcmV0dXJuIHRoaXM7aWYobj09PXR8fG4ubGlzdGVuZXI9PT10KTA9PS0tdGhpcy5fZXZlbnRzQ291bnQ/dGhpcy5fZXZlbnRzPU9iamVjdC5jcmVhdGUobnVsbCk6KGRlbGV0ZSByW2VdLHIucmVtb3ZlTGlzdGVuZXImJnRoaXMuZW1pdChcInJlbW92ZUxpc3RlbmVyXCIsZSxuLmxpc3RlbmVyfHx0KSk7ZWxzZSBpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBuKXtmb3Iobz0tMSxkPW4ubGVuZ3RoLTE7MDw9ZDtkLS0paWYobltkXT09PXR8fG5bZF0ubGlzdGVuZXI9PT10KXtzPW5bZF0ubGlzdGVuZXIsbz1kO2JyZWFrfWlmKDA+bylyZXR1cm4gdGhpczswPT09bz9uLnNoaWZ0KCk6cChuLG8pLDE9PT1uLmxlbmd0aCYmKHJbZV09blswXSksdm9pZCAwIT09ci5yZW1vdmVMaXN0ZW5lciYmdGhpcy5lbWl0KFwicmVtb3ZlTGlzdGVuZXJcIixlLHN8fHQpfXJldHVybiB0aGlzfSxyLnByb3RvdHlwZS5vZmY9ci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIsci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3ZhciB0LG4scjtpZihuPXRoaXMuX2V2ZW50cyx2b2lkIDA9PT1uKXJldHVybiB0aGlzO2lmKHZvaWQgMD09PW4ucmVtb3ZlTGlzdGVuZXIpcmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoPyh0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wKTp2b2lkIDAhPT1uW2VdJiYoMD09LS10aGlzLl9ldmVudHNDb3VudD90aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKTpkZWxldGUgbltlXSksdGhpcztpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGEsbz1PYmplY3Qua2V5cyhuKTtmb3Iocj0wO3I8by5sZW5ndGg7KytyKWE9b1tyXSxcInJlbW92ZUxpc3RlbmVyXCIhPT1hJiZ0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhhKTtyZXR1cm4gdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZW1vdmVMaXN0ZW5lclwiKSx0aGlzLl9ldmVudHM9T2JqZWN0LmNyZWF0ZShudWxsKSx0aGlzLl9ldmVudHNDb3VudD0wLHRoaXN9aWYodD1uW2VdLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQpdGhpcy5yZW1vdmVMaXN0ZW5lcihlLHQpO2Vsc2UgaWYodm9pZCAwIT09dClmb3Iocj10Lmxlbmd0aC0xOzA8PXI7ci0tKXRoaXMucmVtb3ZlTGlzdGVuZXIoZSx0W3JdKTtyZXR1cm4gdGhpc30sci5wcm90b3R5cGUubGlzdGVuZXJzPWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMsZSwhMCl9LHIucHJvdG90eXBlLnJhd0xpc3RlbmVycz1mdW5jdGlvbihlKXtyZXR1cm4gbCh0aGlzLGUsITEpfSxyLmxpc3RlbmVyQ291bnQ9ZnVuY3Rpb24oZSx0KXtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlLmxpc3RlbmVyQ291bnQ/ZS5saXN0ZW5lckNvdW50KHQpOmMuY2FsbChlLHQpfSxyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50PWMsci5wcm90b3R5cGUuZXZlbnROYW1lcz1mdW5jdGlvbigpe3JldHVybiAwPHRoaXMuX2V2ZW50c0NvdW50P2godGhpcy5fZXZlbnRzKTpbXX19LHt9XSw4OltmdW5jdGlvbihlLHQpe3QuZXhwb3J0cz1mdW5jdGlvbigpe2lmKFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWxUaGlzKXJldHVybiBudWxsO3ZhciBlPXtSVENQZWVyQ29ubmVjdGlvbjpnbG9iYWxUaGlzLlJUQ1BlZXJDb25uZWN0aW9ufHxnbG9iYWxUaGlzLm1velJUQ1BlZXJDb25uZWN0aW9ufHxnbG9iYWxUaGlzLndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLFJUQ1Nlc3Npb25EZXNjcmlwdGlvbjpnbG9iYWxUaGlzLlJUQ1Nlc3Npb25EZXNjcmlwdGlvbnx8Z2xvYmFsVGhpcy5tb3pSVENTZXNzaW9uRGVzY3JpcHRpb258fGdsb2JhbFRoaXMud2Via2l0UlRDU2Vzc2lvbkRlc2NyaXB0aW9uLFJUQ0ljZUNhbmRpZGF0ZTpnbG9iYWxUaGlzLlJUQ0ljZUNhbmRpZGF0ZXx8Z2xvYmFsVGhpcy5tb3pSVENJY2VDYW5kaWRhdGV8fGdsb2JhbFRoaXMud2Via2l0UlRDSWNlQ2FuZGlkYXRlfTtyZXR1cm4gZS5SVENQZWVyQ29ubmVjdGlvbj9lOm51bGx9fSx7fV0sOTpbZnVuY3Rpb24oZSxhLG8pey8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovby5yZWFkPWZ1bmN0aW9uKHQsbixhLG8sbCl7dmFyIGMsdSxwPTgqbC1vLTEsZj0oMTw8cCktMSxnPWY+PjEsXz0tNyxoPWE/bC0xOjAsYj1hPy0xOjEsZD10W24raF07Zm9yKGgrPWIsYz1kJigxPDwtXyktMSxkPj49LV8sXys9cDswPF87Yz0yNTYqYyt0W24raF0saCs9YixfLT04KTtmb3IodT1jJigxPDwtXyktMSxjPj49LV8sXys9bzswPF87dT0yNTYqdSt0W24raF0saCs9YixfLT04KTtpZigwPT09YyljPTEtZztlbHNle2lmKGM9PT1mKXJldHVybiB1P05hTjooZD8tMToxKSooMS8wKTt1Kz1yKDIsbyksYy09Z31yZXR1cm4oZD8tMToxKSp1KnIoMixjLW8pfSxvLndyaXRlPWZ1bmN0aW9uKGEsbyxsLHUscCxmKXt2YXIgaCxiLHksZz1NYXRoLkxOMixfPU1hdGgubG9nLEM9OCpmLXAtMSxSPSgxPDxDKS0xLEU9Uj4+MSx3PTIzPT09cD9yKDIsLTI0KS1yKDIsLTc3KTowLFM9dT8wOmYtMSxUPXU/MTotMSxkPTA+b3x8MD09PW8mJjA+MS9vPzE6MDtmb3Iobz1uKG8pLGlzTmFOKG8pfHxvPT09MS8wPyhiPWlzTmFOKG8pPzE6MCxoPVIpOihoPXQoXyhvKS9nKSwxPm8qKHk9cigyLC1oKSkmJihoLS0seSo9Miksbys9MTw9aCtFP3cveTp3KnIoMiwxLUUpLDI8PW8qeSYmKGgrKyx5Lz0yKSxoK0U+PVI/KGI9MCxoPVIpOjE8PWgrRT8oYj0obyp5LTEpKnIoMixwKSxoKz1FKTooYj1vKnIoMixFLTEpKnIoMixwKSxoPTApKTs4PD1wO2FbbCtTXT0yNTUmYixTKz1ULGIvPTI1NixwLT04KTtmb3IoaD1oPDxwfGIsQys9cDswPEM7YVtsK1NdPTI1NSZoLFMrPVQsaC89MjU2LEMtPTgpO2FbbCtTLVRdfD0xMjgqZH19LHt9XSwxMDpbZnVuY3Rpb24oZSx0KXt0LmV4cG9ydHM9XCJmdW5jdGlvblwiPT10eXBlb2YgT2JqZWN0LmNyZWF0ZT9mdW5jdGlvbihlLHQpe3QmJihlLnN1cGVyXz10LGUucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUse2NvbnN0cnVjdG9yOnt2YWx1ZTplLGVudW1lcmFibGU6ITEsd3JpdGFibGU6ITAsY29uZmlndXJhYmxlOiEwfX0pKX06ZnVuY3Rpb24oZSx0KXtpZih0KXtlLnN1cGVyXz10O3ZhciBuPWZ1bmN0aW9uKCl7fTtuLnByb3RvdHlwZT10LnByb3RvdHlwZSxlLnByb3RvdHlwZT1uZXcgbixlLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1lfX19LHt9XSwxMTpbZnVuY3Rpb24oZSx0KXt2YXIgcj1NYXRoLnJvdW5kO2Z1bmN0aW9uIGEoZSl7aWYoZSs9XCJcIiwhKDEwMDxlLmxlbmd0aCkpe3ZhciB0PS9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhlKTtpZih0KXt2YXIgcj1wYXJzZUZsb2F0KHRbMV0pLG49KHRbMl18fFwibXNcIikudG9Mb3dlckNhc2UoKTtyZXR1cm5cInllYXJzXCI9PT1ufHxcInllYXJcIj09PW58fFwieXJzXCI9PT1ufHxcInlyXCI9PT1ufHxcInlcIj09PW4/MzE1NTc2MDAwMDAqcjpcIndlZWtzXCI9PT1ufHxcIndlZWtcIj09PW58fFwid1wiPT09bj82MDQ4MDAwMDAqcjpcImRheXNcIj09PW58fFwiZGF5XCI9PT1ufHxcImRcIj09PW4/ODY0MDAwMDAqcjpcImhvdXJzXCI9PT1ufHxcImhvdXJcIj09PW58fFwiaHJzXCI9PT1ufHxcImhyXCI9PT1ufHxcImhcIj09PW4/MzYwMDAwMCpyOlwibWludXRlc1wiPT09bnx8XCJtaW51dGVcIj09PW58fFwibWluc1wiPT09bnx8XCJtaW5cIj09PW58fFwibVwiPT09bj82MDAwMCpyOlwic2Vjb25kc1wiPT09bnx8XCJzZWNvbmRcIj09PW58fFwic2Vjc1wiPT09bnx8XCJzZWNcIj09PW58fFwic1wiPT09bj8xMDAwKnI6XCJtaWxsaXNlY29uZHNcIj09PW58fFwibWlsbGlzZWNvbmRcIj09PW58fFwibXNlY3NcIj09PW58fFwibXNlY1wiPT09bnx8XCJtc1wiPT09bj9yOnZvaWQgMH19fWZ1bmN0aW9uIG8oZSl7dmFyIHQ9bihlKTtyZXR1cm4gODY0MDAwMDA8PXQ/cihlLzg2NDAwMDAwKStcImRcIjozNjAwMDAwPD10P3IoZS8zNjAwMDAwKStcImhcIjo2MDAwMDw9dD9yKGUvNjAwMDApK1wibVwiOjEwMDA8PXQ/cihlLzEwMDApK1wic1wiOmUrXCJtc1wifWZ1bmN0aW9uIGkoZSl7dmFyIHQ9bihlKTtyZXR1cm4gODY0MDAwMDA8PXQ/cyhlLHQsODY0MDAwMDAsXCJkYXlcIik6MzYwMDAwMDw9dD9zKGUsdCwzNjAwMDAwLFwiaG91clwiKTo2MDAwMDw9dD9zKGUsdCw2MDAwMCxcIm1pbnV0ZVwiKToxMDAwPD10P3MoZSx0LDEwMDAsXCJzZWNvbmRcIik6ZStcIiBtc1wifWZ1bmN0aW9uIHMoZSx0LGEsbil7cmV0dXJuIHIoZS9hKStcIiBcIituKyh0Pj0xLjUqYT9cInNcIjpcIlwiKX12YXIgbD0yNCooNjAqNjAwMDApO3QuZXhwb3J0cz1mdW5jdGlvbihlLHQpe3Q9dHx8e307dmFyIG49dHlwZW9mIGU7aWYoXCJzdHJpbmdcIj09biYmMDxlLmxlbmd0aClyZXR1cm4gYShlKTtpZihcIm51bWJlclwiPT09biYmaXNGaW5pdGUoZSkpcmV0dXJuIHQubG9uZz9pKGUpOm8oZSk7dGhyb3cgbmV3IEVycm9yKFwidmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD1cIitKU09OLnN0cmluZ2lmeShlKSl9fSx7fV0sMTI6W2Z1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gbigpe3Rocm93IG5ldyBFcnJvcihcInNldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWRcIil9ZnVuY3Rpb24gcigpe3Rocm93IG5ldyBFcnJvcihcImNsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZFwiKX1mdW5jdGlvbiBhKHQpe2lmKGM9PT1zZXRUaW1lb3V0KXJldHVybiBzZXRUaW1lb3V0KHQsMCk7aWYoKGM9PT1ufHwhYykmJnNldFRpbWVvdXQpcmV0dXJuIGM9c2V0VGltZW91dCxzZXRUaW1lb3V0KHQsMCk7dHJ5e3JldHVybiBjKHQsMCl9Y2F0Y2gobil7dHJ5e3JldHVybiBjLmNhbGwobnVsbCx0LDApfWNhdGNoKG4pe3JldHVybiBjLmNhbGwodGhpcyx0LDApfX19ZnVuY3Rpb24gbyh0KXtpZih1PT09Y2xlYXJUaW1lb3V0KXJldHVybiBjbGVhclRpbWVvdXQodCk7aWYoKHU9PT1yfHwhdSkmJmNsZWFyVGltZW91dClyZXR1cm4gdT1jbGVhclRpbWVvdXQsY2xlYXJUaW1lb3V0KHQpO3RyeXtyZXR1cm4gdSh0KX1jYXRjaChuKXt0cnl7cmV0dXJuIHUuY2FsbChudWxsLHQpfWNhdGNoKG4pe3JldHVybiB1LmNhbGwodGhpcyx0KX19fWZ1bmN0aW9uIGkoKXtfJiZmJiYoXz0hMSxmLmxlbmd0aD9nPWYuY29uY2F0KGcpOmg9LTEsZy5sZW5ndGgmJmQoKSl9ZnVuY3Rpb24gZCgpe2lmKCFfKXt2YXIgZT1hKGkpO189ITA7Zm9yKHZhciB0PWcubGVuZ3RoO3Q7KXtmb3IoZj1nLGc9W107KytoPHQ7KWYmJmZbaF0ucnVuKCk7aD0tMSx0PWcubGVuZ3RofWY9bnVsbCxfPSExLG8oZSl9fWZ1bmN0aW9uIHMoZSx0KXt0aGlzLmZ1bj1lLHRoaXMuYXJyYXk9dH1mdW5jdGlvbiBsKCl7fXZhciBjLHUscD10LmV4cG9ydHM9e307KGZ1bmN0aW9uKCl7dHJ5e2M9XCJmdW5jdGlvblwiPT10eXBlb2Ygc2V0VGltZW91dD9zZXRUaW1lb3V0Om59Y2F0Y2godCl7Yz1ufXRyeXt1PVwiZnVuY3Rpb25cIj09dHlwZW9mIGNsZWFyVGltZW91dD9jbGVhclRpbWVvdXQ6cn1jYXRjaCh0KXt1PXJ9fSkoKTt2YXIgZixnPVtdLF89ITEsaD0tMTtwLm5leHRUaWNrPWZ1bmN0aW9uKGUpe3ZhciB0PUFycmF5KGFyZ3VtZW50cy5sZW5ndGgtMSk7aWYoMTxhcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgbj0xO248YXJndW1lbnRzLmxlbmd0aDtuKyspdFtuLTFdPWFyZ3VtZW50c1tuXTtnLnB1c2gobmV3IHMoZSx0KSksMSE9PWcubGVuZ3RofHxffHxhKGQpfSxzLnByb3RvdHlwZS5ydW49ZnVuY3Rpb24oKXt0aGlzLmZ1bi5hcHBseShudWxsLHRoaXMuYXJyYXkpfSxwLnRpdGxlPVwiYnJvd3NlclwiLHAuYnJvd3Nlcj0hMCxwLmVudj17fSxwLmFyZ3Y9W10scC52ZXJzaW9uPVwiXCIscC52ZXJzaW9ucz17fSxwLm9uPWwscC5hZGRMaXN0ZW5lcj1sLHAub25jZT1sLHAub2ZmPWwscC5yZW1vdmVMaXN0ZW5lcj1sLHAucmVtb3ZlQWxsTGlzdGVuZXJzPWwscC5lbWl0PWwscC5wcmVwZW5kTGlzdGVuZXI9bCxwLnByZXBlbmRPbmNlTGlzdGVuZXI9bCxwLmxpc3RlbmVycz1mdW5jdGlvbigpe3JldHVybltdfSxwLmJpbmRpbmc9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZFwiKX0scC5jd2Q9ZnVuY3Rpb24oKXtyZXR1cm5cIi9cIn0scC5jaGRpcj1mdW5jdGlvbigpe3Rocm93IG5ldyBFcnJvcihcInByb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZFwiKX0scC51bWFzaz1mdW5jdGlvbigpe3JldHVybiAwfX0se31dLDEzOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihlKXsoZnVuY3Rpb24oKXsvKiEgcXVldWUtbWljcm90YXNrLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovbGV0IG47dC5leHBvcnRzPVwiZnVuY3Rpb25cIj09dHlwZW9mIHF1ZXVlTWljcm90YXNrP3F1ZXVlTWljcm90YXNrLmJpbmQoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz9lOndpbmRvdyk6ZT0+KG58fChuPVByb21pc2UucmVzb2x2ZSgpKSkudGhlbihlKS5jYXRjaChlPT5zZXRUaW1lb3V0KCgpPT57dGhyb3cgZX0sMCkpfSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxcInVuZGVmaW5lZFwiPT10eXBlb2YgZ2xvYmFsP1widW5kZWZpbmVkXCI9PXR5cGVvZiBzZWxmP1widW5kZWZpbmVkXCI9PXR5cGVvZiB3aW5kb3c/e306d2luZG93OnNlbGY6Z2xvYmFsKX0se31dLDE0OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0Jzt2YXIgYT1lKFwic2FmZS1idWZmZXJcIikuQnVmZmVyLG89ci5jcnlwdG98fHIubXNDcnlwdG87dC5leHBvcnRzPW8mJm8uZ2V0UmFuZG9tVmFsdWVzP2Z1bmN0aW9uKGUsdCl7aWYoZT40Mjk0OTY3Mjk1KXRocm93IG5ldyBSYW5nZUVycm9yKFwicmVxdWVzdGVkIHRvbyBtYW55IHJhbmRvbSBieXRlc1wiKTt2YXIgcj1hLmFsbG9jVW5zYWZlKGUpO2lmKDA8ZSlpZig2NTUzNjxlKWZvcih2YXIgaT0wO2k8ZTtpKz02NTUzNilvLmdldFJhbmRvbVZhbHVlcyhyLnNsaWNlKGksaSs2NTUzNikpO2Vsc2Ugby5nZXRSYW5kb21WYWx1ZXMocik7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgdD9uLm5leHRUaWNrKGZ1bmN0aW9uKCl7dChudWxsLHIpfSk6cn06ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRXJyb3IoXCJTZWN1cmUgcmFuZG9tIG51bWJlciBnZW5lcmF0aW9uIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlxcblVzZSBDaHJvbWUsIEZpcmVmb3ggb3IgSW50ZXJuZXQgRXhwbG9yZXIgMTFcIil9fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHtfcHJvY2VzczoxMixcInNhZmUtYnVmZmVyXCI6MzB9XSwxNTpbZnVuY3Rpb24oZSx0KXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gbihlLHQpe2UucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodC5wcm90b3R5cGUpLGUucHJvdG90eXBlLmNvbnN0cnVjdG9yPWUsZS5fX3Byb3RvX189dH1mdW5jdGlvbiByKGUsdCxyKXtmdW5jdGlvbiBhKGUsbixyKXtyZXR1cm5cInN0cmluZ1wiPT10eXBlb2YgdD90OnQoZSxuLHIpfXJ8fChyPUVycm9yKTt2YXIgbz1mdW5jdGlvbihlKXtmdW5jdGlvbiB0KHQsbixyKXtyZXR1cm4gZS5jYWxsKHRoaXMsYSh0LG4scikpfHx0aGlzfXJldHVybiBuKHQsZSksdH0ocik7by5wcm90b3R5cGUubmFtZT1yLm5hbWUsby5wcm90b3R5cGUuY29kZT1lLHNbZV09b31mdW5jdGlvbiBhKGUsdCl7aWYoQXJyYXkuaXNBcnJheShlKSl7dmFyIG49ZS5sZW5ndGg7cmV0dXJuIGU9ZS5tYXAoZnVuY3Rpb24oZSl7cmV0dXJuIGUrXCJcIn0pLDI8bj9cIm9uZSBvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUuc2xpY2UoMCxuLTEpLmpvaW4oXCIsIFwiKSxcIiwgb3IgXCIpK2Vbbi0xXToyPT09bj9cIm9uZSBvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGVbMF0sXCIgb3IgXCIpLmNvbmNhdChlWzFdKTpcIm9mIFwiLmNvbmNhdCh0LFwiIFwiKS5jb25jYXQoZVswXSl9cmV0dXJuXCJvZiBcIi5jb25jYXQodCxcIiBcIikuY29uY2F0KGUrXCJcIil9ZnVuY3Rpb24gbyhlLHQsbil7cmV0dXJuIGUuc3Vic3RyKCFufHwwPm4/MDorbix0Lmxlbmd0aCk9PT10fWZ1bmN0aW9uIGkoZSx0LG4pe3JldHVybih2b2lkIDA9PT1ufHxuPmUubGVuZ3RoKSYmKG49ZS5sZW5ndGgpLGUuc3Vic3RyaW5nKG4tdC5sZW5ndGgsbik9PT10fWZ1bmN0aW9uIGQoZSx0LG4pe3JldHVyblwibnVtYmVyXCIhPXR5cGVvZiBuJiYobj0wKSwhKG4rdC5sZW5ndGg+ZS5sZW5ndGgpJiYtMSE9PWUuaW5kZXhPZih0LG4pfXZhciBzPXt9O3IoXCJFUlJfSU5WQUxJRF9PUFRfVkFMVUVcIixmdW5jdGlvbihlLHQpe3JldHVyblwiVGhlIHZhbHVlIFxcXCJcIit0K1wiXFxcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXFxcIlwiK2UrXCJcXFwiXCJ9LFR5cGVFcnJvcikscihcIkVSUl9JTlZBTElEX0FSR19UWVBFXCIsZnVuY3Rpb24oZSx0LG4pe3ZhciByO1wic3RyaW5nXCI9PXR5cGVvZiB0JiZvKHQsXCJub3QgXCIpPyhyPVwibXVzdCBub3QgYmVcIix0PXQucmVwbGFjZSgvXm5vdCAvLFwiXCIpKTpyPVwibXVzdCBiZVwiO3ZhciBzO2lmKGkoZSxcIiBhcmd1bWVudFwiKSlzPVwiVGhlIFwiLmNvbmNhdChlLFwiIFwiKS5jb25jYXQocixcIiBcIikuY29uY2F0KGEodCxcInR5cGVcIikpO2Vsc2V7dmFyIGw9ZChlLFwiLlwiKT9cInByb3BlcnR5XCI6XCJhcmd1bWVudFwiO3M9XCJUaGUgXFxcIlwiLmNvbmNhdChlLFwiXFxcIiBcIikuY29uY2F0KGwsXCIgXCIpLmNvbmNhdChyLFwiIFwiKS5jb25jYXQoYSh0LFwidHlwZVwiKSl9cmV0dXJuIHMrPVwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2Ygbiksc30sVHlwZUVycm9yKSxyKFwiRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRlwiLFwic3RyZWFtLnB1c2goKSBhZnRlciBFT0ZcIikscihcIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEXCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJUaGUgXCIrZStcIiBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkXCJ9KSxyKFwiRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0VcIixcIlByZW1hdHVyZSBjbG9zZVwiKSxyKFwiRVJSX1NUUkVBTV9ERVNUUk9ZRURcIixmdW5jdGlvbihlKXtyZXR1cm5cIkNhbm5vdCBjYWxsIFwiK2UrXCIgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZFwifSkscihcIkVSUl9NVUxUSVBMRV9DQUxMQkFDS1wiLFwiQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzXCIpLHIoXCJFUlJfU1RSRUFNX0NBTk5PVF9QSVBFXCIsXCJDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlXCIpLHIoXCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORFwiLFwid3JpdGUgYWZ0ZXIgZW5kXCIpLHIoXCJFUlJfU1RSRUFNX05VTExfVkFMVUVTXCIsXCJNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbVwiLFR5cGVFcnJvcikscihcIkVSUl9VTktOT1dOX0VOQ09ESU5HXCIsZnVuY3Rpb24oZSl7cmV0dXJuXCJVbmtub3duIGVuY29kaW5nOiBcIitlfSxUeXBlRXJyb3IpLHIoXCJFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UXCIsXCJzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudFwiKSx0LmV4cG9ydHMuY29kZXM9c30se31dLDE2OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIHI/dm9pZChkLmNhbGwodGhpcyxlKSxzLmNhbGwodGhpcyxlKSx0aGlzLmFsbG93SGFsZk9wZW49ITAsZSYmKCExPT09ZS5yZWFkYWJsZSYmKHRoaXMucmVhZGFibGU9ITEpLCExPT09ZS53cml0YWJsZSYmKHRoaXMud3JpdGFibGU9ITEpLCExPT09ZS5hbGxvd0hhbGZPcGVuJiYodGhpcy5hbGxvd0hhbGZPcGVuPSExLHRoaXMub25jZShcImVuZFwiLGEpKSkpOm5ldyByKGUpfWZ1bmN0aW9uIGEoKXt0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkfHxuLm5leHRUaWNrKG8sdGhpcyl9ZnVuY3Rpb24gbyhlKXtlLmVuZCgpfXZhciBpPU9iamVjdC5rZXlzfHxmdW5jdGlvbihlKXt2YXIgdD1bXTtmb3IodmFyIG4gaW4gZSl0LnB1c2gobik7cmV0dXJuIHR9O3QuZXhwb3J0cz1yO3ZhciBkPWUoXCIuL19zdHJlYW1fcmVhZGFibGVcIikscz1lKFwiLi9fc3RyZWFtX3dyaXRhYmxlXCIpO2UoXCJpbmhlcml0c1wiKShyLGQpO2Zvcih2YXIgbCxjPWkocy5wcm90b3R5cGUpLHU9MDt1PGMubGVuZ3RoO3UrKylsPWNbdV0sci5wcm90b3R5cGVbbF18fChyLnByb3RvdHlwZVtsXT1zLnByb3RvdHlwZVtsXSk7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIucHJvdG90eXBlLFwid3JpdGFibGVIaWdoV2F0ZXJNYXJrXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFya319KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoci5wcm90b3R5cGUsXCJ3cml0YWJsZUJ1ZmZlclwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSxcIndyaXRhYmxlTGVuZ3RoXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RofX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyLnByb3RvdHlwZSxcImRlc3Ryb3llZFwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB2b2lkIDAhPT10aGlzLl9yZWFkYWJsZVN0YXRlJiZ2b2lkIDAhPT10aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt2b2lkIDA9PT10aGlzLl9yZWFkYWJsZVN0YXRlfHx2b2lkIDA9PT10aGlzLl93cml0YWJsZVN0YXRlfHwodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSx0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD1lKX19KX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpKX0se1wiLi9fc3RyZWFtX3JlYWRhYmxlXCI6MTgsXCIuL19zdHJlYW1fd3JpdGFibGVcIjoyMCxfcHJvY2VzczoxMixpbmhlcml0czoxMH1dLDE3OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3JldHVybiB0aGlzIGluc3RhbmNlb2Ygbj92b2lkIHIuY2FsbCh0aGlzLGUpOm5ldyBuKGUpfXQuZXhwb3J0cz1uO3ZhciByPWUoXCIuL19zdHJlYW1fdHJhbnNmb3JtXCIpO2UoXCJpbmhlcml0c1wiKShuLHIpLG4ucHJvdG90eXBlLl90cmFuc2Zvcm09ZnVuY3Rpb24oZSx0LG4pe24obnVsbCxlKX19LHtcIi4vX3N0cmVhbV90cmFuc2Zvcm1cIjoxOSxpbmhlcml0czoxMH1dLDE4OltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBhKGUpe3JldHVybiBQLmZyb20oZSl9ZnVuY3Rpb24gbyhlKXtyZXR1cm4gUC5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIE19ZnVuY3Rpb24gaShlLHQsbil7cmV0dXJuXCJmdW5jdGlvblwiPT10eXBlb2YgZS5wcmVwZW5kTGlzdGVuZXI/ZS5wcmVwZW5kTGlzdGVuZXIodCxuKTp2b2lkKGUuX2V2ZW50cyYmZS5fZXZlbnRzW3RdP0FycmF5LmlzQXJyYXkoZS5fZXZlbnRzW3RdKT9lLl9ldmVudHNbdF0udW5zaGlmdChuKTplLl9ldmVudHNbdF09W24sZS5fZXZlbnRzW3RdXTplLm9uKHQsbikpfWZ1bmN0aW9uIGQodCxuLHIpe0E9QXx8ZShcIi4vX3N0cmVhbV9kdXBsZXhcIiksdD10fHx7fSxcImJvb2xlYW5cIiE9dHlwZW9mIHImJihyPW4gaW5zdGFuY2VvZiBBKSx0aGlzLm9iamVjdE1vZGU9ISF0Lm9iamVjdE1vZGUsciYmKHRoaXMub2JqZWN0TW9kZT10aGlzLm9iamVjdE1vZGV8fCEhdC5yZWFkYWJsZU9iamVjdE1vZGUpLHRoaXMuaGlnaFdhdGVyTWFyaz1IKHRoaXMsdCxcInJlYWRhYmxlSGlnaFdhdGVyTWFya1wiLHIpLHRoaXMuYnVmZmVyPW5ldyBqLHRoaXMubGVuZ3RoPTAsdGhpcy5waXBlcz1udWxsLHRoaXMucGlwZXNDb3VudD0wLHRoaXMuZmxvd2luZz1udWxsLHRoaXMuZW5kZWQ9ITEsdGhpcy5lbmRFbWl0dGVkPSExLHRoaXMucmVhZGluZz0hMSx0aGlzLnN5bmM9ITAsdGhpcy5uZWVkUmVhZGFibGU9ITEsdGhpcy5lbWl0dGVkUmVhZGFibGU9ITEsdGhpcy5yZWFkYWJsZUxpc3RlbmluZz0hMSx0aGlzLnJlc3VtZVNjaGVkdWxlZD0hMSx0aGlzLnBhdXNlZD0hMCx0aGlzLmVtaXRDbG9zZT0hMSE9PXQuZW1pdENsb3NlLHRoaXMuYXV0b0Rlc3Ryb3k9ISF0LmF1dG9EZXN0cm95LHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVmYXVsdEVuY29kaW5nPXQuZGVmYXVsdEVuY29kaW5nfHxcInV0ZjhcIix0aGlzLmF3YWl0RHJhaW49MCx0aGlzLnJlYWRpbmdNb3JlPSExLHRoaXMuZGVjb2Rlcj1udWxsLHRoaXMuZW5jb2Rpbmc9bnVsbCx0LmVuY29kaW5nJiYoIUYmJihGPWUoXCJzdHJpbmdfZGVjb2Rlci9cIikuU3RyaW5nRGVjb2RlciksdGhpcy5kZWNvZGVyPW5ldyBGKHQuZW5jb2RpbmcpLHRoaXMuZW5jb2Rpbmc9dC5lbmNvZGluZyl9ZnVuY3Rpb24gcyh0KXtpZihBPUF8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpLCEodGhpcyBpbnN0YW5jZW9mIHMpKXJldHVybiBuZXcgcyh0KTt2YXIgbj10aGlzIGluc3RhbmNlb2YgQTt0aGlzLl9yZWFkYWJsZVN0YXRlPW5ldyBkKHQsdGhpcyxuKSx0aGlzLnJlYWRhYmxlPSEwLHQmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnJlYWQmJih0aGlzLl9yZWFkPXQucmVhZCksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiYodGhpcy5fZGVzdHJveT10LmRlc3Ryb3kpKSxJLmNhbGwodGhpcyl9ZnVuY3Rpb24gbChlLHQsbixyLG8pe3goXCJyZWFkYWJsZUFkZENodW5rXCIsdCk7dmFyIGk9ZS5fcmVhZGFibGVTdGF0ZTtpZihudWxsPT09dClpLnJlYWRpbmc9ITEsZyhlLGkpO2Vsc2V7dmFyIGQ7aWYob3x8KGQ9dShpLHQpKSxkKVgoZSxkKTtlbHNlIGlmKCEoaS5vYmplY3RNb2RlfHx0JiYwPHQubGVuZ3RoKSlyfHwoaS5yZWFkaW5nPSExLG0oZSxpKSk7ZWxzZSBpZihcInN0cmluZ1wiPT10eXBlb2YgdHx8aS5vYmplY3RNb2RlfHxPYmplY3QuZ2V0UHJvdG90eXBlT2YodCk9PT1QLnByb3RvdHlwZXx8KHQ9YSh0KSkscilpLmVuZEVtaXR0ZWQ/WChlLG5ldyBLKTpjKGUsaSx0LCEwKTtlbHNlIGlmKGkuZW5kZWQpWChlLG5ldyB6KTtlbHNle2lmKGkuZGVzdHJveWVkKXJldHVybiExO2kucmVhZGluZz0hMSxpLmRlY29kZXImJiFuPyh0PWkuZGVjb2Rlci53cml0ZSh0KSxpLm9iamVjdE1vZGV8fDAhPT10Lmxlbmd0aD9jKGUsaSx0LCExKTptKGUsaSkpOmMoZSxpLHQsITEpfX1yZXR1cm4haS5lbmRlZCYmKGkubGVuZ3RoPGkuaGlnaFdhdGVyTWFya3x8MD09PWkubGVuZ3RoKX1mdW5jdGlvbiBjKGUsdCxuLHIpe3QuZmxvd2luZyYmMD09PXQubGVuZ3RoJiYhdC5zeW5jPyh0LmF3YWl0RHJhaW49MCxlLmVtaXQoXCJkYXRhXCIsbikpOih0Lmxlbmd0aCs9dC5vYmplY3RNb2RlPzE6bi5sZW5ndGgscj90LmJ1ZmZlci51bnNoaWZ0KG4pOnQuYnVmZmVyLnB1c2gobiksdC5uZWVkUmVhZGFibGUmJl8oZSkpLG0oZSx0KX1mdW5jdGlvbiB1KGUsdCl7dmFyIG47cmV0dXJuIG8odCl8fFwic3RyaW5nXCI9PXR5cGVvZiB0fHx2b2lkIDA9PT10fHxlLm9iamVjdE1vZGV8fChuPW5ldyBWKFwiY2h1bmtcIixbXCJzdHJpbmdcIixcIkJ1ZmZlclwiLFwiVWludDhBcnJheVwiXSx0KSksbn1mdW5jdGlvbiBwKGUpe3JldHVybiAxMDczNzQxODI0PD1lP2U9MTA3Mzc0MTgyNDooZS0tLGV8PWU+Pj4xLGV8PWU+Pj4yLGV8PWU+Pj40LGV8PWU+Pj44LGV8PWU+Pj4xNixlKyspLGV9ZnVuY3Rpb24gZihlLHQpe3JldHVybiAwPj1lfHwwPT09dC5sZW5ndGgmJnQuZW5kZWQ/MDp0Lm9iamVjdE1vZGU/MTplPT09ZT8oZT50LmhpZ2hXYXRlck1hcmsmJih0LmhpZ2hXYXRlck1hcms9cChlKSksZTw9dC5sZW5ndGg/ZTp0LmVuZGVkP3QubGVuZ3RoOih0Lm5lZWRSZWFkYWJsZT0hMCwwKSk6dC5mbG93aW5nJiZ0Lmxlbmd0aD90LmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoOnQubGVuZ3RofWZ1bmN0aW9uIGcoZSx0KXtpZih4KFwib25Fb2ZDaHVua1wiKSwhdC5lbmRlZCl7aWYodC5kZWNvZGVyKXt2YXIgbj10LmRlY29kZXIuZW5kKCk7biYmbi5sZW5ndGgmJih0LmJ1ZmZlci5wdXNoKG4pLHQubGVuZ3RoKz10Lm9iamVjdE1vZGU/MTpuLmxlbmd0aCl9dC5lbmRlZD0hMCx0LnN5bmM/XyhlKToodC5uZWVkUmVhZGFibGU9ITEsIXQuZW1pdHRlZFJlYWRhYmxlJiYodC5lbWl0dGVkUmVhZGFibGU9ITAsaChlKSkpfX1mdW5jdGlvbiBfKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7eChcImVtaXRSZWFkYWJsZVwiLHQubmVlZFJlYWRhYmxlLHQuZW1pdHRlZFJlYWRhYmxlKSx0Lm5lZWRSZWFkYWJsZT0hMSx0LmVtaXR0ZWRSZWFkYWJsZXx8KHgoXCJlbWl0UmVhZGFibGVcIix0LmZsb3dpbmcpLHQuZW1pdHRlZFJlYWRhYmxlPSEwLG4ubmV4dFRpY2soaCxlKSl9ZnVuY3Rpb24gaChlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJlbWl0UmVhZGFibGVfXCIsdC5kZXN0cm95ZWQsdC5sZW5ndGgsdC5lbmRlZCksIXQuZGVzdHJveWVkJiYodC5sZW5ndGh8fHQuZW5kZWQpJiYoZS5lbWl0KFwicmVhZGFibGVcIiksdC5lbWl0dGVkUmVhZGFibGU9ITEpLHQubmVlZFJlYWRhYmxlPSF0LmZsb3dpbmcmJiF0LmVuZGVkJiZ0Lmxlbmd0aDw9dC5oaWdoV2F0ZXJNYXJrLFMoZSl9ZnVuY3Rpb24gbShlLHQpe3QucmVhZGluZ01vcmV8fCh0LnJlYWRpbmdNb3JlPSEwLG4ubmV4dFRpY2soYixlLHQpKX1mdW5jdGlvbiBiKGUsdCl7Zm9yKDshdC5yZWFkaW5nJiYhdC5lbmRlZCYmKHQubGVuZ3RoPHQuaGlnaFdhdGVyTWFya3x8dC5mbG93aW5nJiYwPT09dC5sZW5ndGgpOyl7dmFyIG49dC5sZW5ndGg7aWYoeChcIm1heWJlUmVhZE1vcmUgcmVhZCAwXCIpLGUucmVhZCgwKSxuPT09dC5sZW5ndGgpYnJlYWt9dC5yZWFkaW5nTW9yZT0hMX1mdW5jdGlvbiB5KGUpe3JldHVybiBmdW5jdGlvbigpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7eChcInBpcGVPbkRyYWluXCIsdC5hd2FpdERyYWluKSx0LmF3YWl0RHJhaW4mJnQuYXdhaXREcmFpbi0tLDA9PT10LmF3YWl0RHJhaW4mJkQoZSxcImRhdGFcIikmJih0LmZsb3dpbmc9ITAsUyhlKSl9fWZ1bmN0aW9uIEMoZSl7dmFyIHQ9ZS5fcmVhZGFibGVTdGF0ZTt0LnJlYWRhYmxlTGlzdGVuaW5nPTA8ZS5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIiksdC5yZXN1bWVTY2hlZHVsZWQmJiF0LnBhdXNlZD90LmZsb3dpbmc9ITA6MDxlLmxpc3RlbmVyQ291bnQoXCJkYXRhXCIpJiZlLnJlc3VtZSgpfWZ1bmN0aW9uIFIoZSl7eChcInJlYWRhYmxlIG5leHR0aWNrIHJlYWQgMFwiKSxlLnJlYWQoMCl9ZnVuY3Rpb24gRShlLHQpe3QucmVzdW1lU2NoZWR1bGVkfHwodC5yZXN1bWVTY2hlZHVsZWQ9ITAsbi5uZXh0VGljayh3LGUsdCkpfWZ1bmN0aW9uIHcoZSx0KXt4KFwicmVzdW1lXCIsdC5yZWFkaW5nKSx0LnJlYWRpbmd8fGUucmVhZCgwKSx0LnJlc3VtZVNjaGVkdWxlZD0hMSxlLmVtaXQoXCJyZXN1bWVcIiksUyhlKSx0LmZsb3dpbmcmJiF0LnJlYWRpbmcmJmUucmVhZCgwKX1mdW5jdGlvbiBTKGUpe3ZhciB0PWUuX3JlYWRhYmxlU3RhdGU7Zm9yKHgoXCJmbG93XCIsdC5mbG93aW5nKTt0LmZsb3dpbmcmJm51bGwhPT1lLnJlYWQoKTspO31mdW5jdGlvbiBUKGUsdCl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO3ZhciBuO3JldHVybiB0Lm9iamVjdE1vZGU/bj10LmJ1ZmZlci5zaGlmdCgpOiFlfHxlPj10Lmxlbmd0aD8obj10LmRlY29kZXI/dC5idWZmZXIuam9pbihcIlwiKToxPT09dC5idWZmZXIubGVuZ3RoP3QuYnVmZmVyLmZpcnN0KCk6dC5idWZmZXIuY29uY2F0KHQubGVuZ3RoKSx0LmJ1ZmZlci5jbGVhcigpKTpuPXQuYnVmZmVyLmNvbnN1bWUoZSx0LmRlY29kZXIpLG59ZnVuY3Rpb24gdihlKXt2YXIgdD1lLl9yZWFkYWJsZVN0YXRlO3goXCJlbmRSZWFkYWJsZVwiLHQuZW5kRW1pdHRlZCksdC5lbmRFbWl0dGVkfHwodC5lbmRlZD0hMCxuLm5leHRUaWNrKGssdCxlKSl9ZnVuY3Rpb24gayhlLHQpe2lmKHgoXCJlbmRSZWFkYWJsZU5UXCIsZS5lbmRFbWl0dGVkLGUubGVuZ3RoKSwhZS5lbmRFbWl0dGVkJiYwPT09ZS5sZW5ndGgmJihlLmVuZEVtaXR0ZWQ9ITAsdC5yZWFkYWJsZT0hMSx0LmVtaXQoXCJlbmRcIiksZS5hdXRvRGVzdHJveSkpe3ZhciBuPXQuX3dyaXRhYmxlU3RhdGU7KCFufHxuLmF1dG9EZXN0cm95JiZuLmZpbmlzaGVkKSYmdC5kZXN0cm95KCl9fWZ1bmN0aW9uIEwoZSx0KXtmb3IodmFyIG49MCxyPWUubGVuZ3RoO248cjtuKyspaWYoZVtuXT09PXQpcmV0dXJuIG47cmV0dXJuLTF9dC5leHBvcnRzPXM7dmFyIEE7cy5SZWFkYWJsZVN0YXRlPWQ7dmFyIHgsTj1lKFwiZXZlbnRzXCIpLkV2ZW50RW1pdHRlcixEPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGUubGlzdGVuZXJzKHQpLmxlbmd0aH0sST1lKFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiKSxQPWUoXCJidWZmZXJcIikuQnVmZmVyLE09ci5VaW50OEFycmF5fHxmdW5jdGlvbigpe30sTz1lKFwidXRpbFwiKTt4PU8mJk8uZGVidWdsb2c/Ty5kZWJ1Z2xvZyhcInN0cmVhbVwiKTpmdW5jdGlvbigpe307dmFyIEYsQixVLGo9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdFwiKSxxPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiKSxXPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvc3RhdGVcIiksSD1XLmdldEhpZ2hXYXRlck1hcmssWT1lKFwiLi4vZXJyb3JzXCIpLmNvZGVzLFY9WS5FUlJfSU5WQUxJRF9BUkdfVFlQRSx6PVkuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixHPVkuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsSz1ZLkVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQ7ZShcImluaGVyaXRzXCIpKHMsSSk7dmFyIFg9cS5lcnJvck9yRGVzdHJveSwkPVtcImVycm9yXCIsXCJjbG9zZVwiLFwiZGVzdHJveVwiLFwicGF1c2VcIixcInJlc3VtZVwiXTtPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fcmVhZGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSl9fSkscy5wcm90b3R5cGUuZGVzdHJveT1xLmRlc3Ryb3kscy5wcm90b3R5cGUuX3VuZGVzdHJveT1xLnVuZGVzdHJveSxzLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbihlLHQpe3QoZSl9LHMucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24oZSx0KXt2YXIgbixyPXRoaXMuX3JlYWRhYmxlU3RhdGU7cmV0dXJuIHIub2JqZWN0TW9kZT9uPSEwOlwic3RyaW5nXCI9PXR5cGVvZiBlJiYodD10fHxyLmRlZmF1bHRFbmNvZGluZyx0IT09ci5lbmNvZGluZyYmKGU9UC5mcm9tKGUsdCksdD1cIlwiKSxuPSEwKSxsKHRoaXMsZSx0LCExLG4pfSxzLnByb3RvdHlwZS51bnNoaWZ0PWZ1bmN0aW9uKGUpe3JldHVybiBsKHRoaXMsZSxudWxsLCEwLCExKX0scy5wcm90b3R5cGUuaXNQYXVzZWQ9ZnVuY3Rpb24oKXtyZXR1cm4hMT09PXRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZ30scy5wcm90b3R5cGUuc2V0RW5jb2Rpbmc9ZnVuY3Rpb24odCl7Rnx8KEY9ZShcInN0cmluZ19kZWNvZGVyL1wiKS5TdHJpbmdEZWNvZGVyKTt2YXIgbj1uZXcgRih0KTt0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXI9bix0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nPXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZztmb3IodmFyIHI9dGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuaGVhZCxhPVwiXCI7bnVsbCE9PXI7KWErPW4ud3JpdGUoci5kYXRhKSxyPXIubmV4dDtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKSxcIlwiIT09YSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIucHVzaChhKSx0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aD1hLmxlbmd0aCx0aGlzfTtzLnByb3RvdHlwZS5yZWFkPWZ1bmN0aW9uKGUpe3goXCJyZWFkXCIsZSksZT1wYXJzZUludChlLDEwKTt2YXIgdD10aGlzLl9yZWFkYWJsZVN0YXRlLHI9ZTtpZigwIT09ZSYmKHQuZW1pdHRlZFJlYWRhYmxlPSExKSwwPT09ZSYmdC5uZWVkUmVhZGFibGUmJigoMD09PXQuaGlnaFdhdGVyTWFyaz8wPHQubGVuZ3RoOnQubGVuZ3RoPj10LmhpZ2hXYXRlck1hcmspfHx0LmVuZGVkKSlyZXR1cm4geChcInJlYWQ6IGVtaXRSZWFkYWJsZVwiLHQubGVuZ3RoLHQuZW5kZWQpLDA9PT10Lmxlbmd0aCYmdC5lbmRlZD92KHRoaXMpOl8odGhpcyksbnVsbDtpZihlPWYoZSx0KSwwPT09ZSYmdC5lbmRlZClyZXR1cm4gMD09PXQubGVuZ3RoJiZ2KHRoaXMpLG51bGw7dmFyIGE9dC5uZWVkUmVhZGFibGU7eChcIm5lZWQgcmVhZGFibGVcIixhKSwoMD09PXQubGVuZ3RofHx0Lmxlbmd0aC1lPHQuaGlnaFdhdGVyTWFyaykmJihhPSEwLHgoXCJsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFya1wiLGEpKSx0LmVuZGVkfHx0LnJlYWRpbmc/KGE9ITEseChcInJlYWRpbmcgb3IgZW5kZWRcIixhKSk6YSYmKHgoXCJkbyByZWFkXCIpLHQucmVhZGluZz0hMCx0LnN5bmM9ITAsMD09PXQubGVuZ3RoJiYodC5uZWVkUmVhZGFibGU9ITApLHRoaXMuX3JlYWQodC5oaWdoV2F0ZXJNYXJrKSx0LnN5bmM9ITEsIXQucmVhZGluZyYmKGU9ZihyLHQpKSk7dmFyIG87cmV0dXJuIG89MDxlP1QoZSx0KTpudWxsLG51bGw9PT1vPyh0Lm5lZWRSZWFkYWJsZT10Lmxlbmd0aDw9dC5oaWdoV2F0ZXJNYXJrLGU9MCk6KHQubGVuZ3RoLT1lLHQuYXdhaXREcmFpbj0wKSwwPT09dC5sZW5ndGgmJighdC5lbmRlZCYmKHQubmVlZFJlYWRhYmxlPSEwKSxyIT09ZSYmdC5lbmRlZCYmdih0aGlzKSksbnVsbCE9PW8mJnRoaXMuZW1pdChcImRhdGFcIixvKSxvfSxzLnByb3RvdHlwZS5fcmVhZD1mdW5jdGlvbigpe1godGhpcyxuZXcgRyhcIl9yZWFkKClcIikpfSxzLnByb3RvdHlwZS5waXBlPWZ1bmN0aW9uKGUsdCl7ZnVuY3Rpb24gcihlLHQpe3goXCJvbnVucGlwZVwiKSxlPT09cCYmdCYmITE9PT10Lmhhc1VucGlwZWQmJih0Lmhhc1VucGlwZWQ9ITAsbygpKX1mdW5jdGlvbiBhKCl7eChcIm9uZW5kXCIpLGUuZW5kKCl9ZnVuY3Rpb24gbygpe3goXCJjbGVhbnVwXCIpLGUucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGwpLGUucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixjKSxlLnJlbW92ZUxpc3RlbmVyKFwiZHJhaW5cIixoKSxlLnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIixzKSxlLnJlbW92ZUxpc3RlbmVyKFwidW5waXBlXCIscikscC5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGEpLHAucmVtb3ZlTGlzdGVuZXIoXCJlbmRcIix1KSxwLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLGQpLG09ITAsZi5hd2FpdERyYWluJiYoIWUuX3dyaXRhYmxlU3RhdGV8fGUuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSYmaCgpfWZ1bmN0aW9uIGQodCl7eChcIm9uZGF0YVwiKTt2YXIgbj1lLndyaXRlKHQpO3goXCJkZXN0LndyaXRlXCIsbiksITE9PT1uJiYoKDE9PT1mLnBpcGVzQ291bnQmJmYucGlwZXM9PT1lfHwxPGYucGlwZXNDb3VudCYmLTEhPT1MKGYucGlwZXMsZSkpJiYhbSYmKHgoXCJmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2VcIixmLmF3YWl0RHJhaW4pLGYuYXdhaXREcmFpbisrKSxwLnBhdXNlKCkpfWZ1bmN0aW9uIHModCl7eChcIm9uZXJyb3JcIix0KSx1KCksZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIscyksMD09PUQoZSxcImVycm9yXCIpJiZYKGUsdCl9ZnVuY3Rpb24gbCgpe2UucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixjKSx1KCl9ZnVuY3Rpb24gYygpe3goXCJvbmZpbmlzaFwiKSxlLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIixsKSx1KCl9ZnVuY3Rpb24gdSgpe3goXCJ1bnBpcGVcIikscC51bnBpcGUoZSl9dmFyIHA9dGhpcyxmPXRoaXMuX3JlYWRhYmxlU3RhdGU7c3dpdGNoKGYucGlwZXNDb3VudCl7Y2FzZSAwOmYucGlwZXM9ZTticmVhaztjYXNlIDE6Zi5waXBlcz1bZi5waXBlcyxlXTticmVhaztkZWZhdWx0OmYucGlwZXMucHVzaChlKTt9Zi5waXBlc0NvdW50Kz0xLHgoXCJwaXBlIGNvdW50PSVkIG9wdHM9JWpcIixmLnBpcGVzQ291bnQsdCk7dmFyIGc9KCF0fHwhMSE9PXQuZW5kKSYmZSE9PW4uc3Rkb3V0JiZlIT09bi5zdGRlcnIsXz1nP2E6dTtmLmVuZEVtaXR0ZWQ/bi5uZXh0VGljayhfKTpwLm9uY2UoXCJlbmRcIixfKSxlLm9uKFwidW5waXBlXCIscik7dmFyIGg9eShwKTtlLm9uKFwiZHJhaW5cIixoKTt2YXIgbT0hMTtyZXR1cm4gcC5vbihcImRhdGFcIixkKSxpKGUsXCJlcnJvclwiLHMpLGUub25jZShcImNsb3NlXCIsbCksZS5vbmNlKFwiZmluaXNoXCIsYyksZS5lbWl0KFwicGlwZVwiLHApLGYuZmxvd2luZ3x8KHgoXCJwaXBlIHJlc3VtZVwiKSxwLnJlc3VtZSgpKSxlfSxzLnByb3RvdHlwZS51bnBpcGU9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5fcmVhZGFibGVTdGF0ZSxuPXtoYXNVbnBpcGVkOiExfTtpZigwPT09dC5waXBlc0NvdW50KXJldHVybiB0aGlzO2lmKDE9PT10LnBpcGVzQ291bnQpcmV0dXJuIGUmJmUhPT10LnBpcGVzP3RoaXM6KGV8fChlPXQucGlwZXMpLHQucGlwZXM9bnVsbCx0LnBpcGVzQ291bnQ9MCx0LmZsb3dpbmc9ITEsZSYmZS5lbWl0KFwidW5waXBlXCIsdGhpcyxuKSx0aGlzKTtpZighZSl7dmFyIHI9dC5waXBlcyxhPXQucGlwZXNDb3VudDt0LnBpcGVzPW51bGwsdC5waXBlc0NvdW50PTAsdC5mbG93aW5nPSExO2Zvcih2YXIgbz0wO288YTtvKyspcltvXS5lbWl0KFwidW5waXBlXCIsdGhpcyx7aGFzVW5waXBlZDohMX0pO3JldHVybiB0aGlzfXZhciBkPUwodC5waXBlcyxlKTtyZXR1cm4tMT09PWQ/dGhpczoodC5waXBlcy5zcGxpY2UoZCwxKSx0LnBpcGVzQ291bnQtPTEsMT09PXQucGlwZXNDb3VudCYmKHQucGlwZXM9dC5waXBlc1swXSksZS5lbWl0KFwidW5waXBlXCIsdGhpcyxuKSx0aGlzKX0scy5wcm90b3R5cGUub249ZnVuY3Rpb24oZSx0KXt2YXIgcj1JLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsZSx0KSxhPXRoaXMuX3JlYWRhYmxlU3RhdGU7cmV0dXJuXCJkYXRhXCI9PT1lPyhhLnJlYWRhYmxlTGlzdGVuaW5nPTA8dGhpcy5saXN0ZW5lckNvdW50KFwicmVhZGFibGVcIiksITEhPT1hLmZsb3dpbmcmJnRoaXMucmVzdW1lKCkpOlwicmVhZGFibGVcIj09ZSYmIWEuZW5kRW1pdHRlZCYmIWEucmVhZGFibGVMaXN0ZW5pbmcmJihhLnJlYWRhYmxlTGlzdGVuaW5nPWEubmVlZFJlYWRhYmxlPSEwLGEuZmxvd2luZz0hMSxhLmVtaXR0ZWRSZWFkYWJsZT0hMSx4KFwib24gcmVhZGFibGVcIixhLmxlbmd0aCxhLnJlYWRpbmcpLGEubGVuZ3RoP18odGhpcyk6IWEucmVhZGluZyYmbi5uZXh0VGljayhSLHRoaXMpKSxyfSxzLnByb3RvdHlwZS5hZGRMaXN0ZW5lcj1zLnByb3RvdHlwZS5vbixzLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcj1mdW5jdGlvbihlLHQpe3ZhciByPUkucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcyxlLHQpO3JldHVyblwicmVhZGFibGVcIj09PWUmJm4ubmV4dFRpY2soQyx0aGlzKSxyfSxzLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnM9ZnVuY3Rpb24oZSl7dmFyIHQ9SS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtyZXR1cm4oXCJyZWFkYWJsZVwiPT09ZXx8dm9pZCAwPT09ZSkmJm4ubmV4dFRpY2soQyx0aGlzKSx0fSxzLnByb3RvdHlwZS5yZXN1bWU9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl9yZWFkYWJsZVN0YXRlO3JldHVybiBlLmZsb3dpbmd8fCh4KFwicmVzdW1lXCIpLGUuZmxvd2luZz0hZS5yZWFkYWJsZUxpc3RlbmluZyxFKHRoaXMsZSkpLGUucGF1c2VkPSExLHRoaXN9LHMucHJvdG90eXBlLnBhdXNlPWZ1bmN0aW9uKCl7cmV0dXJuIHgoXCJjYWxsIHBhdXNlIGZsb3dpbmc9JWpcIix0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpLCExIT09dGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nJiYoeChcInBhdXNlXCIpLHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZz0hMSx0aGlzLmVtaXQoXCJwYXVzZVwiKSksdGhpcy5fcmVhZGFibGVTdGF0ZS5wYXVzZWQ9ITAsdGhpc30scy5wcm90b3R5cGUud3JhcD1mdW5jdGlvbihlKXt2YXIgdD10aGlzLHI9dGhpcy5fcmVhZGFibGVTdGF0ZSxhPSExO2Zvcih2YXIgbyBpbiBlLm9uKFwiZW5kXCIsZnVuY3Rpb24oKXtpZih4KFwid3JhcHBlZCBlbmRcIiksci5kZWNvZGVyJiYhci5lbmRlZCl7dmFyIGU9ci5kZWNvZGVyLmVuZCgpO2UmJmUubGVuZ3RoJiZ0LnB1c2goZSl9dC5wdXNoKG51bGwpfSksZS5vbihcImRhdGFcIixmdW5jdGlvbihuKXtpZigoeChcIndyYXBwZWQgZGF0YVwiKSxyLmRlY29kZXImJihuPXIuZGVjb2Rlci53cml0ZShuKSksIShyLm9iamVjdE1vZGUmJihudWxsPT09bnx8dm9pZCAwPT09bikpKSYmKHIub2JqZWN0TW9kZXx8biYmbi5sZW5ndGgpKXt2YXIgbz10LnB1c2gobik7b3x8KGE9ITAsZS5wYXVzZSgpKX19KSxlKXZvaWQgMD09PXRoaXNbb10mJlwiZnVuY3Rpb25cIj09dHlwZW9mIGVbb10mJih0aGlzW29dPWZ1bmN0aW9uKHQpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBlW3RdLmFwcGx5KGUsYXJndW1lbnRzKX19KG8pKTtmb3IodmFyIGk9MDtpPCQubGVuZ3RoO2krKyllLm9uKCRbaV0sdGhpcy5lbWl0LmJpbmQodGhpcywkW2ldKSk7cmV0dXJuIHRoaXMuX3JlYWQ9ZnVuY3Rpb24odCl7eChcIndyYXBwZWQgX3JlYWRcIix0KSxhJiYoYT0hMSxlLnJlc3VtZSgpKX0sdGhpc30sXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYocy5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHZvaWQgMD09PUImJihCPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3JcIikpLEIodGhpcyl9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkocy5wcm90b3R5cGUsXCJyZWFkYWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcInJlYWRhYmxlQnVmZmVyXCIse2VudW1lcmFibGU6ITEsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUmJnRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyfX0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcInJlYWRhYmxlRmxvd2luZ1wiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmd9LHNldDpmdW5jdGlvbihlKXt0aGlzLl9yZWFkYWJsZVN0YXRlJiYodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nPWUpfX0pLHMuX2Zyb21MaXN0PVQsT2JqZWN0LmRlZmluZVByb3BlcnR5KHMucHJvdG90eXBlLFwicmVhZGFibGVMZW5ndGhcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGh9fSksXCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiYocy5mcm9tPWZ1bmN0aW9uKHQsbil7cmV0dXJuIHZvaWQgMD09PVUmJihVPWUoXCIuL2ludGVybmFsL3N0cmVhbXMvZnJvbVwiKSksVShzLHQsbil9KX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsZShcIl9wcm9jZXNzXCIpLFwidW5kZWZpbmVkXCI9PXR5cGVvZiBnbG9iYWw/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHNlbGY/XCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdz97fTp3aW5kb3c6c2VsZjpnbG9iYWwpfSx7XCIuLi9lcnJvcnNcIjoxNSxcIi4vX3N0cmVhbV9kdXBsZXhcIjoxNixcIi4vaW50ZXJuYWwvc3RyZWFtcy9hc3luY19pdGVyYXRvclwiOjIxLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0XCI6MjIsXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVwiOjIzLFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb21cIjoyNSxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiOjI3LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjI4LF9wcm9jZXNzOjEyLGJ1ZmZlcjozLGV2ZW50czo3LGluaGVyaXRzOjEwLFwic3RyaW5nX2RlY29kZXIvXCI6MzEsdXRpbDoyfV0sMTk6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXt2YXIgbj10aGlzLl90cmFuc2Zvcm1TdGF0ZTtuLnRyYW5zZm9ybWluZz0hMTt2YXIgcj1uLndyaXRlY2I7aWYobnVsbD09PXIpcmV0dXJuIHRoaXMuZW1pdChcImVycm9yXCIsbmV3IHMpO24ud3JpdGVjaHVuaz1udWxsLG4ud3JpdGVjYj1udWxsLG51bGwhPXQmJnRoaXMucHVzaCh0KSxyKGUpO3ZhciBhPXRoaXMuX3JlYWRhYmxlU3RhdGU7YS5yZWFkaW5nPSExLChhLm5lZWRSZWFkYWJsZXx8YS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrKSYmdGhpcy5fcmVhZChhLmhpZ2hXYXRlck1hcmspfWZ1bmN0aW9uIHIoZSl7cmV0dXJuIHRoaXMgaW5zdGFuY2VvZiByP3ZvaWQodS5jYWxsKHRoaXMsZSksdGhpcy5fdHJhbnNmb3JtU3RhdGU9e2FmdGVyVHJhbnNmb3JtOm4uYmluZCh0aGlzKSxuZWVkVHJhbnNmb3JtOiExLHRyYW5zZm9ybWluZzohMSx3cml0ZWNiOm51bGwsd3JpdGVjaHVuazpudWxsLHdyaXRlZW5jb2Rpbmc6bnVsbH0sdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGU9ITAsdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jPSExLGUmJihcImZ1bmN0aW9uXCI9PXR5cGVvZiBlLnRyYW5zZm9ybSYmKHRoaXMuX3RyYW5zZm9ybT1lLnRyYW5zZm9ybSksXCJmdW5jdGlvblwiPT10eXBlb2YgZS5mbHVzaCYmKHRoaXMuX2ZsdXNoPWUuZmx1c2gpKSx0aGlzLm9uKFwicHJlZmluaXNoXCIsYSkpOm5ldyByKGUpfWZ1bmN0aW9uIGEoKXt2YXIgZT10aGlzO1wiZnVuY3Rpb25cIiE9dHlwZW9mIHRoaXMuX2ZsdXNofHx0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD9vKHRoaXMsbnVsbCxudWxsKTp0aGlzLl9mbHVzaChmdW5jdGlvbih0LG4pe28oZSx0LG4pfSl9ZnVuY3Rpb24gbyhlLHQsbil7aWYodClyZXR1cm4gZS5lbWl0KFwiZXJyb3JcIix0KTtpZihudWxsIT1uJiZlLnB1c2gobiksZS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpdGhyb3cgbmV3IGM7aWYoZS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKXRocm93IG5ldyBsO3JldHVybiBlLnB1c2gobnVsbCl9dC5leHBvcnRzPXI7dmFyIGk9ZShcIi4uL2Vycm9yc1wiKS5jb2RlcyxkPWkuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQscz1pLkVSUl9NVUxUSVBMRV9DQUxMQkFDSyxsPWkuRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyxjPWkuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wLHU9ZShcIi4vX3N0cmVhbV9kdXBsZXhcIik7ZShcImluaGVyaXRzXCIpKHIsdSksci5wcm90b3R5cGUucHVzaD1mdW5jdGlvbihlLHQpe3JldHVybiB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtPSExLHUucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLGUsdCl9LHIucHJvdG90eXBlLl90cmFuc2Zvcm09ZnVuY3Rpb24oZSx0LG4pe24obmV3IGQoXCJfdHJhbnNmb3JtKClcIikpfSxyLnByb3RvdHlwZS5fd3JpdGU9ZnVuY3Rpb24oZSx0LG4pe3ZhciByPXRoaXMuX3RyYW5zZm9ybVN0YXRlO2lmKHIud3JpdGVjYj1uLHIud3JpdGVjaHVuaz1lLHIud3JpdGVlbmNvZGluZz10LCFyLnRyYW5zZm9ybWluZyl7dmFyIGE9dGhpcy5fcmVhZGFibGVTdGF0ZTsoci5uZWVkVHJhbnNmb3JtfHxhLm5lZWRSZWFkYWJsZXx8YS5sZW5ndGg8YS5oaWdoV2F0ZXJNYXJrKSYmdGhpcy5fcmVhZChhLmhpZ2hXYXRlck1hcmspfX0sci5wcm90b3R5cGUuX3JlYWQ9ZnVuY3Rpb24oKXt2YXIgZT10aGlzLl90cmFuc2Zvcm1TdGF0ZTtudWxsPT09ZS53cml0ZWNodW5rfHxlLnRyYW5zZm9ybWluZz9lLm5lZWRUcmFuc2Zvcm09ITA6KGUudHJhbnNmb3JtaW5nPSEwLHRoaXMuX3RyYW5zZm9ybShlLndyaXRlY2h1bmssZS53cml0ZWVuY29kaW5nLGUuYWZ0ZXJUcmFuc2Zvcm0pKX0sci5wcm90b3R5cGUuX2Rlc3Ryb3k9ZnVuY3Rpb24oZSx0KXt1LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsZSxmdW5jdGlvbihlKXt0KGUpfSl9fSx7XCIuLi9lcnJvcnNcIjoxNSxcIi4vX3N0cmVhbV9kdXBsZXhcIjoxNixpbmhlcml0czoxMH1dLDIwOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuLHIpeyhmdW5jdGlvbigpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBhKGUpe3ZhciB0PXRoaXM7dGhpcy5uZXh0PW51bGwsdGhpcy5lbnRyeT1udWxsLHRoaXMuZmluaXNoPWZ1bmN0aW9uKCl7dih0LGUpfX1mdW5jdGlvbiBvKGUpe3JldHVybiB4LmZyb20oZSl9ZnVuY3Rpb24gaShlKXtyZXR1cm4geC5pc0J1ZmZlcihlKXx8ZSBpbnN0YW5jZW9mIE59ZnVuY3Rpb24gZCgpe31mdW5jdGlvbiBzKHQsbixyKXtrPWt8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpLHQ9dHx8e30sXCJib29sZWFuXCIhPXR5cGVvZiByJiYocj1uIGluc3RhbmNlb2YgayksdGhpcy5vYmplY3RNb2RlPSEhdC5vYmplY3RNb2RlLHImJih0aGlzLm9iamVjdE1vZGU9dGhpcy5vYmplY3RNb2RlfHwhIXQud3JpdGFibGVPYmplY3RNb2RlKSx0aGlzLmhpZ2hXYXRlck1hcms9UCh0aGlzLHQsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIixyKSx0aGlzLmZpbmFsQ2FsbGVkPSExLHRoaXMubmVlZERyYWluPSExLHRoaXMuZW5kaW5nPSExLHRoaXMuZW5kZWQ9ITEsdGhpcy5maW5pc2hlZD0hMSx0aGlzLmRlc3Ryb3llZD0hMTt2YXIgbz0hMT09PXQuZGVjb2RlU3RyaW5nczt0aGlzLmRlY29kZVN0cmluZ3M9IW8sdGhpcy5kZWZhdWx0RW5jb2Rpbmc9dC5kZWZhdWx0RW5jb2Rpbmd8fFwidXRmOFwiLHRoaXMubGVuZ3RoPTAsdGhpcy53cml0aW5nPSExLHRoaXMuY29ya2VkPTAsdGhpcy5zeW5jPSEwLHRoaXMuYnVmZmVyUHJvY2Vzc2luZz0hMSx0aGlzLm9ud3JpdGU9ZnVuY3Rpb24oZSl7bShuLGUpfSx0aGlzLndyaXRlY2I9bnVsbCx0aGlzLndyaXRlbGVuPTAsdGhpcy5idWZmZXJlZFJlcXVlc3Q9bnVsbCx0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCx0aGlzLnBlbmRpbmdjYj0wLHRoaXMucHJlZmluaXNoZWQ9ITEsdGhpcy5lcnJvckVtaXR0ZWQ9ITEsdGhpcy5lbWl0Q2xvc2U9ITEhPT10LmVtaXRDbG9zZSx0aGlzLmF1dG9EZXN0cm95PSEhdC5hdXRvRGVzdHJveSx0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50PTAsdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEodGhpcyl9ZnVuY3Rpb24gbCh0KXtrPWt8fGUoXCIuL19zdHJlYW1fZHVwbGV4XCIpO3ZhciBuPXRoaXMgaW5zdGFuY2VvZiBrO3JldHVybiBufHxWLmNhbGwobCx0aGlzKT92b2lkKHRoaXMuX3dyaXRhYmxlU3RhdGU9bmV3IHModCx0aGlzLG4pLHRoaXMud3JpdGFibGU9ITAsdCYmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQud3JpdGUmJih0aGlzLl93cml0ZT10LndyaXRlKSxcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LndyaXRldiYmKHRoaXMuX3dyaXRldj10LndyaXRldiksXCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95JiYodGhpcy5fZGVzdHJveT10LmRlc3Ryb3kpLFwiZnVuY3Rpb25cIj09dHlwZW9mIHQuZmluYWwmJih0aGlzLl9maW5hbD10LmZpbmFsKSksQS5jYWxsKHRoaXMpKTpuZXcgbCh0KX1mdW5jdGlvbiBjKGUsdCl7dmFyIHI9bmV3IFc7WShlLHIpLG4ubmV4dFRpY2sodCxyKX1mdW5jdGlvbiB1KGUsdCxyLGEpe3ZhciBvO3JldHVybiBudWxsPT09cj9vPW5ldyBxOlwic3RyaW5nXCIhPXR5cGVvZiByJiYhdC5vYmplY3RNb2RlJiYobz1uZXcgTyhcImNodW5rXCIsW1wic3RyaW5nXCIsXCJCdWZmZXJcIl0scikpLCFvfHwoWShlLG8pLG4ubmV4dFRpY2soYSxvKSwhMSl9ZnVuY3Rpb24gcChlLHQsbil7cmV0dXJuIGUub2JqZWN0TW9kZXx8ITE9PT1lLmRlY29kZVN0cmluZ3N8fFwic3RyaW5nXCIhPXR5cGVvZiB0fHwodD14LmZyb20odCxuKSksdH1mdW5jdGlvbiBmKGUsdCxuLHIsYSxvKXtpZighbil7dmFyIGk9cCh0LHIsYSk7ciE9PWkmJihuPSEwLGE9XCJidWZmZXJcIixyPWkpfXZhciBkPXQub2JqZWN0TW9kZT8xOnIubGVuZ3RoO3QubGVuZ3RoKz1kO3ZhciBzPXQubGVuZ3RoPHQuaGlnaFdhdGVyTWFyaztpZihzfHwodC5uZWVkRHJhaW49ITApLHQud3JpdGluZ3x8dC5jb3JrZWQpe3ZhciBsPXQubGFzdEJ1ZmZlcmVkUmVxdWVzdDt0Lmxhc3RCdWZmZXJlZFJlcXVlc3Q9e2NodW5rOnIsZW5jb2Rpbmc6YSxpc0J1ZjpuLGNhbGxiYWNrOm8sbmV4dDpudWxsfSxsP2wubmV4dD10Lmxhc3RCdWZmZXJlZFJlcXVlc3Q6dC5idWZmZXJlZFJlcXVlc3Q9dC5sYXN0QnVmZmVyZWRSZXF1ZXN0LHQuYnVmZmVyZWRSZXF1ZXN0Q291bnQrPTF9ZWxzZSBnKGUsdCwhMSxkLHIsYSxvKTtyZXR1cm4gc31mdW5jdGlvbiBnKGUsdCxuLHIsYSxvLGkpe3Qud3JpdGVsZW49cix0LndyaXRlY2I9aSx0LndyaXRpbmc9ITAsdC5zeW5jPSEwLHQuZGVzdHJveWVkP3Qub253cml0ZShuZXcgaihcIndyaXRlXCIpKTpuP2UuX3dyaXRldihhLHQub253cml0ZSk6ZS5fd3JpdGUoYSxvLHQub253cml0ZSksdC5zeW5jPSExfWZ1bmN0aW9uIF8oZSx0LHIsYSxvKXstLXQucGVuZGluZ2NiLHI/KG4ubmV4dFRpY2sobyxhKSxuLm5leHRUaWNrKFMsZSx0KSxlLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD0hMCxZKGUsYSkpOihvKGEpLGUuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLFkoZSxhKSxTKGUsdCkpfWZ1bmN0aW9uIGgoZSl7ZS53cml0aW5nPSExLGUud3JpdGVjYj1udWxsLGUubGVuZ3RoLT1lLndyaXRlbGVuLGUud3JpdGVsZW49MH1mdW5jdGlvbiBtKGUsdCl7dmFyIHI9ZS5fd3JpdGFibGVTdGF0ZSxhPXIuc3luYyxvPXIud3JpdGVjYjtpZihcImZ1bmN0aW9uXCIhPXR5cGVvZiBvKXRocm93IG5ldyBCO2lmKGgociksdClfKGUscixhLHQsbyk7ZWxzZXt2YXIgaT1SKHIpfHxlLmRlc3Ryb3llZDtpfHxyLmNvcmtlZHx8ci5idWZmZXJQcm9jZXNzaW5nfHwhci5idWZmZXJlZFJlcXVlc3R8fEMoZSxyKSxhP24ubmV4dFRpY2soYixlLHIsaSxvKTpiKGUscixpLG8pfX1mdW5jdGlvbiBiKGUsdCxuLHIpe258fHkoZSx0KSx0LnBlbmRpbmdjYi0tLHIoKSxTKGUsdCl9ZnVuY3Rpb24geShlLHQpezA9PT10Lmxlbmd0aCYmdC5uZWVkRHJhaW4mJih0Lm5lZWREcmFpbj0hMSxlLmVtaXQoXCJkcmFpblwiKSl9ZnVuY3Rpb24gQyhlLHQpe3QuYnVmZmVyUHJvY2Vzc2luZz0hMDt2YXIgbj10LmJ1ZmZlcmVkUmVxdWVzdDtpZihlLl93cml0ZXYmJm4mJm4ubmV4dCl7dmFyIHI9dC5idWZmZXJlZFJlcXVlc3RDb3VudCxvPUFycmF5KHIpLGk9dC5jb3JrZWRSZXF1ZXN0c0ZyZWU7aS5lbnRyeT1uO2Zvcih2YXIgZD0wLHM9ITA7bjspb1tkXT1uLG4uaXNCdWZ8fChzPSExKSxuPW4ubmV4dCxkKz0xO28uYWxsQnVmZmVycz1zLGcoZSx0LCEwLHQubGVuZ3RoLG8sXCJcIixpLmZpbmlzaCksdC5wZW5kaW5nY2IrKyx0Lmxhc3RCdWZmZXJlZFJlcXVlc3Q9bnVsbCxpLm5leHQ/KHQuY29ya2VkUmVxdWVzdHNGcmVlPWkubmV4dCxpLm5leHQ9bnVsbCk6dC5jb3JrZWRSZXF1ZXN0c0ZyZWU9bmV3IGEodCksdC5idWZmZXJlZFJlcXVlc3RDb3VudD0wfWVsc2V7Zm9yKDtuOyl7dmFyIGw9bi5jaHVuayxjPW4uZW5jb2RpbmcsdT1uLmNhbGxiYWNrLHA9dC5vYmplY3RNb2RlPzE6bC5sZW5ndGg7aWYoZyhlLHQsITEscCxsLGMsdSksbj1uLm5leHQsdC5idWZmZXJlZFJlcXVlc3RDb3VudC0tLHQud3JpdGluZylicmVha31udWxsPT09biYmKHQubGFzdEJ1ZmZlcmVkUmVxdWVzdD1udWxsKX10LmJ1ZmZlcmVkUmVxdWVzdD1uLHQuYnVmZmVyUHJvY2Vzc2luZz0hMX1mdW5jdGlvbiBSKGUpe3JldHVybiBlLmVuZGluZyYmMD09PWUubGVuZ3RoJiZudWxsPT09ZS5idWZmZXJlZFJlcXVlc3QmJiFlLmZpbmlzaGVkJiYhZS53cml0aW5nfWZ1bmN0aW9uIEUoZSx0KXtlLl9maW5hbChmdW5jdGlvbihuKXt0LnBlbmRpbmdjYi0tLG4mJlkoZSxuKSx0LnByZWZpbmlzaGVkPSEwLGUuZW1pdChcInByZWZpbmlzaFwiKSxTKGUsdCl9KX1mdW5jdGlvbiB3KGUsdCl7dC5wcmVmaW5pc2hlZHx8dC5maW5hbENhbGxlZHx8KFwiZnVuY3Rpb25cIiE9dHlwZW9mIGUuX2ZpbmFsfHx0LmRlc3Ryb3llZD8odC5wcmVmaW5pc2hlZD0hMCxlLmVtaXQoXCJwcmVmaW5pc2hcIikpOih0LnBlbmRpbmdjYisrLHQuZmluYWxDYWxsZWQ9ITAsbi5uZXh0VGljayhFLGUsdCkpKX1mdW5jdGlvbiBTKGUsdCl7dmFyIG49Uih0KTtpZihuJiYodyhlLHQpLDA9PT10LnBlbmRpbmdjYiYmKHQuZmluaXNoZWQ9ITAsZS5lbWl0KFwiZmluaXNoXCIpLHQuYXV0b0Rlc3Ryb3kpKSl7dmFyIHI9ZS5fcmVhZGFibGVTdGF0ZTsoIXJ8fHIuYXV0b0Rlc3Ryb3kmJnIuZW5kRW1pdHRlZCkmJmUuZGVzdHJveSgpfXJldHVybiBufWZ1bmN0aW9uIFQoZSx0LHIpe3QuZW5kaW5nPSEwLFMoZSx0KSxyJiYodC5maW5pc2hlZD9uLm5leHRUaWNrKHIpOmUub25jZShcImZpbmlzaFwiLHIpKSx0LmVuZGVkPSEwLGUud3JpdGFibGU9ITF9ZnVuY3Rpb24gdihlLHQsbil7dmFyIHI9ZS5lbnRyeTtmb3IoZS5lbnRyeT1udWxsO3I7KXt2YXIgYT1yLmNhbGxiYWNrO3QucGVuZGluZ2NiLS0sYShuKSxyPXIubmV4dH10LmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0PWV9dC5leHBvcnRzPWw7dmFyIGs7bC5Xcml0YWJsZVN0YXRlPXM7dmFyIEw9e2RlcHJlY2F0ZTplKFwidXRpbC1kZXByZWNhdGVcIil9LEE9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cIikseD1lKFwiYnVmZmVyXCIpLkJ1ZmZlcixOPXIuVWludDhBcnJheXx8ZnVuY3Rpb24oKXt9LEQ9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XCIpLEk9ZShcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiKSxQPUkuZ2V0SGlnaFdhdGVyTWFyayxNPWUoXCIuLi9lcnJvcnNcIikuY29kZXMsTz1NLkVSUl9JTlZBTElEX0FSR19UWVBFLEY9TS5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxCPU0uRVJSX01VTFRJUExFX0NBTExCQUNLLFU9TS5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLGo9TS5FUlJfU1RSRUFNX0RFU1RST1lFRCxxPU0uRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxXPU0uRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQsSD1NLkVSUl9VTktOT1dOX0VOQ09ESU5HLFk9RC5lcnJvck9yRGVzdHJveTtlKFwiaW5oZXJpdHNcIikobCxBKSxzLnByb3RvdHlwZS5nZXRCdWZmZXI9ZnVuY3Rpb24oKXtmb3IodmFyIGU9dGhpcy5idWZmZXJlZFJlcXVlc3QsdD1bXTtlOyl0LnB1c2goZSksZT1lLm5leHQ7cmV0dXJuIHR9LGZ1bmN0aW9uKCl7dHJ5e09iamVjdC5kZWZpbmVQcm9wZXJ0eShzLnByb3RvdHlwZSxcImJ1ZmZlclwiLHtnZXQ6TC5kZXByZWNhdGUoZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCdWZmZXIoKX0sXCJfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciBpbnN0ZWFkLlwiLFwiREVQMDAwM1wiKX0pfWNhdGNoKGUpe319KCk7dmFyIFY7XCJmdW5jdGlvblwiPT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaGFzSW5zdGFuY2UmJlwiZnVuY3Rpb25cIj09dHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdPyhWPUZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShsLFN5bWJvbC5oYXNJbnN0YW5jZSx7dmFsdWU6ZnVuY3Rpb24oZSl7cmV0dXJuISFWLmNhbGwodGhpcyxlKXx8ISh0aGlzIT09bCkmJmUmJmUuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBzfX0pKTpWPWZ1bmN0aW9uKGUpe3JldHVybiBlIGluc3RhbmNlb2YgdGhpc30sbC5wcm90b3R5cGUucGlwZT1mdW5jdGlvbigpe1kodGhpcyxuZXcgVSl9LGwucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uKGUsdCxuKXt2YXIgcj10aGlzLl93cml0YWJsZVN0YXRlLGE9ITEscz0hci5vYmplY3RNb2RlJiZpKGUpO3JldHVybiBzJiYheC5pc0J1ZmZlcihlKSYmKGU9byhlKSksXCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLHM/dD1cImJ1ZmZlclwiOiF0JiYodD1yLmRlZmF1bHRFbmNvZGluZyksXCJmdW5jdGlvblwiIT10eXBlb2YgbiYmKG49ZCksci5lbmRpbmc/Yyh0aGlzLG4pOihzfHx1KHRoaXMscixlLG4pKSYmKHIucGVuZGluZ2NiKyssYT1mKHRoaXMscixzLGUsdCxuKSksYX0sbC5wcm90b3R5cGUuY29yaz1mdW5jdGlvbigpe3RoaXMuX3dyaXRhYmxlU3RhdGUuY29ya2VkKyt9LGwucHJvdG90eXBlLnVuY29yaz1mdW5jdGlvbigpe3ZhciBlPXRoaXMuX3dyaXRhYmxlU3RhdGU7ZS5jb3JrZWQmJihlLmNvcmtlZC0tLCFlLndyaXRpbmcmJiFlLmNvcmtlZCYmIWUuYnVmZmVyUHJvY2Vzc2luZyYmZS5idWZmZXJlZFJlcXVlc3QmJkModGhpcyxlKSl9LGwucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZz1mdW5jdGlvbihlKXtpZihcInN0cmluZ1wiPT10eXBlb2YgZSYmKGU9ZS50b0xvd2VyQ2FzZSgpKSwhKC0xPFtcImhleFwiLFwidXRmOFwiLFwidXRmLThcIixcImFzY2lpXCIsXCJiaW5hcnlcIixcImJhc2U2NFwiLFwidWNzMlwiLFwidWNzLTJcIixcInV0ZjE2bGVcIixcInV0Zi0xNmxlXCIsXCJyYXdcIl0uaW5kZXhPZigoZStcIlwiKS50b0xvd2VyQ2FzZSgpKSkpdGhyb3cgbmV3IEgoZSk7cmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nPWUsdGhpc30sT2JqZWN0LmRlZmluZVByb3BlcnR5KGwucHJvdG90eXBlLFwid3JpdGFibGVCdWZmZXJcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKX19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJ3cml0YWJsZUhpZ2hXYXRlck1hcmtcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrfX0pLGwucHJvdG90eXBlLl93cml0ZT1mdW5jdGlvbihlLHQsbil7bihuZXcgRihcIl93cml0ZSgpXCIpKX0sbC5wcm90b3R5cGUuX3dyaXRldj1udWxsLGwucHJvdG90eXBlLmVuZD1mdW5jdGlvbihlLHQsbil7dmFyIHI9dGhpcy5fd3JpdGFibGVTdGF0ZTtyZXR1cm5cImZ1bmN0aW9uXCI9PXR5cGVvZiBlPyhuPWUsZT1udWxsLHQ9bnVsbCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdCYmKG49dCx0PW51bGwpLG51bGwhPT1lJiZ2b2lkIDAhPT1lJiZ0aGlzLndyaXRlKGUsdCksci5jb3JrZWQmJihyLmNvcmtlZD0xLHRoaXMudW5jb3JrKCkpLHIuZW5kaW5nfHxUKHRoaXMscixuKSx0aGlzfSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJ3cml0YWJsZUxlbmd0aFwiLHtlbnVtZXJhYmxlOiExLGdldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aH19KSxPYmplY3QuZGVmaW5lUHJvcGVydHkobC5wcm90b3R5cGUsXCJkZXN0cm95ZWRcIix7ZW51bWVyYWJsZTohMSxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwIT09dGhpcy5fd3JpdGFibGVTdGF0ZSYmdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWR9LHNldDpmdW5jdGlvbihlKXt0aGlzLl93cml0YWJsZVN0YXRlJiYodGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ9ZSl9fSksbC5wcm90b3R5cGUuZGVzdHJveT1ELmRlc3Ryb3ksbC5wcm90b3R5cGUuX3VuZGVzdHJveT1ELnVuZGVzdHJveSxsLnByb3RvdHlwZS5fZGVzdHJveT1mdW5jdGlvbihlLHQpe3QoZSl9fSkuY2FsbCh0aGlzKX0pLmNhbGwodGhpcyxlKFwiX3Byb2Nlc3NcIiksXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHtcIi4uL2Vycm9yc1wiOjE1LFwiLi9fc3RyZWFtX2R1cGxleFwiOjE2LFwiLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3lcIjoyMyxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZVwiOjI3LFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVwiOjI4LF9wcm9jZXNzOjEyLGJ1ZmZlcjozLGluaGVyaXRzOjEwLFwidXRpbC1kZXByZWNhdGVcIjozMn1dLDIxOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihuKXsoZnVuY3Rpb24oKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gYShlLHQpe3JldHVybnt2YWx1ZTplLGRvbmU6dH19ZnVuY3Rpb24gbyhlKXt2YXIgdD1lW2NdO2lmKG51bGwhPT10KXt2YXIgbj1lW2hdLnJlYWQoKTtudWxsIT09biYmKGVbZ109bnVsbCxlW2NdPW51bGwsZVt1XT1udWxsLHQoYShuLCExKSkpfX1mdW5jdGlvbiBpKGUpe24ubmV4dFRpY2sobyxlKX1mdW5jdGlvbiBkKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4scil7ZS50aGVuKGZ1bmN0aW9uKCl7cmV0dXJuIHRbZl0/dm9pZCBuKGEodm9pZCAwLCEwKSk6dm9pZCB0W19dKG4scil9LHIpfX12YXIgcyxsPWUoXCIuL2VuZC1vZi1zdHJlYW1cIiksYz1TeW1ib2woXCJsYXN0UmVzb2x2ZVwiKSx1PVN5bWJvbChcImxhc3RSZWplY3RcIikscD1TeW1ib2woXCJlcnJvclwiKSxmPVN5bWJvbChcImVuZGVkXCIpLGc9U3ltYm9sKFwibGFzdFByb21pc2VcIiksXz1TeW1ib2woXCJoYW5kbGVQcm9taXNlXCIpLGg9U3ltYm9sKFwic3RyZWFtXCIpLG09T2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uKCl7fSksYj1PYmplY3Quc2V0UHJvdG90eXBlT2YoKHM9e2dldCBzdHJlYW0oKXtyZXR1cm4gdGhpc1toXX0sbmV4dDpmdW5jdGlvbigpe3ZhciBlPXRoaXMsdD10aGlzW3BdO2lmKG51bGwhPT10KXJldHVybiBQcm9taXNlLnJlamVjdCh0KTtpZih0aGlzW2ZdKXJldHVybiBQcm9taXNlLnJlc29sdmUoYSh2b2lkIDAsITApKTtpZih0aGlzW2hdLmRlc3Ryb3llZClyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXtuLm5leHRUaWNrKGZ1bmN0aW9uKCl7ZVtwXT9yKGVbcF0pOnQoYSh2b2lkIDAsITApKX0pfSk7dmFyIHIsbz10aGlzW2ddO2lmKG8pcj1uZXcgUHJvbWlzZShkKG8sdGhpcykpO2Vsc2V7dmFyIGk9dGhpc1toXS5yZWFkKCk7aWYobnVsbCE9PWkpcmV0dXJuIFByb21pc2UucmVzb2x2ZShhKGksITEpKTtyPW5ldyBQcm9taXNlKHRoaXNbX10pfXJldHVybiB0aGlzW2ddPXIscn19LHIocyxTeW1ib2wuYXN5bmNJdGVyYXRvcixmdW5jdGlvbigpe3JldHVybiB0aGlzfSkscihzLFwicmV0dXJuXCIsZnVuY3Rpb24oKXt2YXIgZT10aGlzO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih0LG4pe2VbaF0uZGVzdHJveShudWxsLGZ1bmN0aW9uKGUpe3JldHVybiBlP3ZvaWQgbihlKTp2b2lkIHQoYSh2b2lkIDAsITApKX0pfSl9KSxzKSxtKTt0LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHQsbj1PYmplY3QuY3JlYXRlKGIsKHQ9e30scih0LGgse3ZhbHVlOmUsd3JpdGFibGU6ITB9KSxyKHQsYyx7dmFsdWU6bnVsbCx3cml0YWJsZTohMH0pLHIodCx1LHt2YWx1ZTpudWxsLHdyaXRhYmxlOiEwfSkscih0LHAse3ZhbHVlOm51bGwsd3JpdGFibGU6ITB9KSxyKHQsZix7dmFsdWU6ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLHdyaXRhYmxlOiEwfSkscih0LF8se3ZhbHVlOmZ1bmN0aW9uKGUsdCl7dmFyIHI9bltoXS5yZWFkKCk7cj8obltnXT1udWxsLG5bY109bnVsbCxuW3VdPW51bGwsZShhKHIsITEpKSk6KG5bY109ZSxuW3VdPXQpfSx3cml0YWJsZTohMH0pLHQpKTtyZXR1cm4gbltnXT1udWxsLGwoZSxmdW5jdGlvbihlKXtpZihlJiZcIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFXCIhPT1lLmNvZGUpe3ZhciB0PW5bdV07cmV0dXJuIG51bGwhPT10JiYobltnXT1udWxsLG5bY109bnVsbCxuW3VdPW51bGwsdChlKSksdm9pZChuW3BdPWUpfXZhciByPW5bY107bnVsbCE9PXImJihuW2ddPW51bGwsbltjXT1udWxsLG5bdV09bnVsbCxyKGEodm9pZCAwLCEwKSkpLG5bZl09ITB9KSxlLm9uKFwicmVhZGFibGVcIixpLmJpbmQobnVsbCxuKSksbn19KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSl9LHtcIi4vZW5kLW9mLXN0cmVhbVwiOjI0LF9wcm9jZXNzOjEyfV0sMjI6W2Z1bmN0aW9uKGUsdCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXt2YXIgbj1PYmplY3Qua2V5cyhlKTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgcj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO3QmJihyPXIuZmlsdGVyKGZ1bmN0aW9uKHQpe3JldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsdCkuZW51bWVyYWJsZX0pKSxuLnB1c2guYXBwbHkobixyKX1yZXR1cm4gbn1mdW5jdGlvbiByKGUpe2Zvcih2YXIgdCxyPTE7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyl0PW51bGw9PWFyZ3VtZW50c1tyXT97fTphcmd1bWVudHNbcl0sciUyP24oT2JqZWN0KHQpLCEwKS5mb3JFYWNoKGZ1bmN0aW9uKG4pe2EoZSxuLHRbbl0pfSk6T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnM/T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSk6bihPYmplY3QodCkpLmZvckVhY2goZnVuY3Rpb24obil7T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbixPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHQsbikpfSk7cmV0dXJuIGV9ZnVuY3Rpb24gYShlLHQsbil7cmV0dXJuIHQgaW4gZT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSx0LHt2YWx1ZTpuLGVudW1lcmFibGU6ITAsY29uZmlndXJhYmxlOiEwLHdyaXRhYmxlOiEwfSk6ZVt0XT1uLGV9ZnVuY3Rpb24gbyhlLHQpe2lmKCEoZSBpbnN0YW5jZW9mIHQpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIil9ZnVuY3Rpb24gaShlLHQpe2Zvcih2YXIgbixyPTA7cjx0Lmxlbmd0aDtyKyspbj10W3JdLG4uZW51bWVyYWJsZT1uLmVudW1lcmFibGV8fCExLG4uY29uZmlndXJhYmxlPSEwLFwidmFsdWVcImluIG4mJihuLndyaXRhYmxlPSEwKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxuLmtleSxuKX1mdW5jdGlvbiBkKGUsdCxuKXtyZXR1cm4gdCYmaShlLnByb3RvdHlwZSx0KSxuJiZpKGUsbiksZX1mdW5jdGlvbiBzKGUsdCxuKXt1LnByb3RvdHlwZS5jb3B5LmNhbGwoZSx0LG4pfXZhciBsPWUoXCJidWZmZXJcIiksdT1sLkJ1ZmZlcixwPWUoXCJ1dGlsXCIpLGY9cC5pbnNwZWN0LGc9ZiYmZi5jdXN0b218fFwiaW5zcGVjdFwiO3QuZXhwb3J0cz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXtvKHRoaXMsZSksdGhpcy5oZWFkPW51bGwsdGhpcy50YWlsPW51bGwsdGhpcy5sZW5ndGg9MH1yZXR1cm4gZChlLFt7a2V5OlwicHVzaFwiLHZhbHVlOmZ1bmN0aW9uKGUpe3ZhciB0PXtkYXRhOmUsbmV4dDpudWxsfTswPHRoaXMubGVuZ3RoP3RoaXMudGFpbC5uZXh0PXQ6dGhpcy5oZWFkPXQsdGhpcy50YWlsPXQsKyt0aGlzLmxlbmd0aH19LHtrZXk6XCJ1bnNoaWZ0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9e2RhdGE6ZSxuZXh0OnRoaXMuaGVhZH07MD09PXRoaXMubGVuZ3RoJiYodGhpcy50YWlsPXQpLHRoaXMuaGVhZD10LCsrdGhpcy5sZW5ndGh9fSx7a2V5Olwic2hpZnRcIix2YWx1ZTpmdW5jdGlvbigpe2lmKDAhPT10aGlzLmxlbmd0aCl7dmFyIGU9dGhpcy5oZWFkLmRhdGE7cmV0dXJuIHRoaXMuaGVhZD0xPT09dGhpcy5sZW5ndGg/dGhpcy50YWlsPW51bGw6dGhpcy5oZWFkLm5leHQsLS10aGlzLmxlbmd0aCxlfX19LHtrZXk6XCJjbGVhclwiLHZhbHVlOmZ1bmN0aW9uKCl7dGhpcy5oZWFkPXRoaXMudGFpbD1udWxsLHRoaXMubGVuZ3RoPTB9fSx7a2V5Olwiam9pblwiLHZhbHVlOmZ1bmN0aW9uKGUpe2lmKDA9PT10aGlzLmxlbmd0aClyZXR1cm5cIlwiO2Zvcih2YXIgdD10aGlzLmhlYWQsbj1cIlwiK3QuZGF0YTt0PXQubmV4dDspbis9ZSt0LmRhdGE7cmV0dXJuIG59fSx7a2V5OlwiY29uY2F0XCIsdmFsdWU6ZnVuY3Rpb24oZSl7aWYoMD09PXRoaXMubGVuZ3RoKXJldHVybiB1LmFsbG9jKDApO2Zvcih2YXIgdD11LmFsbG9jVW5zYWZlKGU+Pj4wKSxuPXRoaXMuaGVhZCxyPTA7bjspcyhuLmRhdGEsdCxyKSxyKz1uLmRhdGEubGVuZ3RoLG49bi5uZXh0O3JldHVybiB0fX0se2tleTpcImNvbnN1bWVcIix2YWx1ZTpmdW5jdGlvbihlLHQpe3ZhciBuO3JldHVybiBlPHRoaXMuaGVhZC5kYXRhLmxlbmd0aD8obj10aGlzLmhlYWQuZGF0YS5zbGljZSgwLGUpLHRoaXMuaGVhZC5kYXRhPXRoaXMuaGVhZC5kYXRhLnNsaWNlKGUpKTplPT09dGhpcy5oZWFkLmRhdGEubGVuZ3RoP249dGhpcy5zaGlmdCgpOm49dD90aGlzLl9nZXRTdHJpbmcoZSk6dGhpcy5fZ2V0QnVmZmVyKGUpLG59fSx7a2V5OlwiZmlyc3RcIix2YWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhlYWQuZGF0YX19LHtrZXk6XCJfZ2V0U3RyaW5nXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcy5oZWFkLHI9MSxhPXQuZGF0YTtmb3IoZS09YS5sZW5ndGg7dD10Lm5leHQ7KXt2YXIgbz10LmRhdGEsaT1lPm8ubGVuZ3RoP28ubGVuZ3RoOmU7aWYoYSs9aT09PW8ubGVuZ3RoP286by5zbGljZSgwLGUpLGUtPWksMD09PWUpe2k9PT1vLmxlbmd0aD8oKytyLHRoaXMuaGVhZD10Lm5leHQ/dC5uZXh0OnRoaXMudGFpbD1udWxsKToodGhpcy5oZWFkPXQsdC5kYXRhPW8uc2xpY2UoaSkpO2JyZWFrfSsrcn1yZXR1cm4gdGhpcy5sZW5ndGgtPXIsYX19LHtrZXk6XCJfZ2V0QnVmZmVyXCIsdmFsdWU6ZnVuY3Rpb24oZSl7dmFyIHQ9dS5hbGxvY1Vuc2FmZShlKSxyPXRoaXMuaGVhZCxhPTE7Zm9yKHIuZGF0YS5jb3B5KHQpLGUtPXIuZGF0YS5sZW5ndGg7cj1yLm5leHQ7KXt2YXIgbz1yLmRhdGEsaT1lPm8ubGVuZ3RoP28ubGVuZ3RoOmU7aWYoby5jb3B5KHQsdC5sZW5ndGgtZSwwLGkpLGUtPWksMD09PWUpe2k9PT1vLmxlbmd0aD8oKythLHRoaXMuaGVhZD1yLm5leHQ/ci5uZXh0OnRoaXMudGFpbD1udWxsKToodGhpcy5oZWFkPXIsci5kYXRhPW8uc2xpY2UoaSkpO2JyZWFrfSsrYX1yZXR1cm4gdGhpcy5sZW5ndGgtPWEsdH19LHtrZXk6Zyx2YWx1ZTpmdW5jdGlvbihlLHQpe3JldHVybiBmKHRoaXMscih7fSx0LHtkZXB0aDowLGN1c3RvbUluc3BlY3Q6ITF9KSl9fV0pLGV9KCl9LHtidWZmZXI6Myx1dGlsOjJ9XSwyMzpbZnVuY3Rpb24oZSx0KXsoZnVuY3Rpb24oZSl7KGZ1bmN0aW9uKCl7J3VzZSBzdHJpY3QnO2Z1bmN0aW9uIG4oZSx0KXthKGUsdCkscihlKX1mdW5jdGlvbiByKGUpe2UuX3dyaXRhYmxlU3RhdGUmJiFlLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZXx8ZS5fcmVhZGFibGVTdGF0ZSYmIWUuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlfHxlLmVtaXQoXCJjbG9zZVwiKX1mdW5jdGlvbiBhKGUsdCl7ZS5lbWl0KFwiZXJyb3JcIix0KX10LmV4cG9ydHM9e2Rlc3Ryb3k6ZnVuY3Rpb24odCxvKXt2YXIgaT10aGlzLGQ9dGhpcy5fcmVhZGFibGVTdGF0ZSYmdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQscz10aGlzLl93cml0YWJsZVN0YXRlJiZ0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtyZXR1cm4gZHx8cz8obz9vKHQpOnQmJih0aGlzLl93cml0YWJsZVN0YXRlPyF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLGUubmV4dFRpY2soYSx0aGlzLHQpKTplLm5leHRUaWNrKGEsdGhpcyx0KSksdGhpcyk6KHRoaXMuX3JlYWRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD0hMCksdGhpcy5fd3JpdGFibGVTdGF0ZSYmKHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkPSEwKSx0aGlzLl9kZXN0cm95KHR8fG51bGwsZnVuY3Rpb24odCl7IW8mJnQ/aS5fd3JpdGFibGVTdGF0ZT9pLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZD9lLm5leHRUaWNrKHIsaSk6KGkuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSEwLGUubmV4dFRpY2sobixpLHQpKTplLm5leHRUaWNrKG4saSx0KTpvPyhlLm5leHRUaWNrKHIsaSksbyh0KSk6ZS5uZXh0VGljayhyLGkpfSksdGhpcyl9LHVuZGVzdHJveTpmdW5jdGlvbigpe3RoaXMuX3JlYWRhYmxlU3RhdGUmJih0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZD0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmc9ITEsdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZD0hMSx0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ9ITEpLHRoaXMuX3dyaXRhYmxlU3RhdGUmJih0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQ9ITEsdGhpcy5fd3JpdGFibGVTdGF0ZS5wcmVmaW5pc2hlZD0hMSx0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkPSExLHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkPSExKX0sZXJyb3JPckRlc3Ryb3k6ZnVuY3Rpb24oZSx0KXt2YXIgbj1lLl9yZWFkYWJsZVN0YXRlLHI9ZS5fd3JpdGFibGVTdGF0ZTtuJiZuLmF1dG9EZXN0cm95fHxyJiZyLmF1dG9EZXN0cm95P2UuZGVzdHJveSh0KTplLmVtaXQoXCJlcnJvclwiLHQpfX19KS5jYWxsKHRoaXMpfSkuY2FsbCh0aGlzLGUoXCJfcHJvY2Vzc1wiKSl9LHtfcHJvY2VzczoxMn1dLDI0OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3ZhciB0PSExO3JldHVybiBmdW5jdGlvbigpe2lmKCF0KXt0PSEwO2Zvcih2YXIgbj1hcmd1bWVudHMubGVuZ3RoLHI9QXJyYXkobiksYT0wO2E8bjthKyspclthXT1hcmd1bWVudHNbYV07ZS5hcHBseSh0aGlzLHIpfX19ZnVuY3Rpb24gcigpe31mdW5jdGlvbiBhKGUpe3JldHVybiBlLnNldEhlYWRlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hYm9ydH1mdW5jdGlvbiBvKGUsdCxkKXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0KXJldHVybiBvKGUsbnVsbCx0KTt0fHwodD17fSksZD1uKGR8fHIpO3ZhciBzPXQucmVhZGFibGV8fCExIT09dC5yZWFkYWJsZSYmZS5yZWFkYWJsZSxsPXQud3JpdGFibGV8fCExIT09dC53cml0YWJsZSYmZS53cml0YWJsZSxjPWZ1bmN0aW9uKCl7ZS53cml0YWJsZXx8cCgpfSx1PWUuX3dyaXRhYmxlU3RhdGUmJmUuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQscD1mdW5jdGlvbigpe2w9ITEsdT0hMCxzfHxkLmNhbGwoZSl9LGY9ZS5fcmVhZGFibGVTdGF0ZSYmZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkLGc9ZnVuY3Rpb24oKXtzPSExLGY9ITAsbHx8ZC5jYWxsKGUpfSxfPWZ1bmN0aW9uKHQpe2QuY2FsbChlLHQpfSxoPWZ1bmN0aW9uKCl7dmFyIHQ7cmV0dXJuIHMmJiFmPyhlLl9yZWFkYWJsZVN0YXRlJiZlLl9yZWFkYWJsZVN0YXRlLmVuZGVkfHwodD1uZXcgaSksZC5jYWxsKGUsdCkpOmwmJiF1PyhlLl93cml0YWJsZVN0YXRlJiZlLl93cml0YWJsZVN0YXRlLmVuZGVkfHwodD1uZXcgaSksZC5jYWxsKGUsdCkpOnZvaWQgMH0sbT1mdW5jdGlvbigpe2UucmVxLm9uKFwiZmluaXNoXCIscCl9O3JldHVybiBhKGUpPyhlLm9uKFwiY29tcGxldGVcIixwKSxlLm9uKFwiYWJvcnRcIixoKSxlLnJlcT9tKCk6ZS5vbihcInJlcXVlc3RcIixtKSk6bCYmIWUuX3dyaXRhYmxlU3RhdGUmJihlLm9uKFwiZW5kXCIsYyksZS5vbihcImNsb3NlXCIsYykpLGUub24oXCJlbmRcIixnKSxlLm9uKFwiZmluaXNoXCIscCksITEhPT10LmVycm9yJiZlLm9uKFwiZXJyb3JcIixfKSxlLm9uKFwiY2xvc2VcIixoKSxmdW5jdGlvbigpe2UucmVtb3ZlTGlzdGVuZXIoXCJjb21wbGV0ZVwiLHApLGUucmVtb3ZlTGlzdGVuZXIoXCJhYm9ydFwiLGgpLGUucmVtb3ZlTGlzdGVuZXIoXCJyZXF1ZXN0XCIsbSksZS5yZXEmJmUucmVxLnJlbW92ZUxpc3RlbmVyKFwiZmluaXNoXCIscCksZS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLGMpLGUucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLGMpLGUucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIixwKSxlLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsZyksZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsXyksZS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsaCl9fXZhciBpPWUoXCIuLi8uLi8uLi9lcnJvcnNcIikuY29kZXMuRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0U7dC5leHBvcnRzPW99LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1fV0sMjU6W2Z1bmN0aW9uKGUsdCl7dC5leHBvcnRzPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEVycm9yKFwiUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyXCIpfX0se31dLDI2OltmdW5jdGlvbihlLHQpeyd1c2Ugc3RyaWN0JztmdW5jdGlvbiBuKGUpe3ZhciB0PSExO3JldHVybiBmdW5jdGlvbigpe3R8fCh0PSEwLGUuYXBwbHkodm9pZCAwLGFyZ3VtZW50cykpfX1mdW5jdGlvbiByKGUpe2lmKGUpdGhyb3cgZX1mdW5jdGlvbiBhKGUpe3JldHVybiBlLnNldEhlYWRlciYmXCJmdW5jdGlvblwiPT10eXBlb2YgZS5hYm9ydH1mdW5jdGlvbiBvKHQscixvLGkpe2k9bihpKTt2YXIgZD0hMTt0Lm9uKFwiY2xvc2VcIixmdW5jdGlvbigpe2Q9ITB9KSxsPT09dm9pZCAwJiYobD1lKFwiLi9lbmQtb2Ytc3RyZWFtXCIpKSxsKHQse3JlYWRhYmxlOnIsd3JpdGFibGU6b30sZnVuY3Rpb24oZSl7cmV0dXJuIGU/aShlKTp2b2lkKGQ9ITAsaSgpKX0pO3ZhciBzPSExO3JldHVybiBmdW5jdGlvbihlKXtpZighZClyZXR1cm4gcz92b2lkIDA6KHM9ITAsYSh0KT90LmFib3J0KCk6XCJmdW5jdGlvblwiPT10eXBlb2YgdC5kZXN0cm95P3QuZGVzdHJveSgpOnZvaWQgaShlfHxuZXcgcChcInBpcGVcIikpKX19ZnVuY3Rpb24gaShlKXtlKCl9ZnVuY3Rpb24gZChlLHQpe3JldHVybiBlLnBpcGUodCl9ZnVuY3Rpb24gcyhlKXtyZXR1cm4gZS5sZW5ndGg/XCJmdW5jdGlvblwiPT10eXBlb2YgZVtlLmxlbmd0aC0xXT9lLnBvcCgpOnI6cn12YXIgbCxjPWUoXCIuLi8uLi8uLi9lcnJvcnNcIikuY29kZXMsdT1jLkVSUl9NSVNTSU5HX0FSR1MscD1jLkVSUl9TVFJFQU1fREVTVFJPWUVEO3QuZXhwb3J0cz1mdW5jdGlvbigpe2Zvcih2YXIgZT1hcmd1bWVudHMubGVuZ3RoLHQ9QXJyYXkoZSksbj0wO248ZTtuKyspdFtuXT1hcmd1bWVudHNbbl07dmFyIHI9cyh0KTtpZihBcnJheS5pc0FycmF5KHRbMF0pJiYodD10WzBdKSwyPnQubGVuZ3RoKXRocm93IG5ldyB1KFwic3RyZWFtc1wiKTt2YXIgYSxsPXQubWFwKGZ1bmN0aW9uKGUsbil7dmFyIGQ9bjx0Lmxlbmd0aC0xO3JldHVybiBvKGUsZCwwPG4sZnVuY3Rpb24oZSl7YXx8KGE9ZSksZSYmbC5mb3JFYWNoKGkpLGR8fChsLmZvckVhY2goaSkscihhKSl9KX0pO3JldHVybiB0LnJlZHVjZShkKX19LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1LFwiLi9lbmQtb2Ytc3RyZWFtXCI6MjR9XSwyNzpbZnVuY3Rpb24oZSxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlLHQsbil7cmV0dXJuIG51bGw9PWUuaGlnaFdhdGVyTWFyaz90P2Vbbl06bnVsbDplLmhpZ2hXYXRlck1hcmt9dmFyIGE9ZShcIi4uLy4uLy4uL2Vycm9yc1wiKS5jb2Rlcy5FUlJfSU5WQUxJRF9PUFRfVkFMVUU7bi5leHBvcnRzPXtnZXRIaWdoV2F0ZXJNYXJrOmZ1bmN0aW9uKGUsbixvLGkpe3ZhciBkPXIobixpLG8pO2lmKG51bGwhPWQpe2lmKCEoaXNGaW5pdGUoZCkmJnQoZCk9PT1kKXx8MD5kKXt2YXIgcz1pP286XCJoaWdoV2F0ZXJNYXJrXCI7dGhyb3cgbmV3IGEocyxkKX1yZXR1cm4gdChkKX1yZXR1cm4gZS5vYmplY3RNb2RlPzE2OjE2Mzg0fX19LHtcIi4uLy4uLy4uL2Vycm9yc1wiOjE1fV0sMjg6W2Z1bmN0aW9uKGUsdCl7dC5leHBvcnRzPWUoXCJldmVudHNcIikuRXZlbnRFbWl0dGVyfSx7ZXZlbnRzOjd9XSwyOTpbZnVuY3Rpb24oZSx0LG4pe249dC5leHBvcnRzPWUoXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXCIpLG4uU3RyZWFtPW4sbi5SZWFkYWJsZT1uLG4uV3JpdGFibGU9ZShcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIiksbi5EdXBsZXg9ZShcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXCIpLG4uVHJhbnNmb3JtPWUoXCIuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qc1wiKSxuLlBhc3NUaHJvdWdoPWUoXCIuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzXCIpLG4uZmluaXNoZWQ9ZShcIi4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qc1wiKSxuLnBpcGVsaW5lPWUoXCIuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzXCIpfSx7XCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1wiOjE2LFwiLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qc1wiOjE3LFwiLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qc1wiOjE4LFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcIjoxOSxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcIjoyMCxcIi4vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qc1wiOjI0LFwiLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qc1wiOjI2fV0sMzA6W2Z1bmN0aW9uKGUsdCxuKXtmdW5jdGlvbiByKGUsdCl7Zm9yKHZhciBuIGluIGUpdFtuXT1lW25dfWZ1bmN0aW9uIGEoZSx0LG4pe3JldHVybiBpKGUsdCxuKX0vKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi92YXIgbz1lKFwiYnVmZmVyXCIpLGk9by5CdWZmZXI7aS5mcm9tJiZpLmFsbG9jJiZpLmFsbG9jVW5zYWZlJiZpLmFsbG9jVW5zYWZlU2xvdz90LmV4cG9ydHM9bzoocihvLG4pLG4uQnVmZmVyPWEpLGEucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLHIoaSxhKSxhLmZyb209ZnVuY3Rpb24oZSx0LG4pe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gaShlLHQsbil9LGEuYWxsb2M9ZnVuY3Rpb24oZSx0LG4pe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3ZhciByPWkoZSk7cmV0dXJuIHZvaWQgMD09PXQ/ci5maWxsKDApOlwic3RyaW5nXCI9PXR5cGVvZiBuP3IuZmlsbCh0LG4pOnIuZmlsbCh0KSxyfSxhLmFsbG9jVW5zYWZlPWZ1bmN0aW9uKGUpe2lmKFwibnVtYmVyXCIhPXR5cGVvZiBlKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyXCIpO3JldHVybiBpKGUpfSxhLmFsbG9jVW5zYWZlU2xvdz1mdW5jdGlvbihlKXtpZihcIm51bWJlclwiIT10eXBlb2YgZSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlclwiKTtyZXR1cm4gby5TbG93QnVmZmVyKGUpfX0se2J1ZmZlcjozfV0sMzE6W2Z1bmN0aW9uKGUsdCxuKXsndXNlIHN0cmljdCc7ZnVuY3Rpb24gcihlKXtpZighZSlyZXR1cm5cInV0ZjhcIjtmb3IodmFyIHQ7Oylzd2l0Y2goZSl7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuXCJ1dGY4XCI7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuXCJ1dGYxNmxlXCI7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuXCJsYXRpbjFcIjtjYXNlXCJiYXNlNjRcIjpjYXNlXCJhc2NpaVwiOmNhc2VcImhleFwiOnJldHVybiBlO2RlZmF1bHQ6aWYodClyZXR1cm47ZT0oXCJcIitlKS50b0xvd2VyQ2FzZSgpLHQ9ITA7fX1mdW5jdGlvbiBhKGUpe3ZhciB0PXIoZSk7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQmJihtLmlzRW5jb2Rpbmc9PT1ifHwhYihlKSkpdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7cmV0dXJuIHR8fGV9ZnVuY3Rpb24gbyhlKXt0aGlzLmVuY29kaW5nPWEoZSk7dmFyIHQ7c3dpdGNoKHRoaXMuZW5jb2Rpbmcpe2Nhc2VcInV0ZjE2bGVcIjp0aGlzLnRleHQ9dSx0aGlzLmVuZD1wLHQ9NDticmVhaztjYXNlXCJ1dGY4XCI6dGhpcy5maWxsTGFzdD1jLHQ9NDticmVhaztjYXNlXCJiYXNlNjRcIjp0aGlzLnRleHQ9Zix0aGlzLmVuZD1nLHQ9MzticmVhaztkZWZhdWx0OnJldHVybiB0aGlzLndyaXRlPV8sdm9pZCh0aGlzLmVuZD1oKTt9dGhpcy5sYXN0TmVlZD0wLHRoaXMubGFzdFRvdGFsPTAsdGhpcy5sYXN0Q2hhcj1tLmFsbG9jVW5zYWZlKHQpfWZ1bmN0aW9uIGQoZSl7aWYoMTI3Pj1lKXJldHVybiAwO3JldHVybiA2PT1lPj41PzI6MTQ9PWU+PjQ/MzozMD09ZT4+Mz80OjI9PWU+PjY/LTE6LTJ9ZnVuY3Rpb24gcyhlLHQsbil7dmFyIHI9dC5sZW5ndGgtMTtpZihyPG4pcmV0dXJuIDA7dmFyIGE9ZCh0W3JdKTtyZXR1cm4gMDw9YT8oMDxhJiYoZS5sYXN0TmVlZD1hLTEpLGEpOi0tcjxufHwtMj09PWE/MDooYT1kKHRbcl0pLDA8PWEpPygwPGEmJihlLmxhc3ROZWVkPWEtMiksYSk6LS1yPG58fC0yPT09YT8wOihhPWQodFtyXSksMDw9YT8oMDxhJiYoMj09PWE/YT0wOmUubGFzdE5lZWQ9YS0zKSxhKTowKX1mdW5jdGlvbiBsKGUsdCl7aWYoMTI4IT0oMTkyJnRbMF0pKXJldHVybiBlLmxhc3ROZWVkPTAsXCJcXHVGRkZEXCI7aWYoMTxlLmxhc3ROZWVkJiYxPHQubGVuZ3RoKXtpZigxMjghPSgxOTImdFsxXSkpcmV0dXJuIGUubGFzdE5lZWQ9MSxcIlxcdUZGRkRcIjtpZigyPGUubGFzdE5lZWQmJjI8dC5sZW5ndGgmJjEyOCE9KDE5MiZ0WzJdKSlyZXR1cm4gZS5sYXN0TmVlZD0yLFwiXFx1RkZGRFwifX1mdW5jdGlvbiBjKGUpe3ZhciB0PXRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsbj1sKHRoaXMsZSx0KTtyZXR1cm4gdm9pZCAwPT09bj90aGlzLmxhc3ROZWVkPD1lLmxlbmd0aD8oZS5jb3B5KHRoaXMubGFzdENoYXIsdCwwLHRoaXMubGFzdE5lZWQpLHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywwLHRoaXMubGFzdFRvdGFsKSk6dm9pZChlLmNvcHkodGhpcy5sYXN0Q2hhcix0LDAsZS5sZW5ndGgpLHRoaXMubGFzdE5lZWQtPWUubGVuZ3RoKTpufWZ1bmN0aW9uIHUoZSx0KXtpZigwPT0oZS5sZW5ndGgtdCklMil7dmFyIG49ZS50b1N0cmluZyhcInV0ZjE2bGVcIix0KTtpZihuKXt2YXIgcj1uLmNoYXJDb2RlQXQobi5sZW5ndGgtMSk7aWYoNTUyOTY8PXImJjU2MzE5Pj1yKXJldHVybiB0aGlzLmxhc3ROZWVkPTIsdGhpcy5sYXN0VG90YWw9NCx0aGlzLmxhc3RDaGFyWzBdPWVbZS5sZW5ndGgtMl0sdGhpcy5sYXN0Q2hhclsxXT1lW2UubGVuZ3RoLTFdLG4uc2xpY2UoMCwtMSl9cmV0dXJuIG59cmV0dXJuIHRoaXMubGFzdE5lZWQ9MSx0aGlzLmxhc3RUb3RhbD0yLHRoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0xXSxlLnRvU3RyaW5nKFwidXRmMTZsZVwiLHQsZS5sZW5ndGgtMSl9ZnVuY3Rpb24gcChlKXt2YXIgdD1lJiZlLmxlbmd0aD90aGlzLndyaXRlKGUpOlwiXCI7aWYodGhpcy5sYXN0TmVlZCl7dmFyIG49dGhpcy5sYXN0VG90YWwtdGhpcy5sYXN0TmVlZDtyZXR1cm4gdCt0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKFwidXRmMTZsZVwiLDAsbil9cmV0dXJuIHR9ZnVuY3Rpb24gZihlLHQpe3ZhciByPShlLmxlbmd0aC10KSUzO3JldHVybiAwPT1yP2UudG9TdHJpbmcoXCJiYXNlNjRcIix0KToodGhpcy5sYXN0TmVlZD0zLXIsdGhpcy5sYXN0VG90YWw9MywxPT1yP3RoaXMubGFzdENoYXJbMF09ZVtlLmxlbmd0aC0xXToodGhpcy5sYXN0Q2hhclswXT1lW2UubGVuZ3RoLTJdLHRoaXMubGFzdENoYXJbMV09ZVtlLmxlbmd0aC0xXSksZS50b1N0cmluZyhcImJhc2U2NFwiLHQsZS5sZW5ndGgtcikpfWZ1bmN0aW9uIGcoZSl7dmFyIHQ9ZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwiO3JldHVybiB0aGlzLmxhc3ROZWVkP3QrdGhpcy5sYXN0Q2hhci50b1N0cmluZyhcImJhc2U2NFwiLDAsMy10aGlzLmxhc3ROZWVkKTp0fWZ1bmN0aW9uIF8oZSl7cmV0dXJuIGUudG9TdHJpbmcodGhpcy5lbmNvZGluZyl9ZnVuY3Rpb24gaChlKXtyZXR1cm4gZSYmZS5sZW5ndGg/dGhpcy53cml0ZShlKTpcIlwifXZhciBtPWUoXCJzYWZlLWJ1ZmZlclwiKS5CdWZmZXIsYj1tLmlzRW5jb2Rpbmd8fGZ1bmN0aW9uKGUpe3N3aXRjaChlPVwiXCIrZSxlJiZlLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6Y2FzZVwicmF3XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMTt9fTtuLlN0cmluZ0RlY29kZXI9byxvLnByb3RvdHlwZS53cml0ZT1mdW5jdGlvbihlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuXCJcIjt2YXIgdCxuO2lmKHRoaXMubGFzdE5lZWQpe2lmKHQ9dGhpcy5maWxsTGFzdChlKSx2b2lkIDA9PT10KXJldHVyblwiXCI7bj10aGlzLmxhc3ROZWVkLHRoaXMubGFzdE5lZWQ9MH1lbHNlIG49MDtyZXR1cm4gbjxlLmxlbmd0aD90P3QrdGhpcy50ZXh0KGUsbik6dGhpcy50ZXh0KGUsbik6dHx8XCJcIn0sby5wcm90b3R5cGUuZW5kPWZ1bmN0aW9uKGUpe3ZhciB0PWUmJmUubGVuZ3RoP3RoaXMud3JpdGUoZSk6XCJcIjtyZXR1cm4gdGhpcy5sYXN0TmVlZD90K1wiXFx1RkZGRFwiOnR9LG8ucHJvdG90eXBlLnRleHQ9ZnVuY3Rpb24oZSx0KXt2YXIgbj1zKHRoaXMsZSx0KTtpZighdGhpcy5sYXN0TmVlZClyZXR1cm4gZS50b1N0cmluZyhcInV0ZjhcIix0KTt0aGlzLmxhc3RUb3RhbD1uO3ZhciByPWUubGVuZ3RoLShuLXRoaXMubGFzdE5lZWQpO3JldHVybiBlLmNvcHkodGhpcy5sYXN0Q2hhciwwLHIpLGUudG9TdHJpbmcoXCJ1dGY4XCIsdCxyKX0sby5wcm90b3R5cGUuZmlsbExhc3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMubGFzdE5lZWQ8PWUubGVuZ3RoPyhlLmNvcHkodGhpcy5sYXN0Q2hhcix0aGlzLmxhc3RUb3RhbC10aGlzLmxhc3ROZWVkLDAsdGhpcy5sYXN0TmVlZCksdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLDAsdGhpcy5sYXN0VG90YWwpKTp2b2lkKGUuY29weSh0aGlzLmxhc3RDaGFyLHRoaXMubGFzdFRvdGFsLXRoaXMubGFzdE5lZWQsMCxlLmxlbmd0aCksdGhpcy5sYXN0TmVlZC09ZS5sZW5ndGgpfX0se1wic2FmZS1idWZmZXJcIjozMH1dLDMyOltmdW5jdGlvbihlLHQpeyhmdW5jdGlvbihlKXsoZnVuY3Rpb24oKXtmdW5jdGlvbiBuKHQpe3RyeXtpZighZS5sb2NhbFN0b3JhZ2UpcmV0dXJuITF9Y2F0Y2goZSl7cmV0dXJuITF9dmFyIG49ZS5sb2NhbFN0b3JhZ2VbdF07cmV0dXJuIG51bGwhPW4mJlwidHJ1ZVwiPT09KG4rXCJcIikudG9Mb3dlckNhc2UoKX10LmV4cG9ydHM9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiByKCl7aWYoIWEpe2lmKG4oXCJ0aHJvd0RlcHJlY2F0aW9uXCIpKXRocm93IG5ldyBFcnJvcih0KTtlbHNlIG4oXCJ0cmFjZURlcHJlY2F0aW9uXCIpP2NvbnNvbGUudHJhY2UodCk6Y29uc29sZS53YXJuKHQpO2E9ITB9cmV0dXJuIGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfWlmKG4oXCJub0RlcHJlY2F0aW9uXCIpKXJldHVybiBlO3ZhciBhPSExO3JldHVybiByfX0pLmNhbGwodGhpcyl9KS5jYWxsKHRoaXMsXCJ1bmRlZmluZWRcIj09dHlwZW9mIGdsb2JhbD9cInVuZGVmaW5lZFwiPT10eXBlb2Ygc2VsZj9cInVuZGVmaW5lZFwiPT10eXBlb2Ygd2luZG93P3t9OndpbmRvdzpzZWxmOmdsb2JhbCl9LHt9XSxcIi9cIjpbZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiBlLnJlcGxhY2UoL2E9aWNlLW9wdGlvbnM6dHJpY2tsZVxcc1xcbi9nLFwiXCIpfWZ1bmN0aW9uIHIoZSl7Y29uc29sZS53YXJuKGUpfS8qISBzaW1wbGUtcGVlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL2NvbnN0IGE9ZShcImRlYnVnXCIpKFwic2ltcGxlLXBlZXJcIiksbz1lKFwiZ2V0LWJyb3dzZXItcnRjXCIpLGk9ZShcInJhbmRvbWJ5dGVzXCIpLGQ9ZShcInJlYWRhYmxlLXN0cmVhbVwiKSxzPWUoXCJxdWV1ZS1taWNyb3Rhc2tcIiksbD1lKFwiZXJyLWNvZGVcIikse0J1ZmZlcjpjfT1lKFwiYnVmZmVyXCIpLHU9NjU1MzY7Y2xhc3MgcCBleHRlbmRzIGQuRHVwbGV4e2NvbnN0cnVjdG9yKGUpe2lmKGU9T2JqZWN0LmFzc2lnbih7YWxsb3dIYWxmT3BlbjohMX0sZSksc3VwZXIoZSksdGhpcy5faWQ9aSg0KS50b1N0cmluZyhcImhleFwiKS5zbGljZSgwLDcpLHRoaXMuX2RlYnVnKFwibmV3IHBlZXIgJW9cIixlKSx0aGlzLmNoYW5uZWxOYW1lPWUuaW5pdGlhdG9yP2UuY2hhbm5lbE5hbWV8fGkoMjApLnRvU3RyaW5nKFwiaGV4XCIpOm51bGwsdGhpcy5pbml0aWF0b3I9ZS5pbml0aWF0b3J8fCExLHRoaXMuY2hhbm5lbENvbmZpZz1lLmNoYW5uZWxDb25maWd8fHAuY2hhbm5lbENvbmZpZyx0aGlzLmNoYW5uZWxOZWdvdGlhdGVkPXRoaXMuY2hhbm5lbENvbmZpZy5uZWdvdGlhdGVkLHRoaXMuY29uZmlnPU9iamVjdC5hc3NpZ24oe30scC5jb25maWcsZS5jb25maWcpLHRoaXMub2ZmZXJPcHRpb25zPWUub2ZmZXJPcHRpb25zfHx7fSx0aGlzLmFuc3dlck9wdGlvbnM9ZS5hbnN3ZXJPcHRpb25zfHx7fSx0aGlzLnNkcFRyYW5zZm9ybT1lLnNkcFRyYW5zZm9ybXx8KGU9PmUpLHRoaXMuc3RyZWFtcz1lLnN0cmVhbXN8fChlLnN0cmVhbT9bZS5zdHJlYW1dOltdKSx0aGlzLnRyaWNrbGU9dm9pZCAwPT09ZS50cmlja2xlfHxlLnRyaWNrbGUsdGhpcy5hbGxvd0hhbGZUcmlja2xlPXZvaWQgMCE9PWUuYWxsb3dIYWxmVHJpY2tsZSYmZS5hbGxvd0hhbGZUcmlja2xlLHRoaXMuaWNlQ29tcGxldGVUaW1lb3V0PWUuaWNlQ29tcGxldGVUaW1lb3V0fHw1MDAwLHRoaXMuZGVzdHJveWVkPSExLHRoaXMuZGVzdHJveWluZz0hMSx0aGlzLl9jb25uZWN0ZWQ9ITEsdGhpcy5yZW1vdGVBZGRyZXNzPXZvaWQgMCx0aGlzLnJlbW90ZUZhbWlseT12b2lkIDAsdGhpcy5yZW1vdGVQb3J0PXZvaWQgMCx0aGlzLmxvY2FsQWRkcmVzcz12b2lkIDAsdGhpcy5sb2NhbEZhbWlseT12b2lkIDAsdGhpcy5sb2NhbFBvcnQ9dm9pZCAwLHRoaXMuX3dydGM9ZS53cnRjJiZcIm9iamVjdFwiPT10eXBlb2YgZS53cnRjP2Uud3J0YzpvKCksIXRoaXMuX3dydGMpaWYoXCJ1bmRlZmluZWRcIj09dHlwZW9mIHdpbmRvdyl0aHJvdyBsKG5ldyBFcnJvcihcIk5vIFdlYlJUQyBzdXBwb3J0OiBTcGVjaWZ5IGBvcHRzLndydGNgIG9wdGlvbiBpbiB0aGlzIGVudmlyb25tZW50XCIpLFwiRVJSX1dFQlJUQ19TVVBQT1JUXCIpO2Vsc2UgdGhyb3cgbChuZXcgRXJyb3IoXCJObyBXZWJSVEMgc3VwcG9ydDogTm90IGEgc3VwcG9ydGVkIGJyb3dzZXJcIiksXCJFUlJfV0VCUlRDX1NVUFBPUlRcIik7dGhpcy5fcGNSZWFkeT0hMSx0aGlzLl9jaGFubmVsUmVhZHk9ITEsdGhpcy5faWNlQ29tcGxldGU9ITEsdGhpcy5faWNlQ29tcGxldGVUaW1lcj1udWxsLHRoaXMuX2NoYW5uZWw9bnVsbCx0aGlzLl9wZW5kaW5nQ2FuZGlkYXRlcz1bXSx0aGlzLl9pc05lZ290aWF0aW5nPSExLHRoaXMuX2ZpcnN0TmVnb3RpYXRpb249ITAsdGhpcy5fYmF0Y2hlZE5lZ290aWF0aW9uPSExLHRoaXMuX3F1ZXVlZE5lZ290aWF0aW9uPSExLHRoaXMuX3NlbmRlcnNBd2FpdGluZ1N0YWJsZT1bXSx0aGlzLl9zZW5kZXJNYXA9bmV3IE1hcCx0aGlzLl9jbG9zaW5nSW50ZXJ2YWw9bnVsbCx0aGlzLl9yZW1vdGVUcmFja3M9W10sdGhpcy5fcmVtb3RlU3RyZWFtcz1bXSx0aGlzLl9jaHVuaz1udWxsLHRoaXMuX2NiPW51bGwsdGhpcy5faW50ZXJ2YWw9bnVsbDt0cnl7dGhpcy5fcGM9bmV3IHRoaXMuX3dydGMuUlRDUGVlckNvbm5lY3Rpb24odGhpcy5jb25maWcpfWNhdGNoKGUpe3JldHVybiB2b2lkIHRoaXMuZGVzdHJveShsKGUsXCJFUlJfUENfQ09OU1RSVUNUT1JcIikpfXRoaXMuX2lzUmVhY3ROYXRpdmVXZWJydGM9XCJudW1iZXJcIj09dHlwZW9mIHRoaXMuX3BjLl9wZWVyQ29ubmVjdGlvbklkLHRoaXMuX3BjLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlPSgpPT57dGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlPSgpPT57dGhpcy5fb25JY2VTdGF0ZUNoYW5nZSgpfSx0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZT0oKT0+e3RoaXMuX29uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKCl9LHRoaXMuX3BjLm9uc2lnbmFsaW5nc3RhdGVjaGFuZ2U9KCk9Pnt0aGlzLl9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKCl9LHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlPWU9Pnt0aGlzLl9vbkljZUNhbmRpZGF0ZShlKX0sXCJvYmplY3RcIj09dHlwZW9mIHRoaXMuX3BjLnBlZXJJZGVudGl0eSYmdGhpcy5fcGMucGVlcklkZW50aXR5LmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1BDX1BFRVJfSURFTlRJVFlcIikpfSksdGhpcy5pbml0aWF0b3J8fHRoaXMuY2hhbm5lbE5lZ290aWF0ZWQ/dGhpcy5fc2V0dXBEYXRhKHtjaGFubmVsOnRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKHRoaXMuY2hhbm5lbE5hbWUsdGhpcy5jaGFubmVsQ29uZmlnKX0pOnRoaXMuX3BjLm9uZGF0YWNoYW5uZWw9ZT0+e3RoaXMuX3NldHVwRGF0YShlKX0sdGhpcy5zdHJlYW1zJiZ0aGlzLnN0cmVhbXMuZm9yRWFjaChlPT57dGhpcy5hZGRTdHJlYW0oZSl9KSx0aGlzLl9wYy5vbnRyYWNrPWU9Pnt0aGlzLl9vblRyYWNrKGUpfSx0aGlzLl9kZWJ1ZyhcImluaXRpYWwgbmVnb3RpYXRpb25cIiksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpLHRoaXMuX29uRmluaXNoQm91bmQ9KCk9Pnt0aGlzLl9vbkZpbmlzaCgpfSx0aGlzLm9uY2UoXCJmaW5pc2hcIix0aGlzLl9vbkZpbmlzaEJvdW5kKX1nZXQgYnVmZmVyU2l6ZSgpe3JldHVybiB0aGlzLl9jaGFubmVsJiZ0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50fHwwfWdldCBjb25uZWN0ZWQoKXtyZXR1cm4gdGhpcy5fY29ubmVjdGVkJiZcIm9wZW5cIj09PXRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZX1hZGRyZXNzKCl7cmV0dXJue3BvcnQ6dGhpcy5sb2NhbFBvcnQsZmFtaWx5OnRoaXMubG9jYWxGYW1pbHksYWRkcmVzczp0aGlzLmxvY2FsQWRkcmVzc319c2lnbmFsKGUpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IHNpZ25hbCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGUpdHJ5e2U9SlNPTi5wYXJzZShlKX1jYXRjaCh0KXtlPXt9fXRoaXMuX2RlYnVnKFwic2lnbmFsKClcIiksZS5yZW5lZ290aWF0ZSYmdGhpcy5pbml0aWF0b3ImJih0aGlzLl9kZWJ1ZyhcImdvdCByZXF1ZXN0IHRvIHJlbmVnb3RpYXRlXCIpLHRoaXMuX25lZWRzTmVnb3RpYXRpb24oKSksZS50cmFuc2NlaXZlclJlcXVlc3QmJnRoaXMuaW5pdGlhdG9yJiYodGhpcy5fZGVidWcoXCJnb3QgcmVxdWVzdCBmb3IgdHJhbnNjZWl2ZXJcIiksdGhpcy5hZGRUcmFuc2NlaXZlcihlLnRyYW5zY2VpdmVyUmVxdWVzdC5raW5kLGUudHJhbnNjZWl2ZXJSZXF1ZXN0LmluaXQpKSxlLmNhbmRpZGF0ZSYmKHRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uJiZ0aGlzLl9wYy5yZW1vdGVEZXNjcmlwdGlvbi50eXBlP3RoaXMuX2FkZEljZUNhbmRpZGF0ZShlLmNhbmRpZGF0ZSk6dGhpcy5fcGVuZGluZ0NhbmRpZGF0ZXMucHVzaChlLmNhbmRpZGF0ZSkpLGUuc2RwJiZ0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihuZXcgdGhpcy5fd3J0Yy5SVENTZXNzaW9uRGVzY3JpcHRpb24oZSkpLnRoZW4oKCk9Pnt0aGlzLmRlc3Ryb3llZHx8KHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goZT0+e3RoaXMuX2FkZEljZUNhbmRpZGF0ZShlKX0pLHRoaXMuX3BlbmRpbmdDYW5kaWRhdGVzPVtdLFwib2ZmZXJcIj09PXRoaXMuX3BjLnJlbW90ZURlc2NyaXB0aW9uLnR5cGUmJnRoaXMuX2NyZWF0ZUFuc3dlcigpKX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1NFVF9SRU1PVEVfREVTQ1JJUFRJT05cIikpfSksZS5zZHB8fGUuY2FuZGlkYXRlfHxlLnJlbmVnb3RpYXRlfHxlLnRyYW5zY2VpdmVyUmVxdWVzdHx8dGhpcy5kZXN0cm95KGwobmV3IEVycm9yKFwic2lnbmFsKCkgY2FsbGVkIHdpdGggaW52YWxpZCBzaWduYWwgZGF0YVwiKSxcIkVSUl9TSUdOQUxJTkdcIikpfX1fYWRkSWNlQ2FuZGlkYXRlKGUpe2NvbnN0IHQ9bmV3IHRoaXMuX3dydGMuUlRDSWNlQ2FuZGlkYXRlKGUpO3RoaXMuX3BjLmFkZEljZUNhbmRpZGF0ZSh0KS5jYXRjaChlPT57IXQuYWRkcmVzc3x8dC5hZGRyZXNzLmVuZHNXaXRoKFwiLmxvY2FsXCIpP3IoXCJJZ25vcmluZyB1bnN1cHBvcnRlZCBJQ0UgY2FuZGlkYXRlLlwiKTp0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0FERF9JQ0VfQ0FORElEQVRFXCIpKX0pfXNlbmQoZSl7aWYoIXRoaXMuZGVzdHJveWluZyl7aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3Qgc2VuZCBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fY2hhbm5lbC5zZW5kKGUpfX1hZGRUcmFuc2NlaXZlcihlLHQpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IGFkZFRyYW5zY2VpdmVyIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTtpZih0aGlzLl9kZWJ1ZyhcImFkZFRyYW5zY2VpdmVyKClcIiksdGhpcy5pbml0aWF0b3IpdHJ5e3RoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKGUsdCksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpfWNhdGNoKGUpe3RoaXMuZGVzdHJveShsKGUsXCJFUlJfQUREX1RSQU5TQ0VJVkVSXCIpKX1lbHNlIHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwidHJhbnNjZWl2ZXJSZXF1ZXN0XCIsdHJhbnNjZWl2ZXJSZXF1ZXN0OntraW5kOmUsaW5pdDp0fX0pfX1hZGRTdHJlYW0oZSl7aWYoIXRoaXMuZGVzdHJveWluZyl7aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgYWRkU3RyZWFtIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTt0aGlzLl9kZWJ1ZyhcImFkZFN0cmVhbSgpXCIpLGUuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0PT57dGhpcy5hZGRUcmFjayh0LGUpfSl9fWFkZFRyYWNrKGUsdCl7aWYodGhpcy5kZXN0cm95aW5nKXJldHVybjtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCBhZGRUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJhZGRUcmFjaygpXCIpO2NvbnN0IG49dGhpcy5fc2VuZGVyTWFwLmdldChlKXx8bmV3IE1hcDtsZXQgcj1uLmdldCh0KTtpZighcilyPXRoaXMuX3BjLmFkZFRyYWNrKGUsdCksbi5zZXQodCxyKSx0aGlzLl9zZW5kZXJNYXAuc2V0KGUsbiksdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpO2Vsc2UgaWYoci5yZW1vdmVkKXRocm93IGwobmV3IEVycm9yKFwiVHJhY2sgaGFzIGJlZW4gcmVtb3ZlZC4gWW91IHNob3VsZCBlbmFibGUvZGlzYWJsZSB0cmFja3MgdGhhdCB5b3Ugd2FudCB0byByZS1hZGQuXCIpLFwiRVJSX1NFTkRFUl9SRU1PVkVEXCIpO2Vsc2UgdGhyb3cgbChuZXcgRXJyb3IoXCJUcmFjayBoYXMgYWxyZWFkeSBiZWVuIGFkZGVkIHRvIHRoYXQgc3RyZWFtLlwiKSxcIkVSUl9TRU5ERVJfQUxSRUFEWV9BRERFRFwiKX1yZXBsYWNlVHJhY2soZSx0LG4pe2lmKHRoaXMuZGVzdHJveWluZylyZXR1cm47aWYodGhpcy5kZXN0cm95ZWQpdGhyb3cgbChuZXcgRXJyb3IoXCJjYW5ub3QgcmVwbGFjZVRyYWNrIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RFU1RST1lFRFwiKTt0aGlzLl9kZWJ1ZyhcInJlcGxhY2VUcmFjaygpXCIpO2NvbnN0IHI9dGhpcy5fc2VuZGVyTWFwLmdldChlKSxhPXI/ci5nZXQobik6bnVsbDtpZighYSl0aHJvdyBsKG5ldyBFcnJvcihcIkNhbm5vdCByZXBsYWNlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLlwiKSxcIkVSUl9UUkFDS19OT1RfQURERURcIik7dCYmdGhpcy5fc2VuZGVyTWFwLnNldCh0LHIpLG51bGw9PWEucmVwbGFjZVRyYWNrP3RoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcInJlcGxhY2VUcmFjayBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKSxcIkVSUl9VTlNVUFBPUlRFRF9SRVBMQUNFVFJBQ0tcIikpOmEucmVwbGFjZVRyYWNrKHQpfXJlbW92ZVRyYWNrKGUsdCl7aWYodGhpcy5kZXN0cm95aW5nKXJldHVybjtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCByZW1vdmVUcmFjayBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5fZGVidWcoXCJyZW1vdmVTZW5kZXIoKVwiKTtjb25zdCBuPXRoaXMuX3NlbmRlck1hcC5nZXQoZSkscj1uP24uZ2V0KHQpOm51bGw7aWYoIXIpdGhyb3cgbChuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRyYWNrIHRoYXQgd2FzIG5ldmVyIGFkZGVkLlwiKSxcIkVSUl9UUkFDS19OT1RfQURERURcIik7dHJ5e3IucmVtb3ZlZD0hMCx0aGlzLl9wYy5yZW1vdmVUcmFjayhyKX1jYXRjaChlKXtcIk5TX0VSUk9SX1VORVhQRUNURURcIj09PWUubmFtZT90aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUucHVzaChyKTp0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1JFTU9WRV9UUkFDS1wiKSl9dGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpfXJlbW92ZVN0cmVhbShlKXtpZighdGhpcy5kZXN0cm95aW5nKXtpZih0aGlzLmRlc3Ryb3llZCl0aHJvdyBsKG5ldyBFcnJvcihcImNhbm5vdCByZW1vdmVTdHJlYW0gYWZ0ZXIgcGVlciBpcyBkZXN0cm95ZWRcIiksXCJFUlJfREVTVFJPWUVEXCIpO3RoaXMuX2RlYnVnKFwicmVtb3ZlU2VuZGVycygpXCIpLGUuZ2V0VHJhY2tzKCkuZm9yRWFjaCh0PT57dGhpcy5yZW1vdmVUcmFjayh0LGUpfSl9fV9uZWVkc05lZ290aWF0aW9uKCl7dGhpcy5fZGVidWcoXCJfbmVlZHNOZWdvdGlhdGlvblwiKSx0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb258fCh0aGlzLl9iYXRjaGVkTmVnb3RpYXRpb249ITAscygoKT0+e3RoaXMuX2JhdGNoZWROZWdvdGlhdGlvbj0hMSx0aGlzLmluaXRpYXRvcnx8IXRoaXMuX2ZpcnN0TmVnb3RpYXRpb24/KHRoaXMuX2RlYnVnKFwic3RhcnRpbmcgYmF0Y2hlZCBuZWdvdGlhdGlvblwiKSx0aGlzLm5lZ290aWF0ZSgpKTp0aGlzLl9kZWJ1ZyhcIm5vbi1pbml0aWF0b3IgaW5pdGlhbCBuZWdvdGlhdGlvbiByZXF1ZXN0IGRpc2NhcmRlZFwiKSx0aGlzLl9maXJzdE5lZ290aWF0aW9uPSExfSkpfW5lZ290aWF0ZSgpe2lmKCF0aGlzLmRlc3Ryb3lpbmcpe2lmKHRoaXMuZGVzdHJveWVkKXRocm93IGwobmV3IEVycm9yKFwiY2Fubm90IG5lZ290aWF0ZSBhZnRlciBwZWVyIGlzIGRlc3Ryb3llZFwiKSxcIkVSUl9ERVNUUk9ZRURcIik7dGhpcy5pbml0aWF0b3I/dGhpcy5faXNOZWdvdGlhdGluZz8odGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITAsdGhpcy5fZGVidWcoXCJhbHJlYWR5IG5lZ290aWF0aW5nLCBxdWV1ZWluZ1wiKSk6KHRoaXMuX2RlYnVnKFwic3RhcnQgbmVnb3RpYXRpb25cIiksc2V0VGltZW91dCgoKT0+e3RoaXMuX2NyZWF0ZU9mZmVyKCl9LDApKTp0aGlzLl9pc05lZ290aWF0aW5nPyh0aGlzLl9xdWV1ZWROZWdvdGlhdGlvbj0hMCx0aGlzLl9kZWJ1ZyhcImFscmVhZHkgbmVnb3RpYXRpbmcsIHF1ZXVlaW5nXCIpKToodGhpcy5fZGVidWcoXCJyZXF1ZXN0aW5nIG5lZ290aWF0aW9uIGZyb20gaW5pdGlhdG9yXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwicmVuZWdvdGlhdGVcIixyZW5lZ290aWF0ZTohMH0pKSx0aGlzLl9pc05lZ290aWF0aW5nPSEwfX1kZXN0cm95KGUpe3RoaXMuX2Rlc3Ryb3koZSwoKT0+e30pfV9kZXN0cm95KGUsdCl7dGhpcy5kZXN0cm95ZWR8fHRoaXMuZGVzdHJveWluZ3x8KHRoaXMuZGVzdHJveWluZz0hMCx0aGlzLl9kZWJ1ZyhcImRlc3Ryb3lpbmcgKGVycm9yOiAlcylcIixlJiYoZS5tZXNzYWdlfHxlKSkscygoKT0+e2lmKHRoaXMuZGVzdHJveWVkPSEwLHRoaXMuZGVzdHJveWluZz0hMSx0aGlzLl9kZWJ1ZyhcImRlc3Ryb3kgKGVycm9yOiAlcylcIixlJiYoZS5tZXNzYWdlfHxlKSksdGhpcy5yZWFkYWJsZT10aGlzLndyaXRhYmxlPSExLHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWR8fHRoaXMucHVzaChudWxsKSx0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkfHx0aGlzLmVuZCgpLHRoaXMuX2Nvbm5lY3RlZD0hMSx0aGlzLl9wY1JlYWR5PSExLHRoaXMuX2NoYW5uZWxSZWFkeT0hMSx0aGlzLl9yZW1vdGVUcmFja3M9bnVsbCx0aGlzLl9yZW1vdGVTdHJlYW1zPW51bGwsdGhpcy5fc2VuZGVyTWFwPW51bGwsY2xlYXJJbnRlcnZhbCh0aGlzLl9jbG9zaW5nSW50ZXJ2YWwpLHRoaXMuX2Nsb3NpbmdJbnRlcnZhbD1udWxsLGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpLHRoaXMuX2ludGVydmFsPW51bGwsdGhpcy5fY2h1bms9bnVsbCx0aGlzLl9jYj1udWxsLHRoaXMuX29uRmluaXNoQm91bmQmJnRoaXMucmVtb3ZlTGlzdGVuZXIoXCJmaW5pc2hcIix0aGlzLl9vbkZpbmlzaEJvdW5kKSx0aGlzLl9vbkZpbmlzaEJvdW5kPW51bGwsdGhpcy5fY2hhbm5lbCl7dHJ5e3RoaXMuX2NoYW5uZWwuY2xvc2UoKX1jYXRjaChlKXt9dGhpcy5fY2hhbm5lbC5vbm1lc3NhZ2U9bnVsbCx0aGlzLl9jaGFubmVsLm9ub3Blbj1udWxsLHRoaXMuX2NoYW5uZWwub25jbG9zZT1udWxsLHRoaXMuX2NoYW5uZWwub25lcnJvcj1udWxsfWlmKHRoaXMuX3BjKXt0cnl7dGhpcy5fcGMuY2xvc2UoKX1jYXRjaChlKXt9dGhpcy5fcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2U9bnVsbCx0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlPW51bGwsdGhpcy5fcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZT1udWxsLHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlPW51bGwsdGhpcy5fcGMub250cmFjaz1udWxsLHRoaXMuX3BjLm9uZGF0YWNoYW5uZWw9bnVsbH10aGlzLl9wYz1udWxsLHRoaXMuX2NoYW5uZWw9bnVsbCxlJiZ0aGlzLmVtaXQoXCJlcnJvclwiLGUpLHRoaXMuZW1pdChcImNsb3NlXCIpLHQoKX0pKX1fc2V0dXBEYXRhKGUpe2lmKCFlLmNoYW5uZWwpcmV0dXJuIHRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkRhdGEgY2hhbm5lbCBldmVudCBpcyBtaXNzaW5nIGBjaGFubmVsYCBwcm9wZXJ0eVwiKSxcIkVSUl9EQVRBX0NIQU5ORUxcIikpO3RoaXMuX2NoYW5uZWw9ZS5jaGFubmVsLHRoaXMuX2NoYW5uZWwuYmluYXJ5VHlwZT1cImFycmF5YnVmZmVyXCIsXCJudW1iZXJcIj09dHlwZW9mIHRoaXMuX2NoYW5uZWwuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQmJih0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkPXUpLHRoaXMuY2hhbm5lbE5hbWU9dGhpcy5fY2hhbm5lbC5sYWJlbCx0aGlzLl9jaGFubmVsLm9ubWVzc2FnZT1lPT57dGhpcy5fb25DaGFubmVsTWVzc2FnZShlKX0sdGhpcy5fY2hhbm5lbC5vbmJ1ZmZlcmVkYW1vdW50bG93PSgpPT57dGhpcy5fb25DaGFubmVsQnVmZmVyZWRBbW91bnRMb3coKX0sdGhpcy5fY2hhbm5lbC5vbm9wZW49KCk9Pnt0aGlzLl9vbkNoYW5uZWxPcGVuKCl9LHRoaXMuX2NoYW5uZWwub25jbG9zZT0oKT0+e3RoaXMuX29uQ2hhbm5lbENsb3NlKCl9LHRoaXMuX2NoYW5uZWwub25lcnJvcj1lPT57Y29uc3QgdD1lLmVycm9yIGluc3RhbmNlb2YgRXJyb3I/ZS5lcnJvcjpuZXcgRXJyb3IoYERhdGFjaGFubmVsIGVycm9yOiAke2UubWVzc2FnZX0gJHtlLmZpbGVuYW1lfToke2UubGluZW5vfToke2UuY29sbm99YCk7dGhpcy5kZXN0cm95KGwodCxcIkVSUl9EQVRBX0NIQU5ORUxcIikpfTtsZXQgdD0hMTt0aGlzLl9jbG9zaW5nSW50ZXJ2YWw9c2V0SW50ZXJ2YWwoKCk9Pnt0aGlzLl9jaGFubmVsJiZcImNsb3NpbmdcIj09PXRoaXMuX2NoYW5uZWwucmVhZHlTdGF0ZT8odCYmdGhpcy5fb25DaGFubmVsQ2xvc2UoKSx0PSEwKTp0PSExfSw1MDAwKX1fcmVhZCgpe31fd3JpdGUoZSx0LG4pe2lmKHRoaXMuZGVzdHJveWVkKXJldHVybiBuKGwobmV3IEVycm9yKFwiY2Fubm90IHdyaXRlIGFmdGVyIHBlZXIgaXMgZGVzdHJveWVkXCIpLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSk7aWYodGhpcy5fY29ubmVjdGVkKXt0cnl7dGhpcy5zZW5kKGUpfWNhdGNoKGUpe3JldHVybiB0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSl9dGhpcy5fY2hhbm5lbC5idWZmZXJlZEFtb3VudD51Pyh0aGlzLl9kZWJ1ZyhcInN0YXJ0IGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWRcIix0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KSx0aGlzLl9jYj1uKTpuKG51bGwpfWVsc2UgdGhpcy5fZGVidWcoXCJ3cml0ZSBiZWZvcmUgY29ubmVjdFwiKSx0aGlzLl9jaHVuaz1lLHRoaXMuX2NiPW59X29uRmluaXNoKCl7aWYoIXRoaXMuZGVzdHJveWVkKXtjb25zdCBlPSgpPT57c2V0VGltZW91dCgoKT0+dGhpcy5kZXN0cm95KCksMWUzKX07dGhpcy5fY29ubmVjdGVkP2UoKTp0aGlzLm9uY2UoXCJjb25uZWN0XCIsZSl9fV9zdGFydEljZUNvbXBsZXRlVGltZW91dCgpe3RoaXMuZGVzdHJveWVkfHx0aGlzLl9pY2VDb21wbGV0ZVRpbWVyfHwodGhpcy5fZGVidWcoXCJzdGFydGVkIGljZUNvbXBsZXRlIHRpbWVvdXRcIiksdGhpcy5faWNlQ29tcGxldGVUaW1lcj1zZXRUaW1lb3V0KCgpPT57dGhpcy5faWNlQ29tcGxldGV8fCh0aGlzLl9pY2VDb21wbGV0ZT0hMCx0aGlzLl9kZWJ1ZyhcImljZUNvbXBsZXRlIHRpbWVvdXQgY29tcGxldGVkXCIpLHRoaXMuZW1pdChcImljZVRpbWVvdXRcIiksdGhpcy5lbWl0KFwiX2ljZUNvbXBsZXRlXCIpKX0sdGhpcy5pY2VDb21wbGV0ZVRpbWVvdXQpKX1fY3JlYXRlT2ZmZXIoKXt0aGlzLmRlc3Ryb3llZHx8dGhpcy5fcGMuY3JlYXRlT2ZmZXIodGhpcy5vZmZlck9wdGlvbnMpLnRoZW4oZT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0aGlzLnRyaWNrbGV8fHRoaXMuYWxsb3dIYWxmVHJpY2tsZXx8KGUuc2RwPW4oZS5zZHApKSxlLnNkcD10aGlzLnNkcFRyYW5zZm9ybShlLnNkcCk7Y29uc3QgdD0oKT0+e2lmKCF0aGlzLmRlc3Ryb3llZCl7Y29uc3QgdD10aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9ufHxlO3RoaXMuX2RlYnVnKFwic2lnbmFsXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOnQudHlwZSxzZHA6dC5zZHB9KX19O3RoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oZSkudGhlbigoKT0+e3RoaXMuX2RlYnVnKFwiY3JlYXRlT2ZmZXIgc3VjY2Vzc1wiKSx0aGlzLmRlc3Ryb3llZHx8KHRoaXMudHJpY2tsZXx8dGhpcy5faWNlQ29tcGxldGU/dCgpOnRoaXMub25jZShcIl9pY2VDb21wbGV0ZVwiLHQpKX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX1NFVF9MT0NBTF9ERVNDUklQVElPTlwiKSl9KX0pLmNhdGNoKGU9Pnt0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0NSRUFURV9PRkZFUlwiKSl9KX1fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKXt0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMmJnRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpLmZvckVhY2goZT0+e2UubWlkfHwhZS5zZW5kZXIudHJhY2t8fGUucmVxdWVzdGVkfHwoZS5yZXF1ZXN0ZWQ9ITAsdGhpcy5hZGRUcmFuc2NlaXZlcihlLnNlbmRlci50cmFjay5raW5kKSl9KX1fY3JlYXRlQW5zd2VyKCl7dGhpcy5kZXN0cm95ZWR8fHRoaXMuX3BjLmNyZWF0ZUFuc3dlcih0aGlzLmFuc3dlck9wdGlvbnMpLnRoZW4oZT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0aGlzLnRyaWNrbGV8fHRoaXMuYWxsb3dIYWxmVHJpY2tsZXx8KGUuc2RwPW4oZS5zZHApKSxlLnNkcD10aGlzLnNkcFRyYW5zZm9ybShlLnNkcCk7Y29uc3QgdD0oKT0+e2lmKCF0aGlzLmRlc3Ryb3llZCl7Y29uc3QgdD10aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9ufHxlO3RoaXMuX2RlYnVnKFwic2lnbmFsXCIpLHRoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOnQudHlwZSxzZHA6dC5zZHB9KSx0aGlzLmluaXRpYXRvcnx8dGhpcy5fcmVxdWVzdE1pc3NpbmdUcmFuc2NlaXZlcnMoKX19O3RoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oZSkudGhlbigoKT0+e3RoaXMuZGVzdHJveWVkfHwodGhpcy50cmlja2xlfHx0aGlzLl9pY2VDb21wbGV0ZT90KCk6dGhpcy5vbmNlKFwiX2ljZUNvbXBsZXRlXCIsdCkpfSkuY2F0Y2goZT0+e3RoaXMuZGVzdHJveShsKGUsXCJFUlJfU0VUX0xPQ0FMX0RFU0NSSVBUSU9OXCIpKX0pfSkuY2F0Y2goZT0+e3RoaXMuZGVzdHJveShsKGUsXCJFUlJfQ1JFQVRFX0FOU1dFUlwiKSl9KX1fb25Db25uZWN0aW9uU3RhdGVDaGFuZ2UoKXt0aGlzLmRlc3Ryb3llZHx8XCJmYWlsZWRcIj09PXRoaXMuX3BjLmNvbm5lY3Rpb25TdGF0ZSYmdGhpcy5kZXN0cm95KGwobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBmYWlsZWQuXCIpLFwiRVJSX0NPTk5FQ1RJT05fRkFJTFVSRVwiKSl9X29uSWNlU3RhdGVDaGFuZ2UoKXtpZih0aGlzLmRlc3Ryb3llZClyZXR1cm47Y29uc3QgZT10aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUsdD10aGlzLl9wYy5pY2VHYXRoZXJpbmdTdGF0ZTt0aGlzLl9kZWJ1ZyhcImljZVN0YXRlQ2hhbmdlIChjb25uZWN0aW9uOiAlcykgKGdhdGhlcmluZzogJXMpXCIsZSx0KSx0aGlzLmVtaXQoXCJpY2VTdGF0ZUNoYW5nZVwiLGUsdCksKFwiY29ubmVjdGVkXCI9PT1lfHxcImNvbXBsZXRlZFwiPT09ZSkmJih0aGlzLl9wY1JlYWR5PSEwLHRoaXMuX21heWJlUmVhZHkoKSksXCJmYWlsZWRcIj09PWUmJnRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkljZSBjb25uZWN0aW9uIGZhaWxlZC5cIiksXCJFUlJfSUNFX0NPTk5FQ1RJT05fRkFJTFVSRVwiKSksXCJjbG9zZWRcIj09PWUmJnRoaXMuZGVzdHJveShsKG5ldyBFcnJvcihcIkljZSBjb25uZWN0aW9uIGNsb3NlZC5cIiksXCJFUlJfSUNFX0NPTk5FQ1RJT05fQ0xPU0VEXCIpKX1nZXRTdGF0cyhlKXtjb25zdCB0PWU9PihcIltvYmplY3QgQXJyYXldXCI9PT1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZS52YWx1ZXMpJiZlLnZhbHVlcy5mb3JFYWNoKHQ9PntPYmplY3QuYXNzaWduKGUsdCl9KSxlKTswPT09dGhpcy5fcGMuZ2V0U3RhdHMubGVuZ3RofHx0aGlzLl9pc1JlYWN0TmF0aXZlV2VicnRjP3RoaXMuX3BjLmdldFN0YXRzKCkudGhlbihuPT57Y29uc3Qgcj1bXTtuLmZvckVhY2goZT0+e3IucHVzaCh0KGUpKX0pLGUobnVsbCxyKX0sdD0+ZSh0KSk6MDx0aGlzLl9wYy5nZXRTdGF0cy5sZW5ndGg/dGhpcy5fcGMuZ2V0U3RhdHMobj0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjtjb25zdCByPVtdO24ucmVzdWx0KCkuZm9yRWFjaChlPT57Y29uc3Qgbj17fTtlLm5hbWVzKCkuZm9yRWFjaCh0PT57blt0XT1lLnN0YXQodCl9KSxuLmlkPWUuaWQsbi50eXBlPWUudHlwZSxuLnRpbWVzdGFtcD1lLnRpbWVzdGFtcCxyLnB1c2godChuKSl9KSxlKG51bGwscil9LHQ9PmUodCkpOmUobnVsbCxbXSl9X21heWJlUmVhZHkoKXtpZih0aGlzLl9kZWJ1ZyhcIm1heWJlUmVhZHkgcGMgJXMgY2hhbm5lbCAlc1wiLHRoaXMuX3BjUmVhZHksdGhpcy5fY2hhbm5lbFJlYWR5KSx0aGlzLl9jb25uZWN0ZWR8fHRoaXMuX2Nvbm5lY3Rpbmd8fCF0aGlzLl9wY1JlYWR5fHwhdGhpcy5fY2hhbm5lbFJlYWR5KXJldHVybjt0aGlzLl9jb25uZWN0aW5nPSEwO2NvbnN0IGU9KCk9Pnt0aGlzLmRlc3Ryb3llZHx8dGhpcy5nZXRTdGF0cygodCxuKT0+e2lmKHRoaXMuZGVzdHJveWVkKXJldHVybjt0JiYobj1bXSk7Y29uc3Qgcj17fSxhPXt9LG89e307bGV0IGk9ITE7bi5mb3JFYWNoKGU9PnsoXCJyZW1vdGVjYW5kaWRhdGVcIj09PWUudHlwZXx8XCJyZW1vdGUtY2FuZGlkYXRlXCI9PT1lLnR5cGUpJiYocltlLmlkXT1lKSwoXCJsb2NhbGNhbmRpZGF0ZVwiPT09ZS50eXBlfHxcImxvY2FsLWNhbmRpZGF0ZVwiPT09ZS50eXBlKSYmKGFbZS5pZF09ZSksKFwiY2FuZGlkYXRlcGFpclwiPT09ZS50eXBlfHxcImNhbmRpZGF0ZS1wYWlyXCI9PT1lLnR5cGUpJiYob1tlLmlkXT1lKX0pO2NvbnN0IGQ9ZT0+e2k9ITA7bGV0IHQ9YVtlLmxvY2FsQ2FuZGlkYXRlSWRdO3QmJih0LmlwfHx0LmFkZHJlc3MpPyh0aGlzLmxvY2FsQWRkcmVzcz10LmlwfHx0LmFkZHJlc3MsdGhpcy5sb2NhbFBvcnQ9K3QucG9ydCk6dCYmdC5pcEFkZHJlc3M/KHRoaXMubG9jYWxBZGRyZXNzPXQuaXBBZGRyZXNzLHRoaXMubG9jYWxQb3J0PSt0LnBvcnROdW1iZXIpOlwic3RyaW5nXCI9PXR5cGVvZiBlLmdvb2dMb2NhbEFkZHJlc3MmJih0PWUuZ29vZ0xvY2FsQWRkcmVzcy5zcGxpdChcIjpcIiksdGhpcy5sb2NhbEFkZHJlc3M9dFswXSx0aGlzLmxvY2FsUG9ydD0rdFsxXSksdGhpcy5sb2NhbEFkZHJlc3MmJih0aGlzLmxvY2FsRmFtaWx5PXRoaXMubG9jYWxBZGRyZXNzLmluY2x1ZGVzKFwiOlwiKT9cIklQdjZcIjpcIklQdjRcIik7bGV0IG49cltlLnJlbW90ZUNhbmRpZGF0ZUlkXTtuJiYobi5pcHx8bi5hZGRyZXNzKT8odGhpcy5yZW1vdGVBZGRyZXNzPW4uaXB8fG4uYWRkcmVzcyx0aGlzLnJlbW90ZVBvcnQ9K24ucG9ydCk6biYmbi5pcEFkZHJlc3M/KHRoaXMucmVtb3RlQWRkcmVzcz1uLmlwQWRkcmVzcyx0aGlzLnJlbW90ZVBvcnQ9K24ucG9ydE51bWJlcik6XCJzdHJpbmdcIj09dHlwZW9mIGUuZ29vZ1JlbW90ZUFkZHJlc3MmJihuPWUuZ29vZ1JlbW90ZUFkZHJlc3Muc3BsaXQoXCI6XCIpLHRoaXMucmVtb3RlQWRkcmVzcz1uWzBdLHRoaXMucmVtb3RlUG9ydD0rblsxXSksdGhpcy5yZW1vdGVBZGRyZXNzJiYodGhpcy5yZW1vdGVGYW1pbHk9dGhpcy5yZW1vdGVBZGRyZXNzLmluY2x1ZGVzKFwiOlwiKT9cIklQdjZcIjpcIklQdjRcIiksdGhpcy5fZGVidWcoXCJjb25uZWN0IGxvY2FsOiAlczolcyByZW1vdGU6ICVzOiVzXCIsdGhpcy5sb2NhbEFkZHJlc3MsdGhpcy5sb2NhbFBvcnQsdGhpcy5yZW1vdGVBZGRyZXNzLHRoaXMucmVtb3RlUG9ydCl9O2lmKG4uZm9yRWFjaChlPT57XCJ0cmFuc3BvcnRcIj09PWUudHlwZSYmZS5zZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCYmZChvW2Uuc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWRdKSwoXCJnb29nQ2FuZGlkYXRlUGFpclwiPT09ZS50eXBlJiZcInRydWVcIj09PWUuZ29vZ0FjdGl2ZUNvbm5lY3Rpb258fChcImNhbmRpZGF0ZXBhaXJcIj09PWUudHlwZXx8XCJjYW5kaWRhdGUtcGFpclwiPT09ZS50eXBlKSYmZS5zZWxlY3RlZCkmJmQoZSl9KSwhaSYmKCFPYmplY3Qua2V5cyhvKS5sZW5ndGh8fE9iamVjdC5rZXlzKGEpLmxlbmd0aCkpcmV0dXJuIHZvaWQgc2V0VGltZW91dChlLDEwMCk7aWYodGhpcy5fY29ubmVjdGluZz0hMSx0aGlzLl9jb25uZWN0ZWQ9ITAsdGhpcy5fY2h1bmspe3RyeXt0aGlzLnNlbmQodGhpcy5fY2h1bmspfWNhdGNoKGUpe3JldHVybiB0aGlzLmRlc3Ryb3kobChlLFwiRVJSX0RBVEFfQ0hBTk5FTFwiKSl9dGhpcy5fY2h1bms9bnVsbCx0aGlzLl9kZWJ1ZyhcInNlbnQgY2h1bmsgZnJvbSBcXFwid3JpdGUgYmVmb3JlIGNvbm5lY3RcXFwiXCIpO2NvbnN0IGU9dGhpcy5fY2I7dGhpcy5fY2I9bnVsbCxlKG51bGwpfVwibnVtYmVyXCIhPXR5cGVvZiB0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkJiYodGhpcy5faW50ZXJ2YWw9c2V0SW50ZXJ2YWwoKCk9PnRoaXMuX29uSW50ZXJ2YWwoKSwxNTApLHRoaXMuX2ludGVydmFsLnVucmVmJiZ0aGlzLl9pbnRlcnZhbC51bnJlZigpKSx0aGlzLl9kZWJ1ZyhcImNvbm5lY3RcIiksdGhpcy5lbWl0KFwiY29ubmVjdFwiKX0pfTtlKCl9X29uSW50ZXJ2YWwoKXt0aGlzLl9jYiYmdGhpcy5fY2hhbm5lbCYmISh0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50PnUpJiZ0aGlzLl9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpfV9vblNpZ25hbGluZ1N0YXRlQ2hhbmdlKCl7dGhpcy5kZXN0cm95ZWR8fChcInN0YWJsZVwiPT09dGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUmJih0aGlzLl9pc05lZ290aWF0aW5nPSExLHRoaXMuX2RlYnVnKFwiZmx1c2hpbmcgc2VuZGVyIHF1ZXVlXCIsdGhpcy5fc2VuZGVyc0F3YWl0aW5nU3RhYmxlKSx0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGUuZm9yRWFjaChlPT57dGhpcy5fcGMucmVtb3ZlVHJhY2soZSksdGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITB9KSx0aGlzLl9zZW5kZXJzQXdhaXRpbmdTdGFibGU9W10sdGhpcy5fcXVldWVkTmVnb3RpYXRpb24/KHRoaXMuX2RlYnVnKFwiZmx1c2hpbmcgbmVnb3RpYXRpb24gcXVldWVcIiksdGhpcy5fcXVldWVkTmVnb3RpYXRpb249ITEsdGhpcy5fbmVlZHNOZWdvdGlhdGlvbigpKToodGhpcy5fZGVidWcoXCJuZWdvdGlhdGVkXCIpLHRoaXMuZW1pdChcIm5lZ290aWF0ZWRcIikpKSx0aGlzLl9kZWJ1ZyhcInNpZ25hbGluZ1N0YXRlQ2hhbmdlICVzXCIsdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpLHRoaXMuZW1pdChcInNpZ25hbGluZ1N0YXRlQ2hhbmdlXCIsdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUpKX1fb25JY2VDYW5kaWRhdGUoZSl7dGhpcy5kZXN0cm95ZWR8fChlLmNhbmRpZGF0ZSYmdGhpcy50cmlja2xlP3RoaXMuZW1pdChcInNpZ25hbFwiLHt0eXBlOlwiY2FuZGlkYXRlXCIsY2FuZGlkYXRlOntjYW5kaWRhdGU6ZS5jYW5kaWRhdGUuY2FuZGlkYXRlLHNkcE1MaW5lSW5kZXg6ZS5jYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxzZHBNaWQ6ZS5jYW5kaWRhdGUuc2RwTWlkfX0pOiFlLmNhbmRpZGF0ZSYmIXRoaXMuX2ljZUNvbXBsZXRlJiYodGhpcy5faWNlQ29tcGxldGU9ITAsdGhpcy5lbWl0KFwiX2ljZUNvbXBsZXRlXCIpKSxlLmNhbmRpZGF0ZSYmdGhpcy5fc3RhcnRJY2VDb21wbGV0ZVRpbWVvdXQoKSl9X29uQ2hhbm5lbE1lc3NhZ2UoZSl7aWYodGhpcy5kZXN0cm95ZWQpcmV0dXJuO2xldCB0PWUuZGF0YTt0IGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJih0PWMuZnJvbSh0KSksdGhpcy5wdXNoKHQpfV9vbkNoYW5uZWxCdWZmZXJlZEFtb3VudExvdygpe2lmKCF0aGlzLmRlc3Ryb3llZCYmdGhpcy5fY2Ipe3RoaXMuX2RlYnVnKFwiZW5kaW5nIGJhY2twcmVzc3VyZTogYnVmZmVyZWRBbW91bnQgJWRcIix0aGlzLl9jaGFubmVsLmJ1ZmZlcmVkQW1vdW50KTtjb25zdCBlPXRoaXMuX2NiO3RoaXMuX2NiPW51bGwsZShudWxsKX19X29uQ2hhbm5lbE9wZW4oKXt0aGlzLl9jb25uZWN0ZWR8fHRoaXMuZGVzdHJveWVkfHwodGhpcy5fZGVidWcoXCJvbiBjaGFubmVsIG9wZW5cIiksdGhpcy5fY2hhbm5lbFJlYWR5PSEwLHRoaXMuX21heWJlUmVhZHkoKSl9X29uQ2hhbm5lbENsb3NlKCl7dGhpcy5kZXN0cm95ZWR8fCh0aGlzLl9kZWJ1ZyhcIm9uIGNoYW5uZWwgY2xvc2VcIiksdGhpcy5kZXN0cm95KCkpfV9vblRyYWNrKGUpe3RoaXMuZGVzdHJveWVkfHxlLnN0cmVhbXMuZm9yRWFjaCh0PT57dGhpcy5fZGVidWcoXCJvbiB0cmFja1wiKSx0aGlzLmVtaXQoXCJ0cmFja1wiLGUudHJhY2ssdCksdGhpcy5fcmVtb3RlVHJhY2tzLnB1c2goe3RyYWNrOmUudHJhY2ssc3RyZWFtOnR9KSx0aGlzLl9yZW1vdGVTdHJlYW1zLnNvbWUoZT0+ZS5pZD09PXQuaWQpfHwodGhpcy5fcmVtb3RlU3RyZWFtcy5wdXNoKHQpLHMoKCk9Pnt0aGlzLl9kZWJ1ZyhcIm9uIHN0cmVhbVwiKSx0aGlzLmVtaXQoXCJzdHJlYW1cIix0KX0pKX0pfV9kZWJ1Zygpe2NvbnN0IGU9W10uc2xpY2UuY2FsbChhcmd1bWVudHMpO2VbMF09XCJbXCIrdGhpcy5faWQrXCJdIFwiK2VbMF0sYS5hcHBseShudWxsLGUpfX1wLldFQlJUQ19TVVBQT1JUPSEhbygpLHAuY29uZmlnPXtpY2VTZXJ2ZXJzOlt7dXJsczpbXCJzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyXCIsXCJzdHVuOmdsb2JhbC5zdHVuLnR3aWxpby5jb206MzQ3OFwiXX1dLHNkcFNlbWFudGljczpcInVuaWZpZWQtcGxhblwifSxwLmNoYW5uZWxDb25maWc9e30sdC5leHBvcnRzPXB9LHtidWZmZXI6MyxkZWJ1Zzo0LFwiZXJyLWNvZGVcIjo2LFwiZ2V0LWJyb3dzZXItcnRjXCI6OCxcInF1ZXVlLW1pY3JvdGFza1wiOjEzLHJhbmRvbWJ5dGVzOjE0LFwicmVhZGFibGUtc3RyZWFtXCI6Mjl9XX0se30sW10pKFwiL1wiKX0pOyIsICJpbXBvcnQgUGVlcmRyYWZ0UGx1Z2luIGZyb20gJy4vcGVlcmRyYWZ0UGx1Z2luJztcblxuZXhwb3J0IGRlZmF1bHQgUGVlcmRyYWZ0UGx1Z2luIiwgImltcG9ydCB7IE1hcmtkb3duVmlldywgUGx1Z2luLCBURmlsZSwgVEZvbGRlciwgbm9ybWFsaXplUGF0aCB9IGZyb20gXCJvYnNpZGlhblwiXG5pbXBvcnQgeyBBY3RpdmVTdHJlYW1DbGllbnQgfSBmcm9tIFwiLi9hY3RpdmVTdHJlYW1DbGllbnRcIlxuaW1wb3J0IHsgcHJlcGFyZUNvbW11bmljYXRpb24gfSBmcm9tIFwiLi9jb29raWVcIlxuaW1wb3J0IHsgU2VydmVyQVBJIH0gZnJvbSBcIi4vc2VydmVyQVBJXCJcbmltcG9ydCB7IFNldHRpbmdzLCBjcmVhdGVTZXR0aW5nc1RhYiwgZ2V0U2V0dGluZ3MsIG1pZ3JhdGVTZXR0aW5ncywgc2F2ZVNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIlxuaW1wb3J0IHsgU2hhcmVkRG9jdW1lbnQgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudFwiXG5pbXBvcnQgeyBmcm9tU2hhcmVVUkwgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlGYWN0b3J5XCJcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gXCIuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlclwiXG5pbXBvcnQgeyBzaG93Tm90aWNlIH0gZnJvbSBcIi4vdWlcIlxuaW1wb3J0IHsgcHJvbXB0Rm9yU2Vzc2lvblR5cGUgfSBmcm9tIFwiLi91aS9jaG9vc2VTZXNzaW9uVHlwZVwiXG5pbXBvcnQgeyBwcm9tcHRGb3JOYW1lLCBwcm9tcHRGb3JVUkwgfSBmcm9tIFwiLi91aS9lbnRlclRleHRcIlxuaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSBcIi4vdXRpbHMvcGVlcmRyYWZ0UmVjb3JkXCJcbmltcG9ydCB7IFBlZXJkcmFmdExlYWYgfSBmcm9tIFwiLi93b3Jrc3BhY2UvcGVlcmRyYWZ0TGVhZlwiXG5pbXBvcnQgeyBnZXRMZWFmc0J5UGF0aCwgdXBkYXRlUGVlcmRyYWZ0V29ya3NwYWNlIH0gZnJvbSBcIi4vd29ya3NwYWNlL3BlZXJkcmFmdFdvcmtzcGFjZVwiXG5pbXBvcnQgeyBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3BlZXJkcmFmdFdlYlNvY2tldFByb3ZpZGVyXCJcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIlxuaW1wb3J0IHsgb3BlbkZvbGRlck9wdGlvbnMgfSBmcm9tIFwiLi91aS9mb2xkZXJPcHRpb25zXCJcbmltcG9ydCB7IGdldEpXVCB9IGZyb20gXCIuL2xvZ2luXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUGVlcmRyYWZ0UGx1Z2luIGV4dGVuZHMgUGx1Z2luIHtcblxuXHRzZXR0aW5nczogU2V0dGluZ3Ncblx0cHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj5cblx0c2VydmVyQVBJOiBTZXJ2ZXJBUElcblx0YWN0aXZlU3RyZWFtQ2xpZW50OiBBY3RpdmVTdHJlYW1DbGllbnRcblx0c2VydmVyU3luYzogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXJcblxuXHRhc3luYyBvbmxvYWQoKSB7XG5cblx0XHRjb25zdCBwbHVnaW4gPSB0aGlzXG5cblx0XHRwbHVnaW4uc2V0dGluZ3MgPSBhd2FpdCBtaWdyYXRlU2V0dGluZ3MocGx1Z2luKVxuXG5cdFx0YXdhaXQgcHJlcGFyZUNvbW11bmljYXRpb24ocGx1Z2luKVxuXG5cdFx0cGx1Z2luLnB3cyA9IG5ldyBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4oKVxuXHRcdHBsdWdpbi5zZXJ2ZXJBUEkgPSBuZXcgU2VydmVyQVBJKHtcblx0XHRcdG9pZDogcGx1Z2luLnNldHRpbmdzLm9pZCxcblx0XHRcdHBlcm1hbmVudFNlc3Npb25Vcmw6IHBsdWdpbi5zZXR0aW5ncy5zZXNzaW9uQVBJXG5cdFx0fSlcblxuXHRcdHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQgPSBuZXcgQWN0aXZlU3RyZWFtQ2xpZW50KHBsdWdpbi5zZXR0aW5ncy5hY3RpdmVzLCB7XG5cdFx0XHRtYXhCYWNrb2ZmVGltZTogMzAwMDAwLFxuXHRcdFx0Y29ubmVjdDogdHJ1ZSxcblx0XHRcdHJlc3luY0ludGVydmFsOiAtMVxuXHRcdH0pXG5cblx0XHRwbHVnaW4ucHdzLm9uKCdhZGQnLCAoa2V5LCBsZWFmKSA9PiB7XG5cdFx0XHRTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGxlYWYucGF0aCk/LmFkZEV4dGVuc2lvblRvTGVhZihrZXkpXG5cdFx0XHRsZWFmLm9uKFwiY2hhbmdlUGF0aFwiLCAob2xkUGF0aCkgPT4ge1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0XHRcdGNvbnN0IGxlYWZzID0gZ2V0TGVhZnNCeVBhdGgob2xkUGF0aCwgcGx1Z2luLnB3cylcblx0XHRcdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwICYmICFkb2MuaXNQZXJtYW5lbnQpIHtcblx0XHRcdFx0XHRcdGRvYy51bnNoYXJlKClcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0U2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpPy5hZGRFeHRlbnNpb25Ub0xlYWYoa2V5KVxuXHRcdFx0fSlcblx0XHR9KVxuXG5cdFx0cGx1Z2luLnB3cy5vbignZGVsZXRlJywgYXN5bmMgKGtleSwgbGVhZikgPT4ge1xuXHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChsZWFmLnBhdGgpXG5cdFx0XHRpZiAoIWRvYykgcmV0dXJuXG5cdFx0XHRkb2MucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYoa2V5KVxuXHRcdFx0Y29uc3QgbGVhZnMgPSBnZXRMZWFmc0J5UGF0aChsZWFmLnBhdGgsIHBsdWdpbi5wd3MpXG5cdFx0XHRpZiAobGVhZnMubGVuZ3RoID09PSAwKSB7XG5cdFx0XHRcdGlmIChkb2MgJiYgIWRvYy5pc1Blcm1hbmVudCkge1xuXHRcdFx0XHRcdGF3YWl0IGRvYy51bnNoYXJlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bGVhZi5kZXN0cm95KClcblx0XHR9KVxuXG5cdFx0cGx1Z2luLmFwcC53b3Jrc3BhY2Uub25MYXlvdXRSZWFkeShcblx0XHRcdGFzeW5jICgpID0+IHtcdFx0XHRcdFxuXHRcdFx0XHR0aGlzLnNlcnZlclN5bmMgPSBuZXcgUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIodGhpcy5zZXR0aW5ncy5zeW5jLCB7IGp3dDogZ2V0SldUKHBsdWdpbi5zZXR0aW5ncy5vaWQpID8/IHVuZGVmaW5lZCwgY29ubmVjdDogZmFsc2V9KVxuXHRcdFx0XHR0aGlzLnNlcnZlclN5bmMub24oXCJhdXRoZW50aWNhdGVkXCIsIChkYXRhKSA9PiB7XG5cdFx0XHRcdFx0c2hvd05vdGljZShcIkxvZ2dlZCBpbiB0byBQZWVyZHJhZnRcIilcblx0XHRcdFx0XHRwbHVnaW4uc2V0dGluZ3MucGxhbi50eXBlID0gZGF0YS5wbGFuLnR5cGVcblx0XHRcdFx0XHRzYXZlU2V0dGluZ3MocGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pXG5cdFx0XHRcdH0pXG5cblx0XHRcdFx0dGhpcy5zZXJ2ZXJTeW5jLmNvbm5lY3QoKVxuXG5cdFx0XHRcdGZvciAoY29uc3QgZG9jcyBvZiBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzKSB7XG5cdFx0XHRcdFx0YXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVBlcm1hbmVudFNoYXJlRG9jdW1lbnQoeyBwYXRoOiBkb2NzWzBdLCBwZXJzaXN0ZW5jZUlkOiBkb2NzWzFdLnBlcnNpc3RlbmNlSWQsIHNoYXJlSWQ6IGRvY3NbMV0uc2hhcmVJZCB9LCBwbHVnaW4pXG5cdFx0XHRcdH1cblx0XHRcdFx0Zm9yIChjb25zdCBmb2xkZXIgb2YgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzKSB7XG5cdFx0XHRcdFx0YXdhaXQgU2hhcmVkRm9sZGVyLmZyb21QZXJtYW5lbnRTaGFyZUZvbGRlcih7IHBhdGg6IGZvbGRlclswXSwgcGVyc2lzdGVuY2VJZDogZm9sZGVyWzFdLnBlcnNpc3RlbmNlSWQsIHNoYXJlSWQ6IGZvbGRlclsxXS5zaGFyZUlkIH0sIHBsdWdpbilcblx0XHRcdFx0fVxuXHRcdFx0XHR1cGRhdGVQZWVyZHJhZnRXb3Jrc3BhY2UocGx1Z2luLmFwcC53b3Jrc3BhY2UsIHBsdWdpbi5wd3MpXG5cdFx0XHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KHBsdWdpbi5hcHAud29ya3NwYWNlLm9uKFwibGF5b3V0LWNoYW5nZVwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0dXBkYXRlUGVlcmRyYWZ0V29ya3NwYWNlKHBsdWdpbi5hcHAud29ya3NwYWNlLCBwbHVnaW4ucHdzKVxuXHRcdFx0XHR9KSlcblx0XHRcdH1cblx0XHQpXG5cblx0XHRwbHVnaW4ucmVnaXN0ZXJFdmVudChwbHVnaW4uYXBwLndvcmtzcGFjZS5vbignZmlsZS1tZW51JywgKG1lbnUsIGZpbGUpID0+IHtcblx0XHRcdGlmIChmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikge1xuXHRcdFx0XHQvLyBOb3Qgc2hhcmVkIGZvbGRlciAmJiBub3Qgd2l0aGluIHNoYXJlZCBmb2xkZXJcblx0XHRcdFx0Y29uc3Qgc2hhcmVkRm9sZGVyID0gU2hhcmVkRm9sZGVyLmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoIXNoYXJlZEZvbGRlcikge1xuXHRcdFx0XHRcdGlmICghU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZmlsZS5wYXRoKSAmJiBwbHVnaW4uc2V0dGluZ3MucGxhbi50eXBlID09PSBcInRlYW1cIikge1xuXHRcdFx0XHRcdFx0bWVudS5hZGRJdGVtKChpdGVtKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1NoYXJlIEZvbGRlcicpXG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigndXNlcnMnKVxuXHRcdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdFNoYXJlZEZvbGRlci5mcm9tVEZvbGRlcihmaWxlLCBwbHVnaW4pXG5cdFx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRpdGVtLnNldFRpdGxlKCdDb3B5IFBlZXJkcmFmdCBVUkwnKVxuXHRcdFx0XHRcdFx0aXRlbS5zZXRJY29uKCd1c2VycycpXG5cdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyAnL3RlYW0vJyArIHNoYXJlZEZvbGRlci5zaGFyZUlkKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1N0b3Agc3luY2luZyB0aGlzIGZvbGRlcicpXG5cdFx0XHRcdFx0XHRpdGVtLnNldEljb24oJ3JlZnJlc2gtY3ctb2ZmJylcblx0XHRcdFx0XHRcdGl0ZW0ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdGF3YWl0IHNoYXJlZEZvbGRlci51bnNoYXJlKClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRpdGVtLnNldFRpdGxlKCdSZS1jcmVhdGUgc3luYyBmcm9tIHNlcnZlcicpXG5cdFx0XHRcdFx0XHRpdGVtLnNldEljb24oJ3JlZnJlc2gtY3cnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKGFzeW5jICgpID0+IHtcblx0XHRcdFx0XHRcdFx0YXdhaXQgU2hhcmVkRm9sZGVyLnJlY3JlYXRlKHNoYXJlZEZvbGRlciwgcGx1Z2luKVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdG1lbnUuYWRkSXRlbShpdGVtID0+IHtcblx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ1Nob3cgUGVlcmRyYWZ0IGZvbGRlciBvcHRpb25zJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbignY29nJylcblx0XHRcdFx0XHRcdGl0ZW0ub25DbGljayhhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdG9wZW5Gb2xkZXJPcHRpb25zKHRoaXMuYXBwLCBzaGFyZWRGb2xkZXIpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnN0IHNoYXJlZERvY3VtZW50ID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGNvbnN0IHNoYXJlZEZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKHNoYXJlZERvY3VtZW50KSB7XG5cdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0aXRlbS5zZXRUaXRsZSgnQ29weSBQZWVyZHJhZnQgVVJMJylcblx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigndXNlcnMnKVxuXHRcdFx0XHRcdFx0aXRlbS5vbkNsaWNrKCgpID0+IHtcblx0XHRcdFx0XHRcdFx0bmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQocGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgJy9jbS8nICsgc2hhcmVkRG9jdW1lbnQuc2hhcmVJZClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHRpZiAoc2hhcmVkRm9sZGVyKSB7XG5cdFx0XHRcdFx0XHRtZW51LmFkZEl0ZW0oaXRlbSA9PiB7XG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0VGl0bGUoJ0RlbGV0ZSBhbmQgcmVtb3ZlIGZyb20gU2hhcmVkIEZvbGRlcicpXG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigndHJhc2gnKVxuXHRcdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdHNoYXJlZEZvbGRlci5yZW1vdmVEb2N1bWVudChzaGFyZWREb2N1bWVudClcblx0XHRcdFx0XHRcdFx0XHRzaGFyZWREb2N1bWVudC51bnNoYXJlKClcblx0XHRcdFx0XHRcdFx0XHRwbHVnaW4uYXBwLnZhdWx0LmRlbGV0ZShzaGFyZWREb2N1bWVudC5maWxlKVxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bWVudS5hZGRJdGVtKGl0ZW0gPT4ge1xuXHRcdFx0XHRcdFx0XHRpdGVtLnNldFRpdGxlKCdTdG9wIHN5bmNpbmcgdGhpcyBkb2N1bWVudCcpXG5cdFx0XHRcdFx0XHRcdGl0ZW0uc2V0SWNvbigncmVmcmVzaC1jdy1vZmYnKVxuXHRcdFx0XHRcdFx0XHRpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdFx0XHRcdGF3YWl0IHNoYXJlZERvY3VtZW50LnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KSlcblxuXHRcdHBsdWdpbi5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiBcInNoYXJlXCIsXG5cdFx0XHRuYW1lOiBcIlN0YXJ0IHdvcmtpbmcgdG9nZXRoZXIgb24gdGhpcyBkb2N1bWVudFwiLFxuXHRcdFx0Y2hlY2tDYWxsYmFjayhjaGVja2luZykge1xuXHRcdFx0XHRjb25zdCB2aWV3ID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpXG5cdFx0XHRcdGlmICghdmlldykgcmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRjb25zdCBmaWxlID0gdmlldy5maWxlXG5cdFx0XHRcdGlmICghZmlsZSkgcmV0dXJuIGZhbHNlXG5cdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoZG9jKSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0aWYgKGNoZWNraW5nKSByZXR1cm4gdHJ1ZVxuXHRcdFx0XHQvLyBkbyBpdFxuXHRcdFx0XHRpZiAocGx1Z2luLnNldHRpbmdzLnBsYW4udHlwZSA9PT0gXCJ0ZWFtXCIpIHtcblx0XHRcdFx0XHRwcm9tcHRGb3JTZXNzaW9uVHlwZShwbHVnaW4uYXBwKS50aGVuKHJlc3VsdCA9PiB7XG5cdFx0XHRcdFx0XHRpZiAoIXJlc3VsdCkgcmV0dXJuXG5cdFx0XHRcdFx0XHRTaGFyZWREb2N1bWVudC5mcm9tVmlldyh2aWV3LCBwbHVnaW4sIHsgcGVybWFuZW50OiByZXN1bHQucGVybWFuZW50IH0pLnRoZW4oZG9jID0+IHtcblx0XHRcdFx0XHRcdFx0aWYgKCFkb2MpIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gc2hvd05vdGljZShcIkVSUk9SIGNyZWF0aW5nIHNoYXJlZERvY1wiKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0U2hhcmVkRG9jdW1lbnQuZnJvbVZpZXcodmlldywgcGx1Z2luLCB7IHBlcm1hbmVudDogZmFsc2UgfSkudGhlbihkb2MgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKCFkb2MpIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNob3dOb3RpY2UoXCJFUlJPUiBjcmVhdGluZyBzaGFyZWREb2NcIilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHBsdWdpbi5hZGRDb21tYW5kKHtcblx0XHRcdGlkOiAnc3RvcC1zZXNzaW9uLXdpdGgtYWN0aXZlLWRvY3VtZW50Jyxcblx0XHRcdG5hbWU6ICdTdG9wIHdvcmtpbmcgdG9nZXRoZXIgb24gdGhpcyBkb2N1bWVudCcsXG5cdFx0XHRlZGl0b3JDaGVja0NhbGxiYWNrOiAoY2hlY2tpbmcsIGVkaXRvciwgY3R4KSA9PiB7XG5cdFx0XHRcdGNvbnN0IGZpbGUgPSBjdHguZmlsZVxuXHRcdFx0XHRpZiAoIWZpbGUpIHJldHVybiBmYWxzZVxuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0aWYgKCFkb2MgfHwgZG9jLmlzUGVybWFuZW50KSByZXR1cm4gZmFsc2Vcblx0XHRcdFx0aWYgKGNoZWNraW5nKSByZXR1cm4gdHJ1ZVxuXHRcdFx0XHRkb2MudW5zaGFyZSgpLnRoZW4oKCkgPT4geyB9KVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0cGx1Z2luLmFkZENvbW1hbmQoe1xuXHRcdFx0aWQ6IFwiam9pblwiLFxuXHRcdFx0bmFtZTogXCJKb2luIHNlc3Npb24gYW5kIGFkZCBkb2N1bWVudCBmcm9tIHNvbWVvbmUgZWxzZVwiLFxuXHRcdFx0Y2FsbGJhY2s6IGFzeW5jICgpID0+IHtcblx0XHRcdFx0Y29uc3QgdXJsID0gYXdhaXQgcHJvbXB0Rm9yVVJMKHBsdWdpbi5hcHApXG5cdFx0XHRcdGlmICh1cmwgJiYgdXJsLnRleHQpIHtcblx0XHRcdFx0XHRhd2FpdCBmcm9tU2hhcmVVUkwodXJsLnRleHQsIHBsdWdpbilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRpZiAocGx1Z2luLnNldHRpbmdzLmRlYnVnKSB7XG5cdFx0XHRwbHVnaW4uYWRkQ29tbWFuZCh7XG5cdFx0XHRcdGlkOiBcImNsZWFyRGF0YWJhc2VcIixcblx0XHRcdFx0bmFtZTogXCJERUJVRzogY2xlYXIgZGF0YWJhc2UgKE5vdGhpbmcgd2lsbCBiZSBzaGFyZWQgYWZ0ZXIgdGhpcyEpXCIsXG5cdFx0XHRcdGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG5cdFx0XHRcdFx0Y29uc3QgZGJzID0gYXdhaXQgd2luZG93LmluZGV4ZWREQi5kYXRhYmFzZXMoKVxuXHRcdFx0XHRcdGZvciAoY29uc3QgZGIgb2YgZGJzKSB7XG5cdFx0XHRcdFx0XHRpZiAoZGIubmFtZT8uc3RhcnRzV2l0aChcInBlZXJkcmFmdF9cIikpIHtcblx0XHRcdFx0XHRcdFx0d2luZG93LmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShkYi5uYW1lKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9XG5cblx0XHRwbHVnaW4ucmVnaXN0ZXJFdmVudChwbHVnaW4uYXBwLnZhdWx0Lm9uKCdyZW5hbWUnLCBhc3luYyAoZmlsZSwgb2xkUGF0aCkgPT4ge1xuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRjb25zdCBkb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRhd2FpdCBkb2Muc2V0TmV3RmlsZUxvY2F0aW9uKGZpbGUpXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb25zdCBvbGRQYXRoSW5Gb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChvbGRQYXRoKVxuXHRcdFx0XHRjb25zdCBuZXdQYXRoSW5Gb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpXG5cblx0XHRcdFx0aWYgKG9sZFBhdGhJbkZvbGRlciAmJiBuZXdQYXRoSW5Gb2xkZXIpIHtcblx0XHRcdFx0XHRpZiAob2xkUGF0aEluRm9sZGVyID09PSBuZXdQYXRoSW5Gb2xkZXIpIHtcblx0XHRcdFx0XHRcdG9sZFBhdGhJbkZvbGRlci51cGRhdGVQYXRoKG9sZFBhdGgsIGZpbGUucGF0aClcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29uc3QgbmV3RG9jID0gYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVRGaWxlKGZpbGUsIHsgcGVybWFuZW50OiB0cnVlIH0sIHBsdWdpbilcblx0XHRcdFx0XHRcdGlmIChuZXdEb2MpIHtcblx0XHRcdFx0XHRcdFx0bmV3UGF0aEluRm9sZGVyLmFkZERvY3VtZW50KG5ld0RvYylcblx0XHRcdFx0XHRcdFx0Y29uc3QgcHJvcCA9IG5ld1BhdGhJbkZvbGRlci5nZXRBdXRvRmlsbFByb3BlcnR5KClcblx0XHRcdFx0XHRcdFx0aWYgKHByb3ApIG5ld0RvYy51cGRhdGVQcm9wZXJ0eShwcm9wLCBuZXdEb2MuZ2V0U2hhcmVVUkwoKSlcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdFx0Ly8gb2xkUGF0aEluRm9sZGVyLnJlbW92ZURvY3VtZW50KGRvYylcblx0XHRcdFx0XHRcdFx0Ly8gZG9jLnVuc2hhcmUoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChvbGRQYXRoSW5Gb2xkZXIgJiYgIW5ld1BhdGhJbkZvbGRlcikge1xuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdHNob3dOb3RpY2UoXCJJdCBpcyBub3QgcG9zc2libGUgdG8gcmVtb3ZlIGEgZG9jdW1lbnQgZnJvbSBhIHNoYXJlZCBmb2xkZXIgcmlnaHQgbm93LiBDcmVhdGVkIGEgY29weS5cIilcblx0XHRcdFx0XHRcdC8vIG9sZFBhdGhJbkZvbGRlci5yZW1vdmVEb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0XHRhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKHBhdGguZGlybmFtZShvbGRQYXRoKSwgcGx1Z2luKVxuXHRcdFx0XHRcdFx0Y29uc3QgZmlsZSA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKG9sZFBhdGgsICcnKVxuXHRcdFx0XHRcdFx0aWYgKCFmaWxlKSB7XG5cdFx0XHRcdFx0XHRcdHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBmaWxlIFwiICsgb2xkUGF0aCArIFwiLlwiKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGRvYy5zZXROZXdGaWxlTG9jYXRpb24oZmlsZSlcblx0XHRcdFx0XHRcdGRvYy5zeW5jV2l0aFNlcnZlcigpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKCFvbGRQYXRoSW5Gb2xkZXIgJiYgbmV3UGF0aEluRm9sZGVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZG9jID0gYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbVRGaWxlKGZpbGUsIHsgcGVybWFuZW50OiB0cnVlIH0sIHBsdWdpbilcblx0XHRcdFx0XHRpZiAoZG9jKSB7XG5cdFx0XHRcdFx0XHRuZXdQYXRoSW5Gb2xkZXIuYWRkRG9jdW1lbnQoZG9jKVxuXHRcdFx0XHRcdFx0Y29uc3QgcHJvcCA9IG5ld1BhdGhJbkZvbGRlci5nZXRBdXRvRmlsbFByb3BlcnR5KClcblx0XHRcdFx0XHRcdGlmIChwcm9wKSBkb2MudXBkYXRlUHJvcGVydHkocHJvcCwgZG9jLmdldFNoYXJlVVJMKCkpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdGNvbnN0IGZvbGRlciA9IFNoYXJlZEZvbGRlci5maW5kQnlQYXRoKG9sZFBhdGgpXG5cdFx0XHRcdGlmIChmb2xkZXIpIHtcblx0XHRcdFx0XHRhd2FpdCBmb2xkZXIuc2V0TmV3Rm9sZGVyTG9jYXRpb24oZmlsZSlcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pKVxuXG5cdFx0cGx1Z2luLnJlZ2lzdGVyRXZlbnQocGx1Z2luLmFwcC52YXVsdC5vbignZGVsZXRlJywgYXN5bmMgKGZpbGUpID0+IHtcblx0XHRcdHBsdWdpbi5sb2coXCJyZWdpc3RlciBkZWxldGUgZm9yIFwiICsgZmlsZS5wYXRoKVxuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdGNvbnN0IGZvbGRlciA9IFNoYXJlZEZvbGRlci5maW5kQnlQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0Zm9sZGVyPy51bnNoYXJlKClcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSkge1xuXHRcdFx0XHRjb25zdCBmb2xkZXIgPSBTaGFyZWRGb2xkZXIuZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdGlmICghZm9sZGVyKSB7XG5cdFx0XHRcdFx0Y29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpXG5cdFx0XHRcdFx0aWYgKGRvYykge1xuXHRcdFx0XHRcdFx0YXdhaXQgZG9jLnVuc2hhcmUoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0LyogRG8gbmV0IGRlbGV0ZSBvbiBkZWxldGUgZmlsZXMgZnJvbSBTaGFyZWQgRm9sZGVycyBqdXN0IHlldC4uLlxuXHRcdFx0Ly8gSWYgeW91IHJlYWxseSB3YW50IHRvIHJlbW92ZSBhIGZpbGUsIHlvdSBjYW4gbW92ZVxuXHRcdFx0aWYgKGZpbGUgaW5zdGFuY2VvZiBURmlsZSl7XG5cdFx0XHRcdGNvbnN0IGRvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRpZiAoZG9jKSB7XG5cdFx0XHRcdFx0YXdhaXQgZG9jLnVuc2hhcmUoKVxuXHRcdFx0XHRcdGlmIChmb2xkZXIpIHtcblx0XHRcdFx0XHRcdGZvbGRlci5yZW1vdmVEb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGZpbGUgaW5zdGFuY2VvZiBURm9sZGVyKSB7XG5cdFx0XHRcdGNvbnN0IGZvbGRlciA9IFNoYXJlZEZvbGRlci5nZXRTaGFyZWRGb2xkZXJGb3JTdWJQYXRoKGZpbGUucGF0aClcblx0XHRcdFx0XHRpZiAoZm9sZGVyKSB7XG5cdFx0XHRcdFx0XHRmb2xkZXIudW5zaGFyZSgpXG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ki9cblx0XHR9KSlcblxuXHRcdHBsdWdpbi5hcHAud29ya3NwYWNlLm9uTGF5b3V0UmVhZHkoXG5cdFx0XHQoKSA9PiB7XG5cdFx0XHRcdHBsdWdpbi5yZWdpc3RlckV2ZW50KChwbHVnaW4uYXBwLnZhdWx0Lm9uKFwiY3JlYXRlXCIsIGFzeW5jIChmaWxlKSA9PiB7XG5cdFx0XHRcdFx0aWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkgcmV0dXJuXG5cdFx0XHRcdFx0Y29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZmlsZS5wYXRoKVxuXHRcdFx0XHRcdGlmICghZm9sZGVyKSByZXR1cm5cblx0XHRcdFx0XHRpZiAoZm9sZGVyLmlzRmlsZUluU3luY09iamVjdChmaWxlKSkgcmV0dXJuXG5cdFx0XHRcdFx0aWYgKFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKSkgcmV0dXJuXG5cblx0XHRcdFx0XHRpZiAocGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5oYXMobm9ybWFsaXplUGF0aChmaWxlLnBhdGgpKSkgcmV0dXJuXG5cblx0XHRcdFx0XHRjb25zdCBkb2MgPSBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tVEZpbGUoZmlsZSwge1xuXHRcdFx0XHRcdFx0cGVybWFuZW50OiB0cnVlXG5cdFx0XHRcdFx0fSwgcGx1Z2luKVxuXHRcdFx0XHRcdGlmIChkb2MpIHtcblx0XHRcdFx0XHRcdGZvbGRlci5hZGREb2N1bWVudChkb2MpXG5cdFx0XHRcdFx0XHRjb25zdCBwcm9wID0gZm9sZGVyLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuXHRcdFx0XHRcdFx0aWYgKHByb3ApIGRvYy51cGRhdGVQcm9wZXJ0eShwcm9wLCBkb2MuZ2V0U2hhcmVVUkwoKSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pKSlcblx0XHRcdH1cblx0XHQpXG5cblx0XHRjb25zdCBzZXR0aW5nc1RhYiA9IGNyZWF0ZVNldHRpbmdzVGFiKHBsdWdpbilcblxuXHRcdGlmICghcGx1Z2luLnNldHRpbmdzLm5hbWUpIHtcblx0XHRcdGNvbnN0IG5hbWUgPSBhd2FpdCBwcm9tcHRGb3JOYW1lKHBsdWdpbi5hcHApXG5cdFx0XHRpZiAobmFtZSAmJiBuYW1lLnRleHQpIHtcblx0XHRcdFx0dGhpcy5zZXR0aW5ncy5uYW1lID0gbmFtZS50ZXh0XG5cdFx0XHRcdHNhdmVTZXR0aW5ncyh0aGlzLnNldHRpbmdzLCBwbHVnaW4pXG5cdFx0XHR9XG5cdFx0fVxuXHRcdHBsdWdpbi5hZGRTZXR0aW5nVGFiKHNldHRpbmdzVGFiKVxuXHR9XG5cblx0b251bmxvYWQoKSB7XG5cdFx0U2hhcmVkRG9jdW1lbnQuZ2V0QWxsKCkuZm9yRWFjaCgoZG9jKSA9PiB7XG5cdFx0XHRkb2MuZGVzdHJveSgpXG5cdFx0fSlcblx0XHRTaGFyZWRGb2xkZXIuZ2V0QWxsKCkuZm9yRWFjaChmb2xkZXIgPT4ge1xuXHRcdFx0Zm9sZGVyLmRlc3Ryb3koKVxuXHRcdH0pXG5cdFx0dGhpcy5hY3RpdmVTdHJlYW1DbGllbnQuZGVzdHJveSgpXG5cdH1cblxuXHRsb2cobWVzc2FnZTogc3RyaW5nKSB7XG5cdFx0aWYgKHRoaXMuc2V0dGluZ3MuZGVidWcpIHtcblx0XHRcdGNvbnNvbGUubG9nKG1lc3NhZ2UpXG5cdFx0fVxuXHR9XG5cbn1cblxuIiwgIi8qKlxuICogQ29tbW9uIE1hdGggZXhwcmVzc2lvbnMuXG4gKlxuICogQG1vZHVsZSBtYXRoXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZsb29yID0gTWF0aC5mbG9vclxuZXhwb3J0IGNvbnN0IGNlaWwgPSBNYXRoLmNlaWxcbmV4cG9ydCBjb25zdCBhYnMgPSBNYXRoLmFic1xuZXhwb3J0IGNvbnN0IGltdWwgPSBNYXRoLmltdWxcbmV4cG9ydCBjb25zdCByb3VuZCA9IE1hdGgucm91bmRcbmV4cG9ydCBjb25zdCBsb2cxMCA9IE1hdGgubG9nMTBcbmV4cG9ydCBjb25zdCBsb2cyID0gTWF0aC5sb2cyXG5leHBvcnQgY29uc3QgbG9nID0gTWF0aC5sb2dcbmV4cG9ydCBjb25zdCBzcXJ0ID0gTWF0aC5zcXJ0XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIHN1bSBvZiBhIGFuZCBiXG4gKi9cbmV4cG9ydCBjb25zdCBhZGQgPSAoYSwgYikgPT4gYSArIGJcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBhXG4gKiBAcGFyYW0ge251bWJlcn0gYlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgc21hbGxlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1pbiA9IChhLCBiKSA9PiBhIDwgYiA/IGEgOiBiXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gYVxuICogQHBhcmFtIHtudW1iZXJ9IGJcbiAqIEByZXR1cm4ge251bWJlcn0gVGhlIGJpZ2dlciBlbGVtZW50IG9mIGEgYW5kIGJcbiAqL1xuZXhwb3J0IGNvbnN0IG1heCA9IChhLCBiKSA9PiBhID4gYiA/IGEgOiBiXG5cbmV4cG9ydCBjb25zdCBpc05hTiA9IE51bWJlci5pc05hTlxuXG5leHBvcnQgY29uc3QgcG93ID0gTWF0aC5wb3dcbi8qKlxuICogQmFzZSAxMCBleHBvbmVudGlhbCBmdW5jdGlvbi4gUmV0dXJucyB0aGUgdmFsdWUgb2YgMTAgcmFpc2VkIHRvIHRoZSBwb3dlciBvZiBwb3cuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGV4cFxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZXhwMTAgPSBleHAgPT4gTWF0aC5wb3coMTAsIGV4cClcblxuZXhwb3J0IGNvbnN0IHNpZ24gPSBNYXRoLnNpZ25cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2V0aGVyIG4gaXMgbmVnYXRpdmUuIFRoaXMgZnVuY3Rpb24gYWxzbyBkaWZmZXJlbnRpYXRlcyBiZXR3ZWVuIC0wIGFuZCArMFxuICovXG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZVplcm8gPSBuID0+IG4gIT09IDAgPyBuIDwgMCA6IDEgLyBuIDwgMFxuIiwgIi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRpbWUuXG4gKlxuICogQG1vZHVsZSB0aW1lXG4gKi9cblxuaW1wb3J0ICogYXMgbWV0cmljIGZyb20gJy4vbWV0cmljLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbi8qKlxuICogUmV0dXJuIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAcmV0dXJuIHtEYXRlfVxuICovXG5leHBvcnQgY29uc3QgZ2V0RGF0ZSA9ICgpID0+IG5ldyBEYXRlKClcblxuLyoqXG4gKiBSZXR1cm4gY3VycmVudCB1bml4IHRpbWUuXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgZ2V0VW5peFRpbWUgPSBEYXRlLm5vd1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aW1lIChpbiBtcykgdG8gYSBodW1hbiByZWFkYWJsZSBmb3JtYXQuIEUuZy4gMTEwMCA9PiAxLjFzLiA2MHMgPT4gMW1pbi4gLjAwMSA9PiAxMFx1MDNCQ3MuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGQgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGh1bWFuaXplZCBhcHByb3hpbWF0aW9uIG9mIHRpbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGh1bWFuaXplRHVyYXRpb24gPSBkID0+IHtcbiAgaWYgKGQgPCA2MDAwMCkge1xuICAgIGNvbnN0IHAgPSBtZXRyaWMucHJlZml4KGQsIC0xKVxuICAgIHJldHVybiBtYXRoLnJvdW5kKHAubiAqIDEwMCkgLyAxMDAgKyBwLnByZWZpeCArICdzJ1xuICB9XG4gIGQgPSBtYXRoLmZsb29yKGQgLyAxMDAwKVxuICBjb25zdCBzZWNvbmRzID0gZCAlIDYwXG4gIGNvbnN0IG1pbnV0ZXMgPSBtYXRoLmZsb29yKGQgLyA2MCkgJSA2MFxuICBjb25zdCBob3VycyA9IG1hdGguZmxvb3IoZCAvIDM2MDApICUgMjRcbiAgY29uc3QgZGF5cyA9IG1hdGguZmxvb3IoZCAvIDg2NDAwKVxuICBpZiAoZGF5cyA+IDApIHtcbiAgICByZXR1cm4gZGF5cyArICdkJyArICgoaG91cnMgPiAwIHx8IG1pbnV0ZXMgPiAzMCkgPyAnICcgKyAobWludXRlcyA+IDMwID8gaG91cnMgKyAxIDogaG91cnMpICsgJ2gnIDogJycpXG4gIH1cbiAgaWYgKGhvdXJzID4gMCkge1xuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIGhvdXJzICsgJ2gnICsgKChtaW51dGVzID4gMCB8fCBzZWNvbmRzID4gMzApID8gJyAnICsgKHNlY29uZHMgPiAzMCA/IG1pbnV0ZXMgKyAxIDogbWludXRlcykgKyAnbWluJyA6ICcnKVxuICB9XG4gIHJldHVybiBtaW51dGVzICsgJ21pbicgKyAoc2Vjb25kcyA+IDAgPyAnICcgKyBzZWNvbmRzICsgJ3MnIDogJycpXG59XG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGgga2V5LXZhbHVlIHN0b3Jlcy5cbiAqXG4gKiBAbW9kdWxlIG1hcFxuICovXG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBNYXAgaW5zdGFuY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcmV0dXJuIHtNYXA8YW55LCBhbnk+fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKCkgPT4gbmV3IE1hcCgpXG5cbi8qKlxuICogQ29weSBhIE1hcCBvYmplY3QgaW50byBhIGZyZXNoIE1hcCBvYmplY3QuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAdGVtcGxhdGUgSyxWXG4gKiBAcGFyYW0ge01hcDxLLFY+fSBtXG4gKiBAcmV0dXJuIHtNYXA8SyxWPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHkgPSBtID0+IHtcbiAgY29uc3QgciA9IGNyZWF0ZSgpXG4gIG0uZm9yRWFjaCgodiwgaykgPT4geyByLnNldChrLCB2KSB9KVxuICByZXR1cm4gclxufVxuXG4vKipcbiAqIEdldCBtYXAgcHJvcGVydHkuIENyZWF0ZSBUIGlmIHByb3BlcnR5IGlzIHVuZGVmaW5lZCBhbmQgc2V0IFQgb24gbWFwLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBsaXN0ZW5lcnMgPSBtYXAuc2V0SWZVbmRlZmluZWQoZXZlbnRzLCAnZXZlbnROYW1lJywgc2V0LmNyZWF0ZSlcbiAqIGxpc3RlbmVycy5hZGQobGlzdGVuZXIpXG4gKiBgYGBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSB7TWFwPGFueSwgYW55Pn0gTUFQXG4gKiBAdGVtcGxhdGUge01BUCBleHRlbmRzIE1hcDxhbnksaW5mZXIgVj4gPyBmdW5jdGlvbigpOlYgOiB1bmtub3dufSBDRlxuICogQHBhcmFtIHtNQVB9IG1hcFxuICogQHBhcmFtIHtNQVAgZXh0ZW5kcyBNYXA8aW5mZXIgSyxhbnk+ID8gSyA6IHVua25vd259IGtleVxuICogQHBhcmFtIHtDRn0gY3JlYXRlVFxuICogQHJldHVybiB7UmV0dXJuVHlwZTxDRj59XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRJZlVuZGVmaW5lZCA9IChtYXAsIGtleSwgY3JlYXRlVCkgPT4ge1xuICBsZXQgc2V0ID0gbWFwLmdldChrZXkpXG4gIGlmIChzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIG1hcC5zZXQoa2V5LCBzZXQgPSBjcmVhdGVUKCkpXG4gIH1cbiAgcmV0dXJuIHNldFxufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQXJyYXkgYW5kIHBvcHVsYXRlcyBpdCB3aXRoIHRoZSBjb250ZW50IG9mIGFsbCBrZXktdmFsdWUgcGFpcnMgdXNpbmcgdGhlIGBmKHZhbHVlLCBrZXkpYCBmdW5jdGlvbi5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIFJcbiAqIEBwYXJhbSB7TWFwPEssVj59IG1cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVixLKTpSfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChtLCBmKSA9PiB7XG4gIGNvbnN0IHJlcyA9IFtdXG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIG0pIHtcbiAgICByZXMucHVzaChmKHZhbHVlLCBrZXkpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyoqXG4gKiBUZXN0cyB3aGV0aGVyIGFueSBrZXktdmFsdWUgcGFpcnMgcGFzcyB0aGUgdGVzdCBpbXBsZW1lbnRlZCBieSBgZih2YWx1ZSwga2V5KWAuXG4gKlxuICogQHRvZG8gc2hvdWxkIHJlbmFtZSB0byBzb21lIC0gc2ltaWxhcmx5IHRvIEFycmF5LnNvbWVcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbnkgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKGYodmFsdWUsIGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIFRlc3RzIHdoZXRoZXIgYWxsIGtleS12YWx1ZSBwYWlycyBwYXNzIHRoZSB0ZXN0IGltcGxlbWVudGVkIGJ5IGBmKHZhbHVlLCBrZXkpYC5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBLXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHtNYXA8SyxWPn0gbVxuICogQHBhcmFtIHtmdW5jdGlvbihWLEspOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBhbGwgPSAobSwgZikgPT4ge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBtKSB7XG4gICAgaWYgKCFmKHZhbHVlLCBrZXkpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cbiIsICIvKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzZXRzLlxuICpcbiAqIEBtb2R1bGUgc2V0XG4gKi9cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IG5ldyBTZXQoKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1NldDxUPn0gc2V0XG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQXJyYXkgPSBzZXQgPT4gQXJyYXkuZnJvbShzZXQpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7U2V0PFQ+fSBzZXRcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmaXJzdCA9IHNldCA9PlxuICBzZXQudmFsdWVzKCkubmV4dCgpLnZhbHVlIHx8IHVuZGVmaW5lZFxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhYmxlPFQ+fSBlbnRyaWVzXG4gKiBAcmV0dXJuIHtTZXQ8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gZW50cmllcyA9PiBuZXcgU2V0KGVudHJpZXMpXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggQXJyYXlzLlxuICpcbiAqIEBtb2R1bGUgYXJyYXlcbiAqL1xuXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5cbi8qKlxuICogUmV0dXJuIHRoZSBsYXN0IGVsZW1lbnQgb2YgYW4gYXJyYXkuIFRoZSBlbGVtZW50IG11c3QgZXhpc3RcbiAqXG4gKiBAdGVtcGxhdGUgTFxuICogQHBhcmFtIHtBcnJheUxpa2U8TD59IGFyclxuICogQHJldHVybiB7TH1cbiAqL1xuZXhwb3J0IGNvbnN0IGxhc3QgPSBhcnIgPT4gYXJyW2Fyci5sZW5ndGggLSAxXVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBDXG4gKiBAcmV0dXJuIHtBcnJheTxDPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9ICgpID0+IC8qKiBAdHlwZSB7QXJyYXk8Qz59ICovIChbXSlcblxuLyoqXG4gKiBAdGVtcGxhdGUgRFxuICogQHBhcmFtIHtBcnJheTxEPn0gYVxuICogQHJldHVybiB7QXJyYXk8RD59XG4gKi9cbmV4cG9ydCBjb25zdCBjb3B5ID0gYSA9PiAvKiogQHR5cGUge0FycmF5PEQ+fSAqLyAoYS5zbGljZSgpKVxuXG4vKipcbiAqIEFwcGVuZCBlbGVtZW50cyBmcm9tIHNyYyB0byBkZXN0XG4gKlxuICogQHRlbXBsYXRlIE1cbiAqIEBwYXJhbSB7QXJyYXk8TT59IGRlc3RcbiAqIEBwYXJhbSB7QXJyYXk8TT59IHNyY1xuICovXG5leHBvcnQgY29uc3QgYXBwZW5kVG8gPSAoZGVzdCwgc3JjKSA9PiB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVzdC5wdXNoKHNyY1tpXSlcbiAgfVxufVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgc29tZXRoaW5nIGFycmF5LWxpa2UgdG8gYW4gYWN0dWFsIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7QXJyYXlMaWtlPFQ+fEl0ZXJhYmxlPFQ+fSBhcnJheWxpa2VcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBmcm9tID0gQXJyYXkuZnJvbVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBldmVyeSBlbGVtZW50IGluIHRoZSBBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEB0ZW1wbGF0ZSBJVEVNXG4gKiBAdGVtcGxhdGUge0FycmF5TGlrZTxJVEVNPn0gQVJSXG4gKlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihJVEVNLCBudW1iZXIsIEFSUik6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGV2ZXJ5ID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmICghZihhcnJbaV0sIGksIGFycikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG4vKipcbiAqIFRydWUgaWZmIGNvbmRpdGlvbiBob2xkcyBvbiBzb21lIGVsZW1lbnQgaW4gdGhlIEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHRlbXBsYXRlIFNcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPFM+fSBBUlJcbiAqIEBwYXJhbSB7QVJSfSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUywgbnVtYmVyLCBBUlIpOmJvb2xlYW59IGZcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBzb21lID0gKGFyciwgZikgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChmKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxFTEVNPn0gYVxuICogQHBhcmFtIHtBcnJheUxpa2U8RUxFTT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGV2ZXJ5KGEsIChpdGVtLCBpbmRleCkgPT4gaXRlbSA9PT0gYltpbmRleF0pXG5cbi8qKlxuICogQHRlbXBsYXRlIEVMRU1cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8RUxFTT4+fSBhcnJcbiAqIEByZXR1cm4ge0FycmF5PEVMRU0+fVxuICovXG5leHBvcnQgY29uc3QgZmxhdHRlbiA9IGFyciA9PiBmb2xkKGFyciwgLyoqIEB0eXBlIHtBcnJheTxFTEVNPn0gKi8gKFtdKSwgKGFjYywgdmFsKSA9PiBhY2MuY29uY2F0KHZhbCkpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24obnVtYmVyLCBBcnJheTxUPik6VH0gZlxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmZvbGQgPSAobGVuLCBmKSA9PiB7XG4gIGNvbnN0IGFycmF5ID0gbmV3IEFycmF5KGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGFycmF5W2ldID0gZihpLCBhcnJheSlcbiAgfVxuICByZXR1cm4gYXJyYXlcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHRlbXBsYXRlIFJFU1VMVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcGFyYW0ge1JFU1VMVH0gc2VlZFxuICogQHBhcmFtIHtmdW5jdGlvbihSRVNVTFQsIFQsIG51bWJlcik6UkVTVUxUfSBmb2xkZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGZvbGQgPSAoYXJyLCBzZWVkLCBmb2xkZXIpID0+IGFyci5yZWR1Y2UoZm9sZGVyLCBzZWVkKVxuXG5leHBvcnQgY29uc3QgaXNBcnJheSA9IEFycmF5LmlzQXJyYXlcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtBcnJheTxUPn0gYXJyXG4gKiBAcmV0dXJuIHtBcnJheTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuaXF1ZSA9IGFyciA9PiBmcm9tKHNldC5mcm9tKGFycikpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEB0ZW1wbGF0ZSBNXG4gKiBAcGFyYW0ge0FycmF5TGlrZTxUPn0gYXJyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOk19IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8VD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bmlxdWVCeSA9IChhcnIsIG1hcHBlcikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge1NldDxNPn1cbiAgICovXG4gIGNvbnN0IGhhcHBlbmVkID0gc2V0LmNyZWF0ZSgpXG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8VD59XG4gICAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGVsID0gYXJyW2ldXG4gICAgY29uc3QgbWFwcGVkID0gbWFwcGVyKGVsKVxuICAgIGlmICghaGFwcGVuZWQuaGFzKG1hcHBlZCkpIHtcbiAgICAgIGhhcHBlbmVkLmFkZChtYXBwZWQpXG4gICAgICByZXN1bHQucHVzaChlbClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QXJyYXlMaWtlPGFueT59IEFSUlxuICogQHRlbXBsYXRlIHtmdW5jdGlvbihBUlIgZXh0ZW5kcyBBcnJheUxpa2U8aW5mZXIgVD4gPyBUIDogbmV2ZXIsIG51bWJlciwgQVJSKTphbnl9IE1BUFBFUlxuICogQHBhcmFtIHtBUlJ9IGFyclxuICogQHBhcmFtIHtNQVBQRVJ9IG1hcHBlclxuICogQHJldHVybiB7QXJyYXk8TUFQUEVSIGV4dGVuZHMgZnVuY3Rpb24oLi4uYW55KTogaW5mZXIgTSA/IE0gOiBuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAoYXJyLCBtYXBwZXIpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0gQXJyYXkoYXJyLmxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICByZXNbaV0gPSBtYXBwZXIoLyoqIEB0eXBlIHthbnl9ICovIChhcnJbaV0pLCBpLCAvKiogQHR5cGUge2FueX0gKi8gKGFycikpXG4gIH1cbiAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAocmVzKVxufVxuIiwgIi8qKlxuICogT2JzZXJ2YWJsZSBjbGFzcyBwcm90b3R5cGUuXG4gKlxuICogQG1vZHVsZSBvYnNlcnZhYmxlXG4gKi9cblxuaW1wb3J0ICogYXMgbWFwIGZyb20gJy4vbWFwLmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnLi9hcnJheS5qcydcblxuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqIEBleHBlcmltZW50YWxcbiAqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBhIChiZXR0ZXIgdHlwZWQpIGR1cGxpY2F0ZSBvZiBPYnNlcnZhYmxlLCB3aGljaCB3aWxsIHJlcGxhY2UgT2JzZXJ2YWJsZSBpbiB0aGVcbiAqIG5leHQgcmVsZWFzZS5cbiAqXG4gKiBAdGVtcGxhdGUge3tba2V5IGluIGtleW9mIEVWRU5UU106IGZ1bmN0aW9uKC4uLmFueSk6dm9pZH19IEVWRU5UU1xuICovXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZVYyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIFNvbWUgZGVzYy5cbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgU2V0PGFueT4+fVxuICAgICAqL1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCAvKiogQHR5cGUge3N0cmluZ30gKi8gKG5hbWUpLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgICByZXR1cm4gZlxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIC8qKiBAdHlwZSB7YW55fSAqLyAoX2YpKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgRVZFTlRTICYgc3RyaW5nfSBOQU1FXG4gICAqIEBwYXJhbSB7TkFNRX0gbmFtZVxuICAgKiBAcGFyYW0ge0VWRU5UU1tOQU1FXX0gZlxuICAgKi9cbiAgb2ZmIChuYW1lLCBmKSB7XG4gICAgY29uc3Qgb2JzZXJ2ZXJzID0gdGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKVxuICAgIGlmIChvYnNlcnZlcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgb2JzZXJ2ZXJzLmRlbGV0ZShmKVxuICAgICAgaWYgKG9ic2VydmVycy5zaXplID09PSAwKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVycy5kZWxldGUobmFtZSlcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIG5hbWVkIGV2ZW50LiBBbGwgcmVnaXN0ZXJlZCBldmVudCBsaXN0ZW5lcnMgdGhhdCBsaXN0ZW4gdG8gdGhlXG4gICAqIHNwZWNpZmllZCBuYW1lIHdpbGwgcmVjZWl2ZSB0aGUgZXZlbnQuXG4gICAqXG4gICAqIEB0b2RvIFRoaXMgc2hvdWxkIGNhdGNoIGV4Y2VwdGlvbnNcbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBFVkVOVFMgJiBzdHJpbmd9IE5BTUVcbiAgICogQHBhcmFtIHtOQU1FfSBuYW1lIFRoZSBldmVudCBuYW1lLlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlcnM8RVZFTlRTW05BTUVdPn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBIYW5kbGVzIG5hbWVkIGV2ZW50cy5cbiAqXG4gKiBAZGVwcmVjYXRlZFxuICogQHRlbXBsYXRlIE5cbiAqL1xuZXhwb3J0IGNsYXNzIE9ic2VydmFibGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogU29tZSBkZXNjLlxuICAgICAqIEB0eXBlIHtNYXA8TiwgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9vYnNlcnZlcnMgPSBtYXAuY3JlYXRlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb24gKG5hbWUsIGYpIHtcbiAgICBtYXAuc2V0SWZVbmRlZmluZWQodGhpcy5fb2JzZXJ2ZXJzLCBuYW1lLCBzZXQuY3JlYXRlKS5hZGQoZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge059IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZlxuICAgKi9cbiAgb25jZSAobmFtZSwgZikge1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSAgey4uLmFueX0gYXJnc1xuICAgICAqL1xuICAgIGNvbnN0IF9mID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgIHRoaXMub2ZmKG5hbWUsIF9mKVxuICAgICAgZiguLi5hcmdzKVxuICAgIH1cbiAgICB0aGlzLm9uKG5hbWUsIF9mKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tn0gbmFtZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBmXG4gICAqL1xuICBvZmYgKG5hbWUsIGYpIHtcbiAgICBjb25zdCBvYnNlcnZlcnMgPSB0aGlzLl9vYnNlcnZlcnMuZ2V0KG5hbWUpXG4gICAgaWYgKG9ic2VydmVycyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBvYnNlcnZlcnMuZGVsZXRlKGYpXG4gICAgICBpZiAob2JzZXJ2ZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXJzLmRlbGV0ZShuYW1lKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgbmFtZWQgZXZlbnQuIEFsbCByZWdpc3RlcmVkIGV2ZW50IGxpc3RlbmVycyB0aGF0IGxpc3RlbiB0byB0aGVcbiAgICogc3BlY2lmaWVkIG5hbWUgd2lsbCByZWNlaXZlIHRoZSBldmVudC5cbiAgICpcbiAgICogQHRvZG8gVGhpcyBzaG91bGQgY2F0Y2ggZXhjZXB0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge059IG5hbWUgVGhlIGV2ZW50IG5hbWUuXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJncyBUaGUgYXJndW1lbnRzIHRoYXQgYXJlIGFwcGxpZWQgdG8gdGhlIGV2ZW50IGxpc3RlbmVyLlxuICAgKi9cbiAgZW1pdCAobmFtZSwgYXJncykge1xuICAgIC8vIGNvcHkgYWxsIGxpc3RlbmVycyB0byBhbiBhcnJheSBmaXJzdCB0byBtYWtlIHN1cmUgdGhhdCBubyBldmVudCBpcyBlbWl0dGVkIHRvIGxpc3RlbmVycyB0aGF0IGFyZSBzdWJzY3JpYmVkIHdoaWxlIHRoZSBldmVudCBoYW5kbGVyIGlzIGNhbGxlZC5cbiAgICByZXR1cm4gYXJyYXkuZnJvbSgodGhpcy5fb2JzZXJ2ZXJzLmdldChuYW1lKSB8fCBtYXAuY3JlYXRlKCkpLnZhbHVlcygpKS5mb3JFYWNoKGYgPT4gZiguLi5hcmdzKSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX29ic2VydmVycyA9IG1hcC5jcmVhdGUoKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgZW5kICovXG4iLCAiaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBNZW51LCBURmlsZSwgZGVib3VuY2UsIG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgY2FsY3VsYXRlSGFzaCwgY3JlYXRlUmFuZG9tSWQsIGdlbmVyYXRlUmFuZG9tU3RyaW5nLCByYW5kb21VaW50MzIgfSBmcm9tICcuLi90b29scydcbmltcG9ydCB7IENvbXBhcnRtZW50IH0gZnJvbSBcIkBjb2RlbWlycm9yL3N0YXRlXCI7XG5pbXBvcnQgUGVlckRyYWZ0UGx1Z2luIGZyb20gJy4uL21haW4nO1xuaW1wb3J0IHsgb3BlbkZpbGVJbk5ld1RhYiwgcGluTGVhZiwgc2hvd05vdGljZSwgdXNlcmNvbG9ycyB9IGZyb20gJy4uL3VpJztcbmltcG9ydCB7IHlDb2xsYWIgfSBmcm9tICd5LWNvZGVtaXJyb3IubmV4dCc7XG5pbXBvcnQgeyBFZGl0b3JWaWV3IH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyBTdGF0ZUVmZmVjdCB9IGZyb20gXCJAY29kZW1pcnJvci9zdGF0ZVwiO1xuaW1wb3J0IHsgUGVlcmRyYWZ0UmVjb3JkIH0gZnJvbSAnLi4vdXRpbHMvcGVlcmRyYWZ0UmVjb3JkJztcbmltcG9ydCB7IFBlcm1hbmVudFNoYXJlRG9jdW1lbnQgfSBmcm9tICcuLi9wZXJtYW5lbnRTaGFyZVN0b3JlJztcbmltcG9ydCB7IGdldExlYWZJZHNCeVBhdGggfSBmcm9tICcuLi93b3Jrc3BhY2UvcGVlcmRyYWZ0V29ya3NwYWNlJztcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gJy4vc2hhcmVkRW50aXR5JztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gJ3ktaW5kZXhlZGRiJztcbmltcG9ydCB7IGFkZElzU2hhcmVkQ2xhc3MsIHJlbW92ZUlzU2hhcmVkQ2xhc3MgfSBmcm9tICdzcmMvd29ya3NwYWNlL2V4cGxvcmVyVmlldyc7XG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tICcuL3NoYXJlZEZvbGRlcic7XG5pbXBvcnQgeyBNdXRleCB9IGZyb20gJ2FzeW5jLW11dGV4JztcbmltcG9ydCB7IGRpZmYsIGRpZmZDbGVhbnVwRWZmaWNpZW5jeSB9IGZyb20gJ2RpZmYtbWF0Y2gtcGF0Y2gtZXMnXG5pbXBvcnQgeyBhZGQsIGdldERvY0J5UGF0aCwgbW92ZURvYywgcmVtb3ZlRG9jIH0gZnJvbSAnc3JjL3Blcm1hbmVudFNoYXJlU3RvcmVGUyc7XG5pbXBvcnQgeyBvcGVuTG9naW5Nb2RhbCB9IGZyb20gJ3NyYy91aS9sb2dpbic7XG5cbmV4cG9ydCBjbGFzcyBTaGFyZWREb2N1bWVudCBleHRlbmRzIFNoYXJlZEVudGl0eSB7XG5cbiAgcHJpdmF0ZSBzdGF0aWMgX3VzZXJDb2xvciA9IHVzZXJjb2xvcnNbcmFuZG9tVWludDMyKCkgJSB1c2VyY29sb3JzLmxlbmd0aF1cblxuICBwcml2YXRlIF9pc1Blcm1hbmVudDogYm9vbGVhblxuICBwcml2YXRlIF9maWxlOiBURmlsZVxuXG4gIHByaXZhdGUgX2V4dGVuc2lvbnM6IFBlZXJkcmFmdFJlY29yZDxDb21wYXJ0bWVudD5cblxuICBwcml2YXRlIHN0YXR1c0JhckVudHJ5PzogSFRNTEVsZW1lbnRcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWREb2N1bWVudD4gPSBuZXcgQXJyYXk8U2hhcmVkRG9jdW1lbnQ+KClcblxuICBwcml2YXRlIG11dGV4ID0gbmV3IE11dGV4XG4gIHByaXZhdGUgbGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlOiBudW1iZXJcblxuICBzdGF0aWMgYXN5bmMgZnJvbVZpZXcodmlldzogTWFya2Rvd25WaWV3LCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbiwgb3B0cyA9IHsgcGVybWFuZW50OiBmYWxzZSB9KSB7XG4gICAgaWYgKCF2aWV3LmZpbGUpIHJldHVyblxuICAgIGlmICh0aGlzLmZpbmRCeVBhdGgodmlldy5maWxlLnBhdGgpKSByZXR1cm5cbiAgICBjb25zdCBkb2MgPSBhd2FpdCB0aGlzLmZyb21URmlsZSh2aWV3LmZpbGUsIG9wdHMsIHBsdWdpbilcbiAgICBpZiAoZG9jKSB7XG4gICAgICBkb2Muc3RhcnRXZWJSVENTeW5jKClcbiAgICAgIGlmIChkb2MuaXNQZXJtYW5lbnQgJiYgZG9jLl93ZWJSVENQcm92aWRlcikge1xuICAgICAgICBkb2MuZ2V0T3duZXJGcmFnbWVudCgpLmluc2VydCgwLCBkb2MuX3dlYlJUQ1Byb3ZpZGVyLmF3YXJlbmVzcy5jbGllbnRJRC50b0ZpeGVkKDApKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAgICAgcGluTGVhZih2aWV3LmxlYWYpXG4gICAgICB9XG4gICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyBcIi9jbS9cIiArIGRvYy5zaGFyZUlkKVxuICAgICAgc2hvd05vdGljZShcIkNvbGxhYm9yYXRpb24gc3RhcnRlZCBmb3IgXCIgKyBkb2MucGF0aCArIFwiLiBMaW5rIGNvcGllZCB0byBDbGlwYm9hcmQuXCIpXG4gICAgfVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tUGVybWFuZW50U2hhcmVEb2N1bWVudChwZDogUGVybWFuZW50U2hhcmVEb2N1bWVudCwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBpZiAodGhpcy5maW5kQnlQYXRoKHBkLnBhdGgpKSByZXR1cm5cbiAgICAvL2xldCBmaWxlQWxyZWFkeVRoZXJlID0gZmFsc2VcbiAgICAvLyBjaGVjayBpZiBwYXRoIGV4aXN0c1xuICAgIGNvbnN0IGZpbGUgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKHBkLnBhdGgpKVxuICAgIGlmICghZmlsZSkge1xuICAgICAgc2hvd05vdGljZShcIkZpbGUgXCIgKyBwZC5wYXRoICsgXCIgbm90IGZvdW5kLiBDcmVhdGluZyBpdCBub3cuXCIpXG4gICAgICBhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKHBhdGguZGlybmFtZShwZC5wYXRoKSwgcGx1Z2luKVxuICAgICAgY29uc3QgZmlsZSA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlKHBkLnBhdGgsICcnKVxuICAgICAgaWYgKCFmaWxlKSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBmaWxlIFwiICsgcGQucGF0aCArIFwiLlwiKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vZmlsZUFscmVhZHlUaGVyZSA9IHRydWVcbiAgICB9XG5cbiAgICBjb25zdCBkb2MgPSBuZXcgU2hhcmVkRG9jdW1lbnQoe1xuICAgICAgcGF0aDogcGQucGF0aFxuICAgIH0sIHBsdWdpbilcbiAgICBkb2MuX2lzUGVybWFuZW50ID0gdHJ1ZVxuICAgIGRvYy5fc2hhcmVJZCA9IHBkLnNoYXJlSWRcbiAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAvL2lmIChmaWxlQWxyZWFkeVRoZXJlKSB7XG4gICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAvL31cbiAgICBwbHVnaW4uYWN0aXZlU3RyZWFtQ2xpZW50LmFkZChbZG9jLnNoYXJlSWRdKVxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmVVUkwodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKTogUHJvbWlzZTxTaGFyZWREb2N1bWVudCB8IHZvaWQ+IHtcbiAgICBjb25zdCBpZCA9IHVybC5zcGxpdCgnLycpLnBvcCgpXG4gICAgaWYgKCFpZCB8fCAhaWQubWF0Y2goJ15bMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn0kJykpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJObyB2YWxpZCBwZWVyZHJhZnQgbGlua1wiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBpc1Blcm1hbmVudCA9IGF3YWl0IHBsdWdpbi5zZXJ2ZXJBUEkuaXNTZXNzaW9uUGVybWFuZW50KGlkKVxuXG4gICAgY29uc3QgeURvYyA9IG5ldyBZLkRvYygpXG5cbiAgICBzaG93Tm90aWNlKFwiVHJ5aW5nIHRvIGluaXRpYXRlIHN5bmMuLi5cIilcblxuICAgIGNvbnN0IGRvYyA9IG5ldyBTaGFyZWREb2N1bWVudCh7XG4gICAgICBpZCxcbiAgICAgIHlEb2NcbiAgICB9LCBwbHVnaW4pXG5cbiAgICAvLyB3YWl0IGZvciBmaXJzdCB1cGRhdGUgdG8gbWFrZSBzdXJlIGl0IHdvcmtzIGFuZCB0byBnZXQgdGhlIGZpbGVuYW1lXG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgICAgZG9jLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgICAgZG9jLnN5bmNXaXRoU2VydmVyKClcbiAgICAgIH1cbiAgICAgIHlEb2Mub25jZShcInVwZGF0ZVwiLCAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3QgZG9jRmlsZW5hbWUgPSBkb2MueURvYy5nZXRUZXh0KFwib3JpZ2luYWxGaWxlbmFtZVwiKS50b1N0cmluZygpXG4gICAgbGV0IGluaXRpYWxGaWxlTmFtZSA9IGBfcGVlcmRyYWZ0X3Nlc3Npb25fJHtpZH1fJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfS5tZGBcbiAgICBpZiAoZG9jRmlsZW5hbWUgIT0gJycpIHtcbiAgICAgIGNvbnN0IGZpbGVFeGlzdHMgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChub3JtYWxpemVQYXRoKGRvY0ZpbGVuYW1lKSlcbiAgICAgIGlmICghZmlsZUV4aXN0cykge1xuICAgICAgICBpbml0aWFsRmlsZU5hbWUgPSBkb2NGaWxlbmFtZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5pdGlhbEZpbGVOYW1lID0gYF9wZWVyZHJhZnRfJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfV8ke2RvY0ZpbGVuYW1lfWBcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBwYXJlbnQgPSBwbHVnaW4uc2V0dGluZ3Mucm9vdCB8fCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLmdldE5ld0ZpbGVQYXJlbnQoJycsIGluaXRpYWxGaWxlTmFtZSkucGF0aFxuICAgIGNvbnN0IGZpbGVQYXRoID0gcGF0aC5qb2luKHBhcmVudCwgaW5pdGlhbEZpbGVOYW1lKVxuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSwgcGx1Z2luKVxuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShmaWxlUGF0aCwgZG9jLmdldFZhbHVlKCkpXG4gICAgYWRkSXNTaGFyZWRDbGFzcyhmaWxlLnBhdGgsIHBsdWdpbilcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG4gICAgZG9jLl9wYXRoID0gZmlsZS5wYXRoXG5cbiAgICBpZiAoaXNQZXJtYW5lbnQpIHtcbiAgICAgIGRvYy5faXNQZXJtYW5lbnQgPSB0cnVlXG4gICAgICBhd2FpdCBhZGQoZG9jLCBwbHVnaW4pXG4gICAgICBhd2FpdCBkb2Muc3RhcnRJbmRleGVkREJTeW5jKClcbiAgICAgIHBsdWdpbi5hY3RpdmVTdHJlYW1DbGllbnQuYWRkKFtkb2Muc2hhcmVJZF0pXG4gICAgfVxuXG4gICAgY29uc3QgbGVhZiA9IGF3YWl0IG9wZW5GaWxlSW5OZXdUYWIoZmlsZSwgcGx1Z2luLmFwcC53b3Jrc3BhY2UpXG4gICAgZG9jLmFkZFN0YXR1c0JhckVudHJ5KClcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgZG9jLmFkZEV4dGVuc2lvblRvTGVhZihsZWFmLmlkKVxuICAgIHBpbkxlYWYobGVhZilcbiAgICBzaG93Tm90aWNlKFwiSm9pbmVkIFNlc3Npb24gaW4gXCIgKyBkb2MucGF0aCArIFwiLlwiKVxuICAgIHJldHVybiBkb2NcblxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGZyb21JZEFuZFBhdGgoaWQ6IHN0cmluZywgbG9jYXRpb246IHN0cmluZywgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgobG9jYXRpb24pXG4gICAgY29uc3QgZXhpc3RpbmdEb2MgPSBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZClcbiAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJUaGlzIHNoYXJlIGlzIGFscmVhZHkgYWN0aXZlOiBcIiArIGV4aXN0aW5nRG9jLnBhdGgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgYXdhaXQgU2hhcmVkRm9sZGVyLmdldE9yQ3JlYXRlUGF0aChwYXRoLmRpcm5hbWUobm9ybWFsaXplZFBhdGgpLCBwbHVnaW4pXG4gICAgc2hvd05vdGljZShcIkNyZWF0aW5nIG5ldyBzeW5jZWQgZmlsZSBcIiArIG5vcm1hbGl6ZWRQYXRoKVxuICAgIGNvbnN0IHlkb2MgPSBhd2FpdCBwbHVnaW4uc2VydmVyU3luYy5yZXF1ZXN0RG9jdW1lbnQoaWQpXG4gICAgY29uc3QgZG9jID0gbmV3IFNoYXJlZERvY3VtZW50KHtcbiAgICAgIGlkLCB5RG9jOiB5ZG9jXG4gICAgfSwgcGx1Z2luKVxuICAgIGRvYy5fcGF0aCA9IG5vcm1hbGl6ZWRQYXRoXG5cbiAgICBjb25zdCBmaWxlID0gYXdhaXQgcGx1Z2luLmFwcC52YXVsdC5jcmVhdGUobm9ybWFsaXplZFBhdGgsIHlkb2MuZ2V0VGV4dChcImNvbnRlbnRcIikudG9TdHJpbmcoKSlcbiAgICBkb2MuX2ZpbGUgPSBmaWxlXG5cbiAgICBkb2Muc3luY1dpdGhTZXJ2ZXIoKVxuICAgIGF3YWl0IGRvYy5zZXRQZXJtYW5lbnQoKVxuICAgIGF3YWl0IGRvYy5zdGFydEluZGV4ZWREQlN5bmMoKVxuICAgIGFkZElzU2hhcmVkQ2xhc3MoZG9jLnBhdGgsIHBsdWdpbilcbiAgfVxuXG5cbiAgc3RhdGljIGFzeW5jIGZyb21URmlsZShmaWxlOiBURmlsZSwgb3B0czogeyBwZXJtYW5lbnQ/OiBib29sZWFuIH0sIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgaWYgKCFbJ21kJywgJ01EJ10uY29udGFpbnMoZmlsZS5leHRlbnNpb24pKSByZXR1cm5cbiAgICBjb25zdCBleGlzdGluZyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeVBhdGgoZmlsZS5wYXRoKVxuICAgIGlmIChleGlzdGluZykgcmV0dXJuIGV4aXN0aW5nXG5cbiAgICBpZighcGx1Z2luLnNlcnZlclN5bmMuYXV0aGVudGljYXRlZCkge1xuICAgICAgc2hvd05vdGljZShcIlBsZWFzZSBsb2cgaW4gdG8gUGVlcmRyYWZ0IGZpcnN0LlwiKVxuICAgICAgY29uc3QgYXV0aCA9IGF3YWl0IG9wZW5Mb2dpbk1vZGFsKHBsdWdpbilcbiAgICAgIGlmICghYXV0aCkgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZG9jID0gbmV3IFNoYXJlZERvY3VtZW50KHsgcGF0aDogZmlsZS5wYXRoIH0sIHBsdWdpbilcbiAgICBjb25zdCBsZWFmSWRzID0gZ2V0TGVhZklkc0J5UGF0aChmaWxlLnBhdGgsIHBsdWdpbi5wd3MpXG5cbiAgICBpZiAobGVhZklkcy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gKHBsdWdpbi5hcHAud29ya3NwYWNlLmdldExlYWZCeUlkKGxlYWZJZHNbMF0pPy52aWV3IGFzIE1hcmtkb3duVmlldykuZWRpdG9yLmdldFZhbHVlKClcbiAgICAgIGRvYy5nZXRDb250ZW50RnJhZ21lbnQoKS5pbnNlcnQoMCwgY29udGVudClcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQucmVhZChmaWxlKVxuICAgICAgZG9jLmdldENvbnRlbnRGcmFnbWVudCgpLmluc2VydCgwLCBjb250ZW50KVxuICAgIH1cblxuICAgIGRvYy55RG9jLmdldFRleHQoXCJvcmlnaW5hbEZpbGVuYW1lXCIpLmluc2VydCgwLCBmaWxlLm5hbWUpXG5cbiAgICBpZiAob3B0cy5wZXJtYW5lbnQpIHtcbiAgICAgIGF3YWl0IGRvYy5pbml0U2VydmVyWURvYygpXG4gICAgICBhd2FpdCBkb2Muc2V0UGVybWFuZW50KClcbiAgICAgIC8vIGRvYy5zdGFydFdlYlNvY2tldFN5bmMoKVxuICAgICAgZG9jLnN0YXJ0SW5kZXhlZERCU3luYygpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvYy5fc2hhcmVJZCA9IGNyZWF0ZVJhbmRvbUlkKClcbiAgICB9XG5cbiAgICBmb3IgKGNvbnN0IGlkIG9mIGxlYWZJZHMpIHtcbiAgICAgIGRvYy5hZGRFeHRlbnNpb25Ub0xlYWYoaWQpXG4gICAgfVxuXG4gICAgc2hvd05vdGljZShgSW5pdGl0aWFsaXplZCBzaGFyZSBmb3IgJHtmaWxlLnBhdGh9YClcbiAgICByZXR1cm4gZG9jXG4gIH1cblxuICBzdGF0aWMgZmluZEJ5UGF0aChwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZmluZEJ5UGF0aChwYXRoKSBhcyBTaGFyZWREb2N1bWVudCB8IHVuZGVmaW5lZFxuICB9XG5cbiAgc3RhdGljIGZpbmRCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZmluZEJ5SWQoaWQpIGFzIFNoYXJlZERvY3VtZW50IHwgdW5kZWZpbmVkXG4gIH1cblxuICBzdGF0aWMgZ2V0QWxsKCkge1xuICAgIHJldHVybiBzdXBlci5nZXRBbGwoKSBhcyBBcnJheTxTaGFyZWREb2N1bWVudD5cbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3Iob3B0czoge1xuICAgIHBhdGg/OiBzdHJpbmcsXG4gICAgaWQ/OiBzdHJpbmcsXG4gICAgeURvYz86IFkuRG9jXG4gIH0sIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgc3VwZXIocGx1Z2luKVxuICAgIGlmIChvcHRzLnBhdGgpIHtcbiAgICAgIHRoaXMuX3BhdGggPSBub3JtYWxpemVQYXRoKG9wdHMucGF0aClcbiAgICAgIGNvbnN0IGZpbGUgPSB0aGlzLnBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZVBhdGgob3B0cy5wYXRoKSlcbiAgICAgIGlmICgoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgICAgICB0aGlzLl9maWxlID0gZmlsZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hvd05vdGljZShcIkVSUk9SIGNyZWF0aW5nIHNoYXJlZERvY1wiKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0cy5pZCkge1xuICAgICAgdGhpcy5fc2hhcmVJZCA9IG9wdHMuaWRcbiAgICB9XG5cblxuICAgIHRoaXMueURvYyA9IG9wdHMueURvYyA/PyBuZXcgWS5Eb2MoKVxuICAgIHRoaXMueURvYy5vbihcInVwZGF0ZVwiLCAodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IGFueSwgeURvYzogWS5Eb2MsIHRyOiBZLlRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICBpZiAodHIubG9jYWwgJiYgdGhpcy5pc1Blcm1hbmVudCkge1xuICAgICAgICBwbHVnaW4uc2VydmVyU3luYy5zZW5kVXBkYXRlKHRoaXMsIHVwZGF0ZSlcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgU2hhcmVkRG9jdW1lbnQuX3NoYXJlZEVudGl0ZXMucHVzaCh0aGlzKVxuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSBuZXcgUGVlcmRyYWZ0UmVjb3JkPENvbXBhcnRtZW50PigpXG4gICAgdGhpcy5fZXh0ZW5zaW9ucy5vbihcImRlbGV0ZVwiLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5zaXplID09PSAwICYmIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyLmF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlKHt9KVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLmdldENvbnRlbnRGcmFnbWVudCgpLm9ic2VydmUoYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2ZpbGUgJiYgdGhpcy5fZXh0ZW5zaW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgIGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm11dGV4LnJ1bkV4Y2x1c2l2ZShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB5RG9jQ29udGVudCA9IHRoaXMuZ2V0VmFsdWUoKVxuICAgICAgICAgICAgY29uc3QgZmlsZUNvbnRlbnQgPSBhd2FpdCB0aGlzLnBsdWdpbi5hcHAudmF1bHQucmVhZCh0aGlzLl9maWxlKVxuICAgICAgICAgICAgaWYgKHlEb2NDb250ZW50ICE9IGZpbGVDb250ZW50KSB7XG4gICAgICAgICAgICAgIHRoaXMubGFzdFVwZGF0ZVRyaWdnZXJlZEJ5RG9jQ2hhbmdlID0gbmV3IERhdGUoKS52YWx1ZU9mKClcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0Lm1vZGlmeSh0aGlzLl9maWxlLCB5RG9jQ29udGVudCwge1xuICAgICAgICAgICAgICAgIG10aW1lOiB0aGlzLmxhc3RVcGRhdGVUcmlnZ2VyZWRCeURvY0NoYW5nZVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIH0sIDEwMDAsIHRydWUpKClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgdGhpcy5wbHVnaW4ucmVnaXN0ZXJFdmVudCh0aGlzLnBsdWdpbi5hcHAudmF1bHQub24oXCJtb2RpZnlcIiwgYXN5bmMgKGZpbGUpID0+IHtcbiAgICAgIC8vIG9ubHkgcmVhY3QgdG8gY2hhbmdlcyBvZiB0aGlzIGZpbGUsIGFuZCBvbmx5IGlmIGl0IGRpZG4ndCBoYXBwZW4gd2l0aGluIHRoZSBlZGl0b3IuXG4gICAgICAvLyBUaGUgZWRpdG9yIGV4dGVuc2lvbiB0YWtlcyBjYXJlIG9mIHVwZGF0ZXMgaW4gdGhhdCBjYXNlLlxuICAgICAgaWYgKHRoaXMuZmlsZSA9PT0gZmlsZSAmJiB0aGlzLl9leHRlbnNpb25zLnNpemUgPT09IDAgJiYgdGhpcy5maWxlLnN0YXQubXRpbWUgIT0gdGhpcy5sYXN0VXBkYXRlVHJpZ2dlcmVkQnlEb2NDaGFuZ2UpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgZG9jdW1lbnQgYW5kIGNvbnRlbnQgYWN0dWFsbHkgYXJlIG91dCBvZiBzeW5jXG4gICAgICAgIHRoaXMubXV0ZXgucnVuRXhjbHVzaXZlKGFzeW5jICgpID0+IHtcbiAgICAgICAgICBjb25zdCB5RG9jQ29udGVudCA9IHRoaXMuZ2V0VmFsdWUoKVxuICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LnJlYWQodGhpcy5fZmlsZSlcbiAgICAgICAgICBpZiAoeURvY0NvbnRlbnQgIT0gZmlsZUNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmZzID0gZGlmZih5RG9jQ29udGVudCwgZmlsZUNvbnRlbnQpXG4gICAgICAgICAgICBkaWZmQ2xlYW51cEVmZmljaWVuY3koZGlmZnMpXG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKVxuICAgICAgICAgICAgbGV0IHBvcyA9IDBcbiAgICAgICAgICAgIHRoaXMueURvYy50cmFuc2FjdCgoKSA9PiB7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZGlmZiBvZiBkaWZmcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBkaWZmWzFdIGFzIHN0cmluZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHRleHQubGVuZ3RoXG4gICAgICAgICAgICAgICAgc3dpdGNoIChkaWZmWzBdKSB7XG4gICAgICAgICAgICAgICAgICAvLyBrZWVwXG4gICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbGVuZ3RoXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAvLyByZW1vdmVcbiAgICAgICAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LmRlbGV0ZShwb3MsIGxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIC8vIGFkZFxuICAgICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudC5pbnNlcnQocG9zLCB0ZXh0KVxuICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSBsZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH0pKVxuXG4gICAgYWRkSXNTaGFyZWRDbGFzcyh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICB9XG5cbiAgZ2V0IGZpbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVcbiAgfVxuXG4gIGNhbGN1bGF0ZUhhc2goKSB7XG4gICAgY29uc3QgdGV4dCA9IHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KCkudG9TdHJpbmcoKVxuICAgIHJldHVybiBjYWxjdWxhdGVIYXNoKHRleHQpXG4gIH1cblxuICBzdGFydFdlYlJUQ1N5bmMoKSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0YXJ0V2ViUlRDU3luYygocHJvdmlkZXIpID0+IHtcblxuICAgICAgcHJvdmlkZXIuYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgndXNlcicsIHtcbiAgICAgICAgbmFtZTogdGhpcy5wbHVnaW4uc2V0dGluZ3MubmFtZSxcbiAgICAgICAgY29sb3I6IFNoYXJlZERvY3VtZW50Ll91c2VyQ29sb3IuZGFyayxcbiAgICAgICAgY29sb3JMaWdodDogU2hhcmVkRG9jdW1lbnQuX3VzZXJDb2xvci5saWdodFxuICAgICAgfSlcblxuXG4gICAgICBwcm92aWRlci5hd2FyZW5lc3Mub24oXCJ1cGRhdGVcIiwgYXN5bmMgKG1zZzogeyBhZGRlZDogQXJyYXk8bnVtYmVyPiwgcmVtb3ZlZDogQXJyYXk8bnVtYmVyPiB9KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBtc2cucmVtb3ZlZCA/PyBbXTtcbiAgICAgICAgaWYgKHJlbW92ZWQgJiYgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgY29uc3QgcmVtb3ZlZFN0cmluZ3MgPSByZW1vdmVkLm1hcCgoaWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBpZC50b0ZpeGVkKDApO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgY29uc3Qgb3duZXIgPSB0aGlzLmdldE93bmVyRnJhZ21lbnQoKS50b1N0cmluZygpXG4gICAgICAgICAgaWYgKG93bmVyICE9IHByb3ZpZGVyLmF3YXJlbmVzcy5jbGllbnRJRC50b1N0cmluZygpKSB7XG4gICAgICAgICAgICBpZiAocmVtb3ZlZFN0cmluZ3MuaW5jbHVkZXMob3duZXIpICYmICF0aGlzLmlzUGVybWFuZW50KSB7XG4gICAgICAgICAgICAgIHNob3dOb3RpY2UoXCJTaGFyZWQgc2Vzc2lvbiBmb3IgXCIgKyB0aGlzLnBhdGggKyBcIiBzdG9wcGVkIGJ5IG93bmVyXCIpXG4gICAgICAgICAgICAgIGF3YWl0IHRoaXMudW5zaGFyZSgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgICAgICBjb25zdCBhZGRlZCA9IG1zZy5hZGRlZCA/PyBbXTtcbiAgICAgICAgaWYgKGFkZGVkICYmIGFkZGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBzdGF0ZXMgPSBwcm92aWRlci5hd2FyZW5lc3MuZ2V0U3RhdGVzKClcbiAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBhZGRlZCkge1xuICAgICAgICAgICAgY29uc3QgcGVlciA9IHN0YXRlcy5nZXQoa2V5KVxuICAgICAgICAgICAgaWYgKHBlZXIgJiYgdGhpcy5wYXRoICYmIGtleSAhPSB0aGlzLl93ZWJSVENQcm92aWRlcj8uYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgICAgICAgIHNob3dOb3RpY2UoYCR7cGVlci51c2VyPy5uYW1lfSBpcyB3b3JraW5nIG9uICR7dGhpcy5wYXRofWAsIDEwMDAwKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcblxuXG4gICAgICAvKlxuICAgICAgaWYgKCF0aGlzLl93ZWJSVENUaW1lb3V0KSB7XG5cbiAgICAgICAgY29uc3QgaGFuZGxlVGltZW91dCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5zaXplID4gMCB8fCBnZXRMZWFmSWRzQnlQYXRoKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4ucHdzKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWJSVENUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlVGltZW91dCwgNjAwMDApXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFdlYlJUQ1N5bmMoKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dlYlJUQ1RpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChoYW5kbGVUaW1lb3V0LCA2MDAwMClcblxuICAgICAgICBwcm92aWRlci5kb2Mub24oJ3VwZGF0ZScsIGFzeW5jICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55LCBkb2M6IFkuRG9jLCB0cjogWS5UcmFuc2FjdGlvbikgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl93ZWJSVENUaW1lb3V0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fd2ViUlRDVGltZW91dClcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5fd2ViUlRDVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIDYwMDAwKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgICAgKi9cblxuICAgIH0pXG5cbiAgfVxuXG4gIGFzeW5jIHNldE5ld0ZpbGVMb2NhdGlvbihmaWxlOiBURmlsZSkge1xuICAgIGNvbnN0IG9sZFBhdGggPSB0aGlzLl9wYXRoXG4gICAgdGhpcy5fZmlsZSA9IGZpbGVcbiAgICB0aGlzLl9wYXRoID0gbm9ybWFsaXplUGF0aChmaWxlLnBhdGgpXG4gICAgaWYgKHRoaXMuc3RhdHVzQmFyRW50cnkpIHtcbiAgICAgIHRoaXMucmVtb3ZlU3RhdHVzU3RhdHVzQmFyRW50cnkoKVxuICAgICAgdGhpcy5hZGRTdGF0dXNCYXJFbnRyeSgpXG4gICAgfVxuICAgIGF3YWl0IG1vdmVEb2Mob2xkUGF0aCwgZmlsZS5wYXRoLCB0aGlzLnBsdWdpbilcbiAgICByZW1vdmVJc1NoYXJlZENsYXNzKG9sZFBhdGgsIHRoaXMucGx1Z2luKVxuICAgIGFkZElzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG4gIGFzeW5jIHNldFBlcm1hbmVudCgpIHtcbiAgICBpZiAoIXRoaXMuX2lzUGVybWFuZW50KSB7XG4gICAgICB0aGlzLl9pc1Blcm1hbmVudCA9IHRydWVcbiAgICAgIGF3YWl0IGFkZCh0aGlzLCB0aGlzLnBsdWdpbilcbiAgICAgIHRoaXMucGx1Z2luLmFjdGl2ZVN0cmVhbUNsaWVudC5hZGQoW3RoaXMuc2hhcmVJZF0pXG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzUGVybWFuZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9pc1Blcm1hbmVudFxuICB9XG5cbiAgZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudEZyYWdtZW50KCkudG9TdHJpbmcoKVxuICB9XG5cbiAgZ2V0Q29udGVudEZyYWdtZW50KCkge1xuICAgIHJldHVybiB0aGlzLnlEb2MuZ2V0VGV4dChcImNvbnRlbnRcIilcbiAgfVxuXG4gIGdldE93bmVyRnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueURvYy5nZXRUZXh0KFwib3duZXJcIilcbiAgfVxuXG4gIGFzeW5jIHN0YXJ0SW5kZXhlZERCU3luYygpIHtcbiAgICBpZiAodGhpcy5faW5kZXhlZERCUHJvdmlkZXIpIHJldHVybiB0aGlzLl9pbmRleGVkREJQcm92aWRlclxuICAgIGNvbnN0IGlkID0gKGdldERvY0J5UGF0aCh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKSk/LnBlcnNpc3RlbmNlSWRcbiAgICBpZiAoIWlkKSByZXR1cm5cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBJbmRleGVkZGJQZXJzaXN0ZW5jZShTaGFyZWRFbnRpdHkuREJfUEVSU0lTVEVOQ0VfUFJFRklYICsgaWQsIHRoaXMueURvYylcbiAgICB0aGlzLl9pbmRleGVkREJQcm92aWRlciA9IHByb3ZpZGVyXG4gICAgaWYgKCFwcm92aWRlci5zeW5jZWQpIGF3YWl0IHByb3ZpZGVyLndoZW5TeW5jZWRcblxuICAgIHJldHVybiB0aGlzLl9pbmRleGVkREJQcm92aWRlclxuICB9XG5cbiAgYWRkRXh0ZW5zaW9uVG9MZWFmKGxlYWZJZDogc3RyaW5nKSB7XG4gICAgLy8gb25seSBtYWtlcyBzZW5zZSBpZiB3ZSBoYXZlIGEgd2VicmN0IHByb3ZpZGVyIHRvIHN5bmMgd2l0aFxuICAgIGNvbnN0IHdlYlJUQ1Byb3ZpZGVyID0gdGhpcy5zdGFydFdlYlJUQ1N5bmMoKVxuICAgIGlmICghd2ViUlRDUHJvdmlkZXIpIHJldHVyblxuICAgIC8vIGFscmVhZHkgdGhlcmVcbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9ucy5nZXQobGVhZklkKSkgcmV0dXJuXG4gICAgLy8gbmVlZCBhIHBsZWFmXG4gICAgY29uc3QgcExlYWYgPSB0aGlzLnBsdWdpbi5wd3MuZ2V0KGxlYWZJZClcbiAgICBpZiAoIXBMZWFmKSByZXR1cm5cblxuICAgIC8vIHBhdGggbmVlZHMgdG8gbWF0Y2hcblxuICAgIGlmIChwTGVhZi5wYXRoICE9IHRoaXMuX3BhdGgpIHJldHVyblxuICAgIGlmIChwTGVhZi5pc1ByZXZpZXcpIHtcbiAgICAgIHBMZWFmLm9uY2UoXCJjaGFuZ2VJc1ByZXZpZXdcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZEV4dGVuc2lvblRvTGVhZihsZWFmSWQpXG4gICAgICB9KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgbGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZkJ5SWQobGVhZklkKVxuICAgIGlmICghbGVhZikgcmV0dXJuXG4gICAgY29uc3QgdmlldyA9IGxlYWYudmlldyBhcyBNYXJrZG93blZpZXdcbiAgICBjb25zdCBlZGl0b3IgPSB2aWV3LmVkaXRvclxuXG4gICAgZWRpdG9yLnNldFZhbHVlKHRoaXMuZ2V0VmFsdWUoKSlcblxuICAgIGNvbnN0IHVuZG9NYW5hZ2VyID0gbmV3IFkuVW5kb01hbmFnZXIodGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKSlcblxuICAgIGNvbnN0IGV4dGVuc2lvbiA9IHlDb2xsYWIodGhpcy5nZXRDb250ZW50RnJhZ21lbnQoKSwgd2ViUlRDUHJvdmlkZXIuYXdhcmVuZXNzLCB7IHVuZG9NYW5hZ2VyIH0pXG4gICAgY29uc3QgY29tcGFydG1lbnQgPSBuZXcgQ29tcGFydG1lbnQoKVxuXG4gICAgY29uc3QgZWRpdG9yVmlldyA9IChlZGl0b3IgYXMgYW55KS5jbSBhcyBFZGl0b3JWaWV3O1xuICAgIGVkaXRvclZpZXcuZGlzcGF0Y2goe1xuICAgICAgZWZmZWN0czogU3RhdGVFZmZlY3QuYXBwZW5kQ29uZmlnLm9mKGNvbXBhcnRtZW50Lm9mKGV4dGVuc2lvbikpXG4gICAgfSlcblxuICAgIHRoaXMuX2V4dGVuc2lvbnMuc2V0KGxlYWZJZCwgY29tcGFydG1lbnQpXG5cbiAgICAvLyByZW1vdmUgaWYgc3dpdGNoIHRvIHByZXZpZXdcbiAgICBwTGVhZi5vbmNlKFwiY2hhbmdlSXNQcmV2aWV3XCIsICgpID0+IHtcbiAgICAgIHRoaXMucmVtb3ZlRXh0ZW5zaW9uRnJvbUxlYWYobGVhZklkKVxuICAgICAgLy8gYWRkIGFnYWluIGlmIHN3aXRjaGVkIGJhY2tcbiAgICAgIHBMZWFmLm9uY2UoXCJjaGFuZ2VJc1ByZXZpZXdcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZEV4dGVuc2lvblRvTGVhZihsZWFmSWQpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICByZXR1cm4gQ29tcGFydG1lbnRcbiAgfVxuXG4gIHJlbW92ZUV4dGVuc2lvbkZyb21MZWFmKGxlYWZJZDogc3RyaW5nKSB7XG4gICAgY29uc3QgbGVhZiA9IHRoaXMucGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZkJ5SWQobGVhZklkKVxuICAgIGlmIChsZWFmKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSAobGVhZi52aWV3IGFzIE1hcmtkb3duVmlldykuZWRpdG9yXG4gICAgICAgIGNvbnN0IGVkaXRvclZpZXcgPSAoZWRpdG9yIGFzIGFueSkuY20gYXMgRWRpdG9yVmlldztcbiAgICAgICAgY29uc3QgY29tcGFydG1lbnQgPSB0aGlzLl9leHRlbnNpb25zLmdldChsZWFmSWQpXG4gICAgICAgIGlmIChjb21wYXJ0bWVudCkge1xuICAgICAgICAgIGVkaXRvclZpZXcuZGlzcGF0Y2goe1xuICAgICAgICAgICAgZWZmZWN0czogY29tcGFydG1lbnQucmVjb25maWd1cmUoW10pXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5wbHVnaW4ubG9nKFwiZWRpdG9yIGFscmVhZHkgZ29uZVwiKVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9leHRlbnNpb25zLmRlbGV0ZShsZWFmSWQpXG4gIH1cblxuICBhZGRTdGF0dXNCYXJFbnRyeSgpIHtcbiAgICBpZiAodGhpcy5zdGF0dXNCYXJFbnRyeSkgcmV0dXJuXG4gICAgY29uc3QgbWVudSA9IG5ldyBNZW51KClcbiAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0uc2V0VGl0bGUoXCJDb3B5IGxpbmtcIilcbiAgICAgIGl0ZW0ub25DbGljaygoKSA9PiB7XG4gICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgXCIvY20vXCIgKyB0aGlzLnNoYXJlSWQpXG4gICAgICAgIHNob3dOb3RpY2UoXCJMaW5rIGNvcGllZCB0byBjbGlwYm9hcmQuXCIpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBtZW51LmFkZEl0ZW0oKGl0ZW0pID0+IHtcbiAgICAgIGl0ZW0uc2V0VGl0bGUoXCJTdG9wIHNoYXJlZCBzZXNzaW9uXCIpXG4gICAgICBpdGVtLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBhd2FpdCB0aGlzLnVuc2hhcmUoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgY29uc3Qgc3RhdHVzID0gdGhpcy5wbHVnaW4uYWRkU3RhdHVzQmFySXRlbSgpO1xuICAgIHN0YXR1cy5hZGRDbGFzcygnbW9kLWNsaWNrYWJsZScpXG4gICAgc3RhdHVzLmNyZWF0ZUVsKFwic3BhblwiLCB7IHRleHQ6IFwiU2hhcmluZyAnXCIgKyB0aGlzLnBhdGggKyBcIidcIiB9KVxuICAgIHN0YXR1cy5vbkNsaWNrRXZlbnQoKGV2ZW50KSA9PiB7XG4gICAgICBtZW51LnNob3dBdE1vdXNlRXZlbnQoZXZlbnQpO1xuICAgIH0pXG4gICAgdGhpcy5zdGF0dXNCYXJFbnRyeSA9IHN0YXR1c1xuICB9XG5cbiAgcmVtb3ZlU3RhdHVzU3RhdHVzQmFyRW50cnkoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXR1c0JhckVudHJ5KSByZXR1cm5cbiAgICB0aGlzLnN0YXR1c0JhckVudHJ5LnJlbW92ZSgpXG4gICAgdGhpcy5zdGF0dXNCYXJFbnRyeSA9IHVuZGVmaW5lZFxuICB9XG5cbiAgYXN5bmMgdW5zaGFyZSgpIHtcbiAgICBjb25zdCBkYkVudHJ5ID0gZ2V0RG9jQnlQYXRoKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgaWYgKGRiRW50cnkpIHtcbiAgICAgIHJlbW92ZURvYyh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICAgIH1cbiAgICBpZiAodGhpcy5faW5kZXhlZERCUHJvdmlkZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyLmNsZWFyRGF0YSgpXG4gICAgfVxuICAgIHRoaXMuZGVzdHJveSgpXG4gICAgcmVtb3ZlSXNTaGFyZWRDbGFzcyh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICB9XG5cbiAgZ2V0U2hhcmVVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgXCIvY20vXCIgKyB0aGlzLnNoYXJlSWRcbiAgfVxuXG4gIHVwZGF0ZVByb3BlcnR5KG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZywgb2xkUHJvcGVydHk/OiBzdHJpbmcpIHtcbiAgICB0aGlzLnBsdWdpbi5hcHAuZmlsZU1hbmFnZXIucHJvY2Vzc0Zyb250TWF0dGVyKHRoaXMuZmlsZSwgKGZtKSA9PiB7XG4gICAgICBpZiAob2xkUHJvcGVydHkpIHtcbiAgICAgICAgZGVsZXRlIGZtW29sZFByb3BlcnR5XVxuICAgICAgfVxuICAgICAgZm1bbmFtZV0gPSB2YWx1ZVxuICAgIH0pXG4gIH1cblxuXG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAoIXRoaXMuaXNQZXJtYW5lbnQpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJTdG9wcGluZyBjb2xsYWJvcmF0aW9uIG9uIFwiICsgdGhpcy5wYXRoICsgXCIuXCIpXG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMuX2V4dGVuc2lvbnMua2V5cykge1xuICAgICAgdGhpcy5yZW1vdmVFeHRlbnNpb25Gcm9tTGVhZihrZXkpXG4gICAgfVxuICAgIHRoaXMuX2V4dGVuc2lvbnMuZGVzdHJveSgpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgdGhpcy5yZW1vdmVTdGF0dXNTdGF0dXNCYXJFbnRyeSgpXG4gICAgU2hhcmVkRG9jdW1lbnQuX3NoYXJlZEVudGl0ZXMuc3BsaWNlKFNoYXJlZERvY3VtZW50Ll9zaGFyZWRFbnRpdGVzLmluZGV4T2YodGhpcyksIDEpXG4gIH1cbn0iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogQmluYXJ5IGRhdGEgY29uc3RhbnRzLlxuICpcbiAqIEBtb2R1bGUgYmluYXJ5XG4gKi9cblxuLyoqXG4gKiBuLXRoIGJpdCBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVDEgPSAxXG5leHBvcnQgY29uc3QgQklUMiA9IDJcbmV4cG9ydCBjb25zdCBCSVQzID0gNFxuZXhwb3J0IGNvbnN0IEJJVDQgPSA4XG5leHBvcnQgY29uc3QgQklUNSA9IDE2XG5leHBvcnQgY29uc3QgQklUNiA9IDMyXG5leHBvcnQgY29uc3QgQklUNyA9IDY0XG5leHBvcnQgY29uc3QgQklUOCA9IDEyOFxuZXhwb3J0IGNvbnN0IEJJVDkgPSAyNTZcbmV4cG9ydCBjb25zdCBCSVQxMCA9IDUxMlxuZXhwb3J0IGNvbnN0IEJJVDExID0gMTAyNFxuZXhwb3J0IGNvbnN0IEJJVDEyID0gMjA0OFxuZXhwb3J0IGNvbnN0IEJJVDEzID0gNDA5NlxuZXhwb3J0IGNvbnN0IEJJVDE0ID0gODE5MlxuZXhwb3J0IGNvbnN0IEJJVDE1ID0gMTYzODRcbmV4cG9ydCBjb25zdCBCSVQxNiA9IDMyNzY4XG5leHBvcnQgY29uc3QgQklUMTcgPSA2NTUzNlxuZXhwb3J0IGNvbnN0IEJJVDE4ID0gMSA8PCAxN1xuZXhwb3J0IGNvbnN0IEJJVDE5ID0gMSA8PCAxOFxuZXhwb3J0IGNvbnN0IEJJVDIwID0gMSA8PCAxOVxuZXhwb3J0IGNvbnN0IEJJVDIxID0gMSA8PCAyMFxuZXhwb3J0IGNvbnN0IEJJVDIyID0gMSA8PCAyMVxuZXhwb3J0IGNvbnN0IEJJVDIzID0gMSA8PCAyMlxuZXhwb3J0IGNvbnN0IEJJVDI0ID0gMSA8PCAyM1xuZXhwb3J0IGNvbnN0IEJJVDI1ID0gMSA8PCAyNFxuZXhwb3J0IGNvbnN0IEJJVDI2ID0gMSA8PCAyNVxuZXhwb3J0IGNvbnN0IEJJVDI3ID0gMSA8PCAyNlxuZXhwb3J0IGNvbnN0IEJJVDI4ID0gMSA8PCAyN1xuZXhwb3J0IGNvbnN0IEJJVDI5ID0gMSA8PCAyOFxuZXhwb3J0IGNvbnN0IEJJVDMwID0gMSA8PCAyOVxuZXhwb3J0IGNvbnN0IEJJVDMxID0gMSA8PCAzMFxuZXhwb3J0IGNvbnN0IEJJVDMyID0gMSA8PCAzMVxuXG4vKipcbiAqIEZpcnN0IG4gYml0cyBhY3RpdmF0ZWQuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMwID0gMFxuZXhwb3J0IGNvbnN0IEJJVFMxID0gMVxuZXhwb3J0IGNvbnN0IEJJVFMyID0gM1xuZXhwb3J0IGNvbnN0IEJJVFMzID0gN1xuZXhwb3J0IGNvbnN0IEJJVFM0ID0gMTVcbmV4cG9ydCBjb25zdCBCSVRTNSA9IDMxXG5leHBvcnQgY29uc3QgQklUUzYgPSA2M1xuZXhwb3J0IGNvbnN0IEJJVFM3ID0gMTI3XG5leHBvcnQgY29uc3QgQklUUzggPSAyNTVcbmV4cG9ydCBjb25zdCBCSVRTOSA9IDUxMVxuZXhwb3J0IGNvbnN0IEJJVFMxMCA9IDEwMjNcbmV4cG9ydCBjb25zdCBCSVRTMTEgPSAyMDQ3XG5leHBvcnQgY29uc3QgQklUUzEyID0gNDA5NVxuZXhwb3J0IGNvbnN0IEJJVFMxMyA9IDgxOTFcbmV4cG9ydCBjb25zdCBCSVRTMTQgPSAxNjM4M1xuZXhwb3J0IGNvbnN0IEJJVFMxNSA9IDMyNzY3XG5leHBvcnQgY29uc3QgQklUUzE2ID0gNjU1MzVcbmV4cG9ydCBjb25zdCBCSVRTMTcgPSBCSVQxOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTggPSBCSVQxOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMTkgPSBCSVQyMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjAgPSBCSVQyMSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjEgPSBCSVQyMiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjIgPSBCSVQyMyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjMgPSBCSVQyNCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjQgPSBCSVQyNSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjUgPSBCSVQyNiAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjYgPSBCSVQyNyAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjcgPSBCSVQyOCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjggPSBCSVQyOSAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMjkgPSBCSVQzMCAtIDFcbmV4cG9ydCBjb25zdCBCSVRTMzAgPSBCSVQzMSAtIDFcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMSA9IDB4N0ZGRkZGRkZcbi8qKlxuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IEJJVFMzMiA9IDB4RkZGRkZGRkZcbiIsICIvKipcbiAqIFV0aWxpdHkgaGVscGVycyBmb3Igd29ya2luZyB3aXRoIG51bWJlcnMuXG4gKlxuICogQG1vZHVsZSBudW1iZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcblxuZXhwb3J0IGNvbnN0IE1BWF9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuZXhwb3J0IGNvbnN0IE1JTl9TQUZFX0lOVEVHRVIgPSBOdW1iZXIuTUlOX1NBRkVfSU5URUdFUlxuXG5leHBvcnQgY29uc3QgTE9XRVNUX0lOVDMyID0gMSA8PCAzMVxuZXhwb3J0IGNvbnN0IEhJR0hFU1RfSU5UMzIgPSBiaW5hcnkuQklUUzMxXG5leHBvcnQgY29uc3QgSElHSEVTVF9VSU5UMzIgPSBiaW5hcnkuQklUUzMyXG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgaXNJbnRlZ2VyID0gTnVtYmVyLmlzSW50ZWdlciB8fCAobnVtID0+IHR5cGVvZiBudW0gPT09ICdudW1iZXInICYmIGlzRmluaXRlKG51bSkgJiYgbWF0aC5mbG9vcihudW0pID09PSBudW0pXG5leHBvcnQgY29uc3QgaXNOYU4gPSBOdW1iZXIuaXNOYU5cbmV4cG9ydCBjb25zdCBwYXJzZUludCA9IE51bWJlci5wYXJzZUludFxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgXCIxXCIgYml0cyBpbiBhbiB1bnNpZ25lZCAzMmJpdCBudW1iZXIuXG4gKlxuICogU3VwZXIgZnVuIGJpdGNvdW50IGFsZ29yaXRobSBieSBCcmlhbiBLZXJuaWdoYW4uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG5cbiAqL1xuZXhwb3J0IGNvbnN0IGNvdW50Qml0cyA9IG4gPT4ge1xuICBuICY9IGJpbmFyeS5CSVRTMzJcbiAgbGV0IGNvdW50ID0gMFxuICB3aGlsZSAobikge1xuICAgIG4gJj0gKG4gLSAxKVxuICAgIGNvdW50KytcbiAgfVxuICByZXR1cm4gY291bnRcbn1cbiIsICJpbXBvcnQgKiBhcyBhcnJheSBmcm9tICcuL2FycmF5LmpzJ1xuXG4vKipcbiAqIFV0aWxpdHkgbW9kdWxlIHRvIHdvcmsgd2l0aCBzdHJpbmdzLlxuICpcbiAqIEBtb2R1bGUgc3RyaW5nXG4gKi9cblxuZXhwb3J0IGNvbnN0IGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGVcbmV4cG9ydCBjb25zdCBmcm9tQ29kZVBvaW50ID0gU3RyaW5nLmZyb21Db2RlUG9pbnRcblxuLyoqXG4gKiBUaGUgbGFyZ2VzdCB1dGYxNiBjaGFyYWN0ZXIuXG4gKiBDb3JyZXNwb25kcyB0byBVaW50OEFycmF5KFsyNTUsIDI1NV0pIG9yIGNoYXJjb2Rlb2YoMngyXjgpXG4gKi9cbmV4cG9ydCBjb25zdCBNQVhfVVRGMTZfQ0hBUkFDVEVSID0gZnJvbUNoYXJDb2RlKDY1NTM1KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvTG93ZXJDYXNlID0gcyA9PiBzLnRvTG93ZXJDYXNlKClcblxuY29uc3QgdHJpbUxlZnRSZWdleCA9IC9eXFxzKi9nXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHRyaW1MZWZ0ID0gcyA9PiBzLnJlcGxhY2UodHJpbUxlZnRSZWdleCwgJycpXG5cbmNvbnN0IGZyb21DYW1lbENhc2VSZWdleCA9IC8oW0EtWl0pL2dcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHBhcmFtIHtzdHJpbmd9IHNlcGFyYXRvclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgZnJvbUNhbWVsQ2FzZSA9IChzLCBzZXBhcmF0b3IpID0+IHRyaW1MZWZ0KHMucmVwbGFjZShmcm9tQ2FtZWxDYXNlUmVnZXgsIG1hdGNoID0+IGAke3NlcGFyYXRvcn0ke3RvTG93ZXJDYXNlKG1hdGNoKX1gKSlcblxuLyoqXG4gKiBDb21wdXRlIHRoZSB1dGY4Qnl0ZUxlbmd0aFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgdXRmOEJ5dGVMZW5ndGggPSBzdHIgPT4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOFBvbHlmaWxsID0gc3RyID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW4pXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBidWZbaV0gPSAvKiogQHR5cGUge251bWJlcn0gKi8gKGVuY29kZWRTdHJpbmcuY29kZVBvaW50QXQoaSkpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IHV0ZjhUZXh0RW5jb2RlciA9IC8qKiBAdHlwZSB7VGV4dEVuY29kZXJ9ICovICh0eXBlb2YgVGV4dEVuY29kZXIgIT09ICd1bmRlZmluZWQnID8gbmV3IFRleHRFbmNvZGVyKCkgOiBudWxsKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBfZW5jb2RlVXRmOE5hdGl2ZSA9IHN0ciA9PiB1dGY4VGV4dEVuY29kZXIuZW5jb2RlKHN0cilcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVV0ZjggPSB1dGY4VGV4dEVuY29kZXIgPyBfZW5jb2RlVXRmOE5hdGl2ZSA6IF9lbmNvZGVVdGY4UG9seWZpbGxcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhQb2x5ZmlsbCA9IGJ1ZiA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSBidWYubGVuZ3RoXG4gIGxldCBlbmNvZGVkU3RyaW5nID0gJydcbiAgbGV0IGJ1ZlBvcyA9IDBcbiAgd2hpbGUgKHJlbWFpbmluZ0xlbiA+IDApIHtcbiAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMFxuICAgIGNvbnN0IGJ5dGVzID0gYnVmLnN1YmFycmF5KGJ1ZlBvcywgYnVmUG9zICsgbmV4dExlbilcbiAgICBidWZQb3MgKz0gbmV4dExlblxuICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgZW5jb2RlZFN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludC5hcHBseShudWxsLCAvKiogQHR5cGUge2FueX0gKi8gKGJ5dGVzKSlcbiAgICByZW1haW5pbmdMZW4gLT0gbmV4dExlblxuICB9XG4gIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxufVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGxldCB1dGY4VGV4dERlY29kZXIgPSB0eXBlb2YgVGV4dERlY29kZXIgPT09ICd1bmRlZmluZWQnID8gbnVsbCA6IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnLCB7IGZhdGFsOiB0cnVlLCBpZ25vcmVCT006IHRydWUgfSlcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodXRmOFRleHREZWNvZGVyICYmIHV0ZjhUZXh0RGVjb2Rlci5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoKSkubGVuZ3RoID09PSAxKSB7XG4gIC8vIFNhZmFyaSBkb2Vzbid0IGhhbmRsZSBCT00gY29ycmVjdGx5LlxuICAvLyBUaGlzIGZpeGVzIGEgYnVnIGluIFNhZmFyaSAxMy4wLjUgd2hlcmUgaXQgcHJvZHVjZXMgYSBCT00gdGhlIGZpcnN0IHRpbWUgaXQgaXMgY2FsbGVkLlxuICAvLyB1dGY4VGV4dERlY29kZXIuZGVjb2RlKG5ldyBVaW50OEFycmF5KCkpLmxlbmd0aCA9PT0gMSBvbiB0aGUgZmlyc3QgY2FsbCBhbmRcbiAgLy8gdXRmOFRleHREZWNvZGVyLmRlY29kZShuZXcgVWludDhBcnJheSgpKS5sZW5ndGggPT09IDEgb24gdGhlIHNlY29uZCBjYWxsXG4gIC8vIEFub3RoZXIgaXNzdWUgaXMgdGhhdCBmcm9tIHRoZW4gb24gbm8gQk9NIGNoYXJzIGFyZSByZWNvZ25pemVkIGFueW1vcmVcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdXRmOFRleHREZWNvZGVyID0gbnVsbFxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgX2RlY29kZVV0ZjhOYXRpdmUgPSBidWYgPT4gLyoqIEB0eXBlIHtUZXh0RGVjb2Rlcn0gKi8gKHV0ZjhUZXh0RGVjb2RlcikuZGVjb2RlKGJ1ZilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVV0ZjggPSB1dGY4VGV4dERlY29kZXIgPyBfZGVjb2RlVXRmOE5hdGl2ZSA6IF9kZWNvZGVVdGY4UG9seWZpbGxcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyIFRoZSBpbml0aWFsIHN0cmluZ1xuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFN0YXJ0aW5nIHBvc2l0aW9uXG4gKiBAcGFyYW0ge251bWJlcn0gcmVtb3ZlIE51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJlbW92ZVxuICogQHBhcmFtIHtzdHJpbmd9IGluc2VydCBOZXcgY29udGVudCB0byBpbnNlcnRcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGljZSA9IChzdHIsIGluZGV4LCByZW1vdmUsIGluc2VydCA9ICcnKSA9PiBzdHIuc2xpY2UoMCwgaW5kZXgpICsgaW5zZXJ0ICsgc3RyLnNsaWNlKGluZGV4ICsgcmVtb3ZlKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBuXG4gKi9cbmV4cG9ydCBjb25zdCByZXBlYXQgPSAoc291cmNlLCBuKSA9PiBhcnJheS51bmZvbGQobiwgKCkgPT4gc291cmNlKS5qb2luKCcnKVxuIiwgIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBlbmNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZW5jb2RpbmddIHdpdGggW2xpYjAvZGVjb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZW5jb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIGJpbmFyeSBmcm9tICcuL2JpbmFyeS5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5cbi8qKlxuICogQSBCaW5hcnlFbmNvZGVyIGhhbmRsZXMgdGhlIGVuY29kaW5nIHRvIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBFbmNvZGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIHRoaXMuY3BvcyA9IDBcbiAgICB0aGlzLmNidWYgPSBuZXcgVWludDhBcnJheSgxMDApXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAqL1xuICAgIHRoaXMuYnVmcyA9IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEByZXR1cm4ge0VuY29kZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbmNvZGVyID0gKCkgPT4gbmV3IEVuY29kZXIoKVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oRW5jb2Rlcik6dm9pZH0gZlxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlID0gKGYpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IGNyZWF0ZUVuY29kZXIoKVxuICBmKGVuY29kZXIpXG4gIHJldHVybiB0b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBUaGUgY3VycmVudCBsZW5ndGggb2YgdGhlIGVuY29kZWQgZGF0YS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgbGVuZ3RoID0gZW5jb2RlciA9PiB7XG4gIGxldCBsZW4gPSBlbmNvZGVyLmNwb3NcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoOyBpKyspIHtcbiAgICBsZW4gKz0gZW5jb2Rlci5idWZzW2ldLmxlbmd0aFxuICB9XG4gIHJldHVybiBsZW5cbn1cblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGVuY29kZXIgaXMgZW1wdHkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNDb250ZW50ID0gZW5jb2RlciA9PiBlbmNvZGVyLmNwb3MgPiAwIHx8IGVuY29kZXIuYnVmcy5sZW5ndGggPiAwXG5cbi8qKlxuICogVHJhbnNmb3JtIHRvIFVpbnQ4QXJyYXkuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9IFRoZSBjcmVhdGVkIEFycmF5QnVmZmVyLlxuICovXG5leHBvcnQgY29uc3QgdG9VaW50OEFycmF5ID0gZW5jb2RlciA9PiB7XG4gIGNvbnN0IHVpbnQ4YXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKGVuY29kZXIpKVxuICBsZXQgY3VyUG9zID0gMFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZXIuYnVmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBlbmNvZGVyLmJ1ZnNbaV1cbiAgICB1aW50OGFyci5zZXQoZCwgY3VyUG9zKVxuICAgIGN1clBvcyArPSBkLmxlbmd0aFxuICB9XG4gIHVpbnQ4YXJyLnNldChuZXcgVWludDhBcnJheShlbmNvZGVyLmNidWYuYnVmZmVyLCAwLCBlbmNvZGVyLmNwb3MpLCBjdXJQb3MpXG4gIHJldHVybiB1aW50OGFyclxufVxuXG4vKipcbiAqIFZlcmlmeSB0aGF0IGl0IGlzIHBvc3NpYmxlIHRvIHdyaXRlIGBsZW5gIGJ5dGVzIHd0aWhvdXQgY2hlY2tpbmcuIElmXG4gKiBuZWNlc3NhcnksIGEgbmV3IEJ1ZmZlciB3aXRoIHRoZSByZXF1aXJlZCBsZW5ndGggaXMgYXR0YWNoZWQuXG4gKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gKi9cbmV4cG9ydCBjb25zdCB2ZXJpZnlMZW4gPSAoZW5jb2RlciwgbGVuKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgaWYgKGJ1ZmZlckxlbiAtIGVuY29kZXIuY3BvcyA8IGxlbikge1xuICAgIGVuY29kZXIuYnVmcy5wdXNoKG5ldyBVaW50OEFycmF5KGVuY29kZXIuY2J1Zi5idWZmZXIsIDAsIGVuY29kZXIuY3BvcykpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkobWF0aC5tYXgoYnVmZmVyTGVuLCBsZW4pICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSB0byB0aGUgZW5jb2Rlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgYnl0ZSB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZSA9IChlbmNvZGVyLCBudW0pID0+IHtcbiAgY29uc3QgYnVmZmVyTGVuID0gZW5jb2Rlci5jYnVmLmxlbmd0aFxuICBpZiAoZW5jb2Rlci5jcG9zID09PSBidWZmZXJMZW4pIHtcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpXG4gICAgZW5jb2Rlci5jYnVmID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyTGVuICogMilcbiAgICBlbmNvZGVyLmNwb3MgPSAwXG4gIH1cbiAgZW5jb2Rlci5jYnVmW2VuY29kZXIuY3BvcysrXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGF0IGEgc3BlY2lmaWMgcG9zaXRpb24uXG4gKiBQb3NpdGlvbiBtdXN0IGFscmVhZHkgYmUgd3JpdHRlbiAoaS5lLiBlbmNvZGVyLmxlbmd0aCA+IHBvcylcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IHBvcyBQb3NpdGlvbiB0byB3aGljaCB0byB3cml0ZSBkYXRhXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHNldCA9IChlbmNvZGVyLCBwb3MsIG51bSkgPT4ge1xuICBsZXQgYnVmZmVyID0gbnVsbFxuICAvLyBpdGVyYXRlIGFsbCBidWZmZXJzIGFuZCBhZGp1c3QgcG9zaXRpb25cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbmNvZGVyLmJ1ZnMubGVuZ3RoICYmIGJ1ZmZlciA9PT0gbnVsbDsgaSsrKSB7XG4gICAgY29uc3QgYiA9IGVuY29kZXIuYnVmc1tpXVxuICAgIGlmIChwb3MgPCBiLmxlbmd0aCkge1xuICAgICAgYnVmZmVyID0gYiAvLyBmb3VuZCBidWZmZXJcbiAgICB9IGVsc2Uge1xuICAgICAgcG9zIC09IGIubGVuZ3RoXG4gICAgfVxuICB9XG4gIGlmIChidWZmZXIgPT09IG51bGwpIHtcbiAgICAvLyB1c2UgY3VycmVudCBidWZmZXJcbiAgICBidWZmZXIgPSBlbmNvZGVyLmNidWZcbiAgfVxuICBidWZmZXJbcG9zXSA9IG51bVxufVxuXG4vKipcbiAqIFdyaXRlIG9uZSBieXRlIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVVpbnQ4ID0gd3JpdGVcblxuLyoqXG4gKiBXcml0ZSBvbmUgYnl0ZSBhcyBhbiB1bnNpZ25lZCBJbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50OCA9IHNldFxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVaW50MTYgPSAoZW5jb2RlciwgbnVtKSA9PiB7XG4gIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgd3JpdGUoZW5jb2RlciwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MTYgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgc2V0KGVuY29kZXIsIHBvcywgbnVtICYgYmluYXJ5LkJJVFM4KVxuICBzZXQoZW5jb2RlciwgcG9zICsgMSwgKG51bSA+Pj4gOCkgJiBiaW5hcnkuQklUUzgpXG59XG5cbi8qKlxuICogV3JpdGUgdHdvIGJ5dGVzIGFzIGFuIHVuc2lnbmVkIGludGVnZXJcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgIHdyaXRlKGVuY29kZXIsIG51bSAmIGJpbmFyeS5CSVRTOClcbiAgICBudW0gPj4+PSA4XG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSB0d28gYnl0ZXMgYXMgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWcgZW5kaWFuIG9yZGVyLlxuICogKG1vc3Qgc2lnbmlmaWNhbnQgYnl0ZSBmaXJzdClcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDMyQmlnRW5kaWFuID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBmb3IgKGxldCBpID0gMzsgaSA+PSAwOyBpLS0pIHtcbiAgICB3cml0ZShlbmNvZGVyLCAobnVtID4+PiAoOCAqIGkpKSAmIGJpbmFyeS5CSVRTOClcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIHR3byBieXRlcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24uXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBwb3MgVGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBkYXRhIHdpbGwgYmUgd3JpdHRlbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gVGhlIG51bWJlciB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBzZXRVaW50MzIgPSAoZW5jb2RlciwgcG9zLCBudW0pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICBzZXQoZW5jb2RlciwgcG9zICsgaSwgbnVtICYgYmluYXJ5LkJJVFM4KVxuICAgIG51bSA+Pj49IDhcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHVuc2lnbmVkIGludGVnZXIuIE1heCBlbmNvZGFibGUgaW50ZWdlciBpcyAyXjUzLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIFRoZSBudW1iZXIgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVWYXJVaW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICB3aGlsZSAobnVtID4gYmluYXJ5LkJJVFM3KSB7XG4gICAgd3JpdGUoZW5jb2RlciwgYmluYXJ5LkJJVDggfCAoYmluYXJ5LkJJVFM3ICYgbnVtKSlcbiAgICBudW0gPSBtYXRoLmZsb29yKG51bSAvIDEyOCkgLy8gc2hpZnQgPj4+IDdcbiAgfVxuICB3cml0ZShlbmNvZGVyLCBiaW5hcnkuQklUUzcgJiBudW0pXG59XG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlci5cbiAqXG4gKiBXZSB1c2UgdGhlIDd0aCBiaXQgaW5zdGVhZCBmb3Igc2lnbmFsaW5nIHRoYXQgdGhpcyBpcyBhIG5lZ2F0aXZlIG51bWJlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBUaGUgbnVtYmVyIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFySW50ID0gKGVuY29kZXIsIG51bSkgPT4ge1xuICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyhudW0pXG4gIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgbnVtID0gLW51bVxuICB9XG4gIC8vICAgICAgICAgICAgIHwtIHdoZXRoZXIgdG8gY29udGludWUgcmVhZGluZyAgICAgICAgIHwtIHdoZXRoZXIgaXMgbmVnYXRpdmUgICAgIHwtIG51bWJlclxuICB3cml0ZShlbmNvZGVyLCAobnVtID4gYmluYXJ5LkJJVFM2ID8gYmluYXJ5LkJJVDggOiAwKSB8IChpc05lZ2F0aXZlID8gYmluYXJ5LkJJVDcgOiAwKSB8IChiaW5hcnkuQklUUzYgJiBudW0pKVxuICBudW0gPSBtYXRoLmZsb29yKG51bSAvIDY0KSAvLyBzaGlmdCA+Pj4gNlxuICAvLyBXZSBkb24ndCBuZWVkIHRvIGNvbnNpZGVyIHRoZSBjYXNlIG9mIG51bSA9PT0gMCBzbyB3ZSBjYW4gdXNlIGEgZGlmZmVyZW50XG4gIC8vIHBhdHRlcm4gaGVyZSB0aGFuIGFib3ZlLlxuICB3aGlsZSAobnVtID4gMCkge1xuICAgIHdyaXRlKGVuY29kZXIsIChudW0gPiBiaW5hcnkuQklUUzcgPyBiaW5hcnkuQklUOCA6IDApIHwgKGJpbmFyeS5CSVRTNyAmIG51bSkpXG4gICAgbnVtID0gbWF0aC5mbG9vcihudW0gLyAxMjgpIC8vIHNoaWZ0ID4+PiA3XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNhY2hlIHRvIHN0b3JlIHN0cmluZ3MgdGVtcG9yYXJpbHlcbiAqL1xuY29uc3QgX3N0ckJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDMwMDAwKVxuY29uc3QgX21heFN0ckJTaXplID0gX3N0ckJ1ZmZlci5sZW5ndGggLyAzXG5cbi8qKlxuICogV3JpdGUgYSB2YXJpYWJsZSBsZW5ndGggc3RyaW5nLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3QgX3dyaXRlVmFyU3RyaW5nTmF0aXZlID0gKGVuY29kZXIsIHN0cikgPT4ge1xuICBpZiAoc3RyLmxlbmd0aCA8IF9tYXhTdHJCU2l6ZSkge1xuICAgIC8vIFdlIGNhbiBlbmNvZGUgdGhlIHN0cmluZyBpbnRvIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGNvbnN0IHdyaXR0ZW4gPSBzdHJpbmcudXRmOFRleHRFbmNvZGVyLmVuY29kZUludG8oc3RyLCBfc3RyQnVmZmVyKS53cml0dGVuIHx8IDBcbiAgICB3cml0ZVZhclVpbnQoZW5jb2Rlciwgd3JpdHRlbilcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdyaXR0ZW47IGkrKykge1xuICAgICAgd3JpdGUoZW5jb2RlciwgX3N0ckJ1ZmZlcltpXSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHN0cmluZy5lbmNvZGVVdGY4KHN0cikpXG4gIH1cbn1cblxuLyoqXG4gKiBXcml0ZSBhIHZhcmlhYmxlIGxlbmd0aCBzdHJpbmcuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIHN0cmluZyB0aGF0IGlzIHRvIGJlIGVuY29kZWQuXG4gKi9cbmV4cG9ydCBjb25zdCBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbCA9IChlbmNvZGVyLCBzdHIpID0+IHtcbiAgY29uc3QgZW5jb2RlZFN0cmluZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKVxuICBjb25zdCBsZW4gPSBlbmNvZGVkU3RyaW5nLmxlbmd0aFxuICB3cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgd3JpdGUoZW5jb2RlciwgLyoqIEB0eXBlIHtudW1iZXJ9ICovIChlbmNvZGVkU3RyaW5nLmNvZGVQb2ludEF0KGkpKSlcbiAgfVxufVxuXG4vKipcbiAqIFdyaXRlIGEgdmFyaWFibGUgbGVuZ3RoIHN0cmluZy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgc3RyaW5nIHRoYXQgaXMgdG8gYmUgZW5jb2RlZC5cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB3cml0ZVZhclN0cmluZyA9IChzdHJpbmcudXRmOFRleHRFbmNvZGVyICYmIC8qKiBAdHlwZSB7YW55fSAqLyAoc3RyaW5nLnV0ZjhUZXh0RW5jb2RlcikuZW5jb2RlSW50bykgPyBfd3JpdGVWYXJTdHJpbmdOYXRpdmUgOiBfd3JpdGVWYXJTdHJpbmdQb2x5ZmlsbFxuXG4vKipcbiAqIFdyaXRlIGEgc3RyaW5nIHRlcm1pbmF0ZWQgYnkgYSBzcGVjaWFsIGJ5dGUgc2VxdWVuY2UuIFRoaXMgaXMgbm90IHZlcnkgcGVyZm9ybWFudCBhbmQgaXNcbiAqIGdlbmVyYWxseSBkaXNjb3VyYWdlZC4gSG93ZXZlciwgdGhlIHJlc3VsdGluZyBieXRlIGFycmF5cyBhcmUgbGV4aW9ncmFwaGljYWxseSBvcmRlcmVkIHdoaWNoXG4gKiBtYWtlcyB0aGlzIGEgbmljZSBmZWF0dXJlIGZvciBkYXRhYmFzZXMuXG4gKlxuICogVGhlIHN0cmluZyB3aWxsIGJlIGVuY29kZWQgdXNpbmcgdXRmOCBhbmQgdGhlbiB0ZXJtaW5hdGVkIGFuZCBlc2NhcGVkIHVzaW5nIHdyaXRlVGVybWluYXRpbmdVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUZXJtaW5hdGVkU3RyaW5nID0gKGVuY29kZXIsIHN0cikgPT5cbiAgd3JpdGVUZXJtaW5hdGVkVWludDhBcnJheShlbmNvZGVyLCBzdHJpbmcuZW5jb2RlVXRmOChzdHIpKVxuXG4vKipcbiAqIFdyaXRlIGEgdGVybWluYXRpbmcgVWludDhBcnJheS4gTm90ZSB0aGF0IHRoaXMgaXMgbm90IHBlcmZvcm1hbnQgYW5kIGlzIGdlbmVyYWxseVxuICogZGlzY291cmFnZWQuIFRoZXJlIGFyZSBmZXcgc2l0dWF0aW9ucyB3aGVuIHRoaXMgaXMgbmVlZGVkLlxuICpcbiAqIFdlIHVzZSAweDAgYXMgYSB0ZXJtaW5hdGluZyBjaGFyYWN0ZXIuIDB4MSBzZXJ2ZXMgYXMgYW4gZXNjYXBlIGNoYXJhY3RlciBmb3IgMHgwIGFuZCAweDEuXG4gKlxuICogRXhhbXBsZTogWzAsMSwyXSBpcyBlbmNvZGVkIHRvIFsxLDAsMSwxLDIsMF0uIDB4MCwgYW5kIDB4MSBuZWVkZWQgdG8gYmUgZXNjYXBlZCB1c2luZyAweDEuIFRoZW5cbiAqIHRoZSByZXN1bHQgaXMgdGVybWluYXRlZCB1c2luZyB0aGUgMHgwIGNoYXJhY3Rlci5cbiAqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBob3cgbWFueSBzeXN0ZW1zIGltcGxlbWVudCBudWxsIHRlcm1pbmF0ZWQgc3RyaW5ncy4gSG93ZXZlciwgd2UgdXNlIGFuIGVzY2FwZVxuICogY2hhcmFjdGVyIDB4MSB0byBhdm9pZCBpc3N1ZXMgYW5kIHBvdGVuaWFsIGF0dGFja3Mgb24gb3VyIGRhdGFiYXNlIChpZiB0aGlzIGlzIHVzZWQgYXMgYSBrZXlcbiAqIGVuY29kZXIgZm9yIE5vU3FsIGRhdGFiYXNlcykuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmIFRoZSBzdHJpbmcgdGhhdCBpcyB0byBiZSBlbmNvZGVkLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVUZXJtaW5hdGVkVWludDhBcnJheSA9IChlbmNvZGVyLCBidWYpID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBiID0gYnVmW2ldXG4gICAgaWYgKGIgPT09IDAgfHwgYiA9PT0gMSkge1xuICAgICAgd3JpdGUoZW5jb2RlciwgMSlcbiAgICB9XG4gICAgd3JpdGUoZW5jb2RlciwgYnVmW2ldKVxuICB9XG4gIHdyaXRlKGVuY29kZXIsIDApXG59XG5cbi8qKlxuICogV3JpdGUgdGhlIGNvbnRlbnQgb2YgYW5vdGhlciBFbmNvZGVyLlxuICpcbiAqIEBUT0RPOiBjYW4gYmUgaW1wcm92ZWQhXG4gKiAgICAgICAgLSBOb3RlOiBTaG91bGQgY29uc2lkZXIgdGhhdCB3aGVuIGFwcGVuZGluZyBhIGxvdCBvZiBzbWFsbCBFbmNvZGVycywgd2Ugc2hvdWxkIHJhdGhlciBjbG9uZSB0aGFuIHJlZmVyZW5jaW5nIHRoZSBvbGQgc3RydWN0dXJlLlxuICogICAgICAgICAgICAgICAgRW5jb2RlcnMgc3RhcnQgd2l0aCBhIHJhdGhlciBiaWcgaW5pdGlhbCBidWZmZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgVGhlIGVuVWludDhBcnJcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gYXBwZW5kIFRoZSBCaW5hcnlFbmNvZGVyIHRvIGJlIHdyaXR0ZW4uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUJpbmFyeUVuY29kZXIgPSAoZW5jb2RlciwgYXBwZW5kKSA9PiB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdG9VaW50OEFycmF5KGFwcGVuZCkpXG5cbi8qKlxuICogQXBwZW5kIGZpeGVkLWxlbmd0aCBVaW50OEFycmF5IHRvIHRoZSBlbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIGNvbnN0IGJ1ZmZlckxlbiA9IGVuY29kZXIuY2J1Zi5sZW5ndGhcbiAgY29uc3QgY3BvcyA9IGVuY29kZXIuY3Bvc1xuICBjb25zdCBsZWZ0Q29weUxlbiA9IG1hdGgubWluKGJ1ZmZlckxlbiAtIGNwb3MsIHVpbnQ4QXJyYXkubGVuZ3RoKVxuICBjb25zdCByaWdodENvcHlMZW4gPSB1aW50OEFycmF5Lmxlbmd0aCAtIGxlZnRDb3B5TGVuXG4gIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheSgwLCBsZWZ0Q29weUxlbiksIGNwb3MpXG4gIGVuY29kZXIuY3BvcyArPSBsZWZ0Q29weUxlblxuICBpZiAocmlnaHRDb3B5TGVuID4gMCkge1xuICAgIC8vIFN0aWxsIHNvbWV0aGluZyB0byB3cml0ZSwgd3JpdGUgcmlnaHQgaGFsZi4uXG4gICAgLy8gQXBwZW5kIG5ldyBidWZmZXJcbiAgICBlbmNvZGVyLmJ1ZnMucHVzaChlbmNvZGVyLmNidWYpXG4gICAgLy8gbXVzdCBoYXZlIGF0IGxlYXN0IHNpemUgb2YgcmVtYWluaW5nIGJ1ZmZlclxuICAgIGVuY29kZXIuY2J1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGgubWF4KGJ1ZmZlckxlbiAqIDIsIHJpZ2h0Q29weUxlbikpXG4gICAgLy8gY29weSBhcnJheVxuICAgIGVuY29kZXIuY2J1Zi5zZXQodWludDhBcnJheS5zdWJhcnJheShsZWZ0Q29weUxlbikpXG4gICAgZW5jb2Rlci5jcG9zID0gcmlnaHRDb3B5TGVuXG4gIH1cbn1cblxuLyoqXG4gKiBBcHBlbmQgYW4gVWludDhBcnJheSB0byBFbmNvZGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlVmFyVWludDhBcnJheSA9IChlbmNvZGVyLCB1aW50OEFycmF5KSA9PiB7XG4gIHdyaXRlVmFyVWludChlbmNvZGVyLCB1aW50OEFycmF5LmJ5dGVMZW5ndGgpXG4gIHdyaXRlVWludDhBcnJheShlbmNvZGVyLCB1aW50OEFycmF5KVxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBEYXRhVmlldyBvZiB0aGUgbmV4dCBgbGVuYCBieXRlcy4gVXNlIGl0IHRvIHdyaXRlIGRhdGEgYWZ0ZXJcbiAqIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbiAqXG4gKiBgYGBqc1xuICogLy8gd3JpdGUgZmxvYXQzMiB1c2luZyBEYXRhVmlld1xuICogY29uc3QgZHYgPSB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LnNldEZsb2F0MzIoMCwgMS4xKVxuICogLy8gcmVhZCBmbG9hdDMyIHVzaW5nIERhdGFWaWV3XG4gKiBjb25zdCBkdiA9IHJlYWRGcm9tRGF0YVZpZXcoZW5jb2RlciwgNClcbiAqIGR2LmdldEZsb2F0MzIoMCkgLy8gPT4gMS4xMDAwMDAwMjM4NDE4NTggKGxlYXZpbmcgaXQgdG8gdGhlIHJlYWRlciB0byBmaW5kIG91dCB3aHkgdGhpcyBpcyB0aGUgY29ycmVjdCByZXN1bHQpXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEByZXR1cm4ge0RhdGFWaWV3fVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVPbkRhdGFWaWV3ID0gKGVuY29kZXIsIGxlbikgPT4ge1xuICB2ZXJpZnlMZW4oZW5jb2RlciwgbGVuKVxuICBjb25zdCBkdmlldyA9IG5ldyBEYXRhVmlldyhlbmNvZGVyLmNidWYuYnVmZmVyLCBlbmNvZGVyLmNwb3MsIGxlbilcbiAgZW5jb2Rlci5jcG9zICs9IGxlblxuICByZXR1cm4gZHZpZXdcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlRmxvYXQzMiA9IChlbmNvZGVyLCBudW0pID0+IHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA0KS5zZXRGbG9hdDMyKDAsIG51bSwgZmFsc2UpXG5cbi8qKlxuICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZUZsb2F0NjQgPSAoZW5jb2RlciwgbnVtKSA9PiB3cml0ZU9uRGF0YVZpZXcoZW5jb2RlciwgOCkuc2V0RmxvYXQ2NCgwLCBudW0sIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaWdJbnQ2NCA9IChlbmNvZGVyLCBudW0pID0+IC8qKiBAdHlwZSB7YW55fSAqLyAod3JpdGVPbkRhdGFWaWV3KGVuY29kZXIsIDgpKS5zZXRCaWdJbnQ2NCgwLCBudW0sIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtiaWdpbnR9IG51bVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVCaWdVaW50NjQgPSAoZW5jb2RlciwgbnVtKSA9PiAvKiogQHR5cGUge2FueX0gKi8gKHdyaXRlT25EYXRhVmlldyhlbmNvZGVyLCA4KSkuc2V0QmlnVWludDY0KDAsIG51bSwgZmFsc2UpXG5cbmNvbnN0IGZsb2F0VGVzdEJlZCA9IG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoNCkpXG4vKipcbiAqIENoZWNrIGlmIGEgbnVtYmVyIGNhbiBiZSBlbmNvZGVkIGFzIGEgMzIgYml0IGZsb2F0LlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW1cbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGlzRmxvYXQzMiA9IG51bSA9PiB7XG4gIGZsb2F0VGVzdEJlZC5zZXRGbG9hdDMyKDAsIG51bSlcbiAgcmV0dXJuIGZsb2F0VGVzdEJlZC5nZXRGbG9hdDMyKDApID09PSBudW1cbn1cblxuLyoqXG4gKiBFbmNvZGUgZGF0YSB3aXRoIGVmZmljaWVudCBiaW5hcnkgZm9ybWF0LlxuICpcbiAqIERpZmZlcmVuY2VzIHRvIEpTT046XG4gKiBcdTIwMjIgVHJhbnNmb3JtcyBkYXRhIHRvIGEgYmluYXJ5IGZvcm1hdCAobm90IHRvIGEgc3RyaW5nKVxuICogXHUyMDIyIEVuY29kZXMgdW5kZWZpbmVkLCBOYU4sIGFuZCBBcnJheUJ1ZmZlciAodGhlc2UgY2FuJ3QgYmUgcmVwcmVzZW50ZWQgaW4gSlNPTilcbiAqIFx1MjAyMiBOdW1iZXJzIGFyZSBlZmZpY2llbnRseSBlbmNvZGVkIGVpdGhlciBhcyBhIHZhcmlhYmxlIGxlbmd0aCBpbnRlZ2VyLCBhcyBhXG4gKiAgIDMyIGJpdCBmbG9hdCwgYXMgYSA2NCBiaXQgZmxvYXQsIG9yIGFzIGEgNjQgYml0IGJpZ2ludC5cbiAqXG4gKiBFbmNvZGluZyB0YWJsZTpcbiAqXG4gKiB8IERhdGEgVHlwZSAgICAgICAgICAgfCBQcmVmaXggICB8IEVuY29kaW5nIE1ldGhvZCAgICB8IENvbW1lbnQgfFxuICogfCAtLS0tLS0tLS0tLS0tLS0tLS0tIHwgLS0tLS0tLS0gfCAtLS0tLS0tLS0tLS0tLS0tLS0gfCAtLS0tLS0tIHxcbiAqIHwgdW5kZWZpbmVkICAgICAgICAgICB8IDEyNyAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgRnVuY3Rpb25zLCBzeW1ib2wsIGFuZCBldmVyeXRoaW5nIHRoYXQgY2Fubm90IGJlIGlkZW50aWZpZWQgaXMgZW5jb2RlZCBhcyB1bmRlZmluZWQgfFxuICogfCBudWxsICAgICAgICAgICAgICAgIHwgMTI2ICAgICAgfCAgICAgICAgICAgICAgICAgICAgfCB8XG4gKiB8IGludGVnZXIgICAgICAgICAgICAgfCAxMjUgICAgICB8IHdyaXRlVmFySW50ICAgICAgICB8IE9ubHkgZW5jb2RlcyAzMiBiaXQgc2lnbmVkIGludGVnZXJzIHxcbiAqIHwgZmxvYXQzMiAgICAgICAgICAgICB8IDEyNCAgICAgIHwgd3JpdGVGbG9hdDMyICAgICAgIHwgfFxuICogfCBmbG9hdDY0ICAgICAgICAgICAgIHwgMTIzICAgICAgfCB3cml0ZUZsb2F0NjQgICAgICAgfCB8XG4gKiB8IGJpZ2ludCAgICAgICAgICAgICAgfCAxMjIgICAgICB8IHdyaXRlQmlnSW50NjQgICAgICB8IHxcbiAqIHwgYm9vbGVhbiAoZmFsc2UpICAgICB8IDEyMSAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgVHJ1ZSBhbmQgZmFsc2UgYXJlIGRpZmZlcmVudCBkYXRhIHR5cGVzIHNvIHdlIHNhdmUgdGhlIGZvbGxvd2luZyBieXRlIHxcbiAqIHwgYm9vbGVhbiAodHJ1ZSkgICAgICB8IDEyMCAgICAgIHwgICAgICAgICAgICAgICAgICAgIHwgLSAwYjAxMTExMDAwIHNvIHRoZSBsYXN0IGJpdCBkZXRlcm1pbmVzIHdoZXRoZXIgdHJ1ZSBvciBmYWxzZSB8XG4gKiB8IHN0cmluZyAgICAgICAgICAgICAgfCAxMTkgICAgICB8IHdyaXRlVmFyU3RyaW5nICAgICB8IHxcbiAqIHwgb2JqZWN0PHN0cmluZyxhbnk+ICB8IDExOCAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ga2V5LXZhbHVlIHBhaXJzIHxcbiAqIHwgYXJyYXk8YW55PiAgICAgICAgICB8IDExNyAgICAgIHwgY3VzdG9tICAgICAgICAgICAgIHwgV3JpdGVzIHtsZW5ndGh9IHRoZW4ge2xlbmd0aH0ganNvbiB2YWx1ZXMgfFxuICogfCBVaW50OEFycmF5ICAgICAgICAgIHwgMTE2ICAgICAgfCB3cml0ZVZhclVpbnQ4QXJyYXkgfCBXZSB1c2UgVWludDhBcnJheSBmb3IgYW55IGtpbmQgb2YgYmluYXJ5IGRhdGEgfFxuICpcbiAqIFJlYXNvbnMgZm9yIHRoZSBkZWNyZWFzaW5nIHByZWZpeDpcbiAqIFdlIG5lZWQgdGhlIGZpcnN0IGJpdCBmb3IgZXh0ZW5kYWJpbGl0eSAobGF0ZXIgd2UgbWF5IHdhbnQgdG8gZW5jb2RlIHRoZVxuICogcHJlZml4IHdpdGggd3JpdGVWYXJVaW50KS4gVGhlIHJlbWFpbmluZyA3IGJpdHMgYXJlIGRpdmlkZWQgYXMgZm9sbG93czpcbiAqIFswLTMwXSAgIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgY3VzdG9tIHB1cnBvc2VzXG4gKiAgICAgICAgICAoZGVmaW5lZCBieSB0aGUgZnVuY3Rpb24gdGhhdCB1c2VzIHRoaXMgbGlicmFyeSlcbiAqIFszMS0xMjddIHRoZSBlbmQgb2YgdGhlIGRhdGEgcmFuZ2UgaXMgdXNlZCBmb3IgZGF0YSBlbmNvZGluZyBieVxuICogICAgICAgICAgbGliMC9lbmNvZGluZy5qc1xuICpcbiAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHt1bmRlZmluZWR8bnVsbHxudW1iZXJ8YmlnaW50fGJvb2xlYW58c3RyaW5nfE9iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fFVpbnQ4QXJyYXl9IGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlQW55ID0gKGVuY29kZXIsIGRhdGEpID0+IHtcbiAgc3dpdGNoICh0eXBlb2YgZGF0YSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAvLyBUWVBFIDExOTogU1RSSU5HXG4gICAgICB3cml0ZShlbmNvZGVyLCAxMTkpXG4gICAgICB3cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkYXRhKVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgaWYgKG51bWJlci5pc0ludGVnZXIoZGF0YSkgJiYgbWF0aC5hYnMoZGF0YSkgPD0gYmluYXJ5LkJJVFMzMSkge1xuICAgICAgICAvLyBUWVBFIDEyNTogSU5URUdFUlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjUpXG4gICAgICAgIHdyaXRlVmFySW50KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2UgaWYgKGlzRmxvYXQzMihkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDEyNDogRkxPQVQzMlxuICAgICAgICB3cml0ZShlbmNvZGVyLCAxMjQpXG4gICAgICAgIHdyaXRlRmxvYXQzMihlbmNvZGVyLCBkYXRhKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVFlQRSAxMjM6IEZMT0FUNjRcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTIzKVxuICAgICAgICB3cml0ZUZsb2F0NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYmlnaW50JzpcbiAgICAgIC8vIFRZUEUgMTIyOiBCaWdJbnRcbiAgICAgIHdyaXRlKGVuY29kZXIsIDEyMilcbiAgICAgIHdyaXRlQmlnSW50NjQoZW5jb2RlciwgZGF0YSlcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRZUEUgMTI2OiBudWxsXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDEyNilcbiAgICAgIH0gZWxzZSBpZiAoYXJyYXkuaXNBcnJheShkYXRhKSkge1xuICAgICAgICAvLyBUWVBFIDExNzogQXJyYXlcbiAgICAgICAgd3JpdGUoZW5jb2RlciwgMTE3KVxuICAgICAgICB3cml0ZVZhclVpbnQoZW5jb2RlciwgZGF0YS5sZW5ndGgpXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHdyaXRlQW55KGVuY29kZXIsIGRhdGFbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgLy8gVFlQRSAxMTY6IEFycmF5QnVmZmVyXG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExNilcbiAgICAgICAgd3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGRhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUWVBFIDExODogT2JqZWN0XG4gICAgICAgIHdyaXRlKGVuY29kZXIsIDExOClcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpXG4gICAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLCBrZXlzLmxlbmd0aClcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGtleSlcbiAgICAgICAgICB3cml0ZUFueShlbmNvZGVyLCBkYXRhW2tleV0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAvLyBUWVBFIDEyMC8xMjE6IGJvb2xlYW4gKHRydWUvZmFsc2UpXG4gICAgICB3cml0ZShlbmNvZGVyLCBkYXRhID8gMTIwIDogMTIxKVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gVFlQRSAxMjc6IHVuZGVmaW5lZFxuICAgICAgd3JpdGUoZW5jb2RlciwgMTI3KVxuICB9XG59XG5cbi8qKlxuICogTm93IGNvbWUgYSBmZXcgc3RhdGVmdWwgZW5jb2RlciB0aGF0IGhhdmUgdGhlaXIgb3duIGNsYXNzZXMuXG4gKi9cblxuLyoqXG4gKiBCYXNpYyBSdW4gTGVuZ3RoIEVuY29kZXIgLSBhIGJhc2ljIGNvbXByZXNzaW9uIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEVuY29kZXMgWzEsMSwxLDddIHRvIFsxLDMsNywxXSAoMyB0aW1lcyAxLCAxIHRpbWUgNykuIFRoaXMgZW5jb2RlciBtaWdodCBkbyBtb3JlIGhhcm0gdGhhbiBnb29kIGlmIHRoZXJlIGFyZSBhIGxvdCBvZiB2YWx1ZXMgdGhhdCBhcmUgbm90IHJlcGVhdGVkLlxuICpcbiAqIEl0IHdhcyBvcmlnaW5hbGx5IHVzZWQgZm9yIGltYWdlIGNvbXByZXNzaW9uLiBDb29sIC4uIGFydGljbGUgaHR0cDovL2NzYnJ1Y2UuY29tL2NibS90cmFuc2FjdG9yL3BkZnMvdHJhbnNfdjdfaTA2LnBkZlxuICpcbiAqIEBub3RlIFQgbXVzdCBub3QgYmUgbnVsbCFcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICovXG5leHBvcnQgY2xhc3MgUmxlRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFbmNvZGVyLCBUKTp2b2lkfSB3cml0ZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh3cml0ZXIpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogVGhlIHdyaXRlclxuICAgICAqL1xuICAgIHRoaXMudyA9IHdyaXRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VH0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMuY291bnQgPiAwKSB7XG4gICAgICAgIC8vIGZsdXNoIGNvdW50ZXIsIHVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCB2YWx1ZSAoY291bnQgPSAwKVxuICAgICAgICB3cml0ZVZhclVpbnQodGhpcywgdGhpcy5jb3VudCAtIDEpIC8vIHNpbmNlIGNvdW50IGlzIGFsd2F5cyA+IDAsIHdlIGNhbiBkZWNyZW1lbnQgYnkgb25lLiBub24tc3RhbmRhcmQgZW5jb2RpbmcgZnR3XG4gICAgICB9XG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgLy8gd3JpdGUgZmlyc3QgdmFsdWVcbiAgICAgIHRoaXMudyh0aGlzLCB2KVxuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2ljIGRpZmYgZGVjb2RlciB1c2luZyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuXG4gKlxuICogRW5jb2RlcyB0aGUgdmFsdWVzIFszLCAxMTAwLCAxMTAxLCAxMDUwLCAwXSB0byBbMywgMTA5NywgMSwgLTUxLCAtMTA1MF0gdXNpbmcgd3JpdGVWYXJJbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICB3cml0ZVZhckludCh0aGlzLCB2IC0gdGhpcy5zKVxuICAgIHRoaXMucyA9IHZcbiAgfVxufVxuXG4vKipcbiAqIEEgY29tYmluYXRpb24gb2YgSW50RGlmZkVuY29kZXIgYW5kIFJsZUVuY29kZXIuXG4gKlxuICogQmFzaWNhbGx5IGZpcnN0IHdyaXRlcyB0aGUgSW50RGlmZkVuY29kZXIgYW5kIHRoZW4gY291bnRzIGR1cGxpY2F0ZSBkaWZmcyB1c2luZyBSbGVFbmNvZGluZy5cbiAqXG4gKiBFbmNvZGVzIHRoZSB2YWx1ZXMgWzEsMSwxLDIsMyw0LDUsNl0gYXMgWzEsMSwwLDIsMSw1XSAoUkxFKFsxLDAsMCwxLDEsMSwxLDFdKSBcdTIxRDIgUmxlSW50RGlmZlsxLDEsMCwyLDEsNV0pXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVJbnREaWZmRW5jb2RlciBleHRlbmRzIEVuY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAoc3RhcnQpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQ3VycmVudCBzdGF0ZVxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gc3RhcnRcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLnMgPT09IHYgJiYgdGhpcy5jb3VudCA+IDApIHtcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb3VudCA+IDApIHtcbiAgICAgICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgICAgIHdyaXRlVmFyVWludCh0aGlzLCB0aGlzLmNvdW50IC0gMSkgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMCwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICAgIH1cbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICAvLyB3cml0ZSBmaXJzdCB2YWx1ZVxuICAgICAgd3JpdGVWYXJJbnQodGhpcywgdiAtIHRoaXMucylcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnRPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoVWludE9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgc2lnbiB0byBwb3NpdGl2ZVxuICAgIC8vIGNhc2UgMjogd3JpdGUgc2V2ZXJhbCB2YWx1ZXMuIHNldCBzaWduIHRvIG5lZ2F0aXZlIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgaXMgYSBsZW5ndGggY29taW5nXG4gICAgd3JpdGVWYXJJbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50ID09PSAxID8gZW5jb2Rlci5zIDogLWVuY29kZXIucylcbiAgICBpZiAoZW5jb2Rlci5jb3VudCA+IDEpIHtcbiAgICAgIHdyaXRlVmFyVWludChlbmNvZGVyLmVuY29kZXIsIGVuY29kZXIuY291bnQgLSAyKSAvLyBzaW5jZSBjb3VudCBpcyBhbHdheXMgPiAxLCB3ZSBjYW4gZGVjcmVtZW50IGJ5IG9uZS4gbm9uLXN0YW5kYXJkIGVuY29kaW5nIGZ0d1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIE9wdGltaXplZCBSbGUgZW5jb2RlciB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tIHRoZSBtZW50aW9uZWQgcHJvYmxlbSBvZiB0aGUgYmFzaWMgUmxlIGVuY29kZXIuXG4gKlxuICogSW50ZXJuYWxseSB1c2VzIFZhckludCBlbmNvZGVyIHRvIHdyaXRlIHVuc2lnbmVkIGludGVnZXJzLiBJZiB0aGUgaW5wdXQgb2NjdXJzIG11bHRpcGxlIHRpbWVzLCB3ZSB3cml0ZVxuICogd3JpdGUgaXQgYXMgYSBuZWdhdGl2ZSBudW1iZXIuIFRoZSBVaW50T3B0UmxlRGVjb2RlciB0aGVuIHVuZGVyc3RhbmRzIHRoYXQgaXQgbmVlZHMgdG8gcmVhZCBhIGNvdW50LlxuICpcbiAqIEVuY29kZXMgWzEsMiwzLDMsM10gYXMgWzEsMiwtMywzXSAob25jZSAxLCBvbmNlIDIsIHRocmVlIHRpbWVzIDMpXG4gKi9cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zID09PSB2KSB7XG4gICAgICB0aGlzLmNvdW50KytcbiAgICB9IGVsc2Uge1xuICAgICAgZmx1c2hVaW50T3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIHRoaXMucyA9IHZcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmx1c2ggdGhlIGVuY29kZWQgc3RhdGUgYW5kIHRyYW5zZm9ybSB0aGlzIHRvIGEgVWludDhBcnJheS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIG9uY2UuXG4gICAqL1xuICB0b1VpbnQ4QXJyYXkgKCkge1xuICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KHRoaXMuZW5jb2RlcilcbiAgfVxufVxuXG4vKipcbiAqIEluY3JlYXNpbmcgVWludCBPcHRpbWl6ZWQgUkxFIEVuY29kZXJcbiAqXG4gKiBUaGUgUkxFIGVuY29kZXIgY291bnRzIHRoZSBudW1iZXIgb2Ygc2FtZSBvY2N1cmVuY2VzIG9mIHRoZSBzYW1lIHZhbHVlLlxuICogVGhlIEluY1VpbnRPcHRSbGUgZW5jb2RlciBjb3VudHMgaWYgdGhlIHZhbHVlIGluY3JlYXNlcy5cbiAqIEkuZS4gNywgOCwgOSwgMTAgd2lsbCBiZSBlbmNvZGVkIGFzIFstNywgNF0uIDEsIDMsIDUgd2lsbCBiZSBlbmNvZGVkXG4gKiBhcyBbMSwgMywgNV0uXG4gKi9cbmV4cG9ydCBjbGFzcyBJbmNVaW50T3B0UmxlRW5jb2RlciB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgRW5jb2RlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gdlxuICAgKi9cbiAgd3JpdGUgKHYpIHtcbiAgICBpZiAodGhpcy5zICsgdGhpcy5jb3VudCA9PT0gdikge1xuICAgICAgdGhpcy5jb3VudCsrXG4gICAgfSBlbHNlIHtcbiAgICAgIGZsdXNoVWludE9wdFJsZUVuY29kZXIodGhpcylcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICB0aGlzLnMgPSB2XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsdXNoIHRoZSBlbmNvZGVkIHN0YXRlIGFuZCB0cmFuc2Zvcm0gdGhpcyB0byBhIFVpbnQ4QXJyYXkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBvbmNlLlxuICAgKi9cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBmbHVzaFVpbnRPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgcmV0dXJuIHRvVWludDhBcnJheSh0aGlzLmVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0ludERpZmZPcHRSbGVFbmNvZGVyfSBlbmNvZGVyXG4gKi9cbmNvbnN0IGZsdXNoSW50RGlmZk9wdFJsZUVuY29kZXIgPSBlbmNvZGVyID0+IHtcbiAgaWYgKGVuY29kZXIuY291bnQgPiAwKSB7XG4gICAgLy8gICAgICAgICAgMzEgYml0IG1ha2luZyB1cCB0aGUgZGlmZiB8IHdldGhlciB0byB3cml0ZSB0aGUgY291bnRlclxuICAgIC8vIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmIDw8IDEgfCAoZW5jb2Rlci5jb3VudCA9PT0gMSA/IDAgOiAxKVxuICAgIGNvbnN0IGVuY29kZWREaWZmID0gZW5jb2Rlci5kaWZmICogMiArIChlbmNvZGVyLmNvdW50ID09PSAxID8gMCA6IDEpXG4gICAgLy8gZmx1c2ggY291bnRlciwgdW5sZXNzIHRoaXMgaXMgdGhlIGZpcnN0IHZhbHVlIChjb3VudCA9IDApXG4gICAgLy8gY2FzZSAxOiBqdXN0IGEgc2luZ2xlIHZhbHVlLiBzZXQgZmlyc3QgYml0IHRvIHBvc2l0aXZlXG4gICAgLy8gY2FzZSAyOiB3cml0ZSBzZXZlcmFsIHZhbHVlcy4gc2V0IGZpcnN0IGJpdCB0byBuZWdhdGl2ZSB0byBpbmRpY2F0ZSB0aGF0IHRoZXJlIGlzIGEgbGVuZ3RoIGNvbWluZ1xuICAgIHdyaXRlVmFySW50KGVuY29kZXIuZW5jb2RlciwgZW5jb2RlZERpZmYpXG4gICAgaWYgKGVuY29kZXIuY291bnQgPiAxKSB7XG4gICAgICB3cml0ZVZhclVpbnQoZW5jb2Rlci5lbmNvZGVyLCBlbmNvZGVyLmNvdW50IC0gMikgLy8gc2luY2UgY291bnQgaXMgYWx3YXlzID4gMSwgd2UgY2FuIGRlY3JlbWVudCBieSBvbmUuIG5vbi1zdGFuZGFyZCBlbmNvZGluZyBmdHdcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNvbWJpbmF0aW9uIG9mIHRoZSBJbnREaWZmRW5jb2RlciBhbmQgdGhlIFVpbnRPcHRSbGVFbmNvZGVyLlxuICpcbiAqIFRoZSBjb3VudCBhcHByb2FjaCBpcyBzaW1pbGFyIHRvIHRoZSBVaW50RGlmZk9wdFJsZUVuY29kZXIsIGJ1dCBpbnN0ZWFkIG9mIHVzaW5nIHRoZSBuZWdhdGl2ZSBiaXRmbGFnLCBpdCBlbmNvZGVzXG4gKiBpbiB0aGUgTFNCIHdoZXRoZXIgYSBjb3VudCBpcyB0byBiZSByZWFkLiBUaGVyZWZvcmUgdGhpcyBFbmNvZGVyIG9ubHkgc3VwcG9ydHMgMzEgYml0IGludGVnZXJzIVxuICpcbiAqIEVuY29kZXMgWzEsIDIsIDMsIDJdIGFzIFszLCAxLCA2LCAtMV0gKG1vcmUgc3BlY2lmaWNhbGx5IFsoMSA8PCAxKSB8IDEsICgzIDw8IDApIHwgMCwgLTFdKVxuICpcbiAqIEludGVybmFsbHkgdXNlcyB2YXJpYWJsZSBsZW5ndGggZW5jb2RpbmcuIENvbnRyYXJ5IHRvIG5vcm1hbCBVaW50VmFyIGVuY29kaW5nLCB0aGUgZmlyc3QgYnl0ZSBjb250YWluczpcbiAqICogMSBiaXQgdGhhdCBkZW5vdGVzIHdoZXRoZXIgdGhlIG5leHQgdmFsdWUgaXMgYSBjb3VudCAoTFNCKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0aGlzIHZhbHVlIGlzIG5lZ2F0aXZlIChNU0IgLSAxKVxuICogKiAxIGJpdCB0aGF0IGRlbm90ZXMgd2hldGhlciB0byBjb250aW51ZSByZWFkaW5nIHRoZSB2YXJpYWJsZSBsZW5ndGggaW50ZWdlciAoTVNCKVxuICpcbiAqIFRoZXJlZm9yZSwgb25seSBmaXZlIGJpdHMgcmVtYWluIHRvIGVuY29kZSBkaWZmIHJhbmdlcy5cbiAqXG4gKiBVc2UgdGhpcyBFbmNvZGVyIG9ubHkgd2hlbiBhcHByb3ByaWF0ZS4gSW4gbW9zdCBjYXNlcywgdGhpcyBpcyBwcm9iYWJseSBhIGJhZCBpZGVhLlxuICovXG5leHBvcnQgY2xhc3MgSW50RGlmZk9wdFJsZUVuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5lbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zID0gMFxuICAgIHRoaXMuY291bnQgPSAwXG4gICAgdGhpcy5kaWZmID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2XG4gICAqL1xuICB3cml0ZSAodikge1xuICAgIGlmICh0aGlzLmRpZmYgPT09IHYgLSB0aGlzLnMpIHtcbiAgICAgIHRoaXMucyA9IHZcbiAgICAgIHRoaXMuY291bnQrK1xuICAgIH0gZWxzZSB7XG4gICAgICBmbHVzaEludERpZmZPcHRSbGVFbmNvZGVyKHRoaXMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgdGhpcy5kaWZmID0gdiAtIHRoaXMuc1xuICAgICAgdGhpcy5zID0gdlxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGbHVzaCB0aGUgZW5jb2RlZCBzdGF0ZSBhbmQgdHJhbnNmb3JtIHRoaXMgdG8gYSBVaW50OEFycmF5LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZS5cbiAgICovXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgZmx1c2hJbnREaWZmT3B0UmxlRW5jb2Rlcih0aGlzKVxuICAgIHJldHVybiB0b1VpbnQ4QXJyYXkodGhpcy5lbmNvZGVyKVxuICB9XG59XG5cbi8qKlxuICogT3B0aW1pemVkIFN0cmluZyBFbmNvZGVyLlxuICpcbiAqIEVuY29kaW5nIG1hbnkgc21hbGwgc3RyaW5ncyBpbiBhIHNpbXBsZSBFbmNvZGVyIGlzIG5vdCB2ZXJ5IGVmZmljaWVudC4gVGhlIGZ1bmN0aW9uIGNhbGwgdG8gZGVjb2RlIGEgc3RyaW5nIHRha2VzIHNvbWUgdGltZSBhbmQgY3JlYXRlcyByZWZlcmVuY2VzIHRoYXQgbXVzdCBiZSBldmVudHVhbGx5IGRlbGV0ZWQuXG4gKiBJbiBwcmFjdGljZSwgd2hlbiBkZWNvZGluZyBzZXZlcmFsIG1pbGxpb24gc21hbGwgc3RyaW5ncywgdGhlIEdDIHdpbGwga2ljayBpbiBtb3JlIGFuZCBtb3JlIG9mdGVuIHRvIGNvbGxlY3Qgb3JwaGFuZWQgc3RyaW5nIG9iamVjdHMgKG9yIG1heWJlIHRoZXJlIGlzIGFub3RoZXIgcmVhc29uPykuXG4gKlxuICogVGhpcyBzdHJpbmcgZW5jb2RlciBzb2x2ZXMgdGhlIGFib3ZlIHByb2JsZW0uIEFsbCBzdHJpbmdzIGFyZSBjb25jYXRlbmF0ZWQgYW5kIHdyaXR0ZW4gYXMgYSBzaW5nbGUgc3RyaW5nIHVzaW5nIGEgc2luZ2xlIGVuY29kaW5nIGNhbGwuXG4gKlxuICogVGhlIGxlbmd0aHMgYXJlIGVuY29kZWQgdXNpbmcgYSBVaW50T3B0UmxlRW5jb2Rlci5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmluZ0VuY29kZXIge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PHN0cmluZz59XG4gICAgICovXG4gICAgdGhpcy5zYXJyID0gW11cbiAgICB0aGlzLnMgPSAnJ1xuICAgIHRoaXMubGVuc0UgPSBuZXcgVWludE9wdFJsZUVuY29kZXIoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAgICovXG4gIHdyaXRlIChzdHJpbmcpIHtcbiAgICB0aGlzLnMgKz0gc3RyaW5nXG4gICAgaWYgKHRoaXMucy5sZW5ndGggPiAxOSkge1xuICAgICAgdGhpcy5zYXJyLnB1c2godGhpcy5zKVxuICAgICAgdGhpcy5zID0gJydcbiAgICB9XG4gICAgdGhpcy5sZW5zRS53cml0ZShzdHJpbmcubGVuZ3RoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gbmV3IEVuY29kZXIoKVxuICAgIHRoaXMuc2Fyci5wdXNoKHRoaXMucylcbiAgICB0aGlzLnMgPSAnJ1xuICAgIHdyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHRoaXMuc2Fyci5qb2luKCcnKSlcbiAgICB3cml0ZVVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZW5zRS50b1VpbnQ4QXJyYXkoKSlcbiAgICByZXR1cm4gdG9VaW50OEFycmF5KGVuY29kZXIpXG4gIH1cbn1cbiIsICIvKipcbiAqIEVycm9yIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBlcnJvclxuICovXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IHMgPT4gbmV3IEVycm9yKHMpXG5cbi8qKlxuICogQHRocm93cyB7RXJyb3J9XG4gKiBAcmV0dXJuIHtuZXZlcn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMyAqL1xuZXhwb3J0IGNvbnN0IG1ldGhvZFVuaW1wbGVtZW50ZWQgPSAoKSA9PiB7XG4gIHRocm93IGNyZWF0ZSgnTWV0aG9kIHVuaW1wbGVtZW50ZWQnKVxufVxuXG4vKipcbiAqIEB0aHJvd3Mge0Vycm9yfVxuICogQHJldHVybiB7bmV2ZXJ9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbmV4cG9ydCBjb25zdCB1bmV4cGVjdGVkQ2FzZSA9ICgpID0+IHtcbiAgdGhyb3cgY3JlYXRlKCdVbmV4cGVjdGVkIGNhc2UnKVxufVxuIiwgIi8qKlxuICogRWZmaWNpZW50IHNjaGVtYS1sZXNzIGJpbmFyeSBkZWNvZGluZyB3aXRoIHN1cHBvcnQgZm9yIHZhcmlhYmxlIGxlbmd0aCBlbmNvZGluZy5cbiAqXG4gKiBVc2UgW2xpYjAvZGVjb2RpbmddIHdpdGggW2xpYjAvZW5jb2RpbmddLiBFdmVyeSBlbmNvZGluZyBmdW5jdGlvbiBoYXMgYSBjb3JyZXNwb25kaW5nIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEVuY29kZXMgbnVtYmVycyBpbiBsaXR0bGUtZW5kaWFuIG9yZGVyIChsZWFzdCB0byBtb3N0IHNpZ25pZmljYW50IGJ5dGUgb3JkZXIpXG4gKiBhbmQgaXMgY29tcGF0aWJsZSB3aXRoIEdvbGFuZydzIGJpbmFyeSBlbmNvZGluZyAoaHR0cHM6Ly9nb2xhbmcub3JnL3BrZy9lbmNvZGluZy9iaW5hcnkvKVxuICogd2hpY2ggaXMgYWxzbyB1c2VkIGluIFByb3RvY29sIEJ1ZmZlcnMuXG4gKlxuICogYGBganNcbiAqIC8vIGVuY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAqIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAyNTYpXG4gKiBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCAnSGVsbG8gd29ybGQhJylcbiAqIGNvbnN0IGJ1ZiA9IGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICogYGBgXG4gKlxuICogYGBganNcbiAqIC8vIGRlY29kaW5nIHN0ZXBcbiAqIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZilcbiAqIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vID0+IDI1NlxuICogZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSAvLyA9PiAnSGVsbG8gd29ybGQhJ1xuICogZGVjb2RpbmcuaGFzQ29udGVudChkZWNvZGVyKSAvLyA9PiBmYWxzZSAtIGFsbCBkYXRhIGlzIHJlYWRcbiAqIGBgYFxuICpcbiAqIEBtb2R1bGUgZGVjb2RpbmdcbiAqL1xuXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIG51bWJlciBmcm9tICcuL251bWJlci5qcydcbmltcG9ydCAqIGFzIHN0cmluZyBmcm9tICcuL3N0cmluZy5qcydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJy4vZXJyb3IuanMnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICcuL2VuY29kaW5nLmpzJ1xuXG5jb25zdCBlcnJvclVuZXhwZWN0ZWRFbmRPZkFycmF5ID0gZXJyb3IuY3JlYXRlKCdVbmV4cGVjdGVkIGVuZCBvZiBhcnJheScpXG5jb25zdCBlcnJvckludGVnZXJPdXRPZlJhbmdlID0gZXJyb3IuY3JlYXRlKCdJbnRlZ2VyIG91dCBvZiBSYW5nZScpXG5cbi8qKlxuICogQSBEZWNvZGVyIGhhbmRsZXMgdGhlIGRlY29kaW5nIG9mIGFuIFVpbnQ4QXJyYXkuXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheSBCaW5hcnkgZGF0YSB0byBkZWNvZGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgLyoqXG4gICAgICogRGVjb2RpbmcgdGFyZ2V0LlxuICAgICAqXG4gICAgICogQHR5cGUge1VpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSB1aW50OEFycmF5XG4gICAgLyoqXG4gICAgICogQ3VycmVudCBkZWNvZGluZyBwb3NpdGlvbi5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5wb3MgPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7RGVjb2Rlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURlY29kZXIgPSB1aW50OEFycmF5ID0+IG5ldyBEZWNvZGVyKHVpbnQ4QXJyYXkpXG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBoYXNDb250ZW50ID0gZGVjb2RlciA9PiBkZWNvZGVyLnBvcyAhPT0gZGVjb2Rlci5hcnIubGVuZ3RoXG5cbi8qKlxuICogQ2xvbmUgYSBkZWNvZGVyIGluc3RhbmNlLlxuICogT3B0aW9uYWxseSBzZXQgYSBuZXcgcG9zaXRpb24gcGFyYW1ldGVyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyIFRoZSBkZWNvZGVyIGluc3RhbmNlXG4gKiBAcGFyYW0ge251bWJlcn0gW25ld1Bvc10gRGVmYXVsdHMgdG8gY3VycmVudCBwb3NpdGlvblxuICogQHJldHVybiB7RGVjb2Rlcn0gQSBjbG9uZSBvZiBgZGVjb2RlcmBcbiAqL1xuZXhwb3J0IGNvbnN0IGNsb25lID0gKGRlY29kZXIsIG5ld1BvcyA9IGRlY29kZXIucG9zKSA9PiB7XG4gIGNvbnN0IF9kZWNvZGVyID0gY3JlYXRlRGVjb2RlcihkZWNvZGVyLmFycilcbiAgX2RlY29kZXIucG9zID0gbmV3UG9zXG4gIHJldHVybiBfZGVjb2RlclxufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBVaW50OEFycmF5IHZpZXcgb2YgdGhlIG5leHQgYGxlbmAgYnl0ZXMgYW5kIGFkdmFuY2UgdGhlIHBvc2l0aW9uIGJ5IGBsZW5gLlxuICpcbiAqIEltcG9ydGFudDogVGhlIFVpbnQ4QXJyYXkgc3RpbGwgcG9pbnRzIHRvIHRoZSB1bmRlcmx5aW5nIEFycmF5QnVmZmVyLiBNYWtlIHN1cmUgdG8gZGlzY2FyZCB0aGUgcmVzdWx0IGFzIHNvb24gYXMgcG9zc2libGUgdG8gcHJldmVudCBhbnkgbWVtb3J5IGxlYWtzLlxuICogICAgICAgICAgICBVc2UgYGJ1ZmZlci5jb3B5VWludDhBcnJheWAgdG8gY29weSB0aGUgcmVzdWx0IGludG8gYSBuZXcgVWludDhBcnJheS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGxlbiBUaGUgbGVuZ3RoIG9mIGJ5dGVzIHRvIHJlYWRcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVWludDhBcnJheSA9IChkZWNvZGVyLCBsZW4pID0+IHtcbiAgY29uc3QgdmlldyA9IG5ldyBVaW50OEFycmF5KGRlY29kZXIuYXJyLmJ1ZmZlciwgZGVjb2Rlci5wb3MgKyBkZWNvZGVyLmFyci5ieXRlT2Zmc2V0LCBsZW4pXG4gIGRlY29kZXIucG9zICs9IGxlblxuICByZXR1cm4gdmlld1xufVxuXG4vKipcbiAqIFJlYWQgdmFyaWFibGUgbGVuZ3RoIFVpbnQ4QXJyYXkuXG4gKlxuICogSW1wb3J0YW50OiBUaGUgVWludDhBcnJheSBzdGlsbCBwb2ludHMgdG8gdGhlIHVuZGVybHlpbmcgQXJyYXlCdWZmZXIuIE1ha2Ugc3VyZSB0byBkaXNjYXJkIHRoZSByZXN1bHQgYXMgc29vbiBhcyBwb3NzaWJsZSB0byBwcmV2ZW50IGFueSBtZW1vcnkgbGVha3MuXG4gKiAgICAgICAgICAgIFVzZSBgYnVmZmVyLmNvcHlVaW50OEFycmF5YCB0byBjb3B5IHRoZSByZXN1bHQgaW50byBhIG5ldyBVaW50OEFycmF5LlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhclVpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIHJlYWRWYXJVaW50KGRlY29kZXIpKVxuXG4vKipcbiAqIFJlYWQgdGhlIHJlc3Qgb2YgdGhlIGNvbnRlbnQgYXMgYW4gQXJyYXlCdWZmZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgcmVhZFRhaWxBc1VpbnQ4QXJyYXkgPSBkZWNvZGVyID0+IHJlYWRVaW50OEFycmF5KGRlY29kZXIsIGRlY29kZXIuYXJyLmxlbmd0aCAtIGRlY29kZXIucG9zKVxuXG4vKipcbiAqIFNraXAgb25lIGJ5dGUsIGp1bXAgdG8gdGhlIG5leHQgcG9zaXRpb24uXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbmV4dCBwb3NpdGlvblxuICovXG5leHBvcnQgY29uc3Qgc2tpcDggPSBkZWNvZGVyID0+IGRlY29kZXIucG9zKytcblxuLyoqXG4gKiBSZWFkIG9uZSBieXRlIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlciBUaGUgZGVjb2RlciBpbnN0YW5jZVxuICogQHJldHVybiB7bnVtYmVyfSBVbnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkVWludDggPSBkZWNvZGVyID0+IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG5cbi8qKlxuICogUmVhZCAyIGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MTYgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuICBkZWNvZGVyLnBvcyArPSAyXG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzIgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zXSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDE2KSArXG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogUmVhZCA0IGJ5dGVzIGFzIHVuc2lnbmVkIGludGVnZXIgaW4gYmlnIGVuZGlhbiBvcmRlci5cbiAqIChtb3N0IHNpZ25pZmljYW50IGJ5dGUgZmlyc3QpXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVaW50MzJCaWdFbmRpYW4gPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgdWludCA9XG4gICAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgM10gK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvcyArIDJdIDw8IDgpICtcbiAgICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCAxNikgK1xuICAgIChkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gPDwgMjQpKSA+Pj4gMFxuICBkZWNvZGVyLnBvcyArPSA0XG4gIHJldHVybiB1aW50XG59XG5cbi8qKlxuICogTG9vayBhaGVhZCB3aXRob3V0IGluY3JlbWVudGluZyB0aGUgcG9zaXRpb25cbiAqIHRvIHRoZSBuZXh0IGJ5dGUgYW5kIHJlYWQgaXQgYXMgdW5zaWduZWQgaW50ZWdlci5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICovXG5leHBvcnQgY29uc3QgcGVla1VpbnQ4ID0gZGVjb2RlciA9PiBkZWNvZGVyLmFycltkZWNvZGVyLnBvc11cblxuLyoqXG4gKiBMb29rIGFoZWFkIHdpdGhvdXQgaW5jcmVtZW50aW5nIHRoZSBwb3NpdGlvblxuICogdG8gdGhlIG5leHQgYnl0ZSBhbmQgcmVhZCBpdCBhcyB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIGludGVnZXIuXG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVWludDE2ID0gZGVjb2RlciA9PlxuICBkZWNvZGVyLmFycltkZWNvZGVyLnBvc10gK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAxXSA8PCA4KVxuXG4vKipcbiAqIExvb2sgYWhlYWQgd2l0aG91dCBpbmNyZW1lbnRpbmcgdGhlIHBvc2l0aW9uXG4gKiB0byB0aGUgbmV4dCBieXRlIGFuZCByZWFkIGl0IGFzIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuZXhwb3J0IGNvbnN0IHBlZWtVaW50MzIgPSBkZWNvZGVyID0+IChcbiAgZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3NdICtcbiAgKGRlY29kZXIuYXJyW2RlY29kZXIucG9zICsgMV0gPDwgOCkgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAyXSA8PCAxNikgK1xuICAoZGVjb2Rlci5hcnJbZGVjb2Rlci5wb3MgKyAzXSA8PCAyNClcbikgPj4+IDBcblxuLyoqXG4gKiBSZWFkIHVuc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge251bWJlcn0gQW4gdW5zaWduZWQgaW50ZWdlci5sZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRWYXJVaW50ID0gZGVjb2RlciA9PiB7XG4gIGxldCBudW0gPSAwXG4gIGxldCBtdWx0ID0gMVxuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGhcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgY29uc3QgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBiaW5hcnkuQklUUzcpICogbXVsdCAvLyBzaGlmdCAkciA8PCAoNyojaXRlcmF0aW9ucykgYW5kIGFkZCBpdCB0byBudW1cbiAgICBtdWx0ICo9IDEyOCAvLyBuZXh0IGl0ZXJhdGlvbiwgc2hpZnQgNyBcIm1vcmVcIiB0byB0aGUgbGVmdFxuICAgIGlmIChyIDwgYmluYXJ5LkJJVDgpIHtcbiAgICAgIHJldHVybiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IG51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufVxuXG4vKipcbiAqIFJlYWQgc2lnbmVkIGludGVnZXIgKDMyYml0KSB3aXRoIHZhcmlhYmxlIGxlbmd0aC5cbiAqIDEvOHRoIG9mIHRoZSBzdG9yYWdlIGlzIHVzZWQgYXMgZW5jb2Rpbmcgb3ZlcmhlYWQuXG4gKiAgKiBudW1iZXJzIDwgMl43IGlzIHN0b3JlZCBpbiBvbmUgYnl0bGVuZ3RoXG4gKiAgKiBudW1iZXJzIDwgMl4xNCBpcyBzdG9yZWQgaW4gdHdvIGJ5bGVuZ3RoXG4gKiBAdG9kbyBUaGlzIHNob3VsZCBwcm9iYWJseSBjcmVhdGUgdGhlIGludmVyc2Ugfm51bSBpZiBudW1iZXIgaXMgbmVnYXRpdmUgLSBidXQgdGhpcyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfSBBbiB1bnNpZ25lZCBpbnRlZ2VyLmxlbmd0aFxuICovXG5leHBvcnQgY29uc3QgcmVhZFZhckludCA9IGRlY29kZXIgPT4ge1xuICBsZXQgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gIGxldCBudW0gPSByICYgYmluYXJ5LkJJVFM2XG4gIGxldCBtdWx0ID0gNjRcbiAgY29uc3Qgc2lnbiA9IChyICYgYmluYXJ5LkJJVDcpID4gMCA/IC0xIDogMVxuICBpZiAoKHIgJiBiaW5hcnkuQklUOCkgPT09IDApIHtcbiAgICAvLyBkb24ndCBjb250aW51ZSByZWFkaW5nXG4gICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgfVxuICBjb25zdCBsZW4gPSBkZWNvZGVyLmFyci5sZW5ndGhcbiAgd2hpbGUgKGRlY29kZXIucG9zIDwgbGVuKSB7XG4gICAgciA9IGRlY29kZXIuYXJyW2RlY29kZXIucG9zKytdXG4gICAgLy8gbnVtID0gbnVtIHwgKChyICYgYmluYXJ5LkJJVFM3KSA8PCBsZW4pXG4gICAgbnVtID0gbnVtICsgKHIgJiBiaW5hcnkuQklUUzcpICogbXVsdFxuICAgIG11bHQgKj0gMTI4XG4gICAgaWYgKHIgPCBiaW5hcnkuQklUOCkge1xuICAgICAgcmV0dXJuIHNpZ24gKiBudW1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgaWYgKG51bSA+IG51bWJlci5NQVhfU0FGRV9JTlRFR0VSKSB7XG4gICAgICB0aHJvdyBlcnJvckludGVnZXJPdXRPZlJhbmdlXG4gICAgfVxuICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gIH1cbiAgdGhyb3cgZXJyb3JVbmV4cGVjdGVkRW5kT2ZBcnJheVxufVxuXG4vKipcbiAqIExvb2sgYWhlYWQgYW5kIHJlYWQgdmFyVWludCB3aXRob3V0IGluY3JlbWVudGluZyBwb3NpdGlvblxuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBwZWVrVmFyVWludCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgZGVjb2Rlci5wb3MgPSBwb3NcbiAgcmV0dXJuIHNcbn1cblxuLyoqXG4gKiBMb29rIGFoZWFkIGFuZCByZWFkIHZhclVpbnQgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhckludCA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhckludChkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIFdlIGRvbid0IHRlc3QgdGhpcyBmdW5jdGlvbiBhbnltb3JlIGFzIHdlIHVzZSBuYXRpdmUgZGVjb2RpbmcvZW5jb2RpbmcgYnkgZGVmYXVsdCBub3cuXG4gKiBCZXR0ZXIgbm90IG1vZGlmeSB0aGlzIGFueW1vcmUuLlxuICpcbiAqIFRyYW5zZm9ybWluZyB1dGY4IHRvIGEgc3RyaW5nIGlzIHByZXR0eSBleHBlbnNpdmUuIFRoZSBjb2RlIHBlcmZvcm1zIDEweCBiZXR0ZXJcbiAqIHdoZW4gU3RyaW5nLmZyb21Db2RlUG9pbnQgaXMgZmVkIHdpdGggYWxsIGNoYXJhY3RlcnMgYXMgYXJndW1lbnRzLlxuICogQnV0IG1vc3QgZW52aXJvbm1lbnRzIGhhdmUgYSBtYXhpbXVtIG51bWJlciBvZiBhcmd1bWVudHMgcGVyIGZ1bmN0aW9ucy5cbiAqIEZvciBlZmZpZW5jeSByZWFzb25zIHdlIGFwcGx5IGEgbWF4aW11bSBvZiAxMDAwMCBjaGFyYWN0ZXJzIGF0IG9uY2UuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1N0cmluZ30gVGhlIHJlYWQgU3RyaW5nLlxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjb25zdCBfcmVhZFZhclN0cmluZ1BvbHlmaWxsID0gZGVjb2RlciA9PiB7XG4gIGxldCByZW1haW5pbmdMZW4gPSByZWFkVmFyVWludChkZWNvZGVyKVxuICBpZiAocmVtYWluaW5nTGVuID09PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH0gZWxzZSB7XG4gICAgbGV0IGVuY29kZWRTdHJpbmcgPSBTdHJpbmcuZnJvbUNvZGVQb2ludChyZWFkVWludDgoZGVjb2RlcikpIC8vIHJlbWVtYmVyIHRvIGRlY3JlYXNlIHJlbWFpbmluZ0xlblxuICAgIGlmICgtLXJlbWFpbmluZ0xlbiA8IDEwMCkgeyAvLyBkbyBub3QgY3JlYXRlIGEgVWludDhBcnJheSBmb3Igc21hbGwgc3RyaW5nc1xuICAgICAgd2hpbGUgKHJlbWFpbmluZ0xlbi0tKSB7XG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQocmVhZFVpbnQ4KGRlY29kZXIpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAocmVtYWluaW5nTGVuID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0TGVuID0gcmVtYWluaW5nTGVuIDwgMTAwMDAgPyByZW1haW5pbmdMZW4gOiAxMDAwMFxuICAgICAgICAvLyB0aGlzIGlzIGRhbmdlcm91cywgd2UgY3JlYXRlIGEgZnJlc2ggYXJyYXkgdmlldyBmcm9tIHRoZSBleGlzdGluZyBidWZmZXJcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBkZWNvZGVyLmFyci5zdWJhcnJheShkZWNvZGVyLnBvcywgZGVjb2Rlci5wb3MgKyBuZXh0TGVuKVxuICAgICAgICBkZWNvZGVyLnBvcyArPSBuZXh0TGVuXG4gICAgICAgIC8vIFN0YXJ0aW5nIHdpdGggRVM1LjEgd2UgY2FuIHN1cHBseSBhIGdlbmVyaWMgYXJyYXktbGlrZSBvYmplY3QgYXMgYXJndW1lbnRzXG4gICAgICAgIGVuY29kZWRTdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQuYXBwbHkobnVsbCwgLyoqIEB0eXBlIHthbnl9ICovIChieXRlcykpXG4gICAgICAgIHJlbWFpbmluZ0xlbiAtPSBuZXh0TGVuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKGVuY29kZWRTdHJpbmcpKVxuICB9XG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICovXG5leHBvcnQgY29uc3QgX3JlYWRWYXJTdHJpbmdOYXRpdmUgPSBkZWNvZGVyID0+XG4gIC8qKiBAdHlwZSBhbnkgKi8gKHN0cmluZy51dGY4VGV4dERlY29kZXIpLmRlY29kZShyZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcblxuLyoqXG4gKiBSZWFkIHN0cmluZyBvZiB2YXJpYWJsZSBsZW5ndGhcbiAqICogdmFyVWludCBpcyB1c2VkIHRvIHN0b3JlIHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZ1xuICpcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFRoZSByZWFkIFN0cmluZ1xuICpcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCByZWFkVmFyU3RyaW5nID0gc3RyaW5nLnV0ZjhUZXh0RGVjb2RlciA/IF9yZWFkVmFyU3RyaW5nTmF0aXZlIDogX3JlYWRWYXJTdHJpbmdQb2x5ZmlsbFxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRUZXJtaW5hdGVkVWludDhBcnJheSA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGxldCBiXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgYiA9IHJlYWRVaW50OChkZWNvZGVyKVxuICAgIGlmIChiID09PSAwKSB7XG4gICAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpXG4gICAgfVxuICAgIGlmIChiID09PSAxKSB7XG4gICAgICBiID0gcmVhZFVpbnQ4KGRlY29kZXIpXG4gICAgfVxuICAgIGVuY29kaW5nLndyaXRlKGVuY29kZXIsIGIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRUZXJtaW5hdGVkU3RyaW5nID0gZGVjb2RlciA9PiBzdHJpbmcuZGVjb2RlVXRmOChyZWFkVGVybWluYXRlZFVpbnQ4QXJyYXkoZGVjb2RlcikpXG5cbi8qKlxuICogTG9vayBhaGVhZCBhbmQgcmVhZCB2YXJTdHJpbmcgd2l0aG91dCBpbmNyZW1lbnRpbmcgcG9zaXRpb25cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgcGVla1ZhclN0cmluZyA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBwb3MgPSBkZWNvZGVyLnBvc1xuICBjb25zdCBzID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICBkZWNvZGVyLnBvcyA9IHBvc1xuICByZXR1cm4gc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICogQHJldHVybiB7RGF0YVZpZXd9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRnJvbURhdGFWaWV3ID0gKGRlY29kZXIsIGxlbikgPT4ge1xuICBjb25zdCBkdiA9IG5ldyBEYXRhVmlldyhkZWNvZGVyLmFyci5idWZmZXIsIGRlY29kZXIuYXJyLmJ5dGVPZmZzZXQgKyBkZWNvZGVyLnBvcywgbGVuKVxuICBkZWNvZGVyLnBvcyArPSBsZW5cbiAgcmV0dXJuIGR2XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWNvZGVyfSBkZWNvZGVyXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkRmxvYXQzMiA9IGRlY29kZXIgPT4gcmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA0KS5nZXRGbG9hdDMyKDAsIGZhbHNlKVxuXG4vKipcbiAqIEBwYXJhbSB7RGVjb2Rlcn0gZGVjb2RlclxuICovXG5leHBvcnQgY29uc3QgcmVhZEZsb2F0NjQgPSBkZWNvZGVyID0+IHJlYWRGcm9tRGF0YVZpZXcoZGVjb2RlciwgOCkuZ2V0RmxvYXQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdJbnQ2NCA9IGRlY29kZXIgPT4gLyoqIEB0eXBlIHthbnl9ICovIChyZWFkRnJvbURhdGFWaWV3KGRlY29kZXIsIDgpKS5nZXRCaWdJbnQ2NCgwLCBmYWxzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRCaWdVaW50NjQgPSBkZWNvZGVyID0+IC8qKiBAdHlwZSB7YW55fSAqLyAocmVhZEZyb21EYXRhVmlldyhkZWNvZGVyLCA4KSkuZ2V0QmlnVWludDY0KDAsIGZhbHNlKVxuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihEZWNvZGVyKTphbnk+fVxuICovXG5jb25zdCByZWFkQW55TG9va3VwVGFibGUgPSBbXG4gIGRlY29kZXIgPT4gdW5kZWZpbmVkLCAvLyBDQVNFIDEyNzogdW5kZWZpbmVkXG4gIGRlY29kZXIgPT4gbnVsbCwgLy8gQ0FTRSAxMjY6IG51bGxcbiAgcmVhZFZhckludCwgLy8gQ0FTRSAxMjU6IGludGVnZXJcbiAgcmVhZEZsb2F0MzIsIC8vIENBU0UgMTI0OiBmbG9hdDMyXG4gIHJlYWRGbG9hdDY0LCAvLyBDQVNFIDEyMzogZmxvYXQ2NFxuICByZWFkQmlnSW50NjQsIC8vIENBU0UgMTIyOiBiaWdpbnRcbiAgZGVjb2RlciA9PiBmYWxzZSwgLy8gQ0FTRSAxMjE6IGJvb2xlYW4gKGZhbHNlKVxuICBkZWNvZGVyID0+IHRydWUsIC8vIENBU0UgMTIwOiBib29sZWFuICh0cnVlKVxuICByZWFkVmFyU3RyaW5nLCAvLyBDQVNFIDExOTogc3RyaW5nXG4gIGRlY29kZXIgPT4geyAvLyBDQVNFIDExODogb2JqZWN0PHN0cmluZyxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAqL1xuICAgIGNvbnN0IG9iaiA9IHt9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0gcmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgb2JqW2tleV0gPSByZWFkQW55KGRlY29kZXIpXG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfSxcbiAgZGVjb2RlciA9PiB7IC8vIENBU0UgMTE3OiBhcnJheTxhbnk+XG4gICAgY29uc3QgbGVuID0gcmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBhcnIgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyci5wdXNoKHJlYWRBbnkoZGVjb2RlcikpXG4gICAgfVxuICAgIHJldHVybiBhcnJcbiAgfSxcbiAgcmVhZFZhclVpbnQ4QXJyYXkgLy8gQ0FTRSAxMTY6IFVpbnQ4QXJyYXlcbl1cblxuLyoqXG4gKiBAcGFyYW0ge0RlY29kZXJ9IGRlY29kZXJcbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRBbnkgPSBkZWNvZGVyID0+IHJlYWRBbnlMb29rdXBUYWJsZVsxMjcgLSByZWFkVWludDgoZGVjb2RlcildKGRlY29kZXIpXG5cbi8qKlxuICogVCBtdXN0IG5vdCBiZSBudWxsLlxuICpcbiAqIEB0ZW1wbGF0ZSBUXG4gKi9cbmV4cG9ydCBjbGFzcyBSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtmdW5jdGlvbihEZWNvZGVyKTpUfSByZWFkZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5LCByZWFkZXIpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIFRoZSByZWFkZXJcbiAgICAgKi9cbiAgICB0aGlzLnJlYWRlciA9IHJlYWRlclxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7VHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucyA9IG51bGxcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHRoaXMucmVhZGVyKHRoaXMpXG4gICAgICBpZiAoaGFzQ29udGVudCh0aGlzKSkge1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAxIC8vIHNlZSBlbmNvZGVyIGltcGxlbWVudGF0aW9uIGZvciB0aGUgcmVhc29uIHdoeSB0aGlzIGlzIGluY3JlbWVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNvdW50ID0gLTEgLy8gcmVhZCB0aGUgY3VycmVudCB2YWx1ZSBmb3JldmVyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge1R9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICByZXR1cm4gdGhpcy5zXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJsZUludERpZmZEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSwgc3RhcnQpIHtcbiAgICBzdXBlcih1aW50OEFycmF5KVxuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IHN0YXJ0XG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkICgpIHtcbiAgICBpZiAodGhpcy5jb3VudCA9PT0gMCkge1xuICAgICAgdGhpcy5zICs9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIGlmIChoYXNDb250ZW50KHRoaXMpKSB7XG4gICAgICAgIHRoaXMuY291bnQgPSByZWFkVmFyVWludCh0aGlzKSArIDEgLy8gc2VlIGVuY29kZXIgaW1wbGVtZW50YXRpb24gZm9yIHRoZSByZWFzb24gd2h5IHRoaXMgaXMgaW5jcmVtZW50ZWRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuY291bnQgPSAtMSAvLyByZWFkIHRoZSBjdXJyZW50IHZhbHVlIGZvcmV2ZXJcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAodGhpcy5zKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVaW50T3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgfVxuXG4gIHJlYWQgKCkge1xuICAgIGlmICh0aGlzLmNvdW50ID09PSAwKSB7XG4gICAgICB0aGlzLnMgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgc2lnbiBpcyBuZWdhdGl2ZSwgd2UgcmVhZCB0aGUgY291bnQgdG9vLCBvdGhlcndpc2UgY291bnQgaXMgMVxuICAgICAgY29uc3QgaXNOZWdhdGl2ZSA9IG1hdGguaXNOZWdhdGl2ZVplcm8odGhpcy5zKVxuICAgICAgdGhpcy5jb3VudCA9IDFcbiAgICAgIGlmIChpc05lZ2F0aXZlKSB7XG4gICAgICAgIHRoaXMucyA9IC10aGlzLnNcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmNvdW50LS1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtudW1iZXJ9ICovICh0aGlzLnMpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEluY1VpbnRPcHRSbGVEZWNvZGVyIGV4dGVuZHMgRGVjb2RlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVpbnQ4QXJyYXlcbiAgICovXG4gIGNvbnN0cnVjdG9yICh1aW50OEFycmF5KSB7XG4gICAgc3VwZXIodWludDhBcnJheSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMucyA9IDBcbiAgICB0aGlzLmNvdW50ID0gMFxuICB9XG5cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIHRoaXMucyA9IHJlYWRWYXJJbnQodGhpcylcbiAgICAgIC8vIGlmIHRoZSBzaWduIGlzIG5lZ2F0aXZlLCB3ZSByZWFkIHRoZSBjb3VudCB0b28sIG90aGVyd2lzZSBjb3VudCBpcyAxXG4gICAgICBjb25zdCBpc05lZ2F0aXZlID0gbWF0aC5pc05lZ2F0aXZlWmVybyh0aGlzLnMpXG4gICAgICB0aGlzLmNvdW50ID0gMVxuICAgICAgaWYgKGlzTmVnYXRpdmUpIHtcbiAgICAgICAgdGhpcy5zID0gLXRoaXMuc1xuICAgICAgICB0aGlzLmNvdW50ID0gcmVhZFZhclVpbnQodGhpcykgKyAyXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY291bnQtLVxuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMucysrKVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBJbnREaWZmT3B0UmxlRGVjb2RlciBleHRlbmRzIERlY29kZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodWludDhBcnJheSkge1xuICAgIHN1cGVyKHVpbnQ4QXJyYXkpXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLnMgPSAwXG4gICAgdGhpcy5jb3VudCA9IDBcbiAgICB0aGlzLmRpZmYgPSAwXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZCAoKSB7XG4gICAgaWYgKHRoaXMuY291bnQgPT09IDApIHtcbiAgICAgIGNvbnN0IGRpZmYgPSByZWFkVmFySW50KHRoaXMpXG4gICAgICAvLyBpZiB0aGUgZmlyc3QgYml0IGlzIHNldCwgd2UgcmVhZCBtb3JlIGRhdGFcbiAgICAgIGNvbnN0IGhhc0NvdW50ID0gZGlmZiAmIDFcbiAgICAgIHRoaXMuZGlmZiA9IG1hdGguZmxvb3IoZGlmZiAvIDIpIC8vIHNoaWZ0ID4+IDFcbiAgICAgIHRoaXMuY291bnQgPSAxXG4gICAgICBpZiAoaGFzQ291bnQpIHtcbiAgICAgICAgdGhpcy5jb3VudCA9IHJlYWRWYXJVaW50KHRoaXMpICsgMlxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnMgKz0gdGhpcy5kaWZmXG4gICAgdGhpcy5jb3VudC0tXG4gICAgcmV0dXJuIHRoaXMuc1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBTdHJpbmdEZWNvZGVyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHVpbnQ4QXJyYXkpIHtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgVWludE9wdFJsZURlY29kZXIodWludDhBcnJheSlcbiAgICB0aGlzLnN0ciA9IHJlYWRWYXJTdHJpbmcodGhpcy5kZWNvZGVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5zcG9zID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWQgKCkge1xuICAgIGNvbnN0IGVuZCA9IHRoaXMuc3BvcyArIHRoaXMuZGVjb2Rlci5yZWFkKClcbiAgICBjb25zdCByZXMgPSB0aGlzLnN0ci5zbGljZSh0aGlzLnNwb3MsIGVuZClcbiAgICB0aGlzLnNwb3MgPSBlbmRcbiAgICByZXR1cm4gcmVzXG4gIH1cbn1cbiIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuZXhwb3J0IGNvbnN0IHN1YnRsZSA9IGNyeXB0by5zdWJ0bGVcbmV4cG9ydCBjb25zdCBnZXRSYW5kb21WYWx1ZXMgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKVxuIiwgIi8qKlxuICogSXNvbW9ycGhpYyBtb2R1bGUgZm9yIHRydWUgcmFuZG9tIG51bWJlcnMgLyBidWZmZXJzIC8gdXVpZHMuXG4gKlxuICogQXR0ZW50aW9uOiBmYWxscyBiYWNrIHRvIE1hdGgucmFuZG9tIGlmIHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgY3J5cHRvLlxuICpcbiAqIEBtb2R1bGUgcmFuZG9tXG4gKi9cblxuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5pbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnLi9iaW5hcnkuanMnXG5pbXBvcnQgeyBnZXRSYW5kb21WYWx1ZXMgfSBmcm9tICdsaWIwL3dlYmNyeXB0bydcblxuZXhwb3J0IGNvbnN0IHJhbmQgPSBNYXRoLnJhbmRvbVxuXG5leHBvcnQgY29uc3QgdWludDMyID0gKCkgPT4gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF1cblxuZXhwb3J0IGNvbnN0IHVpbnQ1MyA9ICgpID0+IHtcbiAgY29uc3QgYXJyID0gZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSg4KSlcbiAgcmV0dXJuIChhcnJbMF0gJiBiaW5hcnkuQklUUzIxKSAqIChiaW5hcnkuQklUUzMyICsgMSkgKyAoYXJyWzFdID4+PiAwKVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0FycmF5PFQ+fSBhcnJcbiAqIEByZXR1cm4ge1R9XG4gKi9cbmV4cG9ydCBjb25zdCBvbmVPZiA9IGFyciA9PiBhcnJbbWF0aC5mbG9vcihyYW5kKCkgKiBhcnIubGVuZ3RoKV1cblxuLy8gQHRzLWlnbm9yZVxuY29uc3QgdXVpZHY0VGVtcGxhdGUgPSBbMWU3XSArIC0xZTMgKyAtNGUzICsgLThlMyArIC0xZTExXG5cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgdXVpZHY0ID0gKCkgPT4gdXVpZHY0VGVtcGxhdGUucmVwbGFjZSgvWzAxOF0vZywgLyoqIEBwYXJhbSB7bnVtYmVyfSBjICovIGMgPT5cbiAgKGMgXiB1aW50MzIoKSAmIDE1ID4+IGMgLyA0KS50b1N0cmluZygxNilcbilcbiIsICIvKipcbiAqIFV0aWxpdHkgaGVscGVycyB0byB3b3JrIHdpdGggcHJvbWlzZXMuXG4gKlxuICogQG1vZHVsZSBwcm9taXNlXG4gKi9cblxuaW1wb3J0ICogYXMgdGltZSBmcm9tICcuL3RpbWUuanMnXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBjYWxsYmFjayBQcm9taXNlUmVzb2x2ZVxuICogQHBhcmFtIHtUfFByb21pc2VMaWtlPFQ+fSBbcmVzdWx0XVxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUHJvbWlzZVJlc29sdmU8VD4sZnVuY3Rpb24oRXJyb3IpOnZvaWQpOmFueX0gZlxuICogQHJldHVybiB7UHJvbWlzZTxUPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IGYgPT4gLyoqIEB0eXBlIHtQcm9taXNlPFQ+fSAqLyAobmV3IFByb21pc2UoZikpXG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbihmdW5jdGlvbigpOnZvaWQsZnVuY3Rpb24oRXJyb3IpOnZvaWQpOnZvaWR9IGZcbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbXB0eSA9IGYgPT4gbmV3IFByb21pc2UoZilcblxuLyoqXG4gKiBgUHJvbWlzZS5hbGxgIHdhaXQgZm9yIGFsbCBwcm9taXNlcyBpbiB0aGUgYXJyYXkgdG8gcmVzb2x2ZSBhbmQgcmV0dXJuIHRoZSByZXN1bHRcbiAqIEB0ZW1wbGF0ZSB7dW5rbm93bltdIHwgW119IFBTXG4gKlxuICogQHBhcmFtIHtQU30gcHNcbiAqIEByZXR1cm4ge1Byb21pc2U8eyAtcmVhZG9ubHkgW1AgaW4ga2V5b2YgUFNdOiBBd2FpdGVkPFBTW1BdPiB9Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFsbCA9IFByb21pc2UuYWxsLmJpbmQoUHJvbWlzZSlcblxuLyoqXG4gKiBAcGFyYW0ge0Vycm9yfSBbcmVhc29uXVxuICogQHJldHVybiB7UHJvbWlzZTxuZXZlcj59XG4gKi9cbmV4cG9ydCBjb25zdCByZWplY3QgPSByZWFzb24gPT4gUHJvbWlzZS5yZWplY3QocmVhc29uKVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge1R8dm9pZH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFR8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCByZXNvbHZlID0gcmVzID0+IFByb21pc2UucmVzb2x2ZShyZXMpXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqIEBwYXJhbSB7VH0gcmVzXG4gKiBAcmV0dXJuIHtQcm9taXNlPFQ+fVxuICovXG5leHBvcnQgY29uc3QgcmVzb2x2ZVdpdGggPSByZXMgPT4gUHJvbWlzZS5yZXNvbHZlKHJlcylcblxuLyoqXG4gKiBAdG9kbyBOZXh0IHZlcnNpb24sIHJlb3JkZXIgcGFyYW1ldGVyczogY2hlY2ssIFt0aW1lb3V0LCBbaW50ZXJ2YWxSZXNvbHV0aW9uXV1cbiAqIEBkZXByZWNhdGVkIHVzZSB1bnRpbEFzeW5jIGluc3RlYWRcbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdGltZW91dFxuICogQHBhcmFtIHtmdW5jdGlvbigpOmJvb2xlYW59IGNoZWNrXG4gKiBAcGFyYW0ge251bWJlcn0gW2ludGVydmFsUmVzb2x1dGlvbl1cbiAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydCBjb25zdCB1bnRpbCA9ICh0aW1lb3V0LCBjaGVjaywgaW50ZXJ2YWxSZXNvbHV0aW9uID0gMTApID0+IGNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBoYXNUaW1lb3V0ID0gdGltZW91dCA+IDBcbiAgY29uc3QgdW50aWxJbnRlcnZhbCA9ICgpID0+IHtcbiAgICBpZiAoY2hlY2soKSkge1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbEhhbmRsZSlcbiAgICAgIHJlc29sdmUoKVxuICAgIH0gZWxzZSBpZiAoaGFzVGltZW91dCkge1xuICAgICAgLyogYzggaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmICh0aW1lLmdldFVuaXhUaW1lKCkgLSBzdGFydFRpbWUgPiB0aW1lb3V0KSB7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxIYW5kbGUpXG4gICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVvdXQnKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3QgaW50ZXJ2YWxIYW5kbGUgPSBzZXRJbnRlcnZhbCh1bnRpbEludGVydmFsLCBpbnRlcnZhbFJlc29sdXRpb24pXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7KCk9PlByb21pc2U8Ym9vbGVhbj58Ym9vbGVhbn0gY2hlY2tcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcGFyYW0ge251bWJlcn0gaW50ZXJ2YWxSZXNvbHV0aW9uXG4gKiBAcmV0dXJuIHtQcm9taXNlPHZvaWQ+fVxuICovXG5leHBvcnQgY29uc3QgdW50aWxBc3luYyA9IGFzeW5jIChjaGVjaywgdGltZW91dCA9IDAsIGludGVydmFsUmVzb2x1dGlvbiA9IDEwKSA9PiB7XG4gIGNvbnN0IHN0YXJ0VGltZSA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICBjb25zdCBub1RpbWVvdXQgPSB0aW1lb3V0IDw9IDBcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVubW9kaWZpZWQtbG9vcC1jb25kaXRpb25cbiAgd2hpbGUgKG5vVGltZW91dCB8fCB0aW1lLmdldFVuaXhUaW1lKCkgLSBzdGFydFRpbWUgPD0gdGltZW91dCkge1xuICAgIGlmIChhd2FpdCBjaGVjaygpKSByZXR1cm5cbiAgICBhd2FpdCB3YWl0KGludGVydmFsUmVzb2x1dGlvbilcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoJ1RpbWVvdXQnKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSB0aW1lb3V0XG4gKiBAcmV0dXJuIHtQcm9taXNlPHVuZGVmaW5lZD59XG4gKi9cbmV4cG9ydCBjb25zdCB3YWl0ID0gdGltZW91dCA9PiBjcmVhdGUoKHJlc29sdmUsIF9yZWplY3QpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dCkpXG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIG9iamVjdCBpcyBhIHByb21pc2UgdXNpbmcgZHVja3R5cGluZy5cbiAqXG4gKiBQcm9taXNlcyBhcmUgb2Z0ZW4gcG9seWZpbGxlZCwgc28gaXQgbWFrZXMgc2Vuc2UgdG8gYWRkIHNvbWUgYWRkaXRpb25hbCBndWFyYW50ZWVzIGlmIHRoZSB1c2VyIG9mIHRoaXNcbiAqIGxpYnJhcnkgaGFzIHNvbWUgaW5zYW5lIGVudmlyb25tZW50IHdoZXJlIGdsb2JhbCBQcm9taXNlIG9iamVjdHMgYXJlIG92ZXJ3cml0dGVuLlxuICpcbiAqIEBwYXJhbSB7YW55fSBwXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNQcm9taXNlID0gcCA9PiBwIGluc3RhbmNlb2YgUHJvbWlzZSB8fCAocCAmJiBwLnRoZW4gJiYgcC5jYXRjaCAmJiBwLmZpbmFsbHkpXG4iLCAiLyoqXG4gKiBPZnRlbiB1c2VkIGNvbmRpdGlvbnMuXG4gKlxuICogQG1vZHVsZSBjb25kaXRpb25zXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfG51bGx8dW5kZWZpbmVkfSB2XG4gKiBAcmV0dXJuIHtUfG51bGx9XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgdW5kZWZpbmVkVG9OdWxsID0gdiA9PiB2ID09PSB1bmRlZmluZWQgPyBudWxsIDogdlxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIElzb21vcnBoaWMgdmFyaWFibGUgc3RvcmFnZS5cbiAqXG4gKiBVc2VzIExvY2FsU3RvcmFnZSBpbiB0aGUgYnJvd3NlciBhbmQgZmFsbHMgYmFjayB0byBpbi1tZW1vcnkgc3RvcmFnZS5cbiAqXG4gKiBAbW9kdWxlIHN0b3JhZ2VcbiAqL1xuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNsYXNzIFZhclN0b3JhZ2VQb2x5ZmlsbCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAgICogQHBhcmFtIHthbnl9IG5ld1ZhbHVlXG4gICAqL1xuICBzZXRJdGVtIChrZXksIG5ld1ZhbHVlKSB7XG4gICAgdGhpcy5tYXAuc2V0KGtleSwgbmV3VmFsdWUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKi9cbiAgZ2V0SXRlbSAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMubWFwLmdldChrZXkpXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHR5cGUge2FueX1cbiAqL1xubGV0IF9sb2NhbFN0b3JhZ2UgPSBuZXcgVmFyU3RvcmFnZVBvbHlmaWxsKClcbmxldCB1c2VQb2x5ZmlsbCA9IHRydWVcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG50cnkge1xuICAvLyBpZiB0aGUgc2FtZS1vcmlnaW4gcnVsZSBpcyB2aW9sYXRlZCwgYWNjZXNzaW5nIGxvY2FsU3RvcmFnZSBtaWdodCB0aHJvd24gYW4gZXJyb3JcbiAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmIGxvY2FsU3RvcmFnZSkge1xuICAgIF9sb2NhbFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2VcbiAgICB1c2VQb2x5ZmlsbCA9IGZhbHNlXG4gIH1cbn0gY2F0Y2ggKGUpIHsgfVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBUaGlzIGlzIGJhc2ljYWxseSBsb2NhbFN0b3JhZ2UgaW4gYnJvd3Nlciwgb3IgYSBwb2x5ZmlsbCBpbiBub2RlanNcbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB2YXJTdG9yYWdlID0gX2xvY2FsU3RvcmFnZVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZXZlbnQgPT4gey4ufSlgIHRoYXQgZG9lcyBub3RoaW5nIGlmIHRoZSBwb2x5ZmlsbCBpcyBiZWluZyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeyBrZXk6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB9KTogdm9pZH0gZXZlbnRIYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBvbkNoYW5nZSA9IGV2ZW50SGFuZGxlciA9PiB1c2VQb2x5ZmlsbCB8fCBhZGRFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgLyoqIEB0eXBlIHthbnl9ICovIChldmVudEhhbmRsZXIpKVxuXG4vKipcbiAqIEEgcG9seWZpbGwgZm9yIGByZW1vdmVFdmVudExpc3RlbmVyKCdzdG9yYWdlJywgZXZlbnQgPT4gey4ufSlgIHRoYXQgZG9lcyBub3RoaW5nIGlmIHRoZSBwb2x5ZmlsbCBpcyBiZWluZyB1c2VkLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oeyBrZXk6IHN0cmluZywgbmV3VmFsdWU6IHN0cmluZywgb2xkVmFsdWU6IHN0cmluZyB9KTogdm9pZH0gZXZlbnRIYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqL1xuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBvZmZDaGFuZ2UgPSBldmVudEhhbmRsZXIgPT4gdXNlUG9seWZpbGwgfHwgcmVtb3ZlRXZlbnRMaXN0ZW5lcignc3RvcmFnZScsIC8qKiBAdHlwZSB7YW55fSAqLyAoZXZlbnRIYW5kbGVyKSlcbiIsICIvKipcbiAqIFV0aWxpdHkgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRWNtYVNjcmlwdCBvYmplY3RzLlxuICpcbiAqIEBtb2R1bGUgb2JqZWN0XG4gKi9cblxuLyoqXG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlID0gKCkgPT4gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vKipcbiAqIE9iamVjdC5hc3NpZ25cbiAqL1xuZXhwb3J0IGNvbnN0IGFzc2lnbiA9IE9iamVjdC5hc3NpZ25cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKi9cbmV4cG9ydCBjb25zdCBrZXlzID0gT2JqZWN0LmtleXNcblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHBhcmFtIHt7W2s6c3RyaW5nXTpWfX0gb2JqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFYsc3RyaW5nKTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGZvckVhY2ggPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGYob2JqW2tleV0sIGtleSlcbiAgfVxufVxuXG4vKipcbiAqIEB0b2RvIGltcGxlbWVudCBtYXBUb0FycmF5ICYgbWFwXG4gKlxuICogQHRlbXBsYXRlIFJcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXAgPSAob2JqLCBmKSA9PiB7XG4gIGNvbnN0IHJlc3VsdHMgPSBbXVxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICByZXN1bHRzLnB1c2goZihvYmpba2V5XSwga2V5KSlcbiAgfVxuICByZXR1cm4gcmVzdWx0c1xufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBvYmplY3Quc2l6ZSBpbnN0ZWFkXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gb2JqXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBjb25zdCBsZW5ndGggPSBvYmogPT4ga2V5cyhvYmopLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNpemUgPSBvYmogPT4ga2V5cyhvYmopLmxlbmd0aFxuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0PHN0cmluZyxhbnk+fSBvYmpcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LHN0cmluZyk6Ym9vbGVhbn0gZlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IHNvbWUgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChmKG9ialtrZXldLCBrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdHx1bmRlZmluZWR9IG9ialxuICovXG5leHBvcnQgY29uc3QgaXNFbXB0eSA9IG9iaiA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICBmb3IgKGNvbnN0IF9rIGluIG9iaikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IG9ialxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksc3RyaW5nKTpib29sZWFufSBmXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXZlcnkgPSAob2JqLCBmKSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmICghZihvYmpba2V5XSwga2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQ2FsbHMgYE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7YW55fSBvYmpcbiAqIEBwYXJhbSB7c3RyaW5nfHN5bWJvbH0ga2V5XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaGFzUHJvcGVydHkgPSAob2JqLCBrZXkpID0+IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYVxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbEZsYXQgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoc2l6ZShhKSA9PT0gc2l6ZShiKSAmJiBldmVyeShhLCAodmFsLCBrZXkpID0+ICh2YWwgIT09IHVuZGVmaW5lZCB8fCBoYXNQcm9wZXJ0eShiLCBrZXkpKSAmJiBiW2tleV0gPT09IHZhbCkpXG4iLCAiLyoqXG4gKiBDb21tb24gZnVuY3Rpb25zIGFuZCBmdW5jdGlvbiBjYWxsIGhlbHBlcnMuXG4gKlxuICogQG1vZHVsZSBmdW5jdGlvblxuICovXG5cbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5pbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnLi9vYmplY3QuanMnXG5cbi8qKlxuICogQ2FsbHMgYWxsIGZ1bmN0aW9ucyBpbiBgZnNgIHdpdGggYXJncy4gT25seSB0aHJvd3MgYWZ0ZXIgYWxsIGZ1bmN0aW9ucyB3ZXJlIGNhbGxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uPn0gZnNcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgY2FsbEFsbCA9IChmcywgYXJncywgaSA9IDApID0+IHtcbiAgdHJ5IHtcbiAgICBmb3IgKDsgaSA8IGZzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmc1tpXSguLi5hcmdzKVxuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoaSA8IGZzLmxlbmd0aCkge1xuICAgICAgY2FsbEFsbChmcywgYXJncywgaSArIDEpXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBub3AgPSAoKSA9PiB7fVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6VH0gZlxuICogQHJldHVybiB7VH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5ID0gZiA9PiBmKClcblxuLyoqXG4gKiBAdGVtcGxhdGUgQVxuICpcbiAqIEBwYXJhbSB7QX0gYVxuICogQHJldHVybiB7QX1cbiAqL1xuZXhwb3J0IGNvbnN0IGlkID0gYSA9PiBhXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqXG4gKiBAcGFyYW0ge1R9IGFcbiAqIEBwYXJhbSB7VH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsaXR5U3RyaWN0ID0gKGEsIGIpID0+IGEgPT09IGJcblxuLyoqXG4gKiBAdGVtcGxhdGUgVFxuICpcbiAqIEBwYXJhbSB7QXJyYXk8VD58b2JqZWN0fSBhXG4gKiBAcGFyYW0ge0FycmF5PFQ+fG9iamVjdH0gYlxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGNvbnN0IGVxdWFsaXR5RmxhdCA9IChhLCBiKSA9PiBhID09PSBiIHx8IChhICE9IG51bGwgJiYgYiAhPSBudWxsICYmIGEuY29uc3RydWN0b3IgPT09IGIuY29uc3RydWN0b3IgJiYgKChhcnJheS5pc0FycmF5KGEpICYmIGFycmF5LmVxdWFsRmxhdChhLCAvKiogQHR5cGUge0FycmF5PFQ+fSAqLyAoYikpKSB8fCAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIG9iamVjdC5lcXVhbEZsYXQoYSwgYikpKSlcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGFcbiAqIEBwYXJhbSB7YW55fSBiXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgZXF1YWxpdHlEZWVwID0gKGEsIGIpID0+IHtcbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHtcbiAgICByZXR1cm4gZXF1YWxpdHlTdHJpY3QoYSwgYilcbiAgfVxuICBpZiAoYS5jb25zdHJ1Y3RvciAhPT0gYi5jb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG4gIGlmIChhID09PSBiKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBzd2l0Y2ggKGEuY29uc3RydWN0b3IpIHtcbiAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgYSA9IG5ldyBVaW50OEFycmF5KGEpXG4gICAgICBiID0gbmV3IFVpbnQ4QXJyYXkoYilcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICBjYXNlIFVpbnQ4QXJyYXk6IHtcbiAgICAgIGlmIChhLmJ5dGVMZW5ndGggIT09IGIuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIFNldDoge1xuICAgICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBhKSB7XG4gICAgICAgIGlmICghYi5oYXModmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGNhc2UgTWFwOiB7XG4gICAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBhLmtleXMoKSkge1xuICAgICAgICBpZiAoIWIuaGFzKGtleSkgfHwgIWVxdWFsaXR5RGVlcChhLmdldChrZXkpLCBiLmdldChrZXkpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIE9iamVjdDpcbiAgICAgIGlmIChvYmplY3QubGVuZ3RoKGEpICE9PSBvYmplY3QubGVuZ3RoKGIpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgICAgICBpZiAoIW9iamVjdC5oYXNQcm9wZXJ0eShhLCBrZXkpIHx8ICFlcXVhbGl0eURlZXAoYVtrZXldLCBiW2tleV0pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSBBcnJheTpcbiAgICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKCFlcXVhbGl0eURlZXAoYVtpXSwgYltpXSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgVlxuICogQHRlbXBsYXRlIHtWfSBPUFRTXG4gKlxuICogQHBhcmFtIHtWfSB2YWx1ZVxuICogQHBhcmFtIHtBcnJheTxPUFRTPn0gb3B0aW9uc1xuICovXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgaXNPbmVPZiA9ICh2YWx1ZSwgb3B0aW9ucykgPT4gb3B0aW9ucy5pbmNsdWRlcyh2YWx1ZSlcbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gYXJyYXkuaXNBcnJheVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzXG4gKiBAcmV0dXJuIHtzIGlzIFN0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IGlzU3RyaW5nID0gKHMpID0+IHMgJiYgcy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG5cbiAqIEByZXR1cm4ge24gaXMgTnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgaXNOdW1iZXIgPSBuID0+IG4gIT0gbnVsbCAmJiBuLmNvbnN0cnVjdG9yID09PSBOdW1iZXJcblxuLyoqXG4gKiBAdGVtcGxhdGUge2Fic3RyYWN0IG5ldyAoLi4uYXJnczogYW55KSA9PiBhbnl9IFRZUEVcbiAqIEBwYXJhbSB7YW55fSBuXG4gKiBAcGFyYW0ge1RZUEV9IFRcbiAqIEByZXR1cm4ge24gaXMgSW5zdGFuY2VUeXBlPFRZUEU+fVxuICovXG5leHBvcnQgY29uc3QgaXMgPSAobiwgVCkgPT4gbiAmJiBuLmNvbnN0cnVjdG9yID09PSBUXG5cbi8qKlxuICogQHRlbXBsYXRlIHthYnN0cmFjdCBuZXcgKC4uLmFyZ3M6IGFueSkgPT4gYW55fSBUWVBFXG4gKiBAcGFyYW0ge1RZUEV9IFRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzVGVtcGxhdGUgPSAoVCkgPT5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBuXG4gICAqIEByZXR1cm4ge24gaXMgSW5zdGFuY2VUeXBlPFRZUEU+fVxuICAgKiovXG4gIG4gPT4gbiAmJiBuLmNvbnN0cnVjdG9yID09PSBUXG4iLCAiLyoqXG4gKiBJc29tb3JwaGljIG1vZHVsZSB0byB3b3JrIGFjY2VzcyB0aGUgZW52aXJvbm1lbnQgKHF1ZXJ5IHBhcmFtcywgZW52IHZhcmlhYmxlcykuXG4gKlxuICogQG1vZHVsZSBtYXBcbiAqL1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBjb25kaXRpb25zIGZyb20gJy4vY29uZGl0aW9ucy5qcydcbmltcG9ydCAqIGFzIHN0b3JhZ2UgZnJvbSAnLi9zdG9yYWdlLmpzJ1xuaW1wb3J0ICogYXMgZiBmcm9tICcuL2Z1bmN0aW9uLmpzJ1xuXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG4vLyBAdHMtaWdub3JlXG5leHBvcnQgY29uc3QgaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MucmVsZWFzZSAmJiAvbm9kZXxpb1xcLmpzLy50ZXN0KHByb2Nlc3MucmVsZWFzZS5uYW1lKSAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXSdcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmICFpc05vZGVcbi8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbmV4cG9ydCBjb25zdCBpc01hYyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gID8gL01hYy8udGVzdChuYXZpZ2F0b3IucGxhdGZvcm0pXG4gIDogZmFsc2VcblxuLyoqXG4gKiBAdHlwZSB7TWFwPHN0cmluZyxzdHJpbmc+fVxuICovXG5sZXQgcGFyYW1zXG5jb25zdCBhcmdzID0gW11cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBjb21wdXRlUGFyYW1zID0gKCkgPT4ge1xuICBpZiAocGFyYW1zID09PSB1bmRlZmluZWQpIHtcbiAgICBpZiAoaXNOb2RlKSB7XG4gICAgICBwYXJhbXMgPSBtYXAuY3JlYXRlKClcbiAgICAgIGNvbnN0IHBhcmdzID0gcHJvY2Vzcy5hcmd2XG4gICAgICBsZXQgY3VyclBhcmFtTmFtZSA9IG51bGxcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGFyZyA9IHBhcmdzW2ldXG4gICAgICAgIGlmIChwYXJnWzBdID09PSAnLScpIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCAnJylcbiAgICAgICAgICB9XG4gICAgICAgICAgY3VyclBhcmFtTmFtZSA9IHBhcmdcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zLnNldChjdXJyUGFyYW1OYW1lLCBwYXJnKVxuICAgICAgICAgICAgY3VyclBhcmFtTmFtZSA9IG51bGxcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJncy5wdXNoKHBhcmcpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY3VyclBhcmFtTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBwYXJhbXMuc2V0KGN1cnJQYXJhbU5hbWUsICcnKVxuICAgICAgfVxuICAgICAgLy8gaW4gUmVhY3ROYXRpdmUgZm9yIGV4YW1wbGUgdGhpcyB3b3VsZCBub3QgYmUgdHJ1ZSAodW5sZXNzIGNvbm5lY3RlZCB0byB0aGUgUmVtb3RlIERlYnVnZ2VyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGxvY2F0aW9uID09PSAnb2JqZWN0Jykge1xuICAgICAgcGFyYW1zID0gbWFwLmNyZWF0ZSgpOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICAgIChsb2NhdGlvbi5zZWFyY2ggfHwgJz8nKS5zbGljZSgxKS5zcGxpdCgnJicpLmZvckVhY2goKGt2KSA9PiB7XG4gICAgICAgIGlmIChrdi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICBjb25zdCBba2V5LCB2YWx1ZV0gPSBrdi5zcGxpdCgnPScpXG4gICAgICAgICAgcGFyYW1zLnNldChgLS0ke3N0cmluZy5mcm9tQ2FtZWxDYXNlKGtleSwgJy0nKX1gLCB2YWx1ZSlcbiAgICAgICAgICBwYXJhbXMuc2V0KGAtJHtzdHJpbmcuZnJvbUNhbWVsQ2FzZShrZXksICctJyl9YCwgdmFsdWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmFtcyA9IG1hcC5jcmVhdGUoKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGhhc1BhcmFtID0gKG5hbWUpID0+IGNvbXB1dGVQYXJhbXMoKS5oYXMobmFtZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IGRlZmF1bHRWYWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IGdldFBhcmFtID0gKG5hbWUsIGRlZmF1bHRWYWwpID0+XG4gIGNvbXB1dGVQYXJhbXMoKS5nZXQobmFtZSkgfHwgZGVmYXVsdFZhbFxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgNCAqL1xuZXhwb3J0IGNvbnN0IGdldFZhcmlhYmxlID0gKG5hbWUpID0+XG4gIGlzTm9kZVxuICAgID8gY29uZGl0aW9ucy51bmRlZmluZWRUb051bGwocHJvY2Vzcy5lbnZbbmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2VBbGwoJy0nLCAnXycpXSlcbiAgICA6IGNvbmRpdGlvbnMudW5kZWZpbmVkVG9OdWxsKHN0b3JhZ2UudmFyU3RvcmFnZS5nZXRJdGVtKG5hbWUpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVsbH1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IGdldENvbmYgPSAobmFtZSkgPT5cbiAgY29tcHV0ZVBhcmFtcygpLmdldCgnLS0nICsgbmFtZSkgfHwgZ2V0VmFyaWFibGUobmFtZSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCA1ICovXG5leHBvcnQgY29uc3QgZW5zdXJlQ29uZiA9IChuYW1lKSA9PiB7XG4gIGNvbnN0IGMgPSBnZXRDb25mKG5hbWUpXG4gIGlmIChjID09IG51bGwpIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgY29uZmlndXJhdGlvbiBcIiR7bmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2VBbGwoJy0nLCAnXycpfVwiYClcbiAgcmV0dXJuIGNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuLyogYzggaWdub3JlIG5leHQgMiAqL1xuZXhwb3J0IGNvbnN0IGhhc0NvbmYgPSAobmFtZSkgPT5cbiAgaGFzUGFyYW0oJy0tJyArIG5hbWUpIHx8IGdldFZhcmlhYmxlKG5hbWUpICE9PSBudWxsXG5cbi8qIGM4IGlnbm9yZSBuZXh0ICovXG5leHBvcnQgY29uc3QgcHJvZHVjdGlvbiA9IGhhc0NvbmYoJ3Byb2R1Y3Rpb24nKVxuXG4vKiBjOCBpZ25vcmUgbmV4dCAyICovXG5jb25zdCBmb3JjZUNvbG9yID0gaXNOb2RlICYmXG4gIGYuaXNPbmVPZihwcm9jZXNzLmVudi5GT1JDRV9DT0xPUiwgWyd0cnVlJywgJzEnLCAnMiddKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0NvbG9yID0gIWhhc1BhcmFtKCctLW5vLWNvbG9ycycpICYmXG4gICghaXNOb2RlIHx8IHByb2Nlc3Muc3Rkb3V0LmlzVFRZIHx8IGZvcmNlQ29sb3IpICYmIChcbiAgIWlzTm9kZSB8fCBoYXNQYXJhbSgnLS1jb2xvcicpIHx8IGZvcmNlQ29sb3IgfHxcbiAgICBnZXRWYXJpYWJsZSgnQ09MT1JURVJNJykgIT09IG51bGwgfHxcbiAgICAoZ2V0VmFyaWFibGUoJ1RFUk0nKSB8fCAnJykuaW5jbHVkZXMoJ2NvbG9yJylcbilcbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iLCAiLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9ucyB0byB3b3JrIHdpdGggYnVmZmVycyAoVWludDhBcnJheSkuXG4gKlxuICogQG1vZHVsZSBidWZmZXJcbiAqL1xuXG5pbXBvcnQgKiBhcyBzdHJpbmcgZnJvbSAnLi9zdHJpbmcuanMnXG5pbXBvcnQgKiBhcyBlbnYgZnJvbSAnLi9lbnZpcm9ubWVudC5qcydcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJy4vYXJyYXkuanMnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJy4vbWF0aC5qcydcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJy4vZW5jb2RpbmcuanMnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICcuL2RlY29kaW5nLmpzJ1xuXG4vKipcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuID0gbGVuID0+IG5ldyBVaW50OEFycmF5KGxlbilcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICogQHBhcmFtIHtudW1iZXJ9IGJ5dGVPZmZzZXRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyID0gKGJ1ZmZlciwgYnl0ZU9mZnNldCwgbGVuZ3RoKSA9PiBuZXcgVWludDhBcnJheShidWZmZXIsIGJ5dGVPZmZzZXQsIGxlbmd0aClcblxuLyoqXG4gKiBDcmVhdGUgVWludDhBcnJheSB3aXRoIGluaXRpYWwgY29udGVudCBmcm9tIGJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGJ1ZmZlclxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVWludDhBcnJheUZyb21BcnJheUJ1ZmZlciA9IGJ1ZmZlciA9PiBuZXcgVWludDhBcnJheShidWZmZXIpXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ5dGVzXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IHRvQmFzZTY0QnJvd3NlciA9IGJ5dGVzID0+IHtcbiAgbGV0IHMgPSAnJ1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmJ5dGVMZW5ndGg7IGkrKykge1xuICAgIHMgKz0gc3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSlcbiAgfVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuIGJ0b2Eocylcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBieXRlc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCB0b0Jhc2U2NE5vZGUgPSBieXRlcyA9PiBCdWZmZXIuZnJvbShieXRlcy5idWZmZXIsIGJ5dGVzLmJ5dGVPZmZzZXQsIGJ5dGVzLmJ5dGVMZW5ndGgpLnRvU3RyaW5nKCdiYXNlNjQnKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmNvbnN0IGZyb21CYXNlNjRCcm93c2VyID0gcyA9PiB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjb25zdCBhID0gYXRvYihzKVxuICBjb25zdCBieXRlcyA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKGEubGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICBieXRlc1tpXSA9IGEuY2hhckNvZGVBdChpKVxuICB9XG4gIHJldHVybiBieXRlc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICovXG5jb25zdCBmcm9tQmFzZTY0Tm9kZSA9IHMgPT4ge1xuICBjb25zdCBidWYgPSBCdWZmZXIuZnJvbShzLCAnYmFzZTY0JylcbiAgcmV0dXJuIGNyZWF0ZVVpbnQ4QXJyYXlWaWV3RnJvbUFycmF5QnVmZmVyKGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aClcbn1cblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCB0b0Jhc2U2NCA9IGVudi5pc0Jyb3dzZXIgPyB0b0Jhc2U2NEJyb3dzZXIgOiB0b0Jhc2U2NE5vZGVcblxuLyogYzggaWdub3JlIG5leHQgKi9cbmV4cG9ydCBjb25zdCBmcm9tQmFzZTY0ID0gZW52LmlzQnJvd3NlciA/IGZyb21CYXNlNjRCcm93c2VyIDogZnJvbUJhc2U2NE5vZGVcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGJhc2U2NHVybCAtIHNlZSBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL3JmYzQ2NDgjc2VjdGlvbi01XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICovXG5leHBvcnQgY29uc3QgdG9CYXNlNjRVcmxFbmNvZGVkID0gYnVmID0+IHRvQmFzZTY0KGJ1ZikucmVwbGFjZUFsbCgnKycsICctJykucmVwbGFjZUFsbCgnLycsICdfJykucmVwbGFjZUFsbCgnPScsICcnKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRcbiAqL1xuZXhwb3J0IGNvbnN0IGZyb21CYXNlNjRVcmxFbmNvZGVkID0gYmFzZTY0ID0+IGZyb21CYXNlNjQoYmFzZTY0LnJlcGxhY2VBbGwoJy0nLCAnKycpLnJlcGxhY2VBbGwoJ18nLCAnLycpKVxuXG4vKipcbiAqIEJhc2U2NCBpcyBhbHdheXMgYSBtb3JlIGVmZmljaWVudCBjaG9pY2UuIFRoaXMgZXhpc3RzIGZvciB1dGlsaXR5IHB1cnBvc2VzIG9ubHkuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqL1xuZXhwb3J0IGNvbnN0IHRvSGV4U3RyaW5nID0gYnVmID0+IGFycmF5Lm1hcChidWYsIGIgPT4gYi50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSkuam9pbignJylcblxuLyoqXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGV4cGVjdHMgdGhhdCB0aGUgaGV4IGRvZXNuJ3Qgc3RhcnQgd2l0aCAweC4uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleFxuICovXG5leHBvcnQgY29uc3QgZnJvbUhleFN0cmluZyA9IGhleCA9PiB7XG4gIGNvbnN0IGhsZW4gPSBoZXgubGVuZ3RoXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KG1hdGguY2VpbChobGVuIC8gMikpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaGxlbjsgaSArPSAyKSB7XG4gICAgYnVmW2J1Zi5sZW5ndGggLSBpIC8gMiAtIDFdID0gTnVtYmVyLnBhcnNlSW50KGhleC5zbGljZShobGVuIC0gaSAtIDIsIGhsZW4gLSBpKSwgMTYpXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIENvcHkgdGhlIGNvbnRlbnQgb2YgYW4gVWludDhBcnJheSB2aWV3IHRvIGEgbmV3IEFycmF5QnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdWludDhBcnJheVxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGNvcHlVaW50OEFycmF5ID0gdWludDhBcnJheSA9PiB7XG4gIGNvbnN0IG5ld0J1ZiA9IGNyZWF0ZVVpbnQ4QXJyYXlGcm9tTGVuKHVpbnQ4QXJyYXkuYnl0ZUxlbmd0aClcbiAgbmV3QnVmLnNldCh1aW50OEFycmF5KVxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qKlxuICogRW5jb2RlIGFueXRoaW5nIGFzIGEgVUludDhBcnJheS4gSXQncyBhIHB1biBvbiB0eXBlc2NyaXB0cydzIGBhbnlgIHR5cGUuXG4gKiBTZWUgZW5jb2Rpbmcud3JpdGVBbnkgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gKlxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBbnkgPSBkYXRhID0+XG4gIGVuY29kaW5nLmVuY29kZShlbmNvZGVyID0+IGVuY29kaW5nLndyaXRlQW55KGVuY29kZXIsIGRhdGEpKVxuXG4vKipcbiAqIERlY29kZSBhbiBhbnktZW5jb2RlZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlQW55ID0gYnVmID0+IGRlY29kaW5nLnJlYWRBbnkoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKVxuXG4vKipcbiAqIFNoaWZ0IEJ5dGUgQXJyYXkge059IGJpdHMgdG8gdGhlIGxlZnQuIERvZXMgbm90IGV4cGFuZCBieXRlIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBOIHNob3VsZCBiZSBpbiB0aGUgcmFuZ2Ugb2YgWzAtN11cbiAqL1xuZXhwb3J0IGNvbnN0IHNoaWZ0TkJpdHNMZWZ0ID0gKGJzLCBOKSA9PiB7XG4gIGlmIChOID09PSAwKSByZXR1cm4gYnNcbiAgYnMgPSBuZXcgVWludDhBcnJheShicylcbiAgYnNbMF0gPDw9IE5cbiAgZm9yIChsZXQgaSA9IDE7IGkgPCBicy5sZW5ndGg7IGkrKykge1xuICAgIGJzW2kgLSAxXSB8PSBic1tpXSA+Pj4gKDggLSBOKVxuICAgIGJzW2ldIDw8PSBOXG4gIH1cbiAgcmV0dXJuIGJzXG59XG4iLCAiLyoqXG4gKiBXb3JraW5nIHdpdGggdmFsdWUgcGFpcnMuXG4gKlxuICogQG1vZHVsZSBwYWlyXG4gKi9cblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKi9cbmV4cG9ydCBjbGFzcyBQYWlyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7TH0gbGVmdFxuICAgKiBAcGFyYW0ge1J9IHJpZ2h0XG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVmdCwgcmlnaHQpIHtcbiAgICB0aGlzLmxlZnQgPSBsZWZ0XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgTCxSXG4gKiBAcGFyYW0ge0x9IGxlZnRcbiAqIEBwYXJhbSB7Un0gcmlnaHRcbiAqIEByZXR1cm4ge1BhaXI8TCxSPn1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IChsZWZ0LCByaWdodCkgPT4gbmV3IFBhaXIobGVmdCwgcmlnaHQpXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtSfSByaWdodFxuICogQHBhcmFtIHtMfSBsZWZ0XG4gKiBAcmV0dXJuIHtQYWlyPEwsUj59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVSZXZlcnNlZCA9IChyaWdodCwgbGVmdCkgPT4gbmV3IFBhaXIobGVmdCwgcmlnaHQpXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUlxuICogQHBhcmFtIHtBcnJheTxQYWlyPEwsUj4+fSBhcnJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oTCwgUik6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCBmb3JFYWNoID0gKGFyciwgZikgPT4gYXJyLmZvckVhY2gocCA9PiBmKHAubGVmdCwgcC5yaWdodCkpXG5cbi8qKlxuICogQHRlbXBsYXRlIEwsUixYXG4gKiBAcGFyYW0ge0FycmF5PFBhaXI8TCxSPj59IGFyclxuICogQHBhcmFtIHtmdW5jdGlvbihMLCBSKTpYfSBmXG4gKiBAcmV0dXJuIHtBcnJheTxYPn1cbiAqL1xuZXhwb3J0IGNvbnN0IG1hcCA9IChhcnIsIGYpID0+IGFyci5tYXAocCA9PiBmKHAubGVmdCwgcC5yaWdodCkpXG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVXRpbGl0eSBtb2R1bGUgdG8gd29yayB3aXRoIHRoZSBET00uXG4gKlxuICogQG1vZHVsZSBkb21cbiAqL1xuXG5pbXBvcnQgKiBhcyBwYWlyIGZyb20gJy4vcGFpci5qcydcbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEB0eXBlIHtEb2N1bWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRvYyA9IC8qKiBAdHlwZSB7RG9jdW1lbnR9ICovICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnID8gZG9jdW1lbnQgOiB7fSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVFbGVtZW50ID0gbmFtZSA9PiBkb2MuY3JlYXRlRWxlbWVudChuYW1lKVxuXG4vKipcbiAqIEByZXR1cm4ge0RvY3VtZW50RnJhZ21lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVEb2N1bWVudEZyYWdtZW50ID0gKCkgPT4gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtUZXh0fVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlVGV4dE5vZGUgPSB0ZXh0ID0+IGRvYy5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxuXG5leHBvcnQgY29uc3QgZG9tUGFyc2VyID0gLyoqIEB0eXBlIHtET01QYXJzZXJ9ICovICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBET01QYXJzZXIoKSA6IG51bGwpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICovXG5leHBvcnQgY29uc3QgZW1pdEN1c3RvbUV2ZW50ID0gKGVsLCBuYW1lLCBvcHRzKSA9PiBlbC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCBvcHRzKSlcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nfGJvb2xlYW4+Pn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcmV0dXJuIHtFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3Qgc2V0QXR0cmlidXRlcyA9IChlbCwgYXR0cnMpID0+IHtcbiAgcGFpci5mb3JFYWNoKGF0dHJzLCAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gZmFsc2UpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShrZXkpXG4gICAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwgJycpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIGVsXG59XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICogQHBhcmFtIHtNYXA8c3RyaW5nLCBzdHJpbmc+fSBhdHRycyBBcnJheSBvZiBrZXktdmFsdWUgcGFpcnNcbiAqIEByZXR1cm4ge0VsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBzZXRBdHRyaWJ1dGVzTWFwID0gKGVsLCBhdHRycykgPT4ge1xuICBhdHRycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7IGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKSB9KVxuICByZXR1cm4gZWxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fEhUTUxDb2xsZWN0aW9ufSBjaGlsZHJlblxuICogQHJldHVybiB7RG9jdW1lbnRGcmFnbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGZyYWdtZW50ID0gY2hpbGRyZW4gPT4ge1xuICBjb25zdCBmcmFnbWVudCA9IGNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgYXBwZW5kQ2hpbGQoZnJhZ21lbnQsIGNoaWxkcmVuW2ldKVxuICB9XG4gIHJldHVybiBmcmFnbWVudFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50XG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBub2Rlc1xuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZCA9IChwYXJlbnQsIG5vZGVzKSA9PiB7XG4gIGFwcGVuZENoaWxkKHBhcmVudCwgZnJhZ21lbnQobm9kZXMpKVxuICByZXR1cm4gcGFyZW50XG59XG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxcbiAqL1xuZXhwb3J0IGNvbnN0IHJlbW92ZSA9IGVsID0+IGVsLnJlbW92ZSgpXG5cbi8qKlxuICogQHBhcmFtIHtFdmVudFRhcmdldH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0V2ZW50TGlzdGVuZXJ9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50TGlzdGVuZXIgPSAoZWwsIG5hbWUsIGYpID0+IGVsLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZilcblxuLyoqXG4gKiBAcGFyYW0ge0V2ZW50VGFyZ2V0fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7RXZlbnRMaXN0ZW5lcn0gZlxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lciA9IChlbCwgbmFtZSwgZikgPT4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCBmKVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLEV2ZW50TGlzdGVuZXI+Pn0gbGlzdGVuZXJzXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgY29uc3QgYWRkRXZlbnRMaXN0ZW5lcnMgPSAobm9kZSwgbGlzdGVuZXJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChsaXN0ZW5lcnMsIChuYW1lLCBmKSA9PiBhZGRFdmVudExpc3RlbmVyKG5vZGUsIG5hbWUsIGYpKVxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtBcnJheTxwYWlyLlBhaXI8c3RyaW5nLEV2ZW50TGlzdGVuZXI+Pn0gbGlzdGVuZXJzXG4gKiBAcmV0dXJuIHtOb2RlfVxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlRXZlbnRMaXN0ZW5lcnMgPSAobm9kZSwgbGlzdGVuZXJzKSA9PiB7XG4gIHBhaXIuZm9yRWFjaChsaXN0ZW5lcnMsIChuYW1lLCBmKSA9PiByZW1vdmVFdmVudExpc3RlbmVyKG5vZGUsIG5hbWUsIGYpKVxuICByZXR1cm4gbm9kZVxufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge0FycmF5PHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPnxwYWlyLlBhaXI8c3RyaW5nLGJvb2xlYW4+Pn0gYXR0cnMgQXJyYXkgb2Yga2V5LXZhbHVlIHBhaXJzXG4gKiBAcGFyYW0ge0FycmF5PE5vZGU+fSBjaGlsZHJlblxuICogQHJldHVybiB7RWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGVsZW1lbnQgPSAobmFtZSwgYXR0cnMgPSBbXSwgY2hpbGRyZW4gPSBbXSkgPT5cbiAgYXBwZW5kKHNldEF0dHJpYnV0ZXMoY3JlYXRlRWxlbWVudChuYW1lKSwgYXR0cnMpLCBjaGlsZHJlbilcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGhcbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHRcbiAqL1xuZXhwb3J0IGNvbnN0IGNhbnZhcyA9ICh3aWR0aCwgaGVpZ2h0KSA9PiB7XG4gIGNvbnN0IGMgPSAvKiogQHR5cGUge0hUTUxDYW52YXNFbGVtZW50fSAqLyAoY3JlYXRlRWxlbWVudCgnY2FudmFzJykpXG4gIGMuaGVpZ2h0ID0gaGVpZ2h0XG4gIGMud2lkdGggPSB3aWR0aFxuICByZXR1cm4gY1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0XG4gKiBAcmV0dXJuIHtUZXh0fVxuICovXG5leHBvcnQgY29uc3QgdGV4dCA9IGNyZWF0ZVRleHROb2RlXG5cbi8qKlxuICogQHBhcmFtIHtwYWlyLlBhaXI8c3RyaW5nLHN0cmluZz59IHBhaXJcbiAqL1xuZXhwb3J0IGNvbnN0IHBhaXJUb1N0eWxlU3RyaW5nID0gcGFpciA9PiBgJHtwYWlyLmxlZnR9OiR7cGFpci5yaWdodH07YFxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8cGFpci5QYWlyPHN0cmluZyxzdHJpbmc+Pn0gcGFpcnNcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGNvbnN0IHBhaXJzVG9TdHlsZVN0cmluZyA9IHBhaXJzID0+IHBhaXJzLm1hcChwYWlyVG9TdHlsZVN0cmluZykuam9pbignJylcblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsc3RyaW5nPn0gbVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3QgbWFwVG9TdHlsZVN0cmluZyA9IG0gPT4gbWFwLm1hcChtLCAodmFsdWUsIGtleSkgPT4gYCR7a2V5fToke3ZhbHVlfTtgKS5qb2luKCcnKVxuXG4vKipcbiAqIEB0b2RvIHNob3VsZCBhbHdheXMgcXVlcnkgb24gYSBkb20gZWxlbWVudFxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U2hhZG93Um9vdH0gZWxcbiAqIEBwYXJhbSB7c3RyaW5nfSBxdWVyeVxuICogQHJldHVybiB7SFRNTEVsZW1lbnQgfCBudWxsfVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlTZWxlY3RvciA9IChlbCwgcXVlcnkpID0+IGVsLnF1ZXJ5U2VsZWN0b3IocXVlcnkpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxTaGFkb3dSb290fSBlbFxuICogQHBhcmFtIHtzdHJpbmd9IHF1ZXJ5XG4gKiBAcmV0dXJuIHtOb2RlTGlzdE9mPEhUTUxFbGVtZW50Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHF1ZXJ5U2VsZWN0b3JBbGwgPSAoZWwsIHF1ZXJ5KSA9PiBlbC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRFbGVtZW50QnlJZCA9IGlkID0+IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChkb2MuZ2V0RWxlbWVudEJ5SWQoaWQpKVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuY29uc3QgX3BhcnNlID0gaHRtbCA9PiBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKGA8aHRtbD48Ym9keT4ke2h0bWx9PC9ib2R5PjwvaHRtbD5gLCAndGV4dC9odG1sJykuYm9keVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAcmV0dXJuIHtEb2N1bWVudEZyYWdtZW50fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VGcmFnbWVudCA9IGh0bWwgPT4gZnJhZ21lbnQoLyoqIEB0eXBlIHthbnl9ICovIChfcGFyc2UoaHRtbCkuY2hpbGROb2RlcykpXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2VFbGVtZW50ID0gaHRtbCA9PiAvKiogQHR5cGUgSFRNTEVsZW1lbnQgKi8gKF9wYXJzZShodG1sKS5maXJzdEVsZW1lbnRDaGlsZClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvbGRFbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudHxEb2N1bWVudEZyYWdtZW50fSBuZXdFbFxuICovXG5leHBvcnQgY29uc3QgcmVwbGFjZVdpdGggPSAob2xkRWwsIG5ld0VsKSA9PiBvbGRFbC5yZXBsYWNlV2l0aChuZXdFbClcblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcGFyYW0ge05vZGV8bnVsbH0gcmVmXG4gKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAqL1xuZXhwb3J0IGNvbnN0IGluc2VydEJlZm9yZSA9IChwYXJlbnQsIGVsLCByZWYpID0+IHBhcmVudC5pbnNlcnRCZWZvcmUoZWwsIHJlZilcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtOb2RlfSBjaGlsZFxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGVuZENoaWxkID0gKHBhcmVudCwgY2hpbGQpID0+IHBhcmVudC5hcHBlbmRDaGlsZChjaGlsZClcblxuZXhwb3J0IGNvbnN0IEVMRU1FTlRfTk9ERSA9IGRvYy5FTEVNRU5UX05PREVcbmV4cG9ydCBjb25zdCBURVhUX05PREUgPSBkb2MuVEVYVF9OT0RFXG5leHBvcnQgY29uc3QgQ0RBVEFfU0VDVElPTl9OT0RFID0gZG9jLkNEQVRBX1NFQ1RJT05fTk9ERVxuZXhwb3J0IGNvbnN0IENPTU1FTlRfTk9ERSA9IGRvYy5DT01NRU5UX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9OT0RFID0gZG9jLkRPQ1VNRU5UX05PREVcbmV4cG9ydCBjb25zdCBET0NVTUVOVF9UWVBFX05PREUgPSBkb2MuRE9DVU1FTlRfVFlQRV9OT0RFXG5leHBvcnQgY29uc3QgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IGRvYy5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IG5vZGVcbiAqIEBwYXJhbSB7bnVtYmVyfSB0eXBlXG4gKi9cbmV4cG9ydCBjb25zdCBjaGVja05vZGVUeXBlID0gKG5vZGUsIHR5cGUpID0+IG5vZGUubm9kZVR5cGUgPT09IHR5cGVcblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2hpbGRcbiAqL1xuZXhwb3J0IGNvbnN0IGlzUGFyZW50T2YgPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBsZXQgcCA9IGNoaWxkLnBhcmVudE5vZGVcbiAgd2hpbGUgKHAgJiYgcCAhPT0gcGFyZW50KSB7XG4gICAgcCA9IHAucGFyZW50Tm9kZVxuICB9XG4gIHJldHVybiBwID09PSBwYXJlbnRcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iLCAiLyoqXG4gKiBKU09OIHV0aWxpdHkgZnVuY3Rpb25zLlxuICpcbiAqIEBtb2R1bGUganNvblxuICovXG5cbi8qKlxuICogVHJhbnNmb3JtIEphdmFTY3JpcHQgb2JqZWN0IHRvIEpTT04uXG4gKlxuICogQHBhcmFtIHthbnl9IG9iamVjdFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgY29uc3Qgc3RyaW5naWZ5ID0gSlNPTi5zdHJpbmdpZnlcblxuLyoqXG4gKiBQYXJzZSBKU09OIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ganNvblxuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcGFyc2UgPSBKU09OLnBhcnNlXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byB3b3JrIHdpdGggRWNtYVNjcmlwdCBTeW1ib2xzLlxuICpcbiAqIEBtb2R1bGUgc3ltYm9sXG4gKi9cblxuLyoqXG4gKiBSZXR1cm4gZnJlc2ggc3ltYm9sLlxuICpcbiAqIEByZXR1cm4ge1N5bWJvbH1cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZSA9IFN5bWJvbFxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBzXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgY29uc3QgaXNTeW1ib2wgPSBzID0+IHR5cGVvZiBzID09PSAnc3ltYm9sJ1xuIiwgImltcG9ydCAqIGFzIHN5bWJvbCBmcm9tICcuL3N5bWJvbC5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lLmpzJ1xuaW1wb3J0ICogYXMgZW52IGZyb20gJy4vZW52aXJvbm1lbnQuanMnXG5pbXBvcnQgKiBhcyBmdW5jIGZyb20gJy4vZnVuY3Rpb24uanMnXG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vanNvbi5qcydcblxuZXhwb3J0IGNvbnN0IEJPTEQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBVTkJPTEQgPSBzeW1ib2wuY3JlYXRlKClcbmV4cG9ydCBjb25zdCBCTFVFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgR1JFWSA9IHN5bWJvbC5jcmVhdGUoKVxuZXhwb3J0IGNvbnN0IEdSRUVOID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgUkVEID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgUFVSUExFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgT1JBTkdFID0gc3ltYm9sLmNyZWF0ZSgpXG5leHBvcnQgY29uc3QgVU5DT0xPUiA9IHN5bWJvbC5jcmVhdGUoKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTx1bmRlZmluZWR8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyfGZ1bmN0aW9uKCk6YW55Pn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG9iamVjdHxudW1iZXI+fVxuICovXG5leHBvcnQgY29uc3QgY29tcHV0ZU5vQ29sb3JMb2dnaW5nQXJncyA9IGFyZ3MgPT4ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXT8uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgYXJncyA9IC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gKi8gKC8qKiBAdHlwZSB7W2Z1bmN0aW9uXX0gKi8gKGFyZ3MpWzBdKCkpXG4gIH1cbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IGxvZ0FyZ3MgPSBbXVxuICAvLyB0cnkgd2l0aCBmb3JtYXR0aW5nIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHVuc3VwcG9ydGVkXG4gIGxldCBpID0gMFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBhcmcgPSBhcmdzW2ldXG4gICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBzdHJCdWlsZGVyLnB1c2goJ3VuZGVmaW5lZCcpXG4gICAgfSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgc3RyQnVpbGRlci5wdXNoKGFyZylcbiAgICB9IGVsc2UgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICBsb2dBcmdzLnB1c2goSlNPTi5zdHJpbmdpZnkoYXJnKSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGxvZ0FyZ3Ncbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbmNvbnN0IGxvZ2dpbmdDb2xvcnMgPSBbR1JFRU4sIFBVUlBMRSwgT1JBTkdFLCBCTFVFXVxubGV0IG5leHRDb2xvciA9IDBcbmxldCBsYXN0TG9nZ2luZ1RpbWUgPSB0aW1lLmdldFVuaXhUaW1lKClcblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oLi4uYW55KTp2b2lkfSBfcHJpbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcmV0dXJuIHtmdW5jdGlvbiguLi5hbnkpOnZvaWR9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNb2R1bGVMb2dnZXIgPSAoX3ByaW50LCBtb2R1bGVOYW1lKSA9PiB7XG4gIGNvbnN0IGNvbG9yID0gbG9nZ2luZ0NvbG9yc1tuZXh0Q29sb3JdXG4gIGNvbnN0IGRlYnVnUmVnZXhWYXIgPSBlbnYuZ2V0VmFyaWFibGUoJ2xvZycpXG4gIGNvbnN0IGRvTG9nZ2luZyA9IGRlYnVnUmVnZXhWYXIgIT09IG51bGwgJiZcbiAgICAoZGVidWdSZWdleFZhciA9PT0gJyonIHx8IGRlYnVnUmVnZXhWYXIgPT09ICd0cnVlJyB8fFxuICAgICAgbmV3IFJlZ0V4cChkZWJ1Z1JlZ2V4VmFyLCAnZ2knKS50ZXN0KG1vZHVsZU5hbWUpKVxuICBuZXh0Q29sb3IgPSAobmV4dENvbG9yICsgMSkgJSBsb2dnaW5nQ29sb3JzLmxlbmd0aFxuICBtb2R1bGVOYW1lICs9ICc6ICdcbiAgcmV0dXJuICFkb0xvZ2dpbmdcbiAgICA/IGZ1bmMubm9wXG4gICAgOiAoLi4uYXJncykgPT4ge1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXT8uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgICAgICAgYXJncyA9IGFyZ3NbMF0oKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVOb3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgICAgY29uc3QgdGltZURpZmYgPSB0aW1lTm93IC0gbGFzdExvZ2dpbmdUaW1lXG4gICAgICAgIGxhc3RMb2dnaW5nVGltZSA9IHRpbWVOb3dcbiAgICAgICAgX3ByaW50KFxuICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgIG1vZHVsZU5hbWUsXG4gICAgICAgICAgVU5DT0xPUixcbiAgICAgICAgICAuLi5hcmdzLm1hcCgoYXJnKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnICE9IG51bGwgJiYgYXJnLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICAgIGFyZyA9IEFycmF5LmZyb20oYXJnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdCA9IHR5cGVvZiBhcmdcbiAgICAgICAgICAgIHN3aXRjaCAodCkge1xuICAgICAgICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgICBjYXNlICdzeW1ib2wnOlxuICAgICAgICAgICAgICAgIHJldHVybiBhcmdcbiAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIHJldHVybiBqc29uLnN0cmluZ2lmeShhcmcpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KSxcbiAgICAgICAgICBjb2xvcixcbiAgICAgICAgICAnICsnICsgdGltZURpZmYgKyAnbXMnXG4gICAgICAgIClcbiAgICAgIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG4iLCAiLyoqXG4gKiBJc29tb3JwaGljIGxvZ2dpbmcgbW9kdWxlIHdpdGggc3VwcG9ydCBmb3IgY29sb3JzIVxuICpcbiAqIEBtb2R1bGUgbG9nZ2luZ1xuICovXG5cbmltcG9ydCAqIGFzIGVudiBmcm9tICcuL2Vudmlyb25tZW50LmpzJ1xuaW1wb3J0ICogYXMgc2V0IGZyb20gJy4vc2V0LmpzJ1xuaW1wb3J0ICogYXMgcGFpciBmcm9tICcuL3BhaXIuanMnXG5pbXBvcnQgKiBhcyBkb20gZnJvbSAnLi9kb20uanMnXG5pbXBvcnQgKiBhcyBqc29uIGZyb20gJy4vanNvbi5qcydcbmltcG9ydCAqIGFzIG1hcCBmcm9tICcuL21hcC5qcydcbmltcG9ydCAqIGFzIGV2ZW50bG9vcCBmcm9tICcuL2V2ZW50bG9vcC5qcydcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnLi9tYXRoLmpzJ1xuaW1wb3J0ICogYXMgY29tbW9uIGZyb20gJy4vbG9nZ2luZy5jb21tb24uanMnXG5cbmV4cG9ydCB7IEJPTEQsIFVOQk9MRCwgQkxVRSwgR1JFWSwgR1JFRU4sIFJFRCwgUFVSUExFLCBPUkFOR0UsIFVOQ09MT1IgfSBmcm9tICcuL2xvZ2dpbmcuY29tbW9uLmpzJ1xuXG4vKipcbiAqIEB0eXBlIHtPYmplY3Q8U3ltYm9sLHBhaXIuUGFpcjxzdHJpbmcsc3RyaW5nPj59XG4gKi9cbmNvbnN0IF9icm93c2VyU3R5bGVNYXAgPSB7XG4gIFtjb21tb24uQk9MRF06IHBhaXIuY3JlYXRlKCdmb250LXdlaWdodCcsICdib2xkJyksXG4gIFtjb21tb24uVU5CT0xEXTogcGFpci5jcmVhdGUoJ2ZvbnQtd2VpZ2h0JywgJ25vcm1hbCcpLFxuICBbY29tbW9uLkJMVUVdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnYmx1ZScpLFxuICBbY29tbW9uLkdSRUVOXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ2dyZWVuJyksXG4gIFtjb21tb24uR1JFWV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdncmV5JyksXG4gIFtjb21tb24uUkVEXTogcGFpci5jcmVhdGUoJ2NvbG9yJywgJ3JlZCcpLFxuICBbY29tbW9uLlBVUlBMRV06IHBhaXIuY3JlYXRlKCdjb2xvcicsICdwdXJwbGUnKSxcbiAgW2NvbW1vbi5PUkFOR0VdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnb3JhbmdlJyksIC8vIG5vdCB3ZWxsIHN1cHBvcnRlZCBpbiBjaHJvbWUgd2hlbiBkZWJ1Z2dpbmcgbm9kZSB3aXRoIGluc3BlY3RvciAtIFRPRE86IGRlcHJlY2F0ZVxuICBbY29tbW9uLlVOQ09MT1JdOiBwYWlyLmNyZWF0ZSgnY29sb3InLCAnYmxhY2snKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyfGZ1bmN0aW9uKCk6YW55Pn0gYXJnc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nfG9iamVjdHxudW1iZXI+fVxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3MgPSAoYXJncykgPT4ge1xuICBpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgYXJnc1swXT8uY29uc3RydWN0b3IgPT09IEZ1bmN0aW9uKSB7XG4gICAgYXJncyA9IC8qKiBAdHlwZSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gKi8gKC8qKiBAdHlwZSB7W2Z1bmN0aW9uXX0gKi8gKGFyZ3MpWzBdKCkpXG4gIH1cbiAgY29uc3Qgc3RyQnVpbGRlciA9IFtdXG4gIGNvbnN0IHN0eWxlcyA9IFtdXG4gIGNvbnN0IGN1cnJlbnRTdHlsZSA9IG1hcC5jcmVhdGUoKVxuICAvKipcbiAgICogQHR5cGUge0FycmF5PHN0cmluZ3xPYmplY3R8bnVtYmVyPn1cbiAgICovXG4gIGxldCBsb2dBcmdzID0gW11cbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYXJnID0gYXJnc1tpXVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBzdHlsZSA9IF9icm93c2VyU3R5bGVNYXBbYXJnXVxuICAgIGlmIChzdHlsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdXJyZW50U3R5bGUuc2V0KHN0eWxlLmxlZnQsIHN0eWxlLnJpZ2h0KVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIGlmIChhcmcuY29uc3RydWN0b3IgPT09IFN0cmluZyB8fCBhcmcuY29uc3RydWN0b3IgPT09IE51bWJlcikge1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSlcbiAgICAgICAgaWYgKGkgPiAwIHx8IHN0eWxlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goJyVjJyArIGFyZylcbiAgICAgICAgICBzdHlsZXMucHVzaChzdHlsZSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJCdWlsZGVyLnB1c2goYXJnKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoaSA+IDApIHtcbiAgICAvLyBjcmVhdGUgbG9nQXJncyB3aXRoIHdoYXQgd2UgaGF2ZSBzbyBmYXJcbiAgICBsb2dBcmdzID0gc3R5bGVzXG4gICAgbG9nQXJncy51bnNoaWZ0KHN0ckJ1aWxkZXIuam9pbignJykpXG4gIH1cbiAgLy8gYXBwZW5kIHRoZSByZXN0XG4gIGZvciAoOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGFyZyA9IGFyZ3NbaV1cbiAgICBpZiAoIShhcmcgaW5zdGFuY2VvZiBTeW1ib2wpKSB7XG4gICAgICBsb2dBcmdzLnB1c2goYXJnKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbG9nQXJnc1xufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyogYzggaWdub3JlIHN0YXJ0ICovXG5jb25zdCBjb21wdXRlTG9nZ2luZ0FyZ3MgPSBlbnYuc3VwcG9ydHNDb2xvclxuICA/IGNvbXB1dGVCcm93c2VyTG9nZ2luZ0FyZ3NcbiAgOiBjb21tb24uY29tcHV0ZU5vQ29sb3JMb2dnaW5nQXJnc1xuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqL1xuZXhwb3J0IGNvbnN0IHByaW50ID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS5sb2coLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLnByaW50KGFyZ3MpKVxufVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCB3YXJuID0gKC4uLmFyZ3MpID0+IHtcbiAgY29uc29sZS53YXJuKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgYXJncy51bnNoaWZ0KGNvbW1vbi5PUkFOR0UpXG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnQoYXJncykpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjb25zdCBwcmludEVycm9yID0gKGVycikgPT4ge1xuICBjb25zb2xlLmVycm9yKGVycilcbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5wcmludEVycm9yKGVycikpXG59XG4vKiBjOCBpZ25vcmUgc3RvcCAqL1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgaW1hZ2UgbG9jYXRpb25cbiAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgaGVpZ2h0IG9mIHRoZSBpbWFnZSBpbiBwaXhlbFxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmV4cG9ydCBjb25zdCBwcmludEltZyA9ICh1cmwsIGhlaWdodCkgPT4ge1xuICBpZiAoZW52LmlzQnJvd3Nlcikge1xuICAgIGNvbnNvbGUubG9nKFxuICAgICAgJyVjICAgICAgICAgICAgICAgICAgICAgICcsXG4gICAgICBgZm9udC1zaXplOiAke2hlaWdodH1weDsgYmFja2dyb3VuZC1zaXplOiBjb250YWluOyBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0OyBiYWNrZ3JvdW5kLWltYWdlOiB1cmwoJHt1cmx9KWBcbiAgICApXG4gICAgLy8gY29uc29sZS5sb2coJyVjICAgICAgICAgICAgICAgICcsIGBmb250LXNpemU6ICR7aGVpZ2h0fXg7IGJhY2tncm91bmQ6IHVybCgke3VybH0pIG5vLXJlcGVhdDtgKVxuICB9XG4gIHZjb25zb2xlcy5mb3JFYWNoKCh2YykgPT4gdmMucHJpbnRJbWcodXJsLCBoZWlnaHQpKVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0XG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBwcmludEltZ0Jhc2U2NCA9IChiYXNlNjQsIGhlaWdodCkgPT5cbiAgcHJpbnRJbWcoYGRhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCwke2Jhc2U2NH1gLCBoZWlnaHQpXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gKi9cbmV4cG9ydCBjb25zdCBncm91cCA9ICguLi5hcmdzKSA9PiB7XG4gIGNvbnNvbGUuZ3JvdXAoLi4uY29tcHV0ZUxvZ2dpbmdBcmdzKGFyZ3MpKVxuICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLmdyb3VwKGFyZ3MpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICovXG5leHBvcnQgY29uc3QgZ3JvdXBDb2xsYXBzZWQgPSAoLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmdyb3VwQ29sbGFwc2VkKC4uLmNvbXB1dGVMb2dnaW5nQXJncyhhcmdzKSlcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5ncm91cENvbGxhcHNlZChhcmdzKSlcbn1cblxuZXhwb3J0IGNvbnN0IGdyb3VwRW5kID0gKCkgPT4ge1xuICBjb25zb2xlLmdyb3VwRW5kKClcbiAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgdmNvbnNvbGVzLmZvckVhY2goKHZjKSA9PiB2Yy5ncm91cEVuZCgpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpOb2RlfSBjcmVhdGVOb2RlXG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBwcmludERvbSA9IChjcmVhdGVOb2RlKSA9PlxuICB2Y29uc29sZXMuZm9yRWFjaCgodmMpID0+IHZjLnByaW50RG9tKGNyZWF0ZU5vZGUoKSkpXG5cbi8qKlxuICogQHBhcmFtIHtIVE1MQ2FudmFzRWxlbWVudH0gY2FudmFzXG4gKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gKi9cbi8qIGM4IGlnbm9yZSBuZXh0IDIgKi9cbmV4cG9ydCBjb25zdCBwcmludENhbnZhcyA9IChjYW52YXMsIGhlaWdodCkgPT5cbiAgcHJpbnRJbWcoY2FudmFzLnRvRGF0YVVSTCgpLCBoZWlnaHQpXG5cbmV4cG9ydCBjb25zdCB2Y29uc29sZXMgPSBzZXQuY3JlYXRlKClcblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZ3xTeW1ib2x8T2JqZWN0fG51bWJlcj59IGFyZ3NcbiAqIEByZXR1cm4ge0FycmF5PEVsZW1lbnQ+fVxuICovXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IF9jb21wdXRlTGluZVNwYW5zID0gKGFyZ3MpID0+IHtcbiAgY29uc3Qgc3BhbnMgPSBbXVxuICBjb25zdCBjdXJyZW50U3R5bGUgPSBuZXcgTWFwKClcbiAgLy8gdHJ5IHdpdGggZm9ybWF0dGluZyB1bnRpbCB3ZSBmaW5kIHNvbWV0aGluZyB1bnN1cHBvcnRlZFxuICBsZXQgaSA9IDBcbiAgZm9yICg7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGFyZyA9IGFyZ3NbaV1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc3R5bGUgPSBfYnJvd3NlclN0eWxlTWFwW2FyZ11cbiAgICBpZiAoc3R5bGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY3VycmVudFN0eWxlLnNldChzdHlsZS5sZWZ0LCBzdHlsZS5yaWdodClcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGFyZyA9ICd1bmRlZmluZWQgJ1xuICAgICAgfVxuICAgICAgaWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nIHx8IGFyZy5jb25zdHJ1Y3RvciA9PT0gTnVtYmVyKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgY29uc3Qgc3BhbiA9IGRvbS5lbGVtZW50KCdzcGFuJywgW1xuICAgICAgICAgIHBhaXIuY3JlYXRlKCdzdHlsZScsIGRvbS5tYXBUb1N0eWxlU3RyaW5nKGN1cnJlbnRTdHlsZSkpXG4gICAgICAgIF0sIFtkb20udGV4dChhcmcudG9TdHJpbmcoKSldKVxuICAgICAgICBpZiAoc3Bhbi5pbm5lckhUTUwgPT09ICcnKSB7XG4gICAgICAgICAgc3Bhbi5pbm5lckhUTUwgPSAnJm5ic3A7J1xuICAgICAgICB9XG4gICAgICAgIHNwYW5zLnB1c2goc3BhbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vIGFwcGVuZCB0aGUgcmVzdFxuICBmb3IgKDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgY29udGVudCA9IGFyZ3NbaV1cbiAgICBpZiAoIShjb250ZW50IGluc3RhbmNlb2YgU3ltYm9sKSkge1xuICAgICAgaWYgKGNvbnRlbnQuY29uc3RydWN0b3IgIT09IFN0cmluZyAmJiBjb250ZW50LmNvbnN0cnVjdG9yICE9PSBOdW1iZXIpIHtcbiAgICAgICAgY29udGVudCA9ICcgJyArIGpzb24uc3RyaW5naWZ5KGNvbnRlbnQpICsgJyAnXG4gICAgICB9XG4gICAgICBzcGFucy5wdXNoKFxuICAgICAgICBkb20uZWxlbWVudCgnc3BhbicsIFtdLCBbZG9tLnRleHQoLyoqIEB0eXBlIHtzdHJpbmd9ICovIChjb250ZW50KSldKVxuICAgICAgKVxuICAgIH1cbiAgfVxuICByZXR1cm4gc3BhbnNcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbmNvbnN0IGxpbmVTdHlsZSA9XG4gICdmb250LWZhbWlseTptb25vc3BhY2U7Ym9yZGVyLWJvdHRvbToxcHggc29saWQgI2UyZTJlMjtwYWRkaW5nOjJweDsnXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuZXhwb3J0IGNsYXNzIFZDb25zb2xlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZG9tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9tKSB7XG4gICAgdGhpcy5kb20gPSBkb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RWxlbWVudH1cbiAgICAgKi9cbiAgICB0aGlzLmNjb250YWluZXIgPSB0aGlzLmRvbVxuICAgIHRoaXMuZGVwdGggPSAwXG4gICAgdmNvbnNvbGVzLmFkZCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nfFN5bWJvbHxPYmplY3R8bnVtYmVyPn0gYXJnc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNvbGxhcHNlZFxuICAgKi9cbiAgZ3JvdXAgKGFyZ3MsIGNvbGxhcHNlZCA9IGZhbHNlKSB7XG4gICAgZXZlbnRsb29wLmVucXVldWUoKCkgPT4ge1xuICAgICAgY29uc3QgdHJpYW5nbGVEb3duID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXG4gICAgICAgIHBhaXIuY3JlYXRlKCdoaWRkZW4nLCBjb2xsYXBzZWQpLFxuICAgICAgICBwYWlyLmNyZWF0ZSgnc3R5bGUnLCAnY29sb3I6Z3JleTtmb250LXNpemU6MTIwJTsnKVxuICAgICAgXSwgW2RvbS50ZXh0KCdcdTI1QkMnKV0pXG4gICAgICBjb25zdCB0cmlhbmdsZVJpZ2h0ID0gZG9tLmVsZW1lbnQoJ3NwYW4nLCBbXG4gICAgICAgIHBhaXIuY3JlYXRlKCdoaWRkZW4nLCAhY29sbGFwc2VkKSxcbiAgICAgICAgcGFpci5jcmVhdGUoJ3N0eWxlJywgJ2NvbG9yOmdyZXk7Zm9udC1zaXplOjEyNSU7JylcbiAgICAgIF0sIFtkb20udGV4dCgnXHUyNUI2JyldKVxuICAgICAgY29uc3QgY29udGVudCA9IGRvbS5lbGVtZW50KFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgW3BhaXIuY3JlYXRlKFxuICAgICAgICAgICdzdHlsZScsXG4gICAgICAgICAgYCR7bGluZVN0eWxlfTtwYWRkaW5nLWxlZnQ6JHt0aGlzLmRlcHRoICogMTB9cHhgXG4gICAgICAgICldLFxuICAgICAgICBbdHJpYW5nbGVEb3duLCB0cmlhbmdsZVJpZ2h0LCBkb20udGV4dCgnICcpXS5jb25jYXQoXG4gICAgICAgICAgX2NvbXB1dGVMaW5lU3BhbnMoYXJncylcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgY29uc3QgbmV4dENvbnRhaW5lciA9IGRvbS5lbGVtZW50KCdkaXYnLCBbXG4gICAgICAgIHBhaXIuY3JlYXRlKCdoaWRkZW4nLCBjb2xsYXBzZWQpXG4gICAgICBdKVxuICAgICAgY29uc3QgbmV4dExpbmUgPSBkb20uZWxlbWVudCgnZGl2JywgW10sIFtjb250ZW50LCBuZXh0Q29udGFpbmVyXSlcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbbmV4dExpbmVdKVxuICAgICAgdGhpcy5jY29udGFpbmVyID0gbmV4dENvbnRhaW5lclxuICAgICAgdGhpcy5kZXB0aCsrXG4gICAgICAvLyB3aGVuIGhlYWRlciBpcyBjbGlja2VkLCBjb2xsYXBzZS91bmNvbGxhcHNlIGNvbnRhaW5lclxuICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoY29udGVudCwgJ2NsaWNrJywgKF9ldmVudCkgPT4ge1xuICAgICAgICBuZXh0Q29udGFpbmVyLnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgICAgdHJpYW5nbGVEb3duLnRvZ2dsZUF0dHJpYnV0ZSgnaGlkZGVuJylcbiAgICAgICAgdHJpYW5nbGVSaWdodC50b2dnbGVBdHRyaWJ1dGUoJ2hpZGRlbicpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gICAqL1xuICBncm91cENvbGxhcHNlZCAoYXJncykge1xuICAgIHRoaXMuZ3JvdXAoYXJncywgdHJ1ZSlcbiAgfVxuXG4gIGdyb3VwRW5kICgpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXB0aCA+IDApIHtcbiAgICAgICAgdGhpcy5kZXB0aC0tXG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5jY29udGFpbmVyID0gdGhpcy5jY29udGFpbmVyLnBhcmVudEVsZW1lbnQucGFyZW50RWxlbWVudFxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxzdHJpbmd8U3ltYm9sfE9iamVjdHxudW1iZXI+fSBhcmdzXG4gICAqL1xuICBwcmludCAoYXJncykge1xuICAgIGV2ZW50bG9vcC5lbnF1ZXVlKCgpID0+IHtcbiAgICAgIGRvbS5hcHBlbmQodGhpcy5jY29udGFpbmVyLCBbXG4gICAgICAgIGRvbS5lbGVtZW50KCdkaXYnLCBbXG4gICAgICAgICAgcGFpci5jcmVhdGUoXG4gICAgICAgICAgICAnc3R5bGUnLFxuICAgICAgICAgICAgYCR7bGluZVN0eWxlfTtwYWRkaW5nLWxlZnQ6JHt0aGlzLmRlcHRoICogMTB9cHhgXG4gICAgICAgICAgKVxuICAgICAgICBdLCBfY29tcHV0ZUxpbmVTcGFucyhhcmdzKSlcbiAgICAgIF0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnJcbiAgICovXG4gIHByaW50RXJyb3IgKGVycikge1xuICAgIHRoaXMucHJpbnQoW2NvbW1vbi5SRUQsIGNvbW1vbi5CT0xELCBlcnIudG9TdHJpbmcoKV0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0XG4gICAqL1xuICBwcmludEltZyAodXJsLCBoZWlnaHQpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW1xuICAgICAgICBkb20uZWxlbWVudCgnaW1nJywgW1xuICAgICAgICAgIHBhaXIuY3JlYXRlKCdzcmMnLCB1cmwpLFxuICAgICAgICAgIHBhaXIuY3JlYXRlKCdoZWlnaHQnLCBgJHttYXRoLnJvdW5kKGhlaWdodCAqIDEuNSl9cHhgKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgcHJpbnREb20gKG5vZGUpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICBkb20uYXBwZW5kKHRoaXMuY2NvbnRhaW5lciwgW25vZGVdKVxuICAgIH0pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBldmVudGxvb3AuZW5xdWV1ZSgoKSA9PiB7XG4gICAgICB2Y29uc29sZXMuZGVsZXRlKHRoaXMpXG4gICAgfSlcbiAgfVxufVxuLyogYzggaWdub3JlIHN0b3AgKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGRvbVxuICovXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZDb25zb2xlID0gKGRvbSkgPT4gbmV3IFZDb25zb2xlKGRvbSlcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbW9kdWxlTmFtZVxuICogQHJldHVybiB7ZnVuY3Rpb24oLi4uYW55KTp2b2lkfVxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTW9kdWxlTG9nZ2VyID0gKG1vZHVsZU5hbWUpID0+IGNvbW1vbi5jcmVhdGVNb2R1bGVMb2dnZXIocHJpbnQsIG1vZHVsZU5hbWUpXG4iLCAiLyoqXG4gKiBVdGlsaXR5IG1vZHVsZSB0byBjcmVhdGUgYW5kIG1hbmlwdWxhdGUgSXRlcmF0b3JzLlxuICpcbiAqIEBtb2R1bGUgaXRlcmF0b3JcbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBULFJcbiAqIEBwYXJhbSB7SXRlcmF0b3I8VD59IGl0ZXJhdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFQpOlJ9IGZcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8Uj59XG4gKi9cbmV4cG9ydCBjb25zdCBtYXBJdGVyYXRvciA9IChpdGVyYXRvciwgZikgPT4gKHtcbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH0sXG4gIC8vIEB0cy1pZ25vcmVcbiAgbmV4dCAoKSB7XG4gICAgY29uc3QgciA9IGl0ZXJhdG9yLm5leHQoKVxuICAgIHJldHVybiB7IHZhbHVlOiByLmRvbmUgPyB1bmRlZmluZWQgOiBmKHIudmFsdWUpLCBkb25lOiByLmRvbmUgfVxuICB9XG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCk6SXRlcmF0b3JSZXN1bHQ8VD59IG5leHRcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJdGVyYXRvciA9IG5leHQgPT4gKHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8VD59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfSxcbiAgLy8gQHRzLWlnbm9yZVxuICBuZXh0XG59KVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAcGFyYW0ge0l0ZXJhdG9yPFQ+fSBpdGVyYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbihUKTpib29sZWFufSBmaWx0ZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGl0ZXJhdG9yRmlsdGVyID0gKGl0ZXJhdG9yLCBmaWx0ZXIpID0+IGNyZWF0ZUl0ZXJhdG9yKCgpID0+IHtcbiAgbGV0IHJlc1xuICBkbyB7XG4gICAgcmVzID0gaXRlcmF0b3IubmV4dCgpXG4gIH0gd2hpbGUgKCFyZXMuZG9uZSAmJiAhZmlsdGVyKHJlcy52YWx1ZSkpXG4gIHJldHVybiByZXNcbn0pXG5cbi8qKlxuICogQHRlbXBsYXRlIFQsTVxuICogQHBhcmFtIHtJdGVyYXRvcjxUPn0gaXRlcmF0b3JcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oVCk6TX0gZm1hcFxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0b3JNYXAgPSAoaXRlcmF0b3IsIGZtYXApID0+IGNyZWF0ZUl0ZXJhdG9yKCgpID0+IHtcbiAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gaXRlcmF0b3IubmV4dCgpXG4gIHJldHVybiB7IGRvbmUsIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogZm1hcCh2YWx1ZSkgfVxufSlcbiIsICJpbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5cbmltcG9ydCB7XG4gIERvYyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBUaGlzIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSB0aGF0IGFsbCBDb25uZWN0b3JzIHNob3VsZCBpbXBsZW1lbnQgdG8ga2VlcCB0aGVtIGludGVyY2hhbmdlYWJsZS5cbiAqXG4gKiBAbm90ZSBUaGlzIGludGVyZmFjZSBpcyBleHBlcmltZW50YWwgYW5kIGl0IGlzIG5vdCBhZHZpc2VkIHRvIGFjdHVhbGx5IGluaGVyaXQgdGhpcyBjbGFzcy5cbiAqICAgICAgIEl0IGp1c3Qgc2VydmVzIGFzIHR5cGluZyBpbmZvcm1hdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZVYyPGFueT59XG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdENvbm5lY3RvciBleHRlbmRzIE9ic2VydmFibGVWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30geWRvY1xuICAgKiBAcGFyYW0ge2FueX0gYXdhcmVuZXNzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeWRvYywgYXdhcmVuZXNzKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0geWRvY1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gIH1cbn1cbiIsICJpbXBvcnQge1xuICBmaW5kSW5kZXhTUyxcbiAgZ2V0U3RhdGUsXG4gIHNwbGl0SXRlbSxcbiAgaXRlcmF0ZVN0cnVjdHMsXG4gIFVwZGF0ZUVuY29kZXJWMixcbiAgRFNEZWNvZGVyVjEsIERTRW5jb2RlclYxLCBEU0RlY29kZXJWMiwgRFNFbmNvZGVyVjIsIEl0ZW0sIEdDLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcblxuZXhwb3J0IGNsYXNzIERlbGV0ZUl0ZW0ge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbG9jaywgbGVuKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsb2NrID0gY2xvY2tcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMubGVuID0gbGVuXG4gIH1cbn1cblxuLyoqXG4gKiBXZSBubyBsb25nZXIgbWFpbnRhaW4gYSBEZWxldGVTdG9yZS4gRGVsZXRlU2V0IGlzIGEgdGVtcG9yYXJ5IG9iamVjdCB0aGF0IGlzIGNyZWF0ZWQgd2hlbiBuZWVkZWQuXG4gKiAtIFdoZW4gY3JlYXRlZCBpbiBhIHRyYW5zYWN0aW9uLCBpdCBtdXN0IG9ubHkgYmUgYWNjZXNzZWQgYWZ0ZXIgc29ydGluZywgYW5kIG1lcmdpbmdcbiAqICAgLSBUaGlzIERlbGV0ZVNldCBpcyBzZW5kIHRvIG90aGVyIGNsaWVudHNcbiAqIC0gV2UgZG8gbm90IGNyZWF0ZSBhIERlbGV0ZVNldCB3aGVuIHdlIHNlbmQgYSBzeW5jIG1lc3NhZ2UuIFRoZSBEZWxldGVTZXQgbWVzc2FnZSBpcyBjcmVhdGVkIGRpcmVjdGx5IGZyb20gU3RydWN0U3RvcmVcbiAqIC0gV2UgcmVhZCBhIERlbGV0ZVNldCBhcyBwYXJ0IG9mIGEgc3luYy91cGRhdGUgbWVzc2FnZS4gSW4gdGhpcyBjYXNlIHRoZSBEZWxldGVTZXQgaXMgYWxyZWFkeSBzb3J0ZWQgYW5kIG1lcmdlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERlbGV0ZVNldCB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlcixBcnJheTxEZWxldGVJdGVtPj59XG4gICAgICovXG4gICAgdGhpcy5jbGllbnRzID0gbmV3IE1hcCgpXG4gIH1cbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHN0cnVjdHMgdGhhdCB0aGUgRGVsZXRlU2V0IGdjJ3MuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtmdW5jdGlvbihHQ3xJdGVtKTp2b2lkfSBmXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlRGVsZXRlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIGRzLCBmKSA9PlxuICBkcy5jbGllbnRzLmZvckVhY2goKGRlbGV0ZXMsIGNsaWVudGlkKSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovICh0cmFuc2FjdGlvbi5kb2Muc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50aWQpKVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGVsID0gZGVsZXRlc1tpXVxuICAgICAgaXRlcmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0cnVjdHMsIGRlbC5jbG9jaywgZGVsLmxlbiwgZilcbiAgICB9XG4gIH0pXG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxEZWxldGVJdGVtPn0gZGlzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqIEByZXR1cm4ge251bWJlcnxudWxsfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGZpbmRJbmRleERTID0gKGRpcywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IGRpcy5sZW5ndGggLSAxXG4gIHdoaWxlIChsZWZ0IDw9IHJpZ2h0KSB7XG4gICAgY29uc3QgbWlkaW5kZXggPSBtYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMilcbiAgICBjb25zdCBtaWQgPSBkaXNbbWlkaW5kZXhdXG4gICAgY29uc3QgbWlkY2xvY2sgPSBtaWQuY2xvY2tcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbikge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGlzRGVsZXRlZCA9IChkcywgaWQpID0+IHtcbiAgY29uc3QgZGlzID0gZHMuY2xpZW50cy5nZXQoaWQuY2xpZW50KVxuICByZXR1cm4gZGlzICE9PSB1bmRlZmluZWQgJiYgZmluZEluZGV4RFMoZGlzLCBpZC5jbG9jaykgIT09IG51bGxcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBzb3J0QW5kTWVyZ2VEZWxldGVTZXQgPSBkcyA9PiB7XG4gIGRzLmNsaWVudHMuZm9yRWFjaChkZWxzID0+IHtcbiAgICBkZWxzLnNvcnQoKGEsIGIpID0+IGEuY2xvY2sgLSBiLmNsb2NrKVxuICAgIC8vIG1lcmdlIGl0ZW1zIHdpdGhvdXQgZmlsdGVyaW5nIG9yIHNwbGljaW5nIHRoZSBhcnJheVxuICAgIC8vIGkgaXMgdGhlIGN1cnJlbnQgcG9pbnRlclxuICAgIC8vIGogcmVmZXJzIHRvIHRoZSBjdXJyZW50IGluc2VydCBwb3NpdGlvbiBmb3IgdGhlIHBvaW50ZWQgaXRlbVxuICAgIC8vIHRyeSB0byBtZXJnZSBkZWxzW2ldIGludG8gZGVsc1tqLTFdIG9yIHNldCBkZWxzW2pdPWRlbHNbaV1cbiAgICBsZXQgaSwgalxuICAgIGZvciAoaSA9IDEsIGogPSAxOyBpIDwgZGVscy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGVmdCA9IGRlbHNbaiAtIDFdXG4gICAgICBjb25zdCByaWdodCA9IGRlbHNbaV1cbiAgICAgIGlmIChsZWZ0LmNsb2NrICsgbGVmdC5sZW4gPj0gcmlnaHQuY2xvY2spIHtcbiAgICAgICAgbGVmdC5sZW4gPSBtYXRoLm1heChsZWZ0LmxlbiwgcmlnaHQuY2xvY2sgKyByaWdodC5sZW4gLSBsZWZ0LmNsb2NrKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGogPCBpKSB7XG4gICAgICAgICAgZGVsc1tqXSA9IHJpZ2h0XG4gICAgICAgIH1cbiAgICAgICAgaisrXG4gICAgICB9XG4gICAgfVxuICAgIGRlbHMubGVuZ3RoID0galxuICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8RGVsZXRlU2V0Pn0gZHNzXG4gKiBAcmV0dXJuIHtEZWxldGVTZXR9IEEgZnJlc2ggRGVsZXRlU2V0XG4gKi9cbmV4cG9ydCBjb25zdCBtZXJnZURlbGV0ZVNldHMgPSBkc3MgPT4ge1xuICBjb25zdCBtZXJnZWQgPSBuZXcgRGVsZXRlU2V0KClcbiAgZm9yIChsZXQgZHNzSSA9IDA7IGRzc0kgPCBkc3MubGVuZ3RoOyBkc3NJKyspIHtcbiAgICBkc3NbZHNzSV0uY2xpZW50cy5mb3JFYWNoKChkZWxzTGVmdCwgY2xpZW50KSA9PiB7XG4gICAgICBpZiAoIW1lcmdlZC5jbGllbnRzLmhhcyhjbGllbnQpKSB7XG4gICAgICAgIC8vIFdyaXRlIGFsbCBtaXNzaW5nIGtleXMgZnJvbSBjdXJyZW50IGRzIGFuZCBhbGwgZm9sbG93aW5nLlxuICAgICAgICAvLyBJZiBtZXJnZWQgYWxyZWFkeSBjb250YWlucyBgY2xpZW50YCBjdXJyZW50IGRzIGhhcyBhbHJlYWR5IGJlZW4gYWRkZWQuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7QXJyYXk8RGVsZXRlSXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWxzID0gZGVsc0xlZnQuc2xpY2UoKVxuICAgICAgICBmb3IgKGxldCBpID0gZHNzSSArIDE7IGkgPCBkc3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcnJheS5hcHBlbmRUbyhkZWxzLCBkc3NbaV0uY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXSlcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQuY2xpZW50cy5zZXQoY2xpZW50LCBkZWxzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KG1lcmdlZClcbiAgcmV0dXJuIG1lcmdlZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkc1xuICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgYWRkVG9EZWxldGVTZXQgPSAoZHMsIGNsaWVudCwgY2xvY2ssIGxlbmd0aCkgPT4ge1xuICBtYXAuc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiAvKiogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fSAqLyAoW10pKS5wdXNoKG5ldyBEZWxldGVJdGVtKGNsb2NrLCBsZW5ndGgpKVxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlRGVsZXRlU2V0ID0gKCkgPT4gbmV3IERlbGV0ZVNldCgpXG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3NcbiAqIEByZXR1cm4ge0RlbGV0ZVNldH0gTWVyZ2VkIGFuZCBzb3J0ZWQgRGVsZXRlU2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlID0gc3MgPT4ge1xuICBjb25zdCBkcyA9IGNyZWF0ZURlbGV0ZVNldCgpXG4gIHNzLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fVxuICAgICAqL1xuICAgIGNvbnN0IGRzaXRlbXMgPSBbXVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpXVxuICAgICAgaWYgKHN0cnVjdC5kZWxldGVkKSB7XG4gICAgICAgIGNvbnN0IGNsb2NrID0gc3RydWN0LmlkLmNsb2NrXG4gICAgICAgIGxldCBsZW4gPSBzdHJ1Y3QubGVuZ3RoXG4gICAgICAgIGlmIChpICsgMSA8IHN0cnVjdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yIChsZXQgbmV4dCA9IHN0cnVjdHNbaSArIDFdOyBpICsgMSA8IHN0cnVjdHMubGVuZ3RoICYmIG5leHQuZGVsZXRlZDsgbmV4dCA9IHN0cnVjdHNbKytpICsgMV0pIHtcbiAgICAgICAgICAgIGxlbiArPSBuZXh0Lmxlbmd0aFxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkc2l0ZW1zLnB1c2gobmV3IERlbGV0ZUl0ZW0oY2xvY2ssIGxlbikpXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkc2l0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIGRzLmNsaWVudHMuc2V0KGNsaWVudCwgZHNpdGVtcylcbiAgICB9XG4gIH0pXG4gIHJldHVybiBkc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVEZWxldGVTZXQgPSAoZW5jb2RlciwgZHMpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGRzLmNsaWVudHMuc2l6ZSlcblxuICAvLyBFbnN1cmUgdGhhdCB0aGUgZGVsZXRlIHNldCBpcyB3cml0dGVuIGluIGEgZGV0ZXJtaW5pc3RpYyBvcmRlclxuICBhcnJheS5mcm9tKGRzLmNsaWVudHMuZW50cmllcygpKVxuICAgIC5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSlcbiAgICAuZm9yRWFjaCgoW2NsaWVudCwgZHNpdGVtc10pID0+IHtcbiAgICAgIGVuY29kZXIucmVzZXREc0N1clZhbCgpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xpZW50KVxuICAgICAgY29uc3QgbGVuID0gZHNpdGVtcy5sZW5ndGhcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLnJlc3RFbmNvZGVyLCBsZW4pXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkc2l0ZW1zW2ldXG4gICAgICAgIGVuY29kZXIud3JpdGVEc0Nsb2NrKGl0ZW0uY2xvY2spXG4gICAgICAgIGVuY29kZXIud3JpdGVEc0xlbihpdGVtLmxlbilcbiAgICAgIH1cbiAgICB9KVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7RGVsZXRlU2V0fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWREZWxldGVTZXQgPSBkZWNvZGVyID0+IHtcbiAgY29uc3QgZHMgPSBuZXcgRGVsZXRlU2V0KClcbiAgY29uc3QgbnVtQ2xpZW50cyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2xpZW50czsgaSsrKSB7XG4gICAgZGVjb2Rlci5yZXNldERzQ3VyVmFsKClcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIGNvbnN0IG51bWJlck9mRGVsZXRlcyA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgaWYgKG51bWJlck9mRGVsZXRlcyA+IDApIHtcbiAgICAgIGNvbnN0IGRzRmllbGQgPSBtYXAuc2V0SWZVbmRlZmluZWQoZHMuY2xpZW50cywgY2xpZW50LCAoKSA9PiAvKiogQHR5cGUge0FycmF5PERlbGV0ZUl0ZW0+fSAqLyAoW10pKVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZkRlbGV0ZXM7IGkrKykge1xuICAgICAgICBkc0ZpZWxkLnB1c2gobmV3IERlbGV0ZUl0ZW0oZGVjb2Rlci5yZWFkRHNDbG9jaygpLCBkZWNvZGVyLnJlYWREc0xlbigpKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRzXG59XG5cbi8qKlxuICogQHRvZG8gWURlY29kZXIgYWxzbyBjb250YWlucyByZWZlcmVuY2VzIHRvIFN0cmluZyBhbmQgb3RoZXIgRGVjb2RlcnMuIFdvdWxkIG1ha2Ugc2Vuc2UgdG8gZXhjaGFuZ2UgWURlY29kZXIudG9VaW50OEFycmF5IGZvciBZRGVjb2Rlci5Ec1RvVWludDhBcnJheSgpLi5cbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7RFNEZWNvZGVyVjEgfCBEU0RlY29kZXJWMn0gZGVjb2RlclxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fG51bGx9IFJldHVybnMgYSB2MiB1cGRhdGUgY29udGFpbmluZyBhbGwgZGVsZXRlcyB0aGF0IGNvdWxkbid0IGJlIGFwcGxpZWQgeWV0OyBvciBudWxsIGlmIGFsbCBkZWxldGVzIHdlcmUgYXBwbGllZCBzdWNjZXNzZnVsbHkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZEFuZEFwcGx5RGVsZXRlU2V0ID0gKGRlY29kZXIsIHRyYW5zYWN0aW9uLCBzdG9yZSkgPT4ge1xuICBjb25zdCB1bmFwcGxpZWREUyA9IG5ldyBEZWxldGVTZXQoKVxuICBjb25zdCBudW1DbGllbnRzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1DbGllbnRzOyBpKyspIHtcbiAgICBkZWNvZGVyLnJlc2V0RHNDdXJWYWwoKVxuICAgIGNvbnN0IGNsaWVudCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgY29uc3QgbnVtYmVyT2ZEZWxldGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSB8fCBbXVxuICAgIGNvbnN0IHN0YXRlID0gZ2V0U3RhdGUoc3RvcmUsIGNsaWVudClcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bWJlck9mRGVsZXRlczsgaSsrKSB7XG4gICAgICBjb25zdCBjbG9jayA9IGRlY29kZXIucmVhZERzQ2xvY2soKVxuICAgICAgY29uc3QgY2xvY2tFbmQgPSBjbG9jayArIGRlY29kZXIucmVhZERzTGVuKClcbiAgICAgIGlmIChjbG9jayA8IHN0YXRlKSB7XG4gICAgICAgIGlmIChzdGF0ZSA8IGNsb2NrRW5kKSB7XG4gICAgICAgICAgYWRkVG9EZWxldGVTZXQodW5hcHBsaWVkRFMsIGNsaWVudCwgc3RhdGUsIGNsb2NrRW5kIC0gc3RhdGUpXG4gICAgICAgIH1cbiAgICAgICAgbGV0IGluZGV4ID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSBjYW4gaWdub3JlIHRoZSBjYXNlIG9mIEdDIGFuZCBEZWxldGUgc3RydWN0cywgYmVjYXVzZSB3ZSBhcmUgZ29pbmcgdG8gc2tpcCB0aGVtXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAgICAgKi9cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgc3RydWN0ID0gc3RydWN0c1tpbmRleF1cbiAgICAgICAgLy8gc3BsaXQgdGhlIGZpcnN0IGl0ZW0gaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQgJiYgc3RydWN0LmlkLmNsb2NrIDwgY2xvY2spIHtcbiAgICAgICAgICBzdHJ1Y3RzLnNwbGljZShpbmRleCArIDEsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9jayAtIHN0cnVjdC5pZC5jbG9jaykpXG4gICAgICAgICAgaW5kZXgrKyAvLyBpbmNyZWFzZSB3ZSBub3cgd2FudCB0byB1c2UgdGhlIG5leHQgc3RydWN0XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgc3RydWN0ID0gc3RydWN0c1tpbmRleCsrXVxuICAgICAgICAgIGlmIChzdHJ1Y3QuaWQuY2xvY2sgPCBjbG9ja0VuZCkge1xuICAgICAgICAgICAgaWYgKCFzdHJ1Y3QuZGVsZXRlZCkge1xuICAgICAgICAgICAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc3RydWN0cy5zcGxpY2UoaW5kZXgsIDAsIHNwbGl0SXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBjbG9ja0VuZCAtIHN0cnVjdC5pZC5jbG9jaykpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RydWN0LmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZFRvRGVsZXRlU2V0KHVuYXBwbGllZERTLCBjbGllbnQsIGNsb2NrLCBjbG9ja0VuZCAtIGNsb2NrKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodW5hcHBsaWVkRFMuY2xpZW50cy5zaXplID4gMCkge1xuICAgIGNvbnN0IGRzID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGRzLnJlc3RFbmNvZGVyLCAwKSAvLyBlbmNvZGUgMCBzdHJ1Y3RzXG4gICAgd3JpdGVEZWxldGVTZXQoZHMsIHVuYXBwbGllZERTKVxuICAgIHJldHVybiBkcy50b1VpbnQ4QXJyYXkoKVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzMVxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzMlxuICovXG5leHBvcnQgY29uc3QgZXF1YWxEZWxldGVTZXRzID0gKGRzMSwgZHMyKSA9PiB7XG4gIGlmIChkczEuY2xpZW50cy5zaXplICE9PSBkczIuY2xpZW50cy5zaXplKSByZXR1cm4gZmFsc2VcbiAgZm9yIChjb25zdCBbY2xpZW50LCBkZWxldGVJdGVtczFdIG9mIGRzMS5jbGllbnRzLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGRlbGV0ZUl0ZW1zMiA9IC8qKiBAdHlwZSB7QXJyYXk8aW1wb3J0KCcuLi9pbnRlcm5hbHMuanMnKS5EZWxldGVJdGVtPn0gKi8gKGRzMi5jbGllbnRzLmdldChjbGllbnQpKVxuICAgIGlmIChkZWxldGVJdGVtczIgPT09IHVuZGVmaW5lZCB8fCBkZWxldGVJdGVtczEubGVuZ3RoICE9PSBkZWxldGVJdGVtczIubGVuZ3RoKSByZXR1cm4gZmFsc2VcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGV0ZUl0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZGkxID0gZGVsZXRlSXRlbXMxW2ldXG4gICAgICBjb25zdCBkaTIgPSBkZWxldGVJdGVtczJbaV1cbiAgICAgIGlmIChkaTEuY2xvY2sgIT09IGRpMi5jbG9jayB8fCBkaTEubGVuICE9PSBkaTIubGVuKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBZXG4gKi9cblxuaW1wb3J0IHtcbiAgU3RydWN0U3RvcmUsXG4gIEFic3RyYWN0VHlwZSxcbiAgWUFycmF5LFxuICBZVGV4dCxcbiAgWU1hcCxcbiAgWVhtbEVsZW1lbnQsXG4gIFlYbWxGcmFnbWVudCxcbiAgdHJhbnNhY3QsXG4gIENvbnRlbnREb2MsIEl0ZW0sIFRyYW5zYWN0aW9uLCBZRXZlbnQgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCB7IE9ic2VydmFibGVWMiB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIHJhbmRvbSBmcm9tICdsaWIwL3JhbmRvbSdcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJ2xpYjAvcHJvbWlzZSdcblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlTmV3Q2xpZW50SWQgPSByYW5kb20udWludDMyXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gRG9jT3B0c1xuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5nYz10cnVlXSBEaXNhYmxlIGdhcmJhZ2UgY29sbGVjdGlvbiAoZGVmYXVsdDogZ2M9dHJ1ZSlcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gW0RvY09wdHMuZ2NGaWx0ZXJdIFdpbGwgYmUgY2FsbGVkIGJlZm9yZSBhbiBJdGVtIGlzIGdhcmJhZ2UgY29sbGVjdGVkLiBSZXR1cm4gZmFsc2UgdG8ga2VlcCB0aGUgSXRlbS5cbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRG9jT3B0cy5ndWlkXSBEZWZpbmUgYSBnbG9iYWxseSB1bmlxdWUgaWRlbnRpZmllciBmb3IgdGhpcyBkb2N1bWVudFxuICogQHByb3BlcnR5IHtzdHJpbmcgfCBudWxsfSBbRG9jT3B0cy5jb2xsZWN0aW9uaWRdIEFzc29jaWF0ZSB0aGlzIGRvY3VtZW50IHdpdGggYSBjb2xsZWN0aW9uLiBUaGlzIG9ubHkgcGxheXMgYSByb2xlIGlmIHlvdXIgcHJvdmlkZXIgaGFzIGEgY29uY2VwdCBvZiBjb2xsZWN0aW9uLlxuICogQHByb3BlcnR5IHthbnl9IFtEb2NPcHRzLm1ldGFdIEFueSBraW5kIG9mIG1ldGEgaW5mb3JtYXRpb24geW91IHdhbnQgdG8gYXNzb2NpYXRlIHdpdGggdGhpcyBkb2N1bWVudC4gSWYgdGhpcyBpcyBhIHN1YmRvY3VtZW50LCByZW1vdGUgcGVlcnMgd2lsbCBzdG9yZSB0aGUgbWV0YSBpbmZvcm1hdGlvbiBhcyB3ZWxsLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbRG9jT3B0cy5hdXRvTG9hZF0gSWYgYSBzdWJkb2N1bWVudCwgYXV0b21hdGljYWxseSBsb2FkIGRvY3VtZW50LiBJZiB0aGlzIGlzIGEgc3ViZG9jdW1lbnQsIHJlbW90ZSBwZWVycyB3aWxsIGxvYWQgdGhlIGRvY3VtZW50IGFzIHdlbGwgYXV0b21hdGljYWxseS5cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW0RvY09wdHMuc2hvdWxkTG9hZF0gV2hldGhlciB0aGUgZG9jdW1lbnQgc2hvdWxkIGJlIHN5bmNlZCBieSB0aGUgcHJvdmlkZXIgbm93LiBUaGlzIGlzIHRvZ2dsZWQgdG8gdHJ1ZSB3aGVuIHlvdSBjYWxsIHlkb2MubG9hZCgpXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBEb2NFdmVudHNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oRG9jKTp2b2lkfSBEb2NFdmVudHMuZGVzdHJveVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihEb2MpOnZvaWR9IERvY0V2ZW50cy5sb2FkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKGJvb2xlYW4sIERvYyk6dm9pZH0gRG9jRXZlbnRzLnN5bmNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVWludDhBcnJheSwgYW55LCBEb2MsIFRyYW5zYWN0aW9uKTp2b2lkfSBEb2NFdmVudHMudXBkYXRlXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFVpbnQ4QXJyYXksIGFueSwgRG9jLCBUcmFuc2FjdGlvbik6dm9pZH0gRG9jRXZlbnRzLnVwZGF0ZVYyXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKERvYyk6dm9pZH0gRG9jRXZlbnRzLmJlZm9yZUFsbFRyYW5zYWN0aW9uc1xuICogQHByb3BlcnR5IHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRG9jKTp2b2lkfSBEb2NFdmVudHMuYmVmb3JlVHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERvYyk6dm9pZH0gRG9jRXZlbnRzLmJlZm9yZU9ic2VydmVyQ2FsbHNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERvYyk6dm9pZH0gRG9jRXZlbnRzLmFmdGVyVHJhbnNhY3Rpb25cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oVHJhbnNhY3Rpb24sIERvYyk6dm9pZH0gRG9jRXZlbnRzLmFmdGVyVHJhbnNhY3Rpb25DbGVhbnVwXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKERvYywgQXJyYXk8VHJhbnNhY3Rpb24+KTp2b2lkfSBEb2NFdmVudHMuYWZ0ZXJBbGxUcmFuc2FjdGlvbnNcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oeyBsb2FkZWQ6IFNldDxEb2M+LCBhZGRlZDogU2V0PERvYz4sIHJlbW92ZWQ6IFNldDxEb2M+IH0sIERvYywgVHJhbnNhY3Rpb24pOnZvaWR9IERvY0V2ZW50cy5zdWJkb2NzXG4gKi9cblxuLyoqXG4gKiBBIFlqcyBpbnN0YW5jZSBoYW5kbGVzIHRoZSBzdGF0ZSBvZiBzaGFyZWQgZGF0YS5cbiAqIEBleHRlbmRzIE9ic2VydmFibGVWMjxEb2NFdmVudHM+XG4gKi9cbmV4cG9ydCBjbGFzcyBEb2MgZXh0ZW5kcyBPYnNlcnZhYmxlVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtEb2NPcHRzfSBvcHRzIGNvbmZpZ3VyYXRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yICh7IGd1aWQgPSByYW5kb20udXVpZHY0KCksIGNvbGxlY3Rpb25pZCA9IG51bGwsIGdjID0gdHJ1ZSwgZ2NGaWx0ZXIgPSAoKSA9PiB0cnVlLCBtZXRhID0gbnVsbCwgYXV0b0xvYWQgPSBmYWxzZSwgc2hvdWxkTG9hZCA9IHRydWUgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZ2MgPSBnY1xuICAgIHRoaXMuZ2NGaWx0ZXIgPSBnY0ZpbHRlclxuICAgIHRoaXMuY2xpZW50SUQgPSBnZW5lcmF0ZU5ld0NsaWVudElkKClcbiAgICB0aGlzLmd1aWQgPSBndWlkXG4gICAgdGhpcy5jb2xsZWN0aW9uaWQgPSBjb2xsZWN0aW9uaWRcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgQWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+Pj59XG4gICAgICovXG4gICAgdGhpcy5zaGFyZSA9IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RvcmUgPSBuZXcgU3RydWN0U3RvcmUoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtUcmFuc2FjdGlvbiB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fdHJhbnNhY3Rpb24gPSBudWxsXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFRyYW5zYWN0aW9uPn1cbiAgICAgKi9cbiAgICB0aGlzLl90cmFuc2FjdGlvbkNsZWFudXBzID0gW11cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzID0gbmV3IFNldCgpXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBkb2N1bWVudCBpcyBhIHN1YmRvY3VtZW50IC0gYSBkb2N1bWVudCBpbnRlZ3JhdGVkIGludG8gYW5vdGhlciBkb2N1bWVudCAtIHRoZW4gX2l0ZW0gaXMgZGVmaW5lZC5cbiAgICAgKiBAdHlwZSB7SXRlbT99XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGxcbiAgICB0aGlzLnNob3VsZExvYWQgPSBzaG91bGRMb2FkXG4gICAgdGhpcy5hdXRvTG9hZCA9IGF1dG9Mb2FkXG4gICAgdGhpcy5tZXRhID0gbWV0YVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2V0IHRvIHRydWUgd2hlbiB0aGUgcGVyc2lzdGVuY2UgcHJvdmlkZXIgbG9hZGVkIHRoZSBkb2N1bWVudCBmcm9tIHRoZSBkYXRhYmFzZSBvciB3aGVuIHRoZSBgc3luY2AgZXZlbnQgZmlyZXMuXG4gICAgICogTm90ZSB0aGF0IG5vdCBhbGwgcHJvdmlkZXJzIGltcGxlbWVudCB0aGlzIGZlYXR1cmUuIFByb3ZpZGVyIGF1dGhvcnMgYXJlIGVuY291cmFnZWQgdG8gZmlyZSB0aGUgYGxvYWRgIGV2ZW50IHdoZW4gdGhlIGRvYyBjb250ZW50IGlzIGxvYWRlZCBmcm9tIHRoZSBkYXRhYmFzZS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgc2V0IHRvIHRydWUgd2hlbiB0aGUgY29ubmVjdGlvbiBwcm92aWRlciBoYXMgc3VjY2Vzc2Z1bGx5IHN5bmNlZCB3aXRoIGEgYmFja2VuZC5cbiAgICAgKiBOb3RlIHRoYXQgd2hlbiB1c2luZyBwZWVyLXRvLXBlZXIgcHJvdmlkZXJzIHRoaXMgZXZlbnQgbWF5IG5vdCBwcm92aWRlIHZlcnkgdXNlZnVsLlxuICAgICAqIEFsc28gbm90ZSB0aGF0IG5vdCBhbGwgcHJvdmlkZXJzIGltcGxlbWVudCB0aGlzIGZlYXR1cmUuIFByb3ZpZGVyIGF1dGhvcnMgYXJlIGVuY291cmFnZWQgdG8gZmlyZVxuICAgICAqIHRoZSBgc3luY2AgZXZlbnQgd2hlbiB0aGUgZG9jIGhhcyBiZWVuIHN5bmNlZCAod2l0aCBgdHJ1ZWAgYXMgYSBwYXJhbWV0ZXIpIG9yIGlmIGNvbm5lY3Rpb24gaXNcbiAgICAgKiBsb3N0ICh3aXRoIGZhbHNlIGFzIGEgcGFyYW1ldGVyKS5cbiAgICAgKi9cbiAgICB0aGlzLmlzU3luY2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgZG9jdW1lbnQgaGFzIGJlZW4gbG9hZGVkIGZyb20gYSBwcmVzaXN0ZW5jZSBwcm92aWRlci5cbiAgICAgKi9cbiAgICB0aGlzLndoZW5Mb2FkZWQgPSBwcm9taXNlLmNyZWF0ZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMub24oJ2xvYWQnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlXG4gICAgICAgIHJlc29sdmUodGhpcylcbiAgICAgIH0pXG4gICAgfSlcbiAgICBjb25zdCBwcm92aWRlU3luY2VkUHJvbWlzZSA9ICgpID0+IHByb21pc2UuY3JlYXRlKHJlc29sdmUgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzU3luY2VkXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGV2ZW50SGFuZGxlciA9IChpc1N5bmNlZCkgPT4ge1xuICAgICAgICBpZiAoaXNTeW5jZWQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bmNlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIHRoaXMub2ZmKCdzeW5jJywgZXZlbnRIYW5kbGVyKVxuICAgICAgICAgIHJlc29sdmUoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLm9uKCdzeW5jJywgZXZlbnRIYW5kbGVyKVxuICAgIH0pXG4gICAgdGhpcy5vbignc3luYycsIGlzU3luY2VkID0+IHtcbiAgICAgIGlmIChpc1N5bmNlZCA9PT0gZmFsc2UgJiYgdGhpcy5pc1N5bmNlZCkge1xuICAgICAgICB0aGlzLndoZW5TeW5jZWQgPSBwcm92aWRlU3luY2VkUHJvbWlzZSgpXG4gICAgICB9XG4gICAgICB0aGlzLmlzU3luY2VkID0gaXNTeW5jZWQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bmNlZCA9PT0gdHJ1ZVxuICAgICAgaWYgKHRoaXMuaXNTeW5jZWQgJiYgIXRoaXMuaXNMb2FkZWQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2FkJywgW3RoaXNdKVxuICAgICAgfVxuICAgIH0pXG4gICAgLyoqXG4gICAgICogUHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIGRvY3VtZW50IGhhcyBiZWVuIHN5bmNlZCB3aXRoIGEgYmFja2VuZC5cbiAgICAgKiBUaGlzIHByb21pc2UgaXMgcmVjcmVhdGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gaXMgbG9zdC5cbiAgICAgKiBOb3RlIHRoZSBkb2N1bWVudGF0aW9uIGFib3V0IHRoZSBgaXNTeW5jZWRgIHByb3BlcnR5LlxuICAgICAqL1xuICAgIHRoaXMud2hlblN5bmNlZCA9IHByb3ZpZGVTeW5jZWRQcm9taXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3RpZnkgdGhlIHBhcmVudCBkb2N1bWVudCB0aGF0IHlvdSByZXF1ZXN0IHRvIGxvYWQgZGF0YSBpbnRvIHRoaXMgc3ViZG9jdW1lbnQgKGlmIGl0IGlzIGEgc3ViZG9jdW1lbnQpLlxuICAgKlxuICAgKiBgbG9hZCgpYCBtaWdodCBiZSB1c2VkIGluIHRoZSBmdXR1cmUgdG8gcmVxdWVzdCBhbnkgcHJvdmlkZXIgdG8gbG9hZCB0aGUgbW9zdCBjdXJyZW50IGRhdGEuXG4gICAqXG4gICAqIEl0IGlzIHNhZmUgdG8gY2FsbCBgbG9hZCgpYCBtdWx0aXBsZSB0aW1lcy5cbiAgICovXG4gIGxvYWQgKCkge1xuICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9pdGVtXG4gICAgaWYgKGl0ZW0gIT09IG51bGwgJiYgIXRoaXMuc2hvdWxkTG9hZCkge1xuICAgICAgdHJhbnNhY3QoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtLnBhcmVudCkuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMpXG4gICAgICB9LCBudWxsLCB0cnVlKVxuICAgIH1cbiAgICB0aGlzLnNob3VsZExvYWQgPSB0cnVlXG4gIH1cblxuICBnZXRTdWJkb2NzICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJkb2NzXG4gIH1cblxuICBnZXRTdWJkb2NHdWlkcyAoKSB7XG4gICAgcmV0dXJuIG5ldyBTZXQoYXJyYXkuZnJvbSh0aGlzLnN1YmRvY3MpLm1hcChkb2MgPT4gZG9jLmd1aWQpKVxuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhhdCBoYXBwZW4gaW5zaWRlIG9mIGEgdHJhbnNhY3Rpb24gYXJlIGJ1bmRsZWQuIFRoaXMgbWVhbnMgdGhhdFxuICAgKiB0aGUgb2JzZXJ2ZXIgZmlyZXMgX2FmdGVyXyB0aGUgdHJhbnNhY3Rpb24gaXMgZmluaXNoZWQgYW5kIHRoYXQgYWxsIGNoYW5nZXNcbiAgICogdGhhdCBoYXBwZW5lZCBpbnNpZGUgb2YgdGhlIHRyYW5zYWN0aW9uIGFyZSBzZW50IGFzIG9uZSBtZXNzYWdlIHRvIHRoZVxuICAgKiBvdGhlciBwZWVycy5cbiAgICpcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6VH0gZiBUaGUgZnVuY3Rpb24gdGhhdCBzaG91bGQgYmUgZXhlY3V0ZWQgYXMgYSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge2FueX0gW29yaWdpbl0gT3JpZ2luIG9mIHdobyBzdGFydGVkIHRoZSB0cmFuc2FjdGlvbi4gV2lsbCBiZSBzdG9yZWQgb24gdHJhbnNhY3Rpb24ub3JpZ2luXG4gICAqIEByZXR1cm4gVFxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0cmFuc2FjdCAoZiwgb3JpZ2luID0gbnVsbCkge1xuICAgIHJldHVybiB0cmFuc2FjdCh0aGlzLCBmLCBvcmlnaW4pXG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgc2hhcmVkIGRhdGEgdHlwZS5cbiAgICpcbiAgICogTXVsdGlwbGUgY2FsbHMgb2YgYHlkb2MuZ2V0KG5hbWUsIFR5cGVDb25zdHJ1Y3RvcilgIHlpZWxkIHRoZSBzYW1lIHJlc3VsdFxuICAgKiBhbmQgZG8gbm90IG92ZXJ3cml0ZSBlYWNoIG90aGVyLiBJLmUuXG4gICAqIGB5ZG9jLmdldChuYW1lLCBZLkFycmF5KSA9PT0geWRvYy5nZXQobmFtZSwgWS5BcnJheSlgXG4gICAqXG4gICAqIEFmdGVyIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCwgdGhlIHR5cGUgaXMgYWxzbyBhdmFpbGFibGUgb24gYHlkb2Muc2hhcmUuZ2V0KG5hbWUpYC5cbiAgICpcbiAgICogKkJlc3QgUHJhY3RpY2VzOipcbiAgICogRGVmaW5lIGFsbCB0eXBlcyByaWdodCBhZnRlciB0aGUgWS5Eb2MgaW5zdGFuY2UgaXMgY3JlYXRlZCBhbmQgc3RvcmUgdGhlbSBpbiBhIHNlcGFyYXRlIG9iamVjdC5cbiAgICogQWxzbyB1c2UgdGhlIHR5cGVkIG1ldGhvZHMgYGdldFRleHQobmFtZSlgLCBgZ2V0QXJyYXkobmFtZSlgLCAuLlxuICAgKlxuICAgKiBAdGVtcGxhdGUge3R5cGVvZiBBYnN0cmFjdFR5cGU8YW55Pn0gVHlwZVxuICAgKiBAZXhhbXBsZVxuICAgKiAgIGNvbnN0IHlkb2MgPSBuZXcgWS5Eb2MoLi4pXG4gICAqICAgY29uc3QgYXBwU3RhdGUgPSB7XG4gICAqICAgICBkb2N1bWVudDogeWRvYy5nZXRUZXh0KCdkb2N1bWVudCcpXG4gICAqICAgICBjb21tZW50czogeWRvYy5nZXRBcnJheSgnY29tbWVudHMnKVxuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtUeXBlfSBUeXBlQ29uc3RydWN0b3IgVGhlIGNvbnN0cnVjdG9yIG9mIHRoZSB0eXBlIGRlZmluaXRpb24uIEUuZy4gWS5UZXh0LCBZLkFycmF5LCBZLk1hcCwgLi4uXG4gICAqIEByZXR1cm4ge0luc3RhbmNlVHlwZTxUeXBlPn0gVGhlIGNyZWF0ZWQgdHlwZS4gQ29uc3RydWN0ZWQgd2l0aCBUeXBlQ29uc3RydWN0b3JcbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IChuYW1lLCBUeXBlQ29uc3RydWN0b3IgPSAvKiogQHR5cGUge2FueX0gKi8gKEFic3RyYWN0VHlwZSkpIHtcbiAgICBjb25zdCB0eXBlID0gbWFwLnNldElmVW5kZWZpbmVkKHRoaXMuc2hhcmUsIG5hbWUsICgpID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGNvbnN0IHQgPSBuZXcgVHlwZUNvbnN0cnVjdG9yKClcbiAgICAgIHQuX2ludGVncmF0ZSh0aGlzLCBudWxsKVxuICAgICAgcmV0dXJuIHRcbiAgICB9KVxuICAgIGNvbnN0IENvbnN0ciA9IHR5cGUuY29uc3RydWN0b3JcbiAgICBpZiAoVHlwZUNvbnN0cnVjdG9yICE9PSBBYnN0cmFjdFR5cGUgJiYgQ29uc3RyICE9PSBUeXBlQ29uc3RydWN0b3IpIHtcbiAgICAgIGlmIChDb25zdHIgPT09IEFic3RyYWN0VHlwZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNvbnN0IHQgPSBuZXcgVHlwZUNvbnN0cnVjdG9yKClcbiAgICAgICAgdC5fbWFwID0gdHlwZS5fbWFwXG4gICAgICAgIHR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0/fSBuICovIG4gPT4ge1xuICAgICAgICAgIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5sZWZ0KSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBuLnBhcmVudCA9IHRcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIHQuX3N0YXJ0ID0gdHlwZS5fc3RhcnRcbiAgICAgICAgZm9yIChsZXQgbiA9IHQuX3N0YXJ0OyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgICAgICAgIG4ucGFyZW50ID0gdFxuICAgICAgICB9XG4gICAgICAgIHQuX2xlbmd0aCA9IHR5cGUuX2xlbmd0aFxuICAgICAgICB0aGlzLnNoYXJlLnNldChuYW1lLCB0KVxuICAgICAgICB0Ll9pbnRlZ3JhdGUodGhpcywgbnVsbClcbiAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7SW5zdGFuY2VUeXBlPFR5cGU+fSAqLyAodClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHlwZSB3aXRoIHRoZSBuYW1lICR7bmFtZX0gaGFzIGFscmVhZHkgYmVlbiBkZWZpbmVkIHdpdGggYSBkaWZmZXJlbnQgY29uc3RydWN0b3JgKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHtJbnN0YW5jZVR5cGU8VHlwZT59ICovICh0eXBlKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0ZW1wbGF0ZSBUXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBcnJheSAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7WUFycmF5PFQ+fSAqLyAodGhpcy5nZXQobmFtZSwgWUFycmF5KSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRUZXh0IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gdGhpcy5nZXQobmFtZSwgWVRleHQpXG4gIH1cblxuICAvKipcbiAgICogQHRlbXBsYXRlIFRcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtuYW1lXVxuICAgKiBAcmV0dXJuIHtZTWFwPFQ+fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRNYXAgKG5hbWUgPSAnJykge1xuICAgIHJldHVybiAvKiogQHR5cGUge1lNYXA8VD59ICovICh0aGlzLmdldChuYW1lLCBZTWFwKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW25hbWVdXG4gICAqIEByZXR1cm4ge1lYbWxFbGVtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRYbWxFbGVtZW50IChuYW1lID0gJycpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHtZWG1sRWxlbWVudDx7W2tleTpzdHJpbmddOnN0cmluZ30+fSAqLyAodGhpcy5nZXQobmFtZSwgWVhtbEVsZW1lbnQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZV1cbiAgICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRYbWxGcmFnbWVudCAobmFtZSA9ICcnKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIFlYbWxGcmFnbWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyB0aGUgZW50aXJlIGRvY3VtZW50IGludG8gYSBqcyBvYmplY3QsIHJlY3Vyc2l2ZWx5IHRyYXZlcnNpbmcgZWFjaCB5anMgdHlwZVxuICAgKiBEb2Vzbid0IGxvZyB0eXBlcyB0aGF0IGhhdmUgbm90IGJlZW4gZGVmaW5lZCAodXNpbmcgeWRvYy5nZXRUeXBlKC4uKSkuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QgYW5kIHJhdGhlciBjYWxsIHRvSlNPTiBkaXJlY3RseSBvbiB0aGUgc2hhcmVkIHR5cGVzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZywgYW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkb2MgPSB7fVxuXG4gICAgdGhpcy5zaGFyZS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBkb2Nba2V5XSA9IHZhbHVlLnRvSlNPTigpXG4gICAgfSlcblxuICAgIHJldHVybiBkb2NcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGBkZXN0cm95YCBldmVudCBhbmQgdW5yZWdpc3RlciBhbGwgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBkZXN0cm95ICgpIHtcbiAgICBhcnJheS5mcm9tKHRoaXMuc3ViZG9jcykuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSlcbiAgICBjb25zdCBpdGVtID0gdGhpcy5faXRlbVxuICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9pdGVtID0gbnVsbFxuICAgICAgY29uc3QgY29udGVudCA9IC8qKiBAdHlwZSB7Q29udGVudERvY30gKi8gKGl0ZW0uY29udGVudClcbiAgICAgIGNvbnRlbnQuZG9jID0gbmV3IERvYyh7IGd1aWQ6IHRoaXMuZ3VpZCwgLi4uY29udGVudC5vcHRzLCBzaG91bGRMb2FkOiBmYWxzZSB9KVxuICAgICAgY29udGVudC5kb2MuX2l0ZW0gPSBpdGVtXG4gICAgICB0cmFuc2FjdCgvKiogQHR5cGUge2FueX0gKi8gKGl0ZW0pLnBhcmVudC5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgY29uc3QgZG9jID0gY29udGVudC5kb2NcbiAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuYWRkKGRvYylcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbi5zdWJkb2NzUmVtb3ZlZC5hZGQodGhpcylcbiAgICAgIH0sIG51bGwsIHRydWUpXG4gICAgfVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3llZCcsIFt0cnVlXSkgLy8gREVQUkVDQVRFRCFcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnbGliMC9idWZmZXInXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0IHtcbiAgSUQsIGNyZWF0ZUlEXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuZXhwb3J0IGNsYXNzIERTRGVjb2RlclYxIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRlY29kZXIpIHtcbiAgICB0aGlzLnJlc3REZWNvZGVyID0gZGVjb2RlclxuICB9XG5cbiAgcmVzZXREc0N1clZhbCAoKSB7XG4gICAgLy8gbm9wXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcmVhZERzQ2xvY2sgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFVwZGF0ZURlY29kZXJWMSBleHRlbmRzIERTRGVjb2RlclYxIHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge0lEfVxuICAgKi9cbiAgcmVhZExlZnRJRCAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUlEKGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpLCBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQodGhpcy5yZXN0RGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRJbmZvICgpIHtcbiAgICByZXR1cm4gZGVjb2RpbmcucmVhZFVpbnQ4KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZFN0cmluZyAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBpc0tleVxuICAgKi9cbiAgcmVhZFBhcmVudEluZm8gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKSA9PT0gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICByZWFkVHlwZVJlZiAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHJlYWRMZW4gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBidWZmZXIuY29weVVpbnQ4QXJyYXkoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogTGVnYWN5IGltcGxlbWVudGF0aW9uIHVzZXMgSlNPTiBwYXJzZS4gV2UgdXNlIGFueS1kZWNvZGluZyBpbiB2Mi5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcikpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgcmV0dXJuIGRlY29kaW5nLnJlYWRWYXJTdHJpbmcodGhpcy5yZXN0RGVjb2RlcilcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgRFNEZWNvZGVyVjIge1xuICAvKipcbiAgICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2Rlcikge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5kc0N1cnJWYWwgPSAwXG4gICAgdGhpcy5yZXN0RGVjb2RlciA9IGRlY29kZXJcbiAgfVxuXG4gIHJlc2V0RHNDdXJWYWwgKCkge1xuICAgIHRoaXMuZHNDdXJyVmFsID0gMFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0Nsb2NrICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCArPSBkZWNvZGluZy5yZWFkVmFyVWludCh0aGlzLnJlc3REZWNvZGVyKVxuICAgIHJldHVybiB0aGlzLmRzQ3VyclZhbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIHJlYWREc0xlbiAoKSB7XG4gICAgY29uc3QgZGlmZiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KHRoaXMucmVzdERlY29kZXIpICsgMVxuICAgIHRoaXMuZHNDdXJyVmFsICs9IGRpZmZcbiAgICByZXR1cm4gZGlmZlxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVEZWNvZGVyVjIgZXh0ZW5kcyBEU0RlY29kZXJWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWNvZGVyKSB7XG4gICAgc3VwZXIoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGNhY2hlZCBrZXlzLiBJZiB0aGUga2V5c1tpZF0gZG9lcyBub3QgZXhpc3QsIHdlIHJlYWQgYSBuZXcga2V5XG4gICAgICogZnJvbSBzdHJpbmdFbmNvZGVyIGFuZCBwdXNoIGl0IHRvIGtleXMuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSBbXVxuICAgIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpIC8vIHJlYWQgZmVhdHVyZSBmbGFnIC0gY3VycmVudGx5IHVudXNlZFxuICAgIHRoaXMua2V5Q2xvY2tEZWNvZGVyID0gbmV3IGRlY29kaW5nLkludERpZmZPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMuY2xpZW50RGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgICB0aGlzLmxlZnRDbG9ja0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuSW50RGlmZk9wdFJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlcikpXG4gICAgdGhpcy5yaWdodENsb2NrRGVjb2RlciA9IG5ldyBkZWNvZGluZy5JbnREaWZmT3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgICB0aGlzLmluZm9EZWNvZGVyID0gbmV3IGRlY29kaW5nLlJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIGRlY29kaW5nLnJlYWRVaW50OClcbiAgICB0aGlzLnN0cmluZ0RlY29kZXIgPSBuZXcgZGVjb2RpbmcuU3RyaW5nRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgICB0aGlzLnBhcmVudEluZm9EZWNvZGVyID0gbmV3IGRlY29kaW5nLlJsZURlY29kZXIoZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIGRlY29kaW5nLnJlYWRVaW50OClcbiAgICB0aGlzLnR5cGVSZWZEZWNvZGVyID0gbmV3IGRlY29kaW5nLlVpbnRPcHRSbGVEZWNvZGVyKGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpKVxuICAgIHRoaXMubGVuRGVjb2RlciA9IG5ldyBkZWNvZGluZy5VaW50T3B0UmxlRGVjb2RlcihkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRMZWZ0SUQgKCkge1xuICAgIHJldHVybiBuZXcgSUQodGhpcy5jbGllbnREZWNvZGVyLnJlYWQoKSwgdGhpcy5sZWZ0Q2xvY2tEZWNvZGVyLnJlYWQoKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJRH1cbiAgICovXG4gIHJlYWRSaWdodElEICgpIHtcbiAgICByZXR1cm4gbmV3IElEKHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKCksIHRoaXMucmlnaHRDbG9ja0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWQgdGhlIG5leHQgY2xpZW50IGlkLlxuICAgKiBVc2UgdGhpcyBpbiBmYXZvciBvZiByZWFkSUQgd2hlbmV2ZXIgcG9zc2libGUgdG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygb2JqZWN0cyBjcmVhdGVkLlxuICAgKi9cbiAgcmVhZENsaWVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50RGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgcmVhZEluZm8gKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge251bWJlcn0gKi8gKHRoaXMuaW5mb0RlY29kZXIucmVhZCgpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIHJlYWRTdHJpbmcgKCkge1xuICAgIHJldHVybiB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIHJlYWRQYXJlbnRJbmZvICgpIHtcbiAgICByZXR1cm4gdGhpcy5wYXJlbnRJbmZvRGVjb2Rlci5yZWFkKCkgPT09IDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHJlYWRUeXBlUmVmICgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlUmVmRGVjb2Rlci5yZWFkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBXcml0ZSBsZW4gb2YgYSBzdHJ1Y3QgLSB3ZWxsIHN1aXRlZCBmb3IgT3B0IFJMRSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICByZWFkTGVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5EZWNvZGVyLnJlYWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHJlYWRBbnkgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7VWludDhBcnJheX1cbiAgICovXG4gIHJlYWRCdWYgKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheSh0aGlzLnJlc3REZWNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgbWFpbmx5IGhlcmUgZm9yIGxlZ2FjeSBwdXJwb3Nlcy5cbiAgICpcbiAgICogSW5pdGlhbCB3ZSBpbmNvZGVkIG9iamVjdHMgdXNpbmcgSlNPTi4gTm93IHdlIHVzZSB0aGUgbXVjaCBmYXN0ZXIgbGliMC9hbnktZW5jb2Rlci4gVGhpcyBtZXRob2QgbWFpbmx5IGV4aXN0cyBmb3IgbGVnYWN5IHB1cnBvc2VzIGZvciB0aGUgdjEgZW5jb2Rlci5cbiAgICpcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgcmVhZEpTT04gKCkge1xuICAgIHJldHVybiBkZWNvZGluZy5yZWFkQW55KHRoaXMucmVzdERlY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgcmVhZEtleSAoKSB7XG4gICAgY29uc3Qga2V5Q2xvY2sgPSB0aGlzLmtleUNsb2NrRGVjb2Rlci5yZWFkKClcbiAgICBpZiAoa2V5Q2xvY2sgPCB0aGlzLmtleXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5rZXlzW2tleUNsb2NrXVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLnN0cmluZ0RlY29kZXIucmVhZCgpXG4gICAgICB0aGlzLmtleXMucHVzaChrZXkpXG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG59XG4iLCAiaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5cbmltcG9ydCB7XG4gIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY2xhc3MgRFNFbmNvZGVyVjEge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgdGhpcy5yZXN0RW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICAvLyBub3BcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIHdyaXRlRHNDbG9jayAoY2xvY2spIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgY2xvY2spXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVEc0xlbiAobGVuKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGxlbilcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVXBkYXRlRW5jb2RlclYxIGV4dGVuZHMgRFNFbmNvZGVyVjEge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICovXG4gIHdyaXRlTGVmdElEIChpZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpZC5jbGllbnQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsb2NrKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZVJpZ2h0SUQgKGlkKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlkLmNsaWVudClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgaWQuY2xvY2spXG4gIH1cblxuICAvKipcbiAgICogVXNlIHdyaXRlQ2xpZW50IGFuZCB3cml0ZUNsb2NrIGluc3RlYWQgb2Ygd3JpdGVJRCBpZiBwb3NzaWJsZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKi9cbiAgd3JpdGVDbGllbnQgKGNsaWVudCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBjbGllbnQpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZm8gQW4gdW5zaWduZWQgOC1iaXQgaW50ZWdlclxuICAgKi9cbiAgd3JpdGVJbmZvIChpbmZvKSB7XG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzXG4gICAqL1xuICB3cml0ZVN0cmluZyAocykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIHMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1lLZXlcbiAgICovXG4gIHdyaXRlUGFyZW50SW5mbyAoaXNZS2V5KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHRoaXMucmVzdEVuY29kZXIsIGlzWUtleSA/IDEgOiAwKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmZvIEFuIHVuc2lnbmVkIDgtYml0IGludGVnZXJcbiAgICovXG4gIHdyaXRlVHlwZVJlZiAoaW5mbykge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBpbmZvKVxuICB9XG5cbiAgLyoqXG4gICAqIFdyaXRlIGxlbiBvZiBhIHN0cnVjdCAtIHdlbGwgc3VpdGVkIGZvciBPcHQgUkxFIGVuY29kZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAgICovXG4gIHdyaXRlTGVuIChsZW4pIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgbGVuKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBhbnlcbiAgICovXG4gIHdyaXRlQW55IChhbnkpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBhbnkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAgICovXG4gIHdyaXRlQnVmIChidWYpIHtcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlciwgYnVmKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBlbWJlZFxuICAgKi9cbiAgd3JpdGVKU09OIChlbWJlZCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKHRoaXMucmVzdEVuY29kZXIsIEpTT04uc3RyaW5naWZ5KGVtYmVkKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICB3cml0ZUtleSAoa2V5KSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcodGhpcy5yZXN0RW5jb2Rlciwga2V5KVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICB0aGlzLnJlc3RFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpIC8vIGVuY29kZXMgYWxsIHRoZSByZXN0IC8gbm9uLW9wdGltaXplZFxuICAgIHRoaXMuZHNDdXJyVmFsID0gMFxuICB9XG5cbiAgdG9VaW50OEFycmF5ICgpIHtcbiAgICByZXR1cm4gZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucmVzdEVuY29kZXIpXG4gIH1cblxuICByZXNldERzQ3VyVmFsICgpIHtcbiAgICB0aGlzLmRzQ3VyclZhbCA9IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIHdyaXRlRHNDbG9jayAoY2xvY2spIHtcbiAgICBjb25zdCBkaWZmID0gY2xvY2sgLSB0aGlzLmRzQ3VyclZhbFxuICAgIHRoaXMuZHNDdXJyVmFsID0gY2xvY2tcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQodGhpcy5yZXN0RW5jb2RlciwgZGlmZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuXG4gICAqL1xuICB3cml0ZURzTGVuIChsZW4pIHtcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICBlcnJvci51bmV4cGVjdGVkQ2FzZSgpXG4gICAgfVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludCh0aGlzLnJlc3RFbmNvZGVyLCBsZW4gLSAxKVxuICAgIHRoaXMuZHNDdXJyVmFsICs9IGxlblxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBVcGRhdGVFbmNvZGVyVjIgZXh0ZW5kcyBEU0VuY29kZXJWMiB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsbnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKVxuICAgIC8qKlxuICAgICAqIFJlZmVycyB0byB0aGUgbmV4dCB1bmlxZSBrZXktaWRlbnRpZmllciB0byBtZSB1c2VkLlxuICAgICAqIFNlZSB3cml0ZUtleSBtZXRob2QgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMua2V5Q2xvY2sgPSAwXG4gICAgdGhpcy5rZXlDbG9ja0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuSW50RGlmZk9wdFJsZUVuY29kZXIoKVxuICAgIHRoaXMuY2xpZW50RW5jb2RlciA9IG5ldyBlbmNvZGluZy5VaW50T3B0UmxlRW5jb2RlcigpXG4gICAgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKClcbiAgICB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyID0gbmV3IGVuY29kaW5nLkludERpZmZPcHRSbGVFbmNvZGVyKClcbiAgICB0aGlzLmluZm9FbmNvZGVyID0gbmV3IGVuY29kaW5nLlJsZUVuY29kZXIoZW5jb2Rpbmcud3JpdGVVaW50OClcbiAgICB0aGlzLnN0cmluZ0VuY29kZXIgPSBuZXcgZW5jb2RpbmcuU3RyaW5nRW5jb2RlcigpXG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2RlciA9IG5ldyBlbmNvZGluZy5SbGVFbmNvZGVyKGVuY29kaW5nLndyaXRlVWludDgpXG4gICAgdGhpcy50eXBlUmVmRW5jb2RlciA9IG5ldyBlbmNvZGluZy5VaW50T3B0UmxlRW5jb2RlcigpXG4gICAgdGhpcy5sZW5FbmNvZGVyID0gbmV3IGVuY29kaW5nLlVpbnRPcHRSbGVFbmNvZGVyKClcbiAgfVxuXG4gIHRvVWludDhBcnJheSAoKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAwKSAvLyB0aGlzIGlzIGEgZmVhdHVyZSBmbGFnIHRoYXQgd2UgbWlnaHQgdXNlIGluIHRoZSBmdXR1cmVcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5rZXlDbG9ja0VuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMuY2xpZW50RW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdGhpcy5sZWZ0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnJpZ2h0Q2xvY2tFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5pbmZvRW5jb2RlcikpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHRoaXMuc3RyaW5nRW5jb2Rlci50b1VpbnQ4QXJyYXkoKSlcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgZW5jb2RpbmcudG9VaW50OEFycmF5KHRoaXMucGFyZW50SW5mb0VuY29kZXIpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLnR5cGVSZWZFbmNvZGVyLnRvVWludDhBcnJheSgpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCB0aGlzLmxlbkVuY29kZXIudG9VaW50OEFycmF5KCkpXG4gICAgLy8gQG5vdGUgVGhlIHJlc3QgZW5jb2RlciBpcyBhcHBlbmRlZCEgKG5vdGUgdGhlIG1pc3NpbmcgdmFyKVxuICAgIGVuY29kaW5nLndyaXRlVWludDhBcnJheShlbmNvZGVyLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkodGhpcy5yZXN0RW5jb2RlcikpXG4gICAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR9IGlkXG4gICAqL1xuICB3cml0ZUxlZnRJRCAoaWQpIHtcbiAgICB0aGlzLmNsaWVudEVuY29kZXIud3JpdGUoaWQuY2xpZW50KVxuICAgIHRoaXMubGVmdENsb2NrRW5jb2Rlci53cml0ZShpZC5jbG9jaylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKi9cbiAgd3JpdGVSaWdodElEIChpZCkge1xuICAgIHRoaXMuY2xpZW50RW5jb2Rlci53cml0ZShpZC5jbGllbnQpXG4gICAgdGhpcy5yaWdodENsb2NrRW5jb2Rlci53cml0ZShpZC5jbG9jaylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gICAqL1xuICB3cml0ZUNsaWVudCAoY2xpZW50KSB7XG4gICAgdGhpcy5jbGllbnRFbmNvZGVyLndyaXRlKGNsaWVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZUluZm8gKGluZm8pIHtcbiAgICB0aGlzLmluZm9FbmNvZGVyLndyaXRlKGluZm8pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNcbiAgICovXG4gIHdyaXRlU3RyaW5nIChzKSB7XG4gICAgdGhpcy5zdHJpbmdFbmNvZGVyLndyaXRlKHMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtib29sZWFufSBpc1lLZXlcbiAgICovXG4gIHdyaXRlUGFyZW50SW5mbyAoaXNZS2V5KSB7XG4gICAgdGhpcy5wYXJlbnRJbmZvRW5jb2Rlci53cml0ZShpc1lLZXkgPyAxIDogMClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5mbyBBbiB1bnNpZ25lZCA4LWJpdCBpbnRlZ2VyXG4gICAqL1xuICB3cml0ZVR5cGVSZWYgKGluZm8pIHtcbiAgICB0aGlzLnR5cGVSZWZFbmNvZGVyLndyaXRlKGluZm8pXG4gIH1cblxuICAvKipcbiAgICogV3JpdGUgbGVuIG9mIGEgc3RydWN0IC0gd2VsbCBzdWl0ZWQgZm9yIE9wdCBSTEUgZW5jb2Rlci5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgd3JpdGVMZW4gKGxlbikge1xuICAgIHRoaXMubGVuRW5jb2Rlci53cml0ZShsZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGFueVxuICAgKi9cbiAgd3JpdGVBbnkgKGFueSkge1xuICAgIGVuY29kaW5nLndyaXRlQW55KHRoaXMucmVzdEVuY29kZXIsIGFueSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGJ1ZlxuICAgKi9cbiAgd3JpdGVCdWYgKGJ1Zikge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheSh0aGlzLnJlc3RFbmNvZGVyLCBidWYpXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBtYWlubHkgaGVyZSBmb3IgbGVnYWN5IHB1cnBvc2VzLlxuICAgKlxuICAgKiBJbml0aWFsIHdlIGluY29kZWQgb2JqZWN0cyB1c2luZyBKU09OLiBOb3cgd2UgdXNlIHRoZSBtdWNoIGZhc3RlciBsaWIwL2FueS1lbmNvZGVyLiBUaGlzIG1ldGhvZCBtYWlubHkgZXhpc3RzIGZvciBsZWdhY3kgcHVycG9zZXMgZm9yIHRoZSB2MSBlbmNvZGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge2FueX0gZW1iZWRcbiAgICovXG4gIHdyaXRlSlNPTiAoZW1iZWQpIHtcbiAgICBlbmNvZGluZy53cml0ZUFueSh0aGlzLnJlc3RFbmNvZGVyLCBlbWJlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9wZXJ0eSBrZXlzIGFyZSBvZnRlbiByZXVzZWQuIEZvciBleGFtcGxlLCBpbiB5LXByb3NlbWlycm9yIHRoZSBrZXkgYGJvbGRgIG1pZ2h0XG4gICAqIG9jY3VyIHZlcnkgb2Z0ZW4uIEZvciBhIDNkIGFwcGxpY2F0aW9uLCB0aGUga2V5IGBwb3NpdGlvbmAgbWlnaHQgb2NjdXIgdmVyeSBvZnRlbi5cbiAgICpcbiAgICogV2UgY2FjaGUgdGhlc2Uga2V5cyBpbiBhIE1hcCBhbmQgcmVmZXIgdG8gdGhlbSB2aWEgYSB1bmlxdWUgbnVtYmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqL1xuICB3cml0ZUtleSAoa2V5KSB7XG4gICAgY29uc3QgY2xvY2sgPSB0aGlzLmtleU1hcC5nZXQoa2V5KVxuICAgIGlmIChjbG9jayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0b2RvIHVuY29tbWVudCB0byBpbnRyb2R1Y2UgdGhpcyBmZWF0dXJlIGZpbmFsbHlcbiAgICAgICAqXG4gICAgICAgKiBCYWNrZ3JvdW5kLiBUaGUgQ29udGVudEZvcm1hdCBvYmplY3Qgd2FzIGFsd2F5cyBlbmNvZGVkIHVzaW5nIHdyaXRlS2V5LCBidXQgdGhlIGRlY29kZXIgdXNlZCB0byB1c2UgcmVhZFN0cmluZy5cbiAgICAgICAqIEZ1cnRoZXJtb3JlLCBJIGZvcmdvdCB0byBzZXQgdGhlIGtleWNsb2NrLiBTbyBldmVyeXRoaW5nIHdhcyB3b3JraW5nIGZpbmUuXG4gICAgICAgKlxuICAgICAgICogSG93ZXZlciwgdGhpcyBmZWF0dXJlIGhlcmUgaXMgYmFzaWNhbGx5IHVzZWxlc3MgYXMgaXQgaXMgbm90IGJlaW5nIHVzZWQgKGl0IGFjdHVhbGx5IG9ubHkgY29uc3VtZXMgZXh0cmEgbWVtb3J5KS5cbiAgICAgICAqXG4gICAgICAgKiBJIGRvbid0IGtub3cgeWV0IGhvdyB0byByZWludHJvZHVjZSB0aGlzIGZlYXR1cmUuLlxuICAgICAgICpcbiAgICAgICAqIE9sZGVyIGNsaWVudHMgd29uJ3QgYmUgYWJsZSB0byByZWFkIHVwZGF0ZXMgd2hlbiB3ZSByZWludHJvZHVjZSB0aGlzIGZlYXR1cmUuIFNvIHRoaXMgc2hvdWxkIHByb2JhYmx5IGJlIGRvbmUgdXNpbmcgYSBmbGFnLlxuICAgICAgICpcbiAgICAgICAqL1xuICAgICAgLy8gdGhpcy5rZXlNYXAuc2V0KGtleSwgdGhpcy5rZXlDbG9jaylcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKHRoaXMua2V5Q2xvY2srKylcbiAgICAgIHRoaXMuc3RyaW5nRW5jb2Rlci53cml0ZShrZXkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMua2V5Q2xvY2tFbmNvZGVyLndyaXRlKGNsb2NrKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qKlxuICogQG1vZHVsZSBlbmNvZGluZ1xuICovXG4vKlxuICogV2UgdXNlIHRoZSBmaXJzdCBmaXZlIGJpdHMgaW4gdGhlIGluZm8gZmxhZyBmb3IgZGV0ZXJtaW5pbmcgdGhlIHR5cGUgb2YgdGhlIHN0cnVjdC5cbiAqXG4gKiAwOiBHQ1xuICogMTogSXRlbSB3aXRoIERlbGV0ZWQgY29udGVudFxuICogMjogSXRlbSB3aXRoIEpTT04gY29udGVudFxuICogMzogSXRlbSB3aXRoIEJpbmFyeSBjb250ZW50XG4gKiA0OiBJdGVtIHdpdGggU3RyaW5nIGNvbnRlbnRcbiAqIDU6IEl0ZW0gd2l0aCBFbWJlZCBjb250ZW50IChmb3IgcmljaHRleHQgY29udGVudClcbiAqIDY6IEl0ZW0gd2l0aCBGb3JtYXQgY29udGVudCAoYSBmb3JtYXR0aW5nIG1hcmtlciBmb3IgcmljaHRleHQgY29udGVudClcbiAqIDc6IEl0ZW0gd2l0aCBUeXBlXG4gKi9cblxuaW1wb3J0IHtcbiAgZmluZEluZGV4U1MsXG4gIGdldFN0YXRlLFxuICBjcmVhdGVJRCxcbiAgZ2V0U3RhdGVWZWN0b3IsXG4gIHJlYWRBbmRBcHBseURlbGV0ZVNldCxcbiAgd3JpdGVEZWxldGVTZXQsXG4gIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSxcbiAgdHJhbnNhY3QsXG4gIHJlYWRJdGVtQ29udGVudCxcbiAgVXBkYXRlRGVjb2RlclYxLFxuICBVcGRhdGVEZWNvZGVyVjIsXG4gIFVwZGF0ZUVuY29kZXJWMSxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBEU0VuY29kZXJWMixcbiAgRFNEZWNvZGVyVjEsXG4gIERTRW5jb2RlclYxLFxuICBtZXJnZVVwZGF0ZXMsXG4gIG1lcmdlVXBkYXRlc1YyLFxuICBTa2lwLFxuICBkaWZmVXBkYXRlVjIsXG4gIGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEsXG4gIERTRGVjb2RlclYyLCBEb2MsIFRyYW5zYWN0aW9uLCBHQywgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJ2xpYjAvYmluYXJ5J1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0FycmF5PEdDfEl0ZW0+fSBzdHJ1Y3RzIEFsbCBzdHJ1Y3RzIGJ5IGBjbGllbnRgXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2sgd3JpdGUgc3RydWN0cyBzdGFydGluZyB3aXRoIGBJRChjbGllbnQsY2xvY2spYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB3cml0ZVN0cnVjdHMgPSAoZW5jb2Rlciwgc3RydWN0cywgY2xpZW50LCBjbG9jaykgPT4ge1xuICAvLyB3cml0ZSBmaXJzdCBpZFxuICBjbG9jayA9IG1hdGgubWF4KGNsb2NrLCBzdHJ1Y3RzWzBdLmlkLmNsb2NrKSAvLyBtYWtlIHN1cmUgdGhlIGZpcnN0IGlkIGV4aXN0c1xuICBjb25zdCBzdGFydE5ld1N0cnVjdHMgPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jaylcbiAgLy8gd3JpdGUgIyBlbmNvZGVkIHN0cnVjdHNcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdHMubGVuZ3RoIC0gc3RhcnROZXdTdHJ1Y3RzKVxuICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsb2NrKVxuICBjb25zdCBmaXJzdFN0cnVjdCA9IHN0cnVjdHNbc3RhcnROZXdTdHJ1Y3RzXVxuICAvLyB3cml0ZSBmaXJzdCBzdHJ1Y3Qgd2l0aCBhbiBvZmZzZXRcbiAgZmlyc3RTdHJ1Y3Qud3JpdGUoZW5jb2RlciwgY2xvY2sgLSBmaXJzdFN0cnVjdC5pZC5jbG9jaylcbiAgZm9yIChsZXQgaSA9IHN0YXJ0TmV3U3RydWN0cyArIDE7IGkgPCBzdHJ1Y3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3RydWN0c1tpXS53cml0ZShlbmNvZGVyLCAwKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gX3NtXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVDbGllbnRzU3RydWN0cyA9IChlbmNvZGVyLCBzdG9yZSwgX3NtKSA9PiB7XG4gIC8vIHdlIGZpbHRlciBhbGwgdmFsaWQgX3NtIGVudHJpZXMgaW50byBzbVxuICBjb25zdCBzbSA9IG5ldyBNYXAoKVxuICBfc20uZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIC8vIG9ubHkgd3JpdGUgaWYgbmV3IHN0cnVjdHMgYXJlIGF2YWlsYWJsZVxuICAgIGlmIChnZXRTdGF0ZShzdG9yZSwgY2xpZW50KSA+IGNsb2NrKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCBjbG9jaylcbiAgICB9XG4gIH0pXG4gIGdldFN0YXRlVmVjdG9yKHN0b3JlKS5mb3JFYWNoKChfY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgIGlmICghX3NtLmhhcyhjbGllbnQpKSB7XG4gICAgICBzbS5zZXQoY2xpZW50LCAwKVxuICAgIH1cbiAgfSlcbiAgLy8gd3JpdGUgIyBzdGF0ZXMgdGhhdCB3ZXJlIHVwZGF0ZWRcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNtLnNpemUpXG4gIC8vIFdyaXRlIGl0ZW1zIHdpdGggaGlnaGVyIGNsaWVudCBpZHMgZmlyc3RcbiAgLy8gVGhpcyBoZWF2aWx5IGltcHJvdmVzIHRoZSBjb25mbGljdCBhbGdvcml0aG0uXG4gIGFycmF5LmZyb20oc20uZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgd3JpdGVTdHJ1Y3RzKGVuY29kZXIsIC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKSwgY2xpZW50LCBjbG9jaylcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlciBUaGUgZGVjb2RlciBvYmplY3QgdG8gcmVhZCBkYXRhIGZyb20uXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtNYXA8bnVtYmVyLCB7IGk6IG51bWJlciwgcmVmczogQXJyYXk8SXRlbSB8IEdDPiB9Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ2xpZW50c1N0cnVjdFJlZnMgPSAoZGVjb2RlciwgZG9jKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IEFycmF5PEl0ZW0gfCBHQz4gfT59XG4gICAqL1xuICBjb25zdCBjbGllbnRSZWZzID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59XG4gICAgICovXG4gICAgY29uc3QgcmVmcyA9IG5ldyBBcnJheShudW1iZXJPZlN0cnVjdHMpXG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2Rlci5yZWFkQ2xpZW50KClcbiAgICBsZXQgY2xvY2sgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgIC8vIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjbGllbnRSZWZzLnNldChjbGllbnQsIHsgaTogMCwgcmVmcyB9KVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZTdHJ1Y3RzOyBpKyspIHtcbiAgICAgIGNvbnN0IGluZm8gPSBkZWNvZGVyLnJlYWRJbmZvKClcbiAgICAgIHN3aXRjaCAoYmluYXJ5LkJJVFM1ICYgaW5mbykge1xuICAgICAgICBjYXNlIDA6IHsgLy8gR0NcbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKVxuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgR0MoY3JlYXRlSUQoY2xpZW50LCBjbG9jayksIGxlbilcbiAgICAgICAgICBjbG9jayArPSBsZW5cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgMTA6IHsgLy8gU2tpcCBTdHJ1Y3QgKG5vdGhpbmcgdG8gYXBwbHkpXG4gICAgICAgICAgLy8gQHRvZG8gd2UgY291bGQgcmVkdWNlIHRoZSBhbW91bnQgb2YgY2hlY2tzIGJ5IGFkZGluZyBTa2lwIHN0cnVjdCB0byBjbGllbnRSZWZzIHNvIHdlIGtub3cgdGhhdCBzb21ldGhpbmcgaXMgbWlzc2luZy5cbiAgICAgICAgICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyLnJlc3REZWNvZGVyKVxuICAgICAgICAgIHJlZnNbaV0gPSBuZXcgU2tpcChjcmVhdGVJRChjbGllbnQsIGNsb2NrKSwgbGVuKVxuICAgICAgICAgIGNsb2NrICs9IGxlblxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDogeyAvLyBJdGVtIHdpdGggY29udGVudFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIFRoZSBvcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgYW55IHZhcmlhYmxlcyBiZWNhdXNlIGlubGluaW5nIHZhcmlhYmxlcyBpcyBmYXN0ZXIuXG4gICAgICAgICAgICogQmVsb3cgYSBub24tb3B0aW1pemVkIHZlcnNpb24gaXMgc2hvd24gdGhhdCBpbXBsZW1lbnRzIHRoZSBiYXNpYyBhbGdvcml0aG0gd2l0aFxuICAgICAgICAgICAqIGEgZmV3IGNvbW1lbnRzXG4gICAgICAgICAgICovXG4gICAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgICAgLy8gSWYgcGFyZW50ID0gbnVsbCBhbmQgbmVpdGhlciBsZWZ0IG5vciByaWdodCBhcmUgZGVmaW5lZCwgdGhlbiB3ZSBrbm93IHRoYXQgYHBhcmVudGAgaXMgY2hpbGQgb2YgYHlgXG4gICAgICAgICAgLy8gYW5kIHdlIHJlYWQgdGhlIG5leHQgc3RyaW5nIGFzIHBhcmVudFlLZXkuXG4gICAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgICAvLyBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICAgICAgY29uc3Qgc3RydWN0ID0gbmV3IEl0ZW0oXG4gICAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICAgIG51bGwsIC8vIGxlZnRcbiAgICAgICAgICAgIChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbCwgLy8gb3JpZ2luXG4gICAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUNykgPT09IGJpbmFyeS5CSVQ3ID8gZGVjb2Rlci5yZWFkUmlnaHRJRCgpIDogbnVsbCwgLy8gcmlnaHQgb3JpZ2luXG4gICAgICAgICAgICBjYW50Q29weVBhcmVudEluZm8gPyAoZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpID8gZG9jLmdldChkZWNvZGVyLnJlYWRTdHJpbmcoKSkgOiBkZWNvZGVyLnJlYWRMZWZ0SUQoKSkgOiBudWxsLCAvLyBwYXJlbnRcbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgICAgcmVhZEl0ZW1Db250ZW50KGRlY29kZXIsIGluZm8pIC8vIGl0ZW0gY29udGVudFxuICAgICAgICAgIClcbiAgICAgICAgICAvKiBBIG5vbi1vcHRpbWl6ZWQgaW1wbGVtZW50YXRpb24gb2YgdGhlIGFib3ZlIGFsZ29yaXRobTpcblxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDgpID09PSBiaW5hcnkuQklUOCA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogbnVsbFxuICAgICAgICAgIC8vIFRoZSBpdGVtIHRoYXQgd2FzIG9yaWdpbmFsbHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgICAgICBjb25zdCByaWdodE9yaWdpbiA9IChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGxcbiAgICAgICAgICBjb25zdCBjYW50Q29weVBhcmVudEluZm8gPSAoaW5mbyAmIChiaW5hcnkuQklUNyB8IGJpbmFyeS5CSVQ4KSkgPT09IDBcbiAgICAgICAgICBjb25zdCBoYXNQYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvID8gZGVjb2Rlci5yZWFkUGFyZW50SW5mbygpIDogZmFsc2VcbiAgICAgICAgICAvLyBJZiBwYXJlbnQgPSBudWxsIGFuZCBuZWl0aGVyIGxlZnQgbm9yIHJpZ2h0IGFyZSBkZWZpbmVkLCB0aGVuIHdlIGtub3cgdGhhdCBgcGFyZW50YCBpcyBjaGlsZCBvZiBgeWBcbiAgICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgICAvLyBJdCBpbmRpY2F0ZXMgaG93IHdlIHN0b3JlL3JldHJpZXZlIHBhcmVudCBmcm9tIGB5LnNoYXJlYFxuICAgICAgICAgIC8vIEB0eXBlIHtzdHJpbmd8bnVsbH1cbiAgICAgICAgICBjb25zdCBwYXJlbnRZS2V5ID0gY2FudENvcHlQYXJlbnRJbmZvICYmIGhhc1BhcmVudFlLZXkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGxcblxuICAgICAgICAgIGNvbnN0IHN0cnVjdCA9IG5ldyBJdGVtKFxuICAgICAgICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayksXG4gICAgICAgICAgICBudWxsLCAvLyBsZWZ0XG4gICAgICAgICAgICBvcmlnaW4sIC8vIG9yaWdpblxuICAgICAgICAgICAgbnVsbCwgLy8gcmlnaHRcbiAgICAgICAgICAgIHJpZ2h0T3JpZ2luLCAvLyByaWdodCBvcmlnaW5cbiAgICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAhaGFzUGFyZW50WUtleSA/IGRlY29kZXIucmVhZExlZnRJRCgpIDogKHBhcmVudFlLZXkgIT09IG51bGwgPyBkb2MuZ2V0KHBhcmVudFlLZXkpIDogbnVsbCksIC8vIHBhcmVudFxuICAgICAgICAgICAgY2FudENvcHlQYXJlbnRJbmZvICYmIChpbmZvICYgYmluYXJ5LkJJVDYpID09PSBiaW5hcnkuQklUNiA/IGRlY29kZXIucmVhZFN0cmluZygpIDogbnVsbCwgLy8gcGFyZW50U3ViXG4gICAgICAgICAgICByZWFkSXRlbUNvbnRlbnQoZGVjb2RlciwgaW5mbykgLy8gaXRlbSBjb250ZW50XG4gICAgICAgICAgKVxuICAgICAgICAgICovXG4gICAgICAgICAgcmVmc1tpXSA9IHN0cnVjdFxuICAgICAgICAgIGNsb2NrICs9IHN0cnVjdC5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZWFkOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgfVxuICByZXR1cm4gY2xpZW50UmVmc1xufVxuXG4vKipcbiAqIFJlc3VtZSBjb21wdXRpbmcgc3RydWN0cyBnZW5lcmF0ZWQgYnkgc3RydWN0IHJlYWRlcnMuXG4gKlxuICogV2hpbGUgdGhlcmUgaXMgc29tZXRoaW5nIHRvIGRvLCB3ZSBpbnRlZ3JhdGUgc3RydWN0cyBpbiB0aGlzIG9yZGVyXG4gKiAxLiB0b3AgZWxlbWVudCBvbiBzdGFjaywgaWYgc3RhY2sgaXMgbm90IGVtcHR5XG4gKiAyLiBuZXh0IGVsZW1lbnQgZnJvbSBjdXJyZW50IHN0cnVjdCByZWFkZXIgKGlmIGVtcHR5LCB1c2UgbmV4dCBzdHJ1Y3QgcmVhZGVyKVxuICpcbiAqIElmIHN0cnVjdCBjYXVzYWxseSBkZXBlbmRzIG9uIGFub3RoZXIgc3RydWN0IChyZWYubWlzc2luZyksIHdlIHB1dCBuZXh0IHJlYWRlciBvZlxuICogYHJlZi5pZC5jbGllbnRgIG9uIHRvcCBvZiBzdGFjay5cbiAqXG4gKiBBdCBzb21lIHBvaW50IHdlIGZpbmQgYSBzdHJ1Y3QgdGhhdCBoYXMgbm8gY2F1c2FsIGRlcGVuZGVuY2llcyxcbiAqIHRoZW4gd2Ugc3RhcnQgZW1wdHlpbmcgdGhlIHN0YWNrLlxuICpcbiAqIEl0IGlzIG5vdCBwb3NzaWJsZSB0byBoYXZlIGNpcmNsZXM6IGkuZS4gc3RydWN0MSAoZnJvbSBjbGllbnQxKSBkZXBlbmRzIG9uIHN0cnVjdDIgKGZyb20gY2xpZW50MilcbiAqIGRlcGVuZHMgb24gc3RydWN0MyAoZnJvbSBjbGllbnQxKS4gVGhlcmVmb3JlIHRoZSBtYXggc3RhY2sgc2l6ZSBpcyBlcWF1bCB0byBgc3RydWN0UmVhZGVycy5sZW5ndGhgLlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIGltcGxlbWVudGVkIGluIGEgd2F5IHNvIHRoYXQgd2UgY2FuIHJlc3VtZSBjb21wdXRhdGlvbiBpZiB0aGlzIHVwZGF0ZVxuICogY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHVwZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7TWFwPG51bWJlciwgeyBpOiBudW1iZXIsIHJlZnM6IChHQyB8IEl0ZW0pW10gfT59IGNsaWVudHNTdHJ1Y3RSZWZzXG4gKiBAcmV0dXJuIHsgbnVsbCB8IHsgdXBkYXRlOiBVaW50OEFycmF5LCBtaXNzaW5nOiBNYXA8bnVtYmVyLG51bWJlcj4gfSB9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBpbnRlZ3JhdGVTdHJ1Y3RzID0gKHRyYW5zYWN0aW9uLCBzdG9yZSwgY2xpZW50c1N0cnVjdFJlZnMpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxJdGVtIHwgR0M+fVxuICAgKi9cbiAgY29uc3Qgc3RhY2sgPSBbXVxuICAvLyBzb3J0IHRoZW0gc28gdGhhdCB3ZSB0YWtlIHRoZSBoaWdoZXIgaWQgZmlyc3QsIGluIGNhc2Ugb2YgY29uZmxpY3RzIHRoZSBsb3dlciBpZCB3aWxsIHByb2JhYmx5IG5vdCBjb25mbGljdCB3aXRoIHRoZSBpZCBmcm9tIHRoZSBoaWdoZXIgdXNlci5cbiAgbGV0IGNsaWVudHNTdHJ1Y3RSZWZzSWRzID0gYXJyYXkuZnJvbShjbGllbnRzU3RydWN0UmVmcy5rZXlzKCkpLnNvcnQoKGEsIGIpID0+IGEgLSBiKVxuICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuICBjb25zdCBnZXROZXh0U3RydWN0VGFyZ2V0ID0gKCkgPT4ge1xuICAgIGlmIChjbGllbnRzU3RydWN0UmVmc0lkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIGxldCBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSlcbiAgICB3aGlsZSAobmV4dFN0cnVjdHNUYXJnZXQucmVmcy5sZW5ndGggPT09IG5leHRTdHJ1Y3RzVGFyZ2V0LmkpIHtcbiAgICAgIGNsaWVudHNTdHJ1Y3RSZWZzSWRzLnBvcCgpXG4gICAgICBpZiAoY2xpZW50c1N0cnVjdFJlZnNJZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBuZXh0U3RydWN0c1RhcmdldCA9IC8qKiBAdHlwZSB7e2k6bnVtYmVyLHJlZnM6QXJyYXk8R0N8SXRlbT59fSAqLyAoY2xpZW50c1N0cnVjdFJlZnMuZ2V0KGNsaWVudHNTdHJ1Y3RSZWZzSWRzW2NsaWVudHNTdHJ1Y3RSZWZzSWRzLmxlbmd0aCAtIDFdKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0U3RydWN0c1RhcmdldFxuICB9XG4gIGxldCBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpXG4gIGlmIChjdXJTdHJ1Y3RzVGFyZ2V0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RydWN0U3RvcmV9XG4gICAqL1xuICBjb25zdCByZXN0U3RydWN0cyA9IG5ldyBTdHJ1Y3RTdG9yZSgpXG4gIGNvbnN0IG1pc3NpbmdTViA9IG5ldyBNYXAoKVxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAgICovXG4gIGNvbnN0IHVwZGF0ZU1pc3NpbmdTdiA9IChjbGllbnQsIGNsb2NrKSA9PiB7XG4gICAgY29uc3QgbWNsb2NrID0gbWlzc2luZ1NWLmdldChjbGllbnQpXG4gICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICBtaXNzaW5nU1Yuc2V0KGNsaWVudCwgY2xvY2spXG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAdHlwZSB7R0N8SXRlbX1cbiAgICovXG4gIGxldCBzdGFja0hlYWQgPSAvKiogQHR5cGUge2FueX0gKi8gKGN1clN0cnVjdHNUYXJnZXQpLnJlZnNbLyoqIEB0eXBlIHthbnl9ICovIChjdXJTdHJ1Y3RzVGFyZ2V0KS5pKytdXG4gIC8vIGNhY2hpbmcgdGhlIHN0YXRlIGJlY2F1c2UgaXQgaXMgdXNlZCB2ZXJ5IG9mdGVuXG4gIGNvbnN0IHN0YXRlID0gbmV3IE1hcCgpXG5cbiAgY29uc3QgYWRkU3RhY2tUb1Jlc3RTUyA9ICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygc3RhY2spIHtcbiAgICAgIGNvbnN0IGNsaWVudCA9IGl0ZW0uaWQuY2xpZW50XG4gICAgICBjb25zdCB1bmFwcGxpY2FibGVJdGVtcyA9IGNsaWVudHNTdHJ1Y3RSZWZzLmdldChjbGllbnQpXG4gICAgICBpZiAodW5hcHBsaWNhYmxlSXRlbXMpIHtcbiAgICAgICAgLy8gZGVjcmVtZW50IGJlY2F1c2Ugd2Ugd2VyZW4ndCBhYmxlIHRvIGFwcGx5IHByZXZpb3VzIG9wZXJhdGlvblxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pLS1cbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCB1bmFwcGxpY2FibGVJdGVtcy5yZWZzLnNsaWNlKHVuYXBwbGljYWJsZUl0ZW1zLmkpKVxuICAgICAgICBjbGllbnRzU3RydWN0UmVmcy5kZWxldGUoY2xpZW50KVxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5pID0gMFxuICAgICAgICB1bmFwcGxpY2FibGVJdGVtcy5yZWZzID0gW11cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0ZW0gd2FzIHRoZSBsYXN0IGl0ZW0gb24gY2xpZW50c1N0cnVjdFJlZnMgYW5kIHRoZSBmaWVsZCB3YXMgYWxyZWFkeSBjbGVhcmVkLiBBZGQgaXRlbSB0byByZXN0U3RydWN0cyBhbmQgY29udGludWVcbiAgICAgICAgcmVzdFN0cnVjdHMuY2xpZW50cy5zZXQoY2xpZW50LCBbaXRlbV0pXG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgY2xpZW50IGZyb20gY2xpZW50c1N0cnVjdFJlZnNJZHMgdG8gcHJldmVudCB1c2VycyBmcm9tIGFwcGx5aW5nIHRoZSBzYW1lIHVwZGF0ZSBhZ2FpblxuICAgICAgY2xpZW50c1N0cnVjdFJlZnNJZHMgPSBjbGllbnRzU3RydWN0UmVmc0lkcy5maWx0ZXIoYyA9PiBjICE9PSBjbGllbnQpXG4gICAgfVxuICAgIHN0YWNrLmxlbmd0aCA9IDBcbiAgfVxuXG4gIC8vIGl0ZXJhdGUgb3ZlciBhbGwgc3RydWN0IHJlYWRlcnMgdW50aWwgd2UgYXJlIGRvbmVcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoc3RhY2tIZWFkLmNvbnN0cnVjdG9yICE9PSBTa2lwKSB7XG4gICAgICBjb25zdCBsb2NhbENsb2NrID0gbWFwLnNldElmVW5kZWZpbmVkKHN0YXRlLCBzdGFja0hlYWQuaWQuY2xpZW50LCAoKSA9PiBnZXRTdGF0ZShzdG9yZSwgc3RhY2tIZWFkLmlkLmNsaWVudCkpXG4gICAgICBjb25zdCBvZmZzZXQgPSBsb2NhbENsb2NrIC0gc3RhY2tIZWFkLmlkLmNsb2NrXG4gICAgICBpZiAob2Zmc2V0IDwgMCkge1xuICAgICAgICAvLyB1cGRhdGUgZnJvbSB0aGUgc2FtZSBjbGllbnQgaXMgbWlzc2luZ1xuICAgICAgICBzdGFjay5wdXNoKHN0YWNrSGVhZClcbiAgICAgICAgdXBkYXRlTWlzc2luZ1N2KHN0YWNrSGVhZC5pZC5jbGllbnQsIHN0YWNrSGVhZC5pZC5jbG9jayAtIDEpXG4gICAgICAgIC8vIGhpZCBhIGRlYWQgd2FsbCwgYWRkIGFsbCBpdGVtcyBmcm9tIHN0YWNrIHRvIHJlc3RTU1xuICAgICAgICBhZGRTdGFja1RvUmVzdFNTKClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG1pc3NpbmcgPSBzdGFja0hlYWQuZ2V0TWlzc2luZyh0cmFuc2FjdGlvbiwgc3RvcmUpXG4gICAgICAgIGlmIChtaXNzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgc3RhY2sucHVzaChzdGFja0hlYWQpXG4gICAgICAgICAgLy8gZ2V0IHRoZSBzdHJ1Y3QgcmVhZGVyIHRoYXQgaGFzIHRoZSBtaXNzaW5nIHN0cnVjdFxuICAgICAgICAgIC8qKlxuICAgICAgICAgICAqIEB0eXBlIHt7IHJlZnM6IEFycmF5PEdDfEl0ZW0+LCBpOiBudW1iZXIgfX1cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBjb25zdCBzdHJ1Y3RSZWZzID0gY2xpZW50c1N0cnVjdFJlZnMuZ2V0KC8qKiBAdHlwZSB7bnVtYmVyfSAqLyAobWlzc2luZykpIHx8IHsgcmVmczogW10sIGk6IDAgfVxuICAgICAgICAgIGlmIChzdHJ1Y3RSZWZzLnJlZnMubGVuZ3RoID09PSBzdHJ1Y3RSZWZzLmkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIG1lc3NhZ2UgY2F1c2FsbHkgZGVwZW5kcyBvbiBhbm90aGVyIHVwZGF0ZSBtZXNzYWdlIHRoYXQgZG9lc24ndCBleGlzdCB5ZXRcbiAgICAgICAgICAgIHVwZGF0ZU1pc3NpbmdTdigvKiogQHR5cGUge251bWJlcn0gKi8gKG1pc3NpbmcpLCBnZXRTdGF0ZShzdG9yZSwgbWlzc2luZykpXG4gICAgICAgICAgICBhZGRTdGFja1RvUmVzdFNTKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3RhY2tIZWFkID0gc3RydWN0UmVmcy5yZWZzW3N0cnVjdFJlZnMuaSsrXVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAob2Zmc2V0ID09PSAwIHx8IG9mZnNldCA8IHN0YWNrSGVhZC5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBhbGwgZmluZSwgYXBwbHkgdGhlIHN0YWNraGVhZFxuICAgICAgICAgIHN0YWNrSGVhZC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIG9mZnNldClcbiAgICAgICAgICBzdGF0ZS5zZXQoc3RhY2tIZWFkLmlkLmNsaWVudCwgc3RhY2tIZWFkLmlkLmNsb2NrICsgc3RhY2tIZWFkLmxlbmd0aClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBpdGVyYXRlIHRvIG5leHQgc3RhY2tIZWFkXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKHN0YWNrLnBvcCgpKVxuICAgIH0gZWxzZSBpZiAoY3VyU3RydWN0c1RhcmdldCAhPT0gbnVsbCAmJiBjdXJTdHJ1Y3RzVGFyZ2V0LmkgPCBjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnMubGVuZ3RoKSB7XG4gICAgICBzdGFja0hlYWQgPSAvKiogQHR5cGUge0dDfEl0ZW19ICovIChjdXJTdHJ1Y3RzVGFyZ2V0LnJlZnNbY3VyU3RydWN0c1RhcmdldC5pKytdKVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJTdHJ1Y3RzVGFyZ2V0ID0gZ2V0TmV4dFN0cnVjdFRhcmdldCgpXG4gICAgICBpZiAoY3VyU3RydWN0c1RhcmdldCA9PT0gbnVsbCkge1xuICAgICAgICAvLyB3ZSBhcmUgZG9uZSFcbiAgICAgICAgYnJlYWtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YWNrSGVhZCA9IC8qKiBAdHlwZSB7R0N8SXRlbX0gKi8gKGN1clN0cnVjdHNUYXJnZXQucmVmc1tjdXJTdHJ1Y3RzVGFyZ2V0LmkrK10pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChyZXN0U3RydWN0cy5jbGllbnRzLnNpemUgPiAwKSB7XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBVcGRhdGVFbmNvZGVyVjIoKVxuICAgIHdyaXRlQ2xpZW50c1N0cnVjdHMoZW5jb2RlciwgcmVzdFN0cnVjdHMsIG5ldyBNYXAoKSlcbiAgICAvLyB3cml0ZSBlbXB0eSBkZWxldGVzZXRcbiAgICAvLyB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBuZXcgRGVsZXRlU2V0KCkpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApIC8vID0+IG5vIG5lZWQgZm9yIGFuIGV4dHJhIGZ1bmN0aW9uIGNhbGwsIGp1c3Qgd3JpdGUgMCBkZWxldGVzXG4gICAgcmV0dXJuIHsgbWlzc2luZzogbWlzc2luZ1NWLCB1cGRhdGU6IGVuY29kZXIudG9VaW50OEFycmF5KCkgfVxuICB9XG4gIHJldHVybiBudWxsXG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYSBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IFtzdHJ1Y3REZWNvZGVyXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFVwZGF0ZVYyID0gKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBzdHJ1Y3REZWNvZGVyID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGVyKSkgPT5cbiAgdHJhbnNhY3QoeWRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIC8vIGZvcmNlIHRoYXQgdHJhbnNhY3Rpb24ubG9jYWwgaXMgc2V0IHRvIG5vbi1sb2NhbFxuICAgIHRyYW5zYWN0aW9uLmxvY2FsID0gZmFsc2VcbiAgICBsZXQgcmV0cnkgPSBmYWxzZVxuICAgIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gICAgLy8gbGV0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCBzcyA9IHJlYWRDbGllbnRzU3RydWN0UmVmcyhzdHJ1Y3REZWNvZGVyLCBkb2MpXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gcmVhZCBzdHJ1Y3RzOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG4gICAgLy8gY29uc29sZS5sb2coJ3RpbWUgdG8gbWVyZ2U6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBjb25zdCByZXN0U3RydWN0cyA9IGludGVncmF0ZVN0cnVjdHModHJhbnNhY3Rpb24sIHN0b3JlLCBzcylcbiAgICBjb25zdCBwZW5kaW5nID0gc3RvcmUucGVuZGluZ1N0cnVjdHNcbiAgICBpZiAocGVuZGluZykge1xuICAgICAgLy8gY2hlY2sgaWYgd2UgY2FuIGFwcGx5IHNvbWV0aGluZ1xuICAgICAgZm9yIChjb25zdCBbY2xpZW50LCBjbG9ja10gb2YgcGVuZGluZy5taXNzaW5nKSB7XG4gICAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgICAgcmV0cnkgPSB0cnVlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHJlc3RTdHJ1Y3RzKSB7XG4gICAgICAgIC8vIG1lcmdlIHJlc3RTdHJ1Y3RzIGludG8gc3RvcmUucGVuZGluZ1xuICAgICAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiByZXN0U3RydWN0cy5taXNzaW5nKSB7XG4gICAgICAgICAgY29uc3QgbWNsb2NrID0gcGVuZGluZy5taXNzaW5nLmdldChjbGllbnQpXG4gICAgICAgICAgaWYgKG1jbG9jayA9PSBudWxsIHx8IG1jbG9jayA+IGNsb2NrKSB7XG4gICAgICAgICAgICBwZW5kaW5nLm1pc3Npbmcuc2V0KGNsaWVudCwgY2xvY2spXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmcudXBkYXRlID0gbWVyZ2VVcGRhdGVzVjIoW3BlbmRpbmcudXBkYXRlLCByZXN0U3RydWN0cy51cGRhdGVdKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IHJlc3RTdHJ1Y3RzXG4gICAgfVxuICAgIC8vIGNvbnNvbGUubG9nKCd0aW1lIHRvIGludGVncmF0ZTogJywgcGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydCkgLy8gQHRvZG8gcmVtb3ZlXG4gICAgLy8gc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKVxuICAgIGNvbnN0IGRzUmVzdCA9IHJlYWRBbmRBcHBseURlbGV0ZVNldChzdHJ1Y3REZWNvZGVyLCB0cmFuc2FjdGlvbiwgc3RvcmUpXG4gICAgaWYgKHN0b3JlLnBlbmRpbmdEcykge1xuICAgICAgLy8gQHRvZG8gd2UgY291bGQgbWFrZSBhIGxvd2VyLWJvdW5kIHN0YXRlLXZlY3RvciBjaGVjayBhcyB3ZSBkbyBhYm92ZVxuICAgICAgY29uc3QgcGVuZGluZ0RTVXBkYXRlID0gbmV3IFVwZGF0ZURlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHN0b3JlLnBlbmRpbmdEcykpXG4gICAgICBkZWNvZGluZy5yZWFkVmFyVWludChwZW5kaW5nRFNVcGRhdGUucmVzdERlY29kZXIpIC8vIHJlYWQgMCBzdHJ1Y3RzLCBiZWNhdXNlIHdlIG9ubHkgZW5jb2RlIGRlbGV0ZXMgaW4gcGVuZGluZ2RzdXBkYXRlXG4gICAgICBjb25zdCBkc1Jlc3QyID0gcmVhZEFuZEFwcGx5RGVsZXRlU2V0KHBlbmRpbmdEU1VwZGF0ZSwgdHJhbnNhY3Rpb24sIHN0b3JlKVxuICAgICAgaWYgKGRzUmVzdCAmJiBkc1Jlc3QyKSB7XG4gICAgICAgIC8vIGNhc2UgMTogZHMxICE9IG51bGwgJiYgZHMyICE9IG51bGxcbiAgICAgICAgc3RvcmUucGVuZGluZ0RzID0gbWVyZ2VVcGRhdGVzVjIoW2RzUmVzdCwgZHNSZXN0Ml0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBjYXNlIDI6IGRzMSAhPSBudWxsXG4gICAgICAgIC8vIGNhc2UgMzogZHMyICE9IG51bGxcbiAgICAgICAgLy8gY2FzZSA0OiBkczEgPT0gbnVsbCAmJiBkczIgPT0gbnVsbFxuICAgICAgICBzdG9yZS5wZW5kaW5nRHMgPSBkc1Jlc3QgfHwgZHNSZXN0MlxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFaXRoZXIgZHNSZXN0ID09IG51bGwgJiYgcGVuZGluZ0RzID09IG51bGwgT1IgZHNSZXN0ICE9IG51bGxcbiAgICAgIHN0b3JlLnBlbmRpbmdEcyA9IGRzUmVzdFxuICAgIH1cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byBjbGVhbnVwOiAnLCBwZXJmb3JtYW5jZS5ub3coKSAtIHN0YXJ0KSAvLyBAdG9kbyByZW1vdmVcbiAgICAvLyBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpXG5cbiAgICAvLyBjb25zb2xlLmxvZygndGltZSB0byByZXN1bWUgZGVsZXRlIHJlYWRlcnM6ICcsIHBlcmZvcm1hbmNlLm5vdygpIC0gc3RhcnQpIC8vIEB0b2RvIHJlbW92ZVxuICAgIC8vIHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KClcbiAgICBpZiAocmV0cnkpIHtcbiAgICAgIGNvbnN0IHVwZGF0ZSA9IC8qKiBAdHlwZSB7e3VwZGF0ZTogVWludDhBcnJheX19ICovIChzdG9yZS5wZW5kaW5nU3RydWN0cykudXBkYXRlXG4gICAgICBzdG9yZS5wZW5kaW5nU3RydWN0cyA9IG51bGxcbiAgICAgIGFwcGx5VXBkYXRlVjIodHJhbnNhY3Rpb24uZG9jLCB1cGRhdGUpXG4gICAgfVxuICB9LCB0cmFuc2FjdGlvbk9yaWdpbiwgZmFsc2UpXG5cbi8qKlxuICogUmVhZCBhbmQgYXBwbHkgYSBkb2N1bWVudCB1cGRhdGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGBhcHBseVVwZGF0ZWAgYnV0IGFjY2VwdHMgYSBkZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7YW55fSBbdHJhbnNhY3Rpb25PcmlnaW5dIFRoaXMgd2lsbCBiZSBzdG9yZWQgb24gYHRyYW5zYWN0aW9uLm9yaWdpbmAgYW5kIGAub24oJ3VwZGF0ZScsICh1cGRhdGUsIG9yaWdpbikpYFxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFVwZGF0ZSA9IChkZWNvZGVyLCB5ZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4gcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgVXBkYXRlRGVjb2RlclYxKGRlY29kZXIpKVxuXG4vKipcbiAqIEFwcGx5IGEgZG9jdW1lbnQgdXBkYXRlIGNyZWF0ZWQgYnksIGZvciBleGFtcGxlLCBgeS5vbigndXBkYXRlJywgdXBkYXRlID0+IC4uKWAgb3IgYHVwZGF0ZSA9IGVuY29kZVN0YXRlQXNVcGRhdGUoKWAuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHNhbWUgZWZmZWN0IGFzIGByZWFkVXBkYXRlYCBidXQgYWNjZXB0cyBhbiBVaW50OEFycmF5IGluc3RlYWQgb2YgYSBEZWNvZGVyLlxuICpcbiAqIEBwYXJhbSB7RG9jfSB5ZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHthbnl9IFt0cmFuc2FjdGlvbk9yaWdpbl0gVGhpcyB3aWxsIGJlIHN0b3JlZCBvbiBgdHJhbnNhY3Rpb24ub3JpZ2luYCBhbmQgYC5vbigndXBkYXRlJywgKHVwZGF0ZSwgb3JpZ2luKSlgXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhcHBseVVwZGF0ZVYyID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4sIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgcmVhZFVwZGF0ZVYyKGRlY29kZXIsIHlkb2MsIHRyYW5zYWN0aW9uT3JpZ2luLCBuZXcgWURlY29kZXIoZGVjb2RlcikpXG59XG5cbi8qKlxuICogQXBwbHkgYSBkb2N1bWVudCB1cGRhdGUgY3JlYXRlZCBieSwgZm9yIGV4YW1wbGUsIGB5Lm9uKCd1cGRhdGUnLCB1cGRhdGUgPT4gLi4pYCBvciBgdXBkYXRlID0gZW5jb2RlU3RhdGVBc1VwZGF0ZSgpYC5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgc2FtZSBlZmZlY3QgYXMgYHJlYWRVcGRhdGVgIGJ1dCBhY2NlcHRzIGFuIFVpbnQ4QXJyYXkgaW5zdGVhZCBvZiBhIERlY29kZXIuXG4gKlxuICogQHBhcmFtIHtEb2N9IHlkb2NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gW3RyYW5zYWN0aW9uT3JpZ2luXSBUaGlzIHdpbGwgYmUgc3RvcmVkIG9uIGB0cmFuc2FjdGlvbi5vcmlnaW5gIGFuZCBgLm9uKCd1cGRhdGUnLCAodXBkYXRlLCBvcmlnaW4pKWBcbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5VXBkYXRlID0gKHlkb2MsIHVwZGF0ZSwgdHJhbnNhY3Rpb25PcmlnaW4pID0+IGFwcGx5VXBkYXRlVjIoeWRvYywgdXBkYXRlLCB0cmFuc2FjdGlvbk9yaWdpbiwgVXBkYXRlRGVjb2RlclYxKVxuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UuIElmIHlvdSBzcGVjaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgcmVtb3RlIGNsaWVudCAoYHRhcmdldFN0YXRlVmVjdG9yYCkgaXQgd2lsbFxuICogb25seSB3cml0ZSB0aGUgb3BlcmF0aW9ucyB0aGF0IGFyZSBtaXNzaW5nLlxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge01hcDxudW1iZXIsbnVtYmVyPn0gW3RhcmdldFN0YXRlVmVjdG9yXSBUaGUgc3RhdGUgb2YgdGhlIHRhcmdldCB0aGF0IHJlY2VpdmVzIHRoZSB1cGRhdGUuIExlYXZlIGVtcHR5IHRvIHdyaXRlIGFsbCBrbm93biBzdHJ1Y3RzXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN0YXRlQXNVcGRhdGUgPSAoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3RvciA9IG5ldyBNYXAoKSkgPT4ge1xuICB3cml0ZUNsaWVudHNTdHJ1Y3RzKGVuY29kZXIsIGRvYy5zdG9yZSwgdGFyZ2V0U3RhdGVWZWN0b3IpXG4gIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpKVxufVxuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIgPSAoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IgPSBuZXcgVWludDhBcnJheShbMF0pLCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpKSA9PiB7XG4gIGNvbnN0IHRhcmdldFN0YXRlVmVjdG9yID0gZGVjb2RlU3RhdGVWZWN0b3IoZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKVxuICB3cml0ZVN0YXRlQXNVcGRhdGUoZW5jb2RlciwgZG9jLCB0YXJnZXRTdGF0ZVZlY3RvcilcbiAgY29uc3QgdXBkYXRlcyA9IFtlbmNvZGVyLnRvVWludDhBcnJheSgpXVxuICAvLyBhbHNvIGFkZCB0aGUgcGVuZGluZyB1cGRhdGVzIChpZiB0aGVyZSBhcmUgYW55KVxuICBpZiAoZG9jLnN0b3JlLnBlbmRpbmdEcykge1xuICAgIHVwZGF0ZXMucHVzaChkb2Muc3RvcmUucGVuZGluZ0RzKVxuICB9XG4gIGlmIChkb2Muc3RvcmUucGVuZGluZ1N0cnVjdHMpIHtcbiAgICB1cGRhdGVzLnB1c2goZGlmZlVwZGF0ZVYyKGRvYy5zdG9yZS5wZW5kaW5nU3RydWN0cy51cGRhdGUsIGVuY29kZWRUYXJnZXRTdGF0ZVZlY3RvcikpXG4gIH1cbiAgaWYgKHVwZGF0ZXMubGVuZ3RoID4gMSkge1xuICAgIGlmIChlbmNvZGVyLmNvbnN0cnVjdG9yID09PSBVcGRhdGVFbmNvZGVyVjEpIHtcbiAgICAgIHJldHVybiBtZXJnZVVwZGF0ZXModXBkYXRlcy5tYXAoKHVwZGF0ZSwgaSkgPT4gaSA9PT0gMCA/IHVwZGF0ZSA6IGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEodXBkYXRlKSkpXG4gICAgfSBlbHNlIGlmIChlbmNvZGVyLmNvbnN0cnVjdG9yID09PSBVcGRhdGVFbmNvZGVyVjIpIHtcbiAgICAgIHJldHVybiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXBkYXRlc1swXVxufVxuXG4vKipcbiAqIFdyaXRlIGFsbCB0aGUgZG9jdW1lbnQgYXMgYSBzaW5nbGUgdXBkYXRlIG1lc3NhZ2UgdGhhdCBjYW4gYmUgYXBwbGllZCBvbiB0aGUgcmVtb3RlIGRvY3VtZW50LiBJZiB5b3Ugc3BlY2lmeSB0aGUgc3RhdGUgb2YgdGhlIHJlbW90ZSBjbGllbnQgKGB0YXJnZXRTdGF0ZWApIGl0IHdpbGxcbiAqIG9ubHkgd3JpdGUgdGhlIG9wZXJhdGlvbnMgdGhhdCBhcmUgbWlzc2luZy5cbiAqXG4gKiBVc2UgYHdyaXRlU3RhdGVBc1VwZGF0ZWAgaW5zdGVhZCBpZiB5b3UgYXJlIHdvcmtpbmcgd2l0aCBsaWIwL2VuY29kaW5nLmpzI0VuY29kZXJcbiAqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IFtlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3JdIFRoZSBzdGF0ZSBvZiB0aGUgdGFyZ2V0IHRoYXQgcmVjZWl2ZXMgdGhlIHVwZGF0ZS4gTGVhdmUgZW1wdHkgdG8gd3JpdGUgYWxsIGtub3duIHN0cnVjdHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTdGF0ZUFzVXBkYXRlID0gKGRvYywgZW5jb2RlZFRhcmdldFN0YXRlVmVjdG9yKSA9PiBlbmNvZGVTdGF0ZUFzVXBkYXRlVjIoZG9jLCBlbmNvZGVkVGFyZ2V0U3RhdGVWZWN0b3IsIG5ldyBVcGRhdGVFbmNvZGVyVjEoKSlcblxuLyoqXG4gKiBSZWFkIHN0YXRlIHZlY3RvciBmcm9tIERlY29kZXIgYW5kIHJldHVybiBhcyBNYXBcbiAqXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFN0YXRlVmVjdG9yID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IHNzID0gbmV3IE1hcCgpXG4gIGNvbnN0IHNzTGVuZ3RoID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc0xlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50ID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBjb25zdCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgc3Muc2V0KGNsaWVudCwgY2xvY2spXG4gIH1cbiAgcmV0dXJuIHNzXG59XG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG4vLyBleHBvcnQgY29uc3QgZGVjb2RlU3RhdGVWZWN0b3JWMiA9IGRlY29kZWRTdGF0ZSA9PiByZWFkU3RhdGVWZWN0b3IobmV3IERTRGVjb2RlclYyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZGVjb2RlZFN0YXRlKSkpXG5cbi8qKlxuICogUmVhZCBkZWNvZGVkU3RhdGUgYW5kIHJldHVybiBTdGF0ZSBhcyBNYXAuXG4gKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkZWNvZGVkU3RhdGVcbiAqIEByZXR1cm4ge01hcDxudW1iZXIsbnVtYmVyPn0gTWFwcyBgY2xpZW50YCB0byB0aGUgbnVtYmVyIG5leHQgZXhwZWN0ZWQgYGNsb2NrYCBmcm9tIHRoYXQgY2xpZW50LlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlU3RhdGVWZWN0b3IgPSBkZWNvZGVkU3RhdGUgPT4gcmVhZFN0YXRlVmVjdG9yKG5ldyBEU0RlY29kZXJWMShkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRlY29kZWRTdGF0ZSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gZW5jb2RlclxuICogQHBhcmFtIHtNYXA8bnVtYmVyLG51bWJlcj59IHN2XG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHdyaXRlU3RhdGVWZWN0b3IgPSAoZW5jb2Rlciwgc3YpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHN2LnNpemUpXG4gIGFycmF5LmZyb20oc3YuZW50cmllcygpKS5zb3J0KChhLCBiKSA9PiBiWzBdIC0gYVswXSkuZm9yRWFjaCgoW2NsaWVudCwgY2xvY2tdKSA9PiB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGNsaWVudCkgLy8gQHRvZG8gdXNlIGEgc3BlY2lhbCBjbGllbnQgZGVjb2RlciB0aGF0IGlzIGJhc2VkIG9uIG1hcHBpbmdcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY2xvY2spXG4gIH0pXG4gIHJldHVybiBlbmNvZGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZURvY3VtZW50U3RhdGVWZWN0b3IgPSAoZW5jb2RlciwgZG9jKSA9PiB3cml0ZVN0YXRlVmVjdG9yKGVuY29kZXIsIGdldFN0YXRlVmVjdG9yKGRvYy5zdG9yZSkpXG5cbi8qKlxuICogRW5jb2RlIFN0YXRlIGFzIFVpbnQ4QXJyYXkuXG4gKlxuICogQHBhcmFtIHtEb2N8TWFwPG51bWJlcixudW1iZXI+fSBkb2NcbiAqIEBwYXJhbSB7RFNFbmNvZGVyVjEgfCBEU0VuY29kZXJWMn0gW2VuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JWMiA9IChkb2MsIGVuY29kZXIgPSBuZXcgRFNFbmNvZGVyVjIoKSkgPT4ge1xuICBpZiAoZG9jIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgd3JpdGVTdGF0ZVZlY3RvcihlbmNvZGVyLCBkb2MpXG4gIH0gZWxzZSB7XG4gICAgd3JpdGVEb2N1bWVudFN0YXRlVmVjdG9yKGVuY29kZXIsIGRvYylcbiAgfVxuICByZXR1cm4gZW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufVxuXG4vKipcbiAqIEVuY29kZSBTdGF0ZSBhcyBVaW50OEFycmF5LlxuICpcbiAqIEBwYXJhbSB7RG9jfE1hcDxudW1iZXIsbnVtYmVyPn0gZG9jXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlU3RhdGVWZWN0b3IgPSBkb2MgPT4gZW5jb2RlU3RhdGVWZWN0b3JWMihkb2MsIG5ldyBEU0VuY29kZXJWMSgpKVxuIiwgImltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcblxuLyoqXG4gKiBHZW5lcmFsIGV2ZW50IGhhbmRsZXIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsIEFSRzFcbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY2xhc3MgRXZlbnRIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihBUkcwLCBBUkcxKTp2b2lkPn1cbiAgICAgKi9cbiAgICB0aGlzLmwgPSBbXVxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHJldHVybnMge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50SGFuZGxlciA9ICgpID0+IG5ldyBFdmVudEhhbmRsZXIoKVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBpcyBjYWxsZWQgd2hlblxuICoge0BsaW5rIEV2ZW50SGFuZGxlciNjYWxsRXZlbnRMaXN0ZW5lcnN9IGlzIGNhbGxlZC5cbiAqXG4gKiBAdGVtcGxhdGUgQVJHMCxBUkcxXG4gKiBAcGFyYW0ge0V2ZW50SGFuZGxlcjxBUkcwLEFSRzE+fSBldmVudEhhbmRsZXJcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oQVJHMCxBUkcxKTp2b2lkfSBmIFRoZSBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyID0gKGV2ZW50SGFuZGxlciwgZikgPT5cbiAgZXZlbnRIYW5kbGVyLmwucHVzaChmKVxuXG4vKipcbiAqIFJlbW92ZXMgYW4gZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEFSRzAsQVJHMSk6dm9pZH0gZiBUaGUgZXZlbnQgaGFuZGxlciB0aGF0IHdhcyBhZGRlZCB3aXRoXG4gKiAgICAgICAgICAgICAgICAgICAgIHtAbGluayBFdmVudEhhbmRsZXIjYWRkRXZlbnRMaXN0ZW5lcn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lciA9IChldmVudEhhbmRsZXIsIGYpID0+IHtcbiAgY29uc3QgbCA9IGV2ZW50SGFuZGxlci5sXG4gIGNvbnN0IGxlbiA9IGwubGVuZ3RoXG4gIGV2ZW50SGFuZGxlci5sID0gbC5maWx0ZXIoZyA9PiBmICE9PSBnKVxuICBpZiAobGVuID09PSBldmVudEhhbmRsZXIubC5sZW5ndGgpIHtcbiAgICBjb25zb2xlLmVycm9yKCdbeWpzXSBUcmllZCB0byByZW1vdmUgZXZlbnQgaGFuZGxlciB0aGF0IGRvZXNuXFwndCBleGlzdC4nKVxuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuICogQHRlbXBsYXRlIEFSRzAsQVJHMVxuICogQHBhcmFtIHtFdmVudEhhbmRsZXI8QVJHMCxBUkcxPn0gZXZlbnRIYW5kbGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzID0gZXZlbnRIYW5kbGVyID0+IHtcbiAgZXZlbnRIYW5kbGVyLmwubGVuZ3RoID0gMFxufVxuXG4vKipcbiAqIENhbGwgYWxsIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQgdmlhXG4gKiB7QGxpbmsgRXZlbnRIYW5kbGVyI2FkZEV2ZW50TGlzdGVuZXJ9LlxuICpcbiAqIEB0ZW1wbGF0ZSBBUkcwLEFSRzFcbiAqIEBwYXJhbSB7RXZlbnRIYW5kbGVyPEFSRzAsQVJHMT59IGV2ZW50SGFuZGxlclxuICogQHBhcmFtIHtBUkcwfSBhcmcwXG4gKiBAcGFyYW0ge0FSRzF9IGFyZzFcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjYWxsRXZlbnRIYW5kbGVyTGlzdGVuZXJzID0gKGV2ZW50SGFuZGxlciwgYXJnMCwgYXJnMSkgPT5cbiAgZi5jYWxsQWxsKGV2ZW50SGFuZGxlci5sLCBbYXJnMCwgYXJnMV0pXG4iLCAiaW1wb3J0IHsgQWJzdHJhY3RUeXBlIH0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuZXhwb3J0IGNsYXNzIElEIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnQgY2xpZW50IGlkXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjbG9jayB1bmlxdWUgcGVyIGNsaWVudCBpZCwgY29udGludW91cyBudW1iZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjbGllbnQsIGNsb2NrKSB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGlkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudCA9IGNsaWVudFxuICAgIC8qKlxuICAgICAqIHVuaXF1ZSBwZXIgY2xpZW50IGlkLCBjb250aW51b3VzIG51bWJlclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdGhpcy5jbG9jayA9IGNsb2NrXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0lEIHwgbnVsbH0gYVxuICogQHBhcmFtIHtJRCB8IG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wYXJlSURzID0gKGEsIGIpID0+IGEgPT09IGIgfHwgKGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLmNsaWVudCA9PT0gYi5jbGllbnQgJiYgYS5jbG9jayA9PT0gYi5jbG9jaylcblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gY2xpZW50XG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVJRCA9IChjbGllbnQsIGNsb2NrKSA9PiBuZXcgSUQoY2xpZW50LCBjbG9jaylcblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7SUR9IGlkXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVJRCA9IChlbmNvZGVyLCBpZCkgPT4ge1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xpZW50KVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgaWQuY2xvY2spXG59XG5cbi8qKlxuICogUmVhZCBJRC5cbiAqICogSWYgZmlyc3QgdmFyVWludCByZWFkIGlzIDB4RkZGRkZGIGEgUm9vdElEIGlzIHJldHVybmVkLlxuICogKiBPdGhlcndpc2UgYW4gSUQgaXMgcmV0dXJuZWRcbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0lEfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRJRCA9IGRlY29kZXIgPT5cbiAgY3JlYXRlSUQoZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlciksIGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKVxuXG4vKipcbiAqIFRoZSB0b3AgdHlwZXMgYXJlIG1hcHBlZCBmcm9tIHkuc2hhcmUuZ2V0KGtleW5hbWUpID0+IHR5cGUuXG4gKiBgdHlwZWAgZG9lcyBub3Qgc3RvcmUgYW55IGluZm9ybWF0aW9uIGFib3V0IHRoZSBga2V5bmFtZWAuXG4gKiBUaGlzIGZ1bmN0aW9uIGZpbmRzIHRoZSBjb3JyZWN0IGBrZXluYW1lYCBmb3IgYHR5cGVgIGFuZCB0aHJvd3Mgb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kUm9vdFR5cGVLZXkgPSB0eXBlID0+IHtcbiAgLy8gQHRzLWlnbm9yZSBfeSBtdXN0IGJlIGRlZmluZWQsIG90aGVyd2lzZSB1bmV4cGVjdGVkIGNhc2VcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgdHlwZS5kb2Muc2hhcmUuZW50cmllcygpKSB7XG4gICAgaWYgKHZhbHVlID09PSB0eXBlKSB7XG4gICAgICByZXR1cm4ga2V5XG4gICAgfVxuICB9XG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn1cbiIsICJpbXBvcnQgeyBBYnN0cmFjdFR5cGUsIEl0ZW0gfSBmcm9tICcuLi9pbnRlcm5hbHMuanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxuLyoqXG4gKiBDaGVjayBpZiBgcGFyZW50YCBpcyBhIHBhcmVudCBvZiBgY2hpbGRgLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtfG51bGx9IGNoaWxkXG4gKiBAcmV0dXJuIHtCb29sZWFufSBXaGV0aGVyIGBwYXJlbnRgIGlzIGEgcGFyZW50IG9mIGBjaGlsZGAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaXNQYXJlbnRPZiA9IChwYXJlbnQsIGNoaWxkKSA9PiB7XG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC5wYXJlbnQgPT09IHBhcmVudCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgY2hpbGQgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAoY2hpbGQucGFyZW50KS5faXRlbVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuIiwgImltcG9ydCB7XG4gIEFic3RyYWN0VHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBDb252ZW5pZW50IGhlbHBlciB0byBsb2cgdHlwZSBpbmZvcm1hdGlvbi5cbiAqXG4gKiBEbyBub3QgdXNlIGluIHByb2R1Y3RpdmUgc3lzdGVtcyBhcyB0aGUgb3V0cHV0IGNhbiBiZSBpbW1lbnNlIVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1R5cGUgPSB0eXBlID0+IHtcbiAgY29uc3QgcmVzID0gW11cbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICB3aGlsZSAobikge1xuICAgIHJlcy5wdXNoKG4pXG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICBjb25zb2xlLmxvZygnQ2hpbGRyZW46ICcsIHJlcylcbiAgY29uc29sZS5sb2coJ0NoaWxkcmVuIGNvbnRlbnQ6ICcsIHJlcy5maWx0ZXIobSA9PiAhbS5kZWxldGVkKS5tYXAobSA9PiBtLmNvbnRlbnQpKVxufVxuIiwgImltcG9ydCB7XG4gIFlBcnJheSxcbiAgWU1hcCxcbiAgcmVhZERlbGV0ZVNldCxcbiAgd3JpdGVEZWxldGVTZXQsXG4gIGNyZWF0ZURlbGV0ZVNldCxcbiAgRFNFbmNvZGVyVjEsIERTRGVjb2RlclYxLCBJRCwgRGVsZXRlU2V0LCBZQXJyYXlFdmVudCwgVHJhbnNhY3Rpb24sIERvYyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZGVjb2RpbmcgZnJvbSAnbGliMC9kZWNvZGluZydcblxuaW1wb3J0IHsgbWVyZ2VEZWxldGVTZXRzLCBpc0RlbGV0ZWQgfSBmcm9tICcuL0RlbGV0ZVNldC5qcydcblxuZXhwb3J0IGNsYXNzIFBlcm1hbmVudFVzZXJEYXRhIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtZTWFwPGFueT59IFtzdG9yZVR5cGVdXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jLCBzdG9yZVR5cGUgPSBkb2MuZ2V0TWFwKCd1c2VycycpKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsRGVsZXRlU2V0Pn1cbiAgICAgKi9cbiAgICBjb25zdCBkc3MgPSBuZXcgTWFwKClcbiAgICB0aGlzLnl1c2VycyA9IHN0b3JlVHlwZVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudGlkIHRvIHVzZXJEZXNjcmlwdGlvblxuICAgICAqXG4gICAgICogQHR5cGUge01hcDxudW1iZXIsc3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKClcbiAgICB0aGlzLmRzcyA9IGRzc1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7WU1hcDxhbnk+fSB1c2VyXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHVzZXJEZXNjcmlwdGlvblxuICAgICAqL1xuICAgIGNvbnN0IGluaXRVc2VyID0gKHVzZXIsIHVzZXJEZXNjcmlwdGlvbikgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7WUFycmF5PFVpbnQ4QXJyYXk+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkcyA9IHVzZXIuZ2V0KCdkcycpXG4gICAgICBjb25zdCBpZHMgPSB1c2VyLmdldCgnaWRzJylcbiAgICAgIGNvbnN0IGFkZENsaWVudElkID0gLyoqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRpZCAqLyBjbGllbnRpZCA9PiB0aGlzLmNsaWVudHMuc2V0KGNsaWVudGlkLCB1c2VyRGVzY3JpcHRpb24pXG4gICAgICBkcy5vYnNlcnZlKC8qKiBAcGFyYW0ge1lBcnJheUV2ZW50PGFueT59IGV2ZW50ICovIGV2ZW50ID0+IHtcbiAgICAgICAgZXZlbnQuY2hhbmdlcy5hZGRlZC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgIGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkuZm9yRWFjaChlbmNvZGVkRHMgPT4ge1xuICAgICAgICAgICAgaWYgKGVuY29kZWREcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgdGhpcy5kc3Muc2V0KHVzZXJEZXNjcmlwdGlvbiwgbWVyZ2VEZWxldGVTZXRzKFt0aGlzLmRzcy5nZXQodXNlckRlc2NyaXB0aW9uKSB8fCBjcmVhdGVEZWxldGVTZXQoKSwgcmVhZERlbGV0ZVNldChuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihlbmNvZGVkRHMpKSldKSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICAgIHRoaXMuZHNzLnNldCh1c2VyRGVzY3JpcHRpb24sIG1lcmdlRGVsZXRlU2V0cyhkcy5tYXAoZW5jb2RlZERzID0+IHJlYWREZWxldGVTZXQobmV3IERTRGVjb2RlclYxKGRlY29kaW5nLmNyZWF0ZURlY29kZXIoZW5jb2RlZERzKSkpKSkpXG4gICAgICBpZHMub2JzZXJ2ZSgvKiogQHBhcmFtIHtZQXJyYXlFdmVudDxhbnk+fSBldmVudCAqLyBldmVudCA9PlxuICAgICAgICBldmVudC5jaGFuZ2VzLmFkZGVkLmZvckVhY2goaXRlbSA9PiBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpLmZvckVhY2goYWRkQ2xpZW50SWQpKVxuICAgICAgKVxuICAgICAgaWRzLmZvckVhY2goYWRkQ2xpZW50SWQpXG4gICAgfVxuICAgIC8vIG9ic2VydmUgdXNlcnNcbiAgICBzdG9yZVR5cGUub2JzZXJ2ZShldmVudCA9PiB7XG4gICAgICBldmVudC5rZXlzQ2hhbmdlZC5mb3JFYWNoKHVzZXJEZXNjcmlwdGlvbiA9PlxuICAgICAgICBpbml0VXNlcihzdG9yZVR5cGUuZ2V0KHVzZXJEZXNjcmlwdGlvbiksIHVzZXJEZXNjcmlwdGlvbilcbiAgICAgIClcbiAgICB9KVxuICAgIC8vIGFkZCBpbnRpYWwgZGF0YVxuICAgIHN0b3JlVHlwZS5mb3JFYWNoKGluaXRVc2VyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICogQHBhcmFtIHtudW1iZXJ9IGNsaWVudGlkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1c2VyRGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZcbiAgICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbiwgRGVsZXRlU2V0KTpib29sZWFufSBbY29uZi5maWx0ZXJdXG4gICAqL1xuICBzZXRVc2VyTWFwcGluZyAoZG9jLCBjbGllbnRpZCwgdXNlckRlc2NyaXB0aW9uLCB7IGZpbHRlciA9ICgpID0+IHRydWUgfSA9IHt9KSB7XG4gICAgY29uc3QgdXNlcnMgPSB0aGlzLnl1c2Vyc1xuICAgIGxldCB1c2VyID0gdXNlcnMuZ2V0KHVzZXJEZXNjcmlwdGlvbilcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHVzZXIgPSBuZXcgWU1hcCgpXG4gICAgICB1c2VyLnNldCgnaWRzJywgbmV3IFlBcnJheSgpKVxuICAgICAgdXNlci5zZXQoJ2RzJywgbmV3IFlBcnJheSgpKVxuICAgICAgdXNlcnMuc2V0KHVzZXJEZXNjcmlwdGlvbiwgdXNlcilcbiAgICB9XG4gICAgdXNlci5nZXQoJ2lkcycpLnB1c2goW2NsaWVudGlkXSlcbiAgICB1c2Vycy5vYnNlcnZlKF9ldmVudCA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXNlck92ZXJ3cml0ZSA9IHVzZXJzLmdldCh1c2VyRGVzY3JpcHRpb24pXG4gICAgICAgIGlmICh1c2VyT3ZlcndyaXRlICE9PSB1c2VyKSB7XG4gICAgICAgICAgLy8gdXNlciB3YXMgb3ZlcndyaXR0ZW4sIHBvcnQgYWxsIGRhdGEgb3ZlciB0byB0aGUgbmV4dCB1c2VyIG9iamVjdFxuICAgICAgICAgIC8vIEB0b2RvIEV4cGVyaW1lbnQgd2l0aCBZLlNldHMgaGVyZVxuICAgICAgICAgIHVzZXIgPSB1c2VyT3ZlcndyaXRlXG4gICAgICAgICAgLy8gQHRvZG8gaXRlcmF0ZSBvdmVyIG9sZCB0eXBlXG4gICAgICAgICAgdGhpcy5jbGllbnRzLmZvckVhY2goKF91c2VyRGVzY3JpcHRpb24sIGNsaWVudGlkKSA9PiB7XG4gICAgICAgICAgICBpZiAodXNlckRlc2NyaXB0aW9uID09PSBfdXNlckRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgIHVzZXIuZ2V0KCdpZHMnKS5wdXNoKFtjbGllbnRpZF0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKClcbiAgICAgICAgICBjb25zdCBkcyA9IHRoaXMuZHNzLmdldCh1c2VyRGVzY3JpcHRpb24pXG4gICAgICAgICAgaWYgKGRzKSB7XG4gICAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcylcbiAgICAgICAgICAgIHVzZXIuZ2V0KCdkcycpLnB1c2goW2VuY29kZXIudG9VaW50OEFycmF5KCldKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgMClcbiAgICB9KVxuICAgIGRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIC8qKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiAqLyB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgY29uc3QgeWRzID0gdXNlci5nZXQoJ2RzJylcbiAgICAgICAgY29uc3QgZHMgPSB0cmFuc2FjdGlvbi5kZWxldGVTZXRcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLmxvY2FsICYmIGRzLmNsaWVudHMuc2l6ZSA+IDAgJiYgZmlsdGVyKHRyYW5zYWN0aW9uLCBkcykpIHtcbiAgICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYxKClcbiAgICAgICAgICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcylcbiAgICAgICAgICB5ZHMucHVzaChbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKV0pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gY2xpZW50aWRcbiAgICogQHJldHVybiB7YW55fVxuICAgKi9cbiAgZ2V0VXNlckJ5Q2xpZW50SWQgKGNsaWVudGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xpZW50cy5nZXQoY2xpZW50aWQpIHx8IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcmV0dXJuIHtzdHJpbmcgfCBudWxsfVxuICAgKi9cbiAgZ2V0VXNlckJ5RGVsZXRlZElkIChpZCkge1xuICAgIGZvciAoY29uc3QgW3VzZXJEZXNjcmlwdGlvbiwgZHNdIG9mIHRoaXMuZHNzLmVudHJpZXMoKSkge1xuICAgICAgaWYgKGlzRGVsZXRlZChkcywgaWQpKSB7XG4gICAgICAgIHJldHVybiB1c2VyRGVzY3JpcHRpb25cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIHdyaXRlSUQsXG4gIHJlYWRJRCxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0U3RhdGUsXG4gIGZpbmRSb290VHlwZUtleSxcbiAgSXRlbSxcbiAgY3JlYXRlSUQsXG4gIENvbnRlbnRUeXBlLFxuICBmb2xsb3dSZWRvbmUsXG4gIGdldEl0ZW0sXG4gIElELCBEb2MsIEFic3RyYWN0VHlwZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG4vKipcbiAqIEEgcmVsYXRpdmUgcG9zaXRpb24gaXMgYmFzZWQgb24gdGhlIFlqcyBtb2RlbCBhbmQgaXMgbm90IGFmZmVjdGVkIGJ5IGRvY3VtZW50IGNoYW5nZXMuXG4gKiBFLmcuIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGJlZm9yZSBhIGNlcnRhaW4gY2hhcmFjdGVyLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGlzIGNoYXJhY3Rlci5cbiAqIElmIHlvdSBwbGFjZSBhIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgYSB0eXBlLCBpdCB3aWxsIGFsd2F5cyBwb2ludCB0byB0aGUgZW5kIG9mIHRoZSB0eXBlLlxuICpcbiAqIEEgbnVtZXJpYyBwb3NpdGlvbiBpcyBvZnRlbiB1bnN1aXRlZCBmb3IgdXNlciBzZWxlY3Rpb25zLCBiZWNhdXNlIGl0IGRvZXMgbm90IGNoYW5nZSB3aGVuIGNvbnRlbnQgaXMgaW5zZXJ0ZWRcbiAqIGJlZm9yZSBvciBhZnRlci5cbiAqXG4gKiBgYGBJbnNlcnQoMCwgJ3gnKSgnYXxiYycpID0gJ3hhfGJjJ2BgYCBXaGVyZSB8IGlzIHRoZSByZWxhdGl2ZSBwb3NpdGlvbi5cbiAqXG4gKiBPbmUgb2YgdGhlIHByb3BlcnRpZXMgbXVzdCBiZSBkZWZpbmVkLlxuICpcbiAqIEBleGFtcGxlXG4gKiAgIC8vIEN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uIGlzIGF0IHBvc2l0aW9uIDEwXG4gKiAgIGNvbnN0IHJlbGF0aXZlUG9zaXRpb24gPSBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUluZGV4KHlUZXh0LCAxMClcbiAqICAgLy8gbW9kaWZ5IHlUZXh0XG4gKiAgIHlUZXh0Lmluc2VydCgwLCAnYWJjJylcbiAqICAgeVRleHQuZGVsZXRlKDMsIDEwKVxuICogICAvLyBDb21wdXRlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAqICAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbih5LCByZWxhdGl2ZVBvc2l0aW9uKVxuICogICBhYnNvbHV0ZVBvc2l0aW9uLnR5cGUgPT09IHlUZXh0IC8vID0+IHRydWVcbiAqICAgY29uc29sZS5sb2coJ2N1cnNvciBsb2NhdGlvbiBpcyAnICsgYWJzb2x1dGVQb3NpdGlvbi5pbmRleCkgLy8gPT4gY3Vyc29yIGxvY2F0aW9uIGlzIDNcbiAqXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWxhdGl2ZVBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SUR8bnVsbH0gdHlwZVxuICAgKiBAcGFyYW0ge3N0cmluZ3xudWxsfSB0bmFtZVxuICAgKiBAcGFyYW0ge0lEfG51bGx9IGl0ZW1cbiAgICogQHBhcmFtIHtudW1iZXJ9IGFzc29jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZSwgdG5hbWUsIGl0ZW0sIGFzc29jID0gMCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJRHxudWxsfVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfG51bGx9XG4gICAgICovXG4gICAgdGhpcy50bmFtZSA9IHRuYW1lXG4gICAgLyoqXG4gICAgICogQHR5cGUge0lEIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLml0ZW0gPSBpdGVtXG4gICAgLyoqXG4gICAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBpcyBhc3NvY2lhdGVkIHRvIGEgc3BlY2lmaWMgY2hhcmFjdGVyLiBCeSBkZWZhdWx0XG4gICAgICogYXNzb2MgPj0gMCwgdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNoYXJhY3RlclxuICAgICAqIGFmdGVyIHRoZSBtZWFudCBwb3NpdGlvbi5cbiAgICAgKiBJLmUuIHBvc2l0aW9uIDEgaW4gJ2FiJyBpcyBhc3NvY2lhdGVkIHRvIGNoYXJhY3RlciAnYicuXG4gICAgICpcbiAgICAgKiBJZiBhc3NvYyA8IDAsIHRoZW4gdGhlIHJlbGF0aXZlIHBvc2l0aW9uIGlzIGFzc29jaWF0ZWQgdG8gdGhlIGNhaGFyYWN0ZXJcbiAgICAgKiBiZWZvcmUgdGhlIG1lYW50IHBvc2l0aW9uLlxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmFzc29jID0gYXNzb2NcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVsYXRpdmVQb3NpdGlvbn0gcnBvc1xuICogQHJldHVybiB7YW55fVxuICovXG5leHBvcnQgY29uc3QgcmVsYXRpdmVQb3NpdGlvblRvSlNPTiA9IHJwb3MgPT4ge1xuICBjb25zdCBqc29uID0ge31cbiAgaWYgKHJwb3MudHlwZSkge1xuICAgIGpzb24udHlwZSA9IHJwb3MudHlwZVxuICB9XG4gIGlmIChycG9zLnRuYW1lKSB7XG4gICAganNvbi50bmFtZSA9IHJwb3MudG5hbWVcbiAgfVxuICBpZiAocnBvcy5pdGVtKSB7XG4gICAganNvbi5pdGVtID0gcnBvcy5pdGVtXG4gIH1cbiAgaWYgKHJwb3MuYXNzb2MgIT0gbnVsbCkge1xuICAgIGpzb24uYXNzb2MgPSBycG9zLmFzc29jXG4gIH1cbiAgcmV0dXJuIGpzb25cbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FueX0ganNvblxuICogQHJldHVybiB7UmVsYXRpdmVQb3NpdGlvbn1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTiA9IGpzb24gPT4gbmV3IFJlbGF0aXZlUG9zaXRpb24oanNvbi50eXBlID09IG51bGwgPyBudWxsIDogY3JlYXRlSUQoanNvbi50eXBlLmNsaWVudCwganNvbi50eXBlLmNsb2NrKSwganNvbi50bmFtZSA/PyBudWxsLCBqc29uLml0ZW0gPT0gbnVsbCA/IG51bGwgOiBjcmVhdGVJRChqc29uLml0ZW0uY2xpZW50LCBqc29uLml0ZW0uY2xvY2spLCBqc29uLmFzc29jID09IG51bGwgPyAwIDoganNvbi5hc3NvYylcblxuZXhwb3J0IGNsYXNzIEFic29sdXRlUG9zaXRpb24ge1xuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMuYXNzb2MgPSBhc3NvY1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlQWJzb2x1dGVQb3NpdGlvbiA9ICh0eXBlLCBpbmRleCwgYXNzb2MgPSAwKSA9PiBuZXcgQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgYXNzb2MpXG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtJRHxudWxsfSBpdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gW2Fzc29jXVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbiA9ICh0eXBlLCBpdGVtLCBhc3NvYykgPT4ge1xuICBsZXQgdHlwZWlkID0gbnVsbFxuICBsZXQgdG5hbWUgPSBudWxsXG4gIGlmICh0eXBlLl9pdGVtID09PSBudWxsKSB7XG4gICAgdG5hbWUgPSBmaW5kUm9vdFR5cGVLZXkodHlwZSlcbiAgfSBlbHNlIHtcbiAgICB0eXBlaWQgPSBjcmVhdGVJRCh0eXBlLl9pdGVtLmlkLmNsaWVudCwgdHlwZS5faXRlbS5pZC5jbG9jaylcbiAgfVxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZWlkLCB0bmFtZSwgaXRlbSwgYXNzb2MpXG59XG5cbi8qKlxuICogQ3JlYXRlIGEgcmVsYXRpdmVQb3NpdGlvbiBiYXNlZCBvbiBhIGFic29sdXRlIHBvc2l0aW9uLlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGUgVGhlIGJhc2UgdHlwZSAoZS5nLiBZVGV4dCBvciBZQXJyYXkpLlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbYXNzb2NdXG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXggPSAodHlwZSwgaW5kZXgsIGFzc29jID0gMCkgPT4ge1xuICBsZXQgdCA9IHR5cGUuX3N0YXJ0XG4gIGlmIChhc3NvYyA8IDApIHtcbiAgICAvLyBhc3NvY2lhdGVkIHRvIHRoZSBsZWZ0IGNoYXJhY3RlciBvciB0aGUgYmVnaW5uaW5nIG9mIGEgdHlwZSwgaW5jcmVtZW50IGluZGV4IGlmIHBvc3NpYmxlLlxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgbnVsbCwgYXNzb2MpXG4gICAgfVxuICAgIGluZGV4LS1cbiAgfVxuICB3aGlsZSAodCAhPT0gbnVsbCkge1xuICAgIGlmICghdC5kZWxldGVkICYmIHQuY291bnRhYmxlKSB7XG4gICAgICBpZiAodC5sZW5ndGggPiBpbmRleCkge1xuICAgICAgICAvLyBjYXNlIDE6IGZvdW5kIHBvc2l0aW9uIHNvbWV3aGVyZSBpbiB0aGUgbGlua2VkIGxpc3RcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgY3JlYXRlSUQodC5pZC5jbGllbnQsIHQuaWQuY2xvY2sgKyBpbmRleCksIGFzc29jKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gdC5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHQucmlnaHQgPT09IG51bGwgJiYgYXNzb2MgPCAwKSB7XG4gICAgICAvLyBsZWZ0LWFzc29jaWF0ZWQgcG9zaXRpb24sIHJldHVybiBsYXN0IGF2YWlsYWJsZSBpZFxuICAgICAgcmV0dXJuIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb24odHlwZSwgdC5sYXN0SWQsIGFzc29jKVxuICAgIH1cbiAgICB0ID0gdC5yaWdodFxuICB9XG4gIHJldHVybiBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uKHR5cGUsIG51bGwsIGFzc29jKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufSBycG9zXG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVJlbGF0aXZlUG9zaXRpb24gPSAoZW5jb2RlciwgcnBvcykgPT4ge1xuICBjb25zdCB7IHR5cGUsIHRuYW1lLCBpdGVtLCBhc3NvYyB9ID0gcnBvc1xuICBpZiAoaXRlbSAhPT0gbnVsbCkge1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCAwKVxuICAgIHdyaXRlSUQoZW5jb2RlciwgaXRlbSlcbiAgfSBlbHNlIGlmICh0bmFtZSAhPT0gbnVsbCkge1xuICAgIC8vIGNhc2UgMjogZm91bmQgcG9zaXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQgdHlwZSBpcyBzdG9yZWQgaW4geS5zaGFyZVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlciwgMSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0bmFtZSlcbiAgfSBlbHNlIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgLy8gY2FzZSAzOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIGF0dGFjaGVkIHRvIGFuIGl0ZW1cbiAgICBlbmNvZGluZy53cml0ZVVpbnQ4KGVuY29kZXIsIDIpXG4gICAgd3JpdGVJRChlbmNvZGVyLCB0eXBlKVxuICB9IGVsc2Uge1xuICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuICBlbmNvZGluZy53cml0ZVZhckludChlbmNvZGVyLCBhc3NvYylcbiAgcmV0dXJuIGVuY29kZXJcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVSZWxhdGl2ZVBvc2l0aW9uID0gcnBvcyA9PiB7XG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgd3JpdGVSZWxhdGl2ZVBvc2l0aW9uKGVuY29kZXIsIHJwb3MpXG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1JlbGF0aXZlUG9zaXRpb259XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkUmVsYXRpdmVQb3NpdGlvbiA9IGRlY29kZXIgPT4ge1xuICBsZXQgdHlwZSA9IG51bGxcbiAgbGV0IHRuYW1lID0gbnVsbFxuICBsZXQgaXRlbUlEID0gbnVsbFxuICBzd2l0Y2ggKGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpKSB7XG4gICAgY2FzZSAwOlxuICAgICAgLy8gY2FzZSAxOiBmb3VuZCBwb3NpdGlvbiBzb21ld2hlcmUgaW4gdGhlIGxpbmtlZCBsaXN0XG4gICAgICBpdGVtSUQgPSByZWFkSUQoZGVjb2RlcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAxOlxuICAgICAgLy8gY2FzZSAyOiBmb3VuZCBwb3NpdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCB0eXBlIGlzIHN0b3JlZCBpbiB5LnNoYXJlXG4gICAgICB0bmFtZSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgIGJyZWFrXG4gICAgY2FzZSAyOiB7XG4gICAgICAvLyBjYXNlIDM6IGZvdW5kIHBvc2l0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGxpc3QgYW5kIHR5cGUgaXMgYXR0YWNoZWQgdG8gYW4gaXRlbVxuICAgICAgdHlwZSA9IHJlYWRJRChkZWNvZGVyKVxuICAgIH1cbiAgfVxuICBjb25zdCBhc3NvYyA9IGRlY29kaW5nLmhhc0NvbnRlbnQoZGVjb2RlcikgPyBkZWNvZGluZy5yZWFkVmFySW50KGRlY29kZXIpIDogMFxuICByZXR1cm4gbmV3IFJlbGF0aXZlUG9zaXRpb24odHlwZSwgdG5hbWUsIGl0ZW1JRCwgYXNzb2MpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1aW50OEFycmF5XG4gKiBAcmV0dXJuIHtSZWxhdGl2ZVBvc2l0aW9ufVxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbiA9IHVpbnQ4QXJyYXkgPT4gcmVhZFJlbGF0aXZlUG9zaXRpb24oZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1aW50OEFycmF5KSlcblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSByZWxhdGl2ZSBwb3NpdGlvbiB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvbi5cbiAqXG4gKiBJZiB5b3Ugd2FudCB0byBzaGFyZSB0aGUgcmVsYXRpdmUgcG9zaXRpb24gd2l0aCBvdGhlciB1c2VycywgeW91IHNob3VsZCBzZXRcbiAqIGBmb2xsb3dVbmRvbmVEZWxldGlvbnNgIHRvIGZhbHNlIHRvIGdldCBjb25zaXN0ZW50IHJlc3VsdHMgYWNyb3NzIGFsbCBjbGllbnRzLlxuICpcbiAqIFdoZW4gY2FsY3VsYXRpbmcgdGhlIGFic29sdXRlIHBvc2l0aW9uLCB3ZSB0cnkgdG8gZm9sbG93IHRoZSBcInVuZG9uZSBkZWxldGlvbnNcIi4gVGhpcyB5aWVsZHNcbiAqIGJldHRlciByZXN1bHRzIGZvciB0aGUgdXNlciB3aG8gcGVyZm9ybWVkIHVuZG8uIEhvd2V2ZXIsIG9ubHkgdGhlIHVzZXIgd2hvIHBlcmZvcm1lZCB0aGUgdW5kb1xuICogd2lsbCBnZXQgdGhlIGJldHRlciByZXN1bHRzLCB0aGUgb3RoZXIgdXNlcnMgZG9uJ3Qga25vdyB3aGljaCBvcGVyYXRpb25zIHJlY3JlYXRlZCBhIGRlbGV0ZWRcbiAqIHJhbmdlIG9mIGNvbnRlbnQuIFRoZXJlIGlzIG1vcmUgaW5mb3JtYXRpb24gaW4gdGhpcyB0aWNrZXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS95anMveWpzL2lzc3Vlcy82MzhcbiAqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb259IHJwb3NcbiAqIEBwYXJhbSB7RG9jfSBkb2NcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9sbG93VW5kb25lRGVsZXRpb25zIC0gd2hldGhlciB0byBmb2xsb3cgdW5kb25lIGRlbGV0aW9ucyAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvNjM4XG4gKiBAcmV0dXJuIHtBYnNvbHV0ZVBvc2l0aW9ufG51bGx9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24gPSAocnBvcywgZG9jLCBmb2xsb3dVbmRvbmVEZWxldGlvbnMgPSB0cnVlKSA9PiB7XG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gIGNvbnN0IHJpZ2h0SUQgPSBycG9zLml0ZW1cbiAgY29uc3QgdHlwZUlEID0gcnBvcy50eXBlXG4gIGNvbnN0IHRuYW1lID0gcnBvcy50bmFtZVxuICBjb25zdCBhc3NvYyA9IHJwb3MuYXNzb2NcbiAgbGV0IHR5cGUgPSBudWxsXG4gIGxldCBpbmRleCA9IDBcbiAgaWYgKHJpZ2h0SUQgIT09IG51bGwpIHtcbiAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHJpZ2h0SUQuY2xpZW50KSA8PSByaWdodElELmNsb2NrKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICBjb25zdCByZXMgPSBmb2xsb3dVbmRvbmVEZWxldGlvbnMgPyBmb2xsb3dSZWRvbmUoc3RvcmUsIHJpZ2h0SUQpIDogeyBpdGVtOiBnZXRJdGVtKHN0b3JlLCByaWdodElEKSwgZGlmZjogMCB9XG4gICAgY29uc3QgcmlnaHQgPSByZXMuaXRlbVxuICAgIGlmICghKHJpZ2h0IGluc3RhbmNlb2YgSXRlbSkpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KVxuICAgIGlmICh0eXBlLl9pdGVtID09PSBudWxsIHx8ICF0eXBlLl9pdGVtLmRlbGV0ZWQpIHtcbiAgICAgIGluZGV4ID0gKHJpZ2h0LmRlbGV0ZWQgfHwgIXJpZ2h0LmNvdW50YWJsZSkgPyAwIDogKHJlcy5kaWZmICsgKGFzc29jID49IDAgPyAwIDogMSkpIC8vIGFkanVzdCBwb3NpdGlvbiBiYXNlZCBvbiBsZWZ0IGFzc29jaWF0aW9uIGlmIG5lY2Vzc2FyeVxuICAgICAgbGV0IG4gPSByaWdodC5sZWZ0XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgICAgIGluZGV4ICs9IG4ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgbiA9IG4ubGVmdFxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodG5hbWUgIT09IG51bGwpIHtcbiAgICAgIHR5cGUgPSBkb2MuZ2V0KHRuYW1lKVxuICAgIH0gZWxzZSBpZiAodHlwZUlEICE9PSBudWxsKSB7XG4gICAgICBpZiAoZ2V0U3RhdGUoc3RvcmUsIHR5cGVJRC5jbGllbnQpIDw9IHR5cGVJRC5jbG9jaykge1xuICAgICAgICAvLyB0eXBlIGRvZXMgbm90IGV4aXN0IHlldFxuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgeyBpdGVtIH0gPSBmb2xsb3dVbmRvbmVEZWxldGlvbnMgPyBmb2xsb3dSZWRvbmUoc3RvcmUsIHR5cGVJRCkgOiB7IGl0ZW06IGdldEl0ZW0oc3RvcmUsIHR5cGVJRCkgfVxuICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBJdGVtICYmIGl0ZW0uY29udGVudCBpbnN0YW5jZW9mIENvbnRlbnRUeXBlKSB7XG4gICAgICAgIHR5cGUgPSBpdGVtLmNvbnRlbnQudHlwZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc3RydWN0IGlzIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgaWYgKGFzc29jID49IDApIHtcbiAgICAgIGluZGV4ID0gdHlwZS5fbGVuZ3RoXG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gMFxuICAgIH1cbiAgfVxuICByZXR1cm4gY3JlYXRlQWJzb2x1dGVQb3NpdGlvbih0eXBlLCBpbmRleCwgcnBvcy5hc3NvYylcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlbGF0aXZlUG9zaXRpb258bnVsbH0gYVxuICogQHBhcmFtIHtSZWxhdGl2ZVBvc2l0aW9ufG51bGx9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBjb21wYXJlUmVsYXRpdmVQb3NpdGlvbnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAoXG4gIGEgIT09IG51bGwgJiYgYiAhPT0gbnVsbCAmJiBhLnRuYW1lID09PSBiLnRuYW1lICYmIGNvbXBhcmVJRHMoYS5pdGVtLCBiLml0ZW0pICYmIGNvbXBhcmVJRHMoYS50eXBlLCBiLnR5cGUpICYmIGEuYXNzb2MgPT09IGIuYXNzb2NcbilcbiIsICJpbXBvcnQge1xuICBpc0RlbGV0ZWQsXG4gIGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZSxcbiAgZ2V0U3RhdGVWZWN0b3IsXG4gIGdldEl0ZW1DbGVhblN0YXJ0LFxuICBpdGVyYXRlRGVsZXRlZFN0cnVjdHMsXG4gIHdyaXRlRGVsZXRlU2V0LFxuICB3cml0ZVN0YXRlVmVjdG9yLFxuICByZWFkRGVsZXRlU2V0LFxuICByZWFkU3RhdGVWZWN0b3IsXG4gIGNyZWF0ZURlbGV0ZVNldCxcbiAgY3JlYXRlSUQsXG4gIGdldFN0YXRlLFxuICBmaW5kSW5kZXhTUyxcbiAgVXBkYXRlRW5jb2RlclYyLFxuICBhcHBseVVwZGF0ZVYyLFxuICBMYXp5U3RydWN0UmVhZGVyLFxuICBlcXVhbERlbGV0ZVNldHMsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBEU0VuY29kZXJWMSwgRFNFbmNvZGVyVjIsIERTRGVjb2RlclYxLCBEU0RlY29kZXJWMiwgVHJhbnNhY3Rpb24sIERvYywgRGVsZXRlU2V0LCBJdGVtLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIG1lcmdlRGVsZXRlU2V0c1xufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCdcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuXG5leHBvcnQgY2xhc3MgU25hcHNob3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gICAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzdiBzdGF0ZSBtYXBcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkcywgc3YpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7RGVsZXRlU2V0fVxuICAgICAqL1xuICAgIHRoaXMuZHMgPSBkc1xuICAgIC8qKlxuICAgICAqIFN0YXRlIE1hcFxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLG51bWJlcj59XG4gICAgICovXG4gICAgdGhpcy5zdiA9IHN2XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwMVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcDJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBjb25zdCBlcXVhbFNuYXBzaG90cyA9IChzbmFwMSwgc25hcDIpID0+IHtcbiAgY29uc3QgZHMxID0gc25hcDEuZHMuY2xpZW50c1xuICBjb25zdCBkczIgPSBzbmFwMi5kcy5jbGllbnRzXG4gIGNvbnN0IHN2MSA9IHNuYXAxLnN2XG4gIGNvbnN0IHN2MiA9IHNuYXAyLnN2XG4gIGlmIChzdjEuc2l6ZSAhPT0gc3YyLnNpemUgfHwgZHMxLnNpemUgIT09IGRzMi5zaXplKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2Ygc3YxLmVudHJpZXMoKSkge1xuICAgIGlmIChzdjIuZ2V0KGtleSkgIT09IHZhbHVlKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBbY2xpZW50LCBkc2l0ZW1zMV0gb2YgZHMxLmVudHJpZXMoKSkge1xuICAgIGNvbnN0IGRzaXRlbXMyID0gZHMyLmdldChjbGllbnQpIHx8IFtdXG4gICAgaWYgKGRzaXRlbXMxLmxlbmd0aCAhPT0gZHNpdGVtczIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkc2l0ZW1zMS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZHNpdGVtMSA9IGRzaXRlbXMxW2ldXG4gICAgICBjb25zdCBkc2l0ZW0yID0gZHNpdGVtczJbaV1cbiAgICAgIGlmIChkc2l0ZW0xLmNsb2NrICE9PSBkc2l0ZW0yLmNsb2NrIHx8IGRzaXRlbTEubGVuICE9PSBkc2l0ZW0yLmxlbikge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWVcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NuYXBzaG90fSBzbmFwc2hvdFxuICogQHBhcmFtIHtEU0VuY29kZXJWMSB8IERTRW5jb2RlclYyfSBbZW5jb2Rlcl1cbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTbmFwc2hvdFYyID0gKHNuYXBzaG90LCBlbmNvZGVyID0gbmV3IERTRW5jb2RlclYyKCkpID0+IHtcbiAgd3JpdGVEZWxldGVTZXQoZW5jb2Rlciwgc25hcHNob3QuZHMpXG4gIHdyaXRlU3RhdGVWZWN0b3IoZW5jb2Rlciwgc25hcHNob3Quc3YpXG4gIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVTbmFwc2hvdCA9IHNuYXBzaG90ID0+IGVuY29kZVNuYXBzaG90VjIoc25hcHNob3QsIG5ldyBEU0VuY29kZXJWMSgpKVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcGFyYW0ge0RTRGVjb2RlclYxIHwgRFNEZWNvZGVyVjJ9IFtkZWNvZGVyXVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVTbmFwc2hvdFYyID0gKGJ1ZiwgZGVjb2RlciA9IG5ldyBEU0RlY29kZXJWMihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGJ1ZikpKSA9PiB7XG4gIHJldHVybiBuZXcgU25hcHNob3QocmVhZERlbGV0ZVNldChkZWNvZGVyKSwgcmVhZFN0YXRlVmVjdG9yKGRlY29kZXIpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlY29kZVNuYXBzaG90ID0gYnVmID0+IGRlY29kZVNuYXBzaG90VjIoYnVmLCBuZXcgRFNEZWNvZGVyVjEoZGVjb2RpbmcuY3JlYXRlRGVjb2RlcihidWYpKSlcblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7TWFwPG51bWJlcixudW1iZXI+fSBzbVxuICogQHJldHVybiB7U25hcHNob3R9XG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTbmFwc2hvdCA9IChkcywgc20pID0+IG5ldyBTbmFwc2hvdChkcywgc20pXG5cbmV4cG9ydCBjb25zdCBlbXB0eVNuYXBzaG90ID0gY3JlYXRlU25hcHNob3QoY3JlYXRlRGVsZXRlU2V0KCksIG5ldyBNYXAoKSlcblxuLyoqXG4gKiBAcGFyYW0ge0RvY30gZG9jXG4gKiBAcmV0dXJuIHtTbmFwc2hvdH1cbiAqL1xuZXhwb3J0IGNvbnN0IHNuYXBzaG90ID0gZG9jID0+IGNyZWF0ZVNuYXBzaG90KGNyZWF0ZURlbGV0ZVNldEZyb21TdHJ1Y3RTdG9yZShkb2Muc3RvcmUpLCBnZXRTdGF0ZVZlY3Rvcihkb2Muc3RvcmUpKVxuXG4vKipcbiAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICogQHBhcmFtIHtTbmFwc2hvdHx1bmRlZmluZWR9IHNuYXBzaG90XG4gKlxuICogQHByb3RlY3RlZFxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpc1Zpc2libGUgPSAoaXRlbSwgc25hcHNob3QpID0+IHNuYXBzaG90ID09PSB1bmRlZmluZWRcbiAgPyAhaXRlbS5kZWxldGVkXG4gIDogc25hcHNob3Quc3YuaGFzKGl0ZW0uaWQuY2xpZW50KSAmJiAoc25hcHNob3Quc3YuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSA+IGl0ZW0uaWQuY2xvY2sgJiYgIWlzRGVsZXRlZChzbmFwc2hvdC5kcywgaXRlbS5pZClcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqL1xuZXhwb3J0IGNvbnN0IHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHNuYXBzaG90KSA9PiB7XG4gIGNvbnN0IG1ldGEgPSBtYXAuc2V0SWZVbmRlZmluZWQodHJhbnNhY3Rpb24ubWV0YSwgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cywgc2V0LmNyZWF0ZSlcbiAgY29uc3Qgc3RvcmUgPSB0cmFuc2FjdGlvbi5kb2Muc3RvcmVcbiAgLy8gY2hlY2sgaWYgd2UgYWxyZWFkeSBzcGxpdCBmb3IgdGhpcyBzbmFwc2hvdFxuICBpZiAoIW1ldGEuaGFzKHNuYXBzaG90KSkge1xuICAgIHNuYXBzaG90LnN2LmZvckVhY2goKGNsb2NrLCBjbGllbnQpID0+IHtcbiAgICAgIGlmIChjbG9jayA8IGdldFN0YXRlKHN0b3JlLCBjbGllbnQpKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSlcbiAgICAgIH1cbiAgICB9KVxuICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc25hcHNob3QuZHMsIF9pdGVtID0+IHt9KVxuICAgIG1ldGEuYWRkKHNuYXBzaG90KVxuICB9XG59XG5cbi8qKlxuICogQGV4YW1wbGVcbiAqICBjb25zdCB5ZG9jID0gbmV3IFkuRG9jKHsgZ2M6IGZhbHNlIH0pXG4gKiAgeWRvYy5nZXRUZXh0KCkuaW5zZXJ0KDAsICd3b3JsZCEnKVxuICogIGNvbnN0IHNuYXBzaG90ID0gWS5zbmFwc2hvdCh5ZG9jKVxuICogIHlkb2MuZ2V0VGV4dCgpLmluc2VydCgwLCAnaGVsbG8gJylcbiAqICBjb25zdCByZXN0b3JlZCA9IFkuY3JlYXRlRG9jRnJvbVNuYXBzaG90KHlkb2MsIHNuYXBzaG90KVxuICogIGFzc2VydChyZXN0b3JlZC5nZXRUZXh0KCkudG9TdHJpbmcoKSA9PT0gJ3dvcmxkIScpXG4gKlxuICogQHBhcmFtIHtEb2N9IG9yaWdpbkRvY1xuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7RG9jfSBbbmV3RG9jXSBPcHRpb25hbGx5LCB5b3UgbWF5IGRlZmluZSB0aGUgWWpzIGRvY3VtZW50IHRoYXQgcmVjZWl2ZXMgdGhlIGRhdGEgZnJvbSBvcmlnaW5Eb2NcbiAqIEByZXR1cm4ge0RvY31cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZURvY0Zyb21TbmFwc2hvdCA9IChvcmlnaW5Eb2MsIHNuYXBzaG90LCBuZXdEb2MgPSBuZXcgRG9jKCkpID0+IHtcbiAgaWYgKG9yaWdpbkRvYy5nYykge1xuICAgIC8vIHdlIHNob3VsZCBub3QgdHJ5IHRvIHJlc3RvcmUgYSBHQy1lZCBkb2N1bWVudCwgYmVjYXVzZSBzb21lIG9mIHRoZSByZXN0b3JlZCBpdGVtcyBtaWdodCBoYXZlIHRoZWlyIGNvbnRlbnQgZGVsZXRlZFxuICAgIHRocm93IG5ldyBFcnJvcignR2FyYmFnZS1jb2xsZWN0aW9uIG11c3QgYmUgZGlzYWJsZWQgaW4gYG9yaWdpbkRvY2AhJylcbiAgfVxuICBjb25zdCB7IHN2LCBkcyB9ID0gc25hcHNob3RcblxuICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMigpXG4gIG9yaWdpbkRvYy50cmFuc2FjdCh0cmFuc2FjdGlvbiA9PiB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgc3YuZm9yRWFjaChjbG9jayA9PiB7XG4gICAgICBpZiAoY2xvY2sgPiAwKSB7XG4gICAgICAgIHNpemUrK1xuICAgICAgfVxuICAgIH0pXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHNpemUpXG4gICAgLy8gc3BsaXR0aW5nIHRoZSBzdHJ1Y3RzIGJlZm9yZSB3cml0aW5nIHRoZW0gdG8gdGhlIGVuY29kZXJcbiAgICBmb3IgKGNvbnN0IFtjbGllbnQsIGNsb2NrXSBvZiBzdikge1xuICAgICAgaWYgKGNsb2NrID09PSAwKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBpZiAoY2xvY2sgPCBnZXRTdGF0ZShvcmlnaW5Eb2Muc3RvcmUsIGNsaWVudCkpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spKVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RydWN0cyA9IG9yaWdpbkRvYy5zdG9yZS5jbGllbnRzLmdldChjbGllbnQpIHx8IFtdXG4gICAgICBjb25zdCBsYXN0U3RydWN0SW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBjbG9jayAtIDEpXG4gICAgICAvLyB3cml0ZSAjIGVuY29kZWQgc3RydWN0c1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGxhc3RTdHJ1Y3RJbmRleCArIDEpXG4gICAgICBlbmNvZGVyLndyaXRlQ2xpZW50KGNsaWVudClcbiAgICAgIC8vIGZpcnN0IGNsb2NrIHdyaXR0ZW4gaXMgMFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBsYXN0U3RydWN0SW5kZXg7IGkrKykge1xuICAgICAgICBzdHJ1Y3RzW2ldLndyaXRlKGVuY29kZXIsIDApXG4gICAgICB9XG4gICAgfVxuICAgIHdyaXRlRGVsZXRlU2V0KGVuY29kZXIsIGRzKVxuICB9KVxuXG4gIGFwcGx5VXBkYXRlVjIobmV3RG9jLCBlbmNvZGVyLnRvVWludDhBcnJheSgpLCAnc25hcHNob3QnKVxuICByZXR1cm4gbmV3RG9jXG59XG5cbi8qKlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjIgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYxfSBbWURlY29kZXJdXG4gKi9cbmV4cG9ydCBjb25zdCBzbmFwc2hvdENvbnRhaW5zVXBkYXRlVjIgPSAoc25hcHNob3QsIHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdXG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKVxuICAgIGlmICgoc25hcHNob3Quc3YuZ2V0KGN1cnIuaWQuY2xpZW50KSB8fCAwKSA8IGN1cnIuaWQuY2xvY2sgKyBjdXJyLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG4gIGNvbnN0IG1lcmdlZERTID0gbWVyZ2VEZWxldGVTZXRzKFtzbmFwc2hvdC5kcywgcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKV0pXG4gIHJldHVybiBlcXVhbERlbGV0ZVNldHMoc25hcHNob3QuZHMsIG1lcmdlZERTKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3Qgc25hcHNob3RDb250YWluc1VwZGF0ZSA9IChzbmFwc2hvdCwgdXBkYXRlKSA9PiBzbmFwc2hvdENvbnRhaW5zVXBkYXRlVjIoc25hcHNob3QsIHVwZGF0ZSwgVXBkYXRlRGVjb2RlclYxKVxuIiwgImltcG9ydCB7XG4gIEdDLFxuICBzcGxpdEl0ZW0sXG4gIFRyYW5zYWN0aW9uLCBJRCwgSXRlbSwgRFNEZWNvZGVyVjIgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuZXhwb3J0IGNsYXNzIFN0cnVjdFN0b3JlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8bnVtYmVyLEFycmF5PEdDfEl0ZW0+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudHMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IHsgbWlzc2luZzogTWFwPG51bWJlciwgbnVtYmVyPiwgdXBkYXRlOiBVaW50OEFycmF5IH19XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nU3RydWN0cyA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IFVpbnQ4QXJyYXl9XG4gICAgICovXG4gICAgdGhpcy5wZW5kaW5nRHMgPSBudWxsXG4gIH1cbn1cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHN0YXRlcyBhcyBhIE1hcDxjbGllbnQsY2xvY2s+LlxuICogTm90ZSB0aGF0IGNsb2NrIHJlZmVycyB0byB0aGUgbmV4dCBleHBlY3RlZCBjbG9jayBpZC5cbiAqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHJldHVybiB7TWFwPG51bWJlcixudW1iZXI+fVxuICpcbiAqIEBwdWJsaWNcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RhdGVWZWN0b3IgPSBzdG9yZSA9PiB7XG4gIGNvbnN0IHNtID0gbmV3IE1hcCgpXG4gIHN0b3JlLmNsaWVudHMuZm9yRWFjaCgoc3RydWN0cywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tzdHJ1Y3RzLmxlbmd0aCAtIDFdXG4gICAgc20uc2V0KGNsaWVudCwgc3RydWN0LmlkLmNsb2NrICsgc3RydWN0Lmxlbmd0aClcbiAgfSlcbiAgcmV0dXJuIHNtXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBjbGllbnRcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFN0YXRlID0gKHN0b3JlLCBjbGllbnQpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudClcbiAgaWYgKHN0cnVjdHMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgY29uc3QgbGFzdFN0cnVjdCA9IHN0cnVjdHNbc3RydWN0cy5sZW5ndGggLSAxXVxuICByZXR1cm4gbGFzdFN0cnVjdC5pZC5jbG9jayArIGxhc3RTdHJ1Y3QubGVuZ3RoXG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpbnRlZ3JldHlDaGVjayA9IHN0b3JlID0+IHtcbiAgc3RvcmUuY2xpZW50cy5mb3JFYWNoKHN0cnVjdHMgPT4ge1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgc3RydWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbCA9IHN0cnVjdHNbaSAtIDFdXG4gICAgICBjb25zdCByID0gc3RydWN0c1tpXVxuICAgICAgaWYgKGwuaWQuY2xvY2sgKyBsLmxlbmd0aCAhPT0gci5pZC5jbG9jaykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0cnVjdFN0b3JlIGZhaWxlZCBpbnRlZ3JldHkgY2hlY2snKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtHQ3xJdGVtfSBzdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRTdHJ1Y3QgPSAoc3RvcmUsIHN0cnVjdCkgPT4ge1xuICBsZXQgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpXG4gIGlmIChzdHJ1Y3RzID09PSB1bmRlZmluZWQpIHtcbiAgICBzdHJ1Y3RzID0gW11cbiAgICBzdG9yZS5jbGllbnRzLnNldChzdHJ1Y3QuaWQuY2xpZW50LCBzdHJ1Y3RzKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxhc3RTdHJ1Y3QgPSBzdHJ1Y3RzW3N0cnVjdHMubGVuZ3RoIC0gMV1cbiAgICBpZiAobGFzdFN0cnVjdC5pZC5jbG9jayArIGxhc3RTdHJ1Y3QubGVuZ3RoICE9PSBzdHJ1Y3QuaWQuY2xvY2spIHtcbiAgICAgIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gIH1cbiAgc3RydWN0cy5wdXNoKHN0cnVjdClcbn1cblxuLyoqXG4gKiBQZXJmb3JtIGEgYmluYXJ5IHNlYXJjaCBvbiBhIHNvcnRlZCBhcnJheVxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZmluZEluZGV4U1MgPSAoc3RydWN0cywgY2xvY2spID0+IHtcbiAgbGV0IGxlZnQgPSAwXG4gIGxldCByaWdodCA9IHN0cnVjdHMubGVuZ3RoIC0gMVxuICBsZXQgbWlkID0gc3RydWN0c1tyaWdodF1cbiAgbGV0IG1pZGNsb2NrID0gbWlkLmlkLmNsb2NrXG4gIGlmIChtaWRjbG9jayA9PT0gY2xvY2spIHtcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuICAvLyBAdG9kbyBkb2VzIGl0IGV2ZW4gbWFrZSBzZW5zZSB0byBwaXZvdCB0aGUgc2VhcmNoP1xuICAvLyBJZiBhIGdvb2Qgc3BsaXQgbWlzc2VzLCBpdCBtaWdodCBhY3R1YWxseSBpbmNyZWFzZSB0aGUgdGltZSB0byBmaW5kIHRoZSBjb3JyZWN0IGl0ZW0uXG4gIC8vIEN1cnJlbnRseSwgdGhlIG9ubHkgYWR2YW50YWdlIGlzIHRoYXQgc2VhcmNoIHdpdGggcGl2b3RpbmcgbWlnaHQgZmluZCB0aGUgaXRlbSBvbiB0aGUgZmlyc3QgdHJ5LlxuICBsZXQgbWlkaW5kZXggPSBtYXRoLmZsb29yKChjbG9jayAvIChtaWRjbG9jayArIG1pZC5sZW5ndGggLSAxKSkgKiByaWdodCkgLy8gcGl2b3RpbmcgdGhlIHNlYXJjaFxuICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgIG1pZCA9IHN0cnVjdHNbbWlkaW5kZXhdXG4gICAgbWlkY2xvY2sgPSBtaWQuaWQuY2xvY2tcbiAgICBpZiAobWlkY2xvY2sgPD0gY2xvY2spIHtcbiAgICAgIGlmIChjbG9jayA8IG1pZGNsb2NrICsgbWlkLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbWlkaW5kZXhcbiAgICAgIH1cbiAgICAgIGxlZnQgPSBtaWRpbmRleCArIDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmlnaHQgPSBtaWRpbmRleCAtIDFcbiAgICB9XG4gICAgbWlkaW5kZXggPSBtYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMilcbiAgfVxuICAvLyBBbHdheXMgY2hlY2sgc3RhdGUgYmVmb3JlIGxvb2tpbmcgZm9yIGEgc3RydWN0IGluIFN0cnVjdFN0b3JlXG4gIC8vIFRoZXJlZm9yZSB0aGUgY2FzZSBvZiBub3QgZmluZGluZyBhIHN0cnVjdCBpcyB1bmV4cGVjdGVkXG4gIHRocm93IGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbn1cblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7R0N8SXRlbX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PEdDfEl0ZW0+fVxuICAgKi9cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBzdHJ1Y3RzID0gc3RvcmUuY2xpZW50cy5nZXQoaWQuY2xpZW50KVxuICByZXR1cm4gc3RydWN0c1tmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jayldXG59XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEl0ZW0gPSAvKiogQHR5cGUge2Z1bmN0aW9uKFN0cnVjdFN0b3JlLElEKTpJdGVtfSAqLyAoZmluZClcblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxJdGVtfEdDPn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IGNsb2NrXG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kSW5kZXhDbGVhblN0YXJ0ID0gKHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9jaykgPT4ge1xuICBjb25zdCBpbmRleCA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGNsb2NrKVxuICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW2luZGV4XVxuICBpZiAoc3RydWN0LmlkLmNsb2NrIDwgY2xvY2sgJiYgc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgIHN0cnVjdHMuc3BsaWNlKGluZGV4ICsgMSwgMCwgc3BsaXRJdGVtKHRyYW5zYWN0aW9uLCBzdHJ1Y3QsIGNsb2NrIC0gc3RydWN0LmlkLmNsb2NrKSlcbiAgICByZXR1cm4gaW5kZXggKyAxXG4gIH1cbiAgcmV0dXJuIGluZGV4XG59XG5cbi8qKlxuICogRXhwZWN0cyB0aGF0IGlkIGlzIGFjdHVhbGx5IGluIHN0b3JlLiBUaGlzIGZ1bmN0aW9uIHRocm93cyBvciBpcyBhbiBpbmZpbml0ZSBsb29wIG90aGVyd2lzZS5cbiAqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0SXRlbUNsZWFuU3RhcnQgPSAodHJhbnNhY3Rpb24sIGlkKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEl0ZW0+fSAqLyAodHJhbnNhY3Rpb24uZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudCkpXG4gIHJldHVybiBzdHJ1Y3RzW2ZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGlkLmNsb2NrKV1cbn1cblxuLyoqXG4gKiBFeHBlY3RzIHRoYXQgaWQgaXMgYWN0dWFsbHkgaW4gc3RvcmUuIFRoaXMgZnVuY3Rpb24gdGhyb3dzIG9yIGlzIGFuIGluZmluaXRlIGxvb3Agb3RoZXJ3aXNlLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJRH0gaWRcbiAqIEByZXR1cm4ge0l0ZW19XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgZ2V0SXRlbUNsZWFuRW5kID0gKHRyYW5zYWN0aW9uLCBzdG9yZSwgaWQpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtBcnJheTxJdGVtPn1cbiAgICovXG4gIC8vIEB0cy1pZ25vcmVcbiAgY29uc3Qgc3RydWN0cyA9IHN0b3JlLmNsaWVudHMuZ2V0KGlkLmNsaWVudClcbiAgY29uc3QgaW5kZXggPSBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBpZC5jbG9jaylcbiAgY29uc3Qgc3RydWN0ID0gc3RydWN0c1tpbmRleF1cbiAgaWYgKGlkLmNsb2NrICE9PSBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoIC0gMSAmJiBzdHJ1Y3QuY29uc3RydWN0b3IgIT09IEdDKSB7XG4gICAgc3RydWN0cy5zcGxpY2UoaW5kZXggKyAxLCAwLCBzcGxpdEl0ZW0odHJhbnNhY3Rpb24sIHN0cnVjdCwgaWQuY2xvY2sgLSBzdHJ1Y3QuaWQuY2xvY2sgKyAxKSlcbiAgfVxuICByZXR1cm4gc3RydWN0XG59XG5cbi8qKlxuICogUmVwbGFjZSBgaXRlbWAgd2l0aCBgbmV3aXRlbWAgaW4gc3RvcmVcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0dDfEl0ZW19IHN0cnVjdFxuICogQHBhcmFtIHtHQ3xJdGVtfSBuZXdTdHJ1Y3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZXBsYWNlU3RydWN0ID0gKHN0b3JlLCBzdHJ1Y3QsIG5ld1N0cnVjdCkgPT4ge1xuICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KHN0cnVjdC5pZC5jbGllbnQpKVxuICBzdHJ1Y3RzW2ZpbmRJbmRleFNTKHN0cnVjdHMsIHN0cnVjdC5pZC5jbG9jayldID0gbmV3U3RydWN0XG59XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGEgcmFuZ2Ugb2Ygc3RydWN0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5PEl0ZW18R0M+fSBzdHJ1Y3RzXG4gKiBAcGFyYW0ge251bWJlcn0gY2xvY2tTdGFydCBJbmNsdXNpdmUgc3RhcnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oR0N8SXRlbSk6dm9pZH0gZlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZVN0cnVjdHMgPSAodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQsIGxlbiwgZikgPT4ge1xuICBpZiAobGVuID09PSAwKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgY29uc3QgY2xvY2tFbmQgPSBjbG9ja1N0YXJ0ICsgbGVuXG4gIGxldCBpbmRleCA9IGZpbmRJbmRleENsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHN0cnVjdHMsIGNsb2NrU3RhcnQpXG4gIGxldCBzdHJ1Y3RcbiAgZG8ge1xuICAgIHN0cnVjdCA9IHN0cnVjdHNbaW5kZXgrK11cbiAgICBpZiAoY2xvY2tFbmQgPCBzdHJ1Y3QuaWQuY2xvY2sgKyBzdHJ1Y3QubGVuZ3RoKSB7XG4gICAgICBmaW5kSW5kZXhDbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBzdHJ1Y3RzLCBjbG9ja0VuZClcbiAgICB9XG4gICAgZihzdHJ1Y3QpXG4gIH0gd2hpbGUgKGluZGV4IDwgc3RydWN0cy5sZW5ndGggJiYgc3RydWN0c1tpbmRleF0uaWQuY2xvY2sgPCBjbG9ja0VuZClcbn1cbiIsICJpbXBvcnQge1xuICBnZXRTdGF0ZSxcbiAgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uLFxuICB3cml0ZURlbGV0ZVNldCxcbiAgRGVsZXRlU2V0LFxuICBzb3J0QW5kTWVyZ2VEZWxldGVTZXQsXG4gIGdldFN0YXRlVmVjdG9yLFxuICBmaW5kSW5kZXhTUyxcbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyxcbiAgSXRlbSxcbiAgZ2VuZXJhdGVOZXdDbGllbnRJZCxcbiAgY3JlYXRlSUQsXG4gIGNsZWFudXBZVGV4dEFmdGVyVHJhbnNhY3Rpb24sXG4gIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBHQywgU3RydWN0U3RvcmUsIEFic3RyYWN0VHlwZSwgQWJzdHJhY3RTdHJ1Y3QsIFlFdmVudCwgRG9jIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCdcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0IHsgY2FsbEFsbCB9IGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5cbi8qKlxuICogQSB0cmFuc2FjdGlvbiBpcyBjcmVhdGVkIGZvciBldmVyeSBjaGFuZ2Ugb24gdGhlIFlqcyBtb2RlbC4gSXQgaXMgcG9zc2libGVcbiAqIHRvIGJ1bmRsZSBjaGFuZ2VzIG9uIHRoZSBZanMgbW9kZWwgaW4gYSBzaW5nbGUgdHJhbnNhY3Rpb24gdG9cbiAqIG1pbmltaXplIHRoZSBudW1iZXIgb24gbWVzc2FnZXMgc2VudCBhbmQgdGhlIG51bWJlciBvZiBvYnNlcnZlciBjYWxscy5cbiAqIElmIHBvc3NpYmxlIHRoZSB1c2VyIG9mIHRoaXMgbGlicmFyeSBzaG91bGQgYnVuZGxlIGFzIG1hbnkgY2hhbmdlcyBhc1xuICogcG9zc2libGUuIEhlcmUgaXMgYW4gZXhhbXBsZSB0byBpbGx1c3RyYXRlIHRoZSBhZHZhbnRhZ2VzIG9mIGJ1bmRsaW5nOlxuICpcbiAqIEBleGFtcGxlXG4gKiBjb25zdCB5ZG9jID0gbmV3IFkuRG9jKClcbiAqIGNvbnN0IG1hcCA9IHlkb2MuZ2V0TWFwKCdtYXAnKVxuICogLy8gTG9nIGNvbnRlbnQgd2hlbiBjaGFuZ2UgaXMgdHJpZ2dlcmVkXG4gKiBtYXAub2JzZXJ2ZSgoKSA9PiB7XG4gKiAgIGNvbnNvbGUubG9nKCdjaGFuZ2UgdHJpZ2dlcmVkJylcbiAqIH0pXG4gKiAvLyBFYWNoIGNoYW5nZSBvbiB0aGUgbWFwIHR5cGUgdHJpZ2dlcnMgYSBsb2cgbWVzc2FnZTpcbiAqIG1hcC5zZXQoJ2EnLCAwKSAvLyA9PiBcImNoYW5nZSB0cmlnZ2VyZWRcIlxuICogbWFwLnNldCgnYicsIDApIC8vID0+IFwiY2hhbmdlIHRyaWdnZXJlZFwiXG4gKiAvLyBXaGVuIHB1dCBpbiBhIHRyYW5zYWN0aW9uLCBpdCB3aWxsIHRyaWdnZXIgdGhlIGxvZyBhZnRlciB0aGUgdHJhbnNhY3Rpb246XG4gKiB5ZG9jLnRyYW5zYWN0KCgpID0+IHtcbiAqICAgbWFwLnNldCgnYScsIDEpXG4gKiAgIG1hcC5zZXQoJ2InLCAxKVxuICogfSkgLy8gPT4gXCJjaGFuZ2UgdHJpZ2dlcmVkXCJcbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0RvY30gZG9jXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICogQHBhcmFtIHtib29sZWFufSBsb2NhbFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgb3JpZ2luLCBsb2NhbCkge1xuICAgIC8qKlxuICAgICAqIFRoZSBZanMgaW5zdGFuY2UuXG4gICAgICogQHR5cGUge0RvY31cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIC8qKlxuICAgICAqIERlc2NyaWJlcyB0aGUgc2V0IG9mIGRlbGV0ZWQgaXRlbXMgYnkgaWRzXG4gICAgICogQHR5cGUge0RlbGV0ZVNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlbGV0ZVNldCA9IG5ldyBEZWxldGVTZXQoKVxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBzdGF0ZSBiZWZvcmUgdGhlIHRyYW5zYWN0aW9uIHN0YXJ0ZWQuXG4gICAgICogQHR5cGUge01hcDxOdW1iZXIsTnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmJlZm9yZVN0YXRlID0gZ2V0U3RhdGVWZWN0b3IoZG9jLnN0b3JlKVxuICAgIC8qKlxuICAgICAqIEhvbGRzIHRoZSBzdGF0ZSBhZnRlciB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHR5cGUge01hcDxOdW1iZXIsTnVtYmVyPn1cbiAgICAgKi9cbiAgICB0aGlzLmFmdGVyU3RhdGUgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBBbGwgdHlwZXMgdGhhdCB3ZXJlIGRpcmVjdGx5IG1vZGlmaWVkIChwcm9wZXJ0eSBhZGRlZCBvciBjaGlsZFxuICAgICAqIGluc2VydGVkL2RlbGV0ZWQpLiBOZXcgdHlwZXMgYXJlIG5vdCBpbmNsdWRlZCBpbiB0aGlzIFNldC5cbiAgICAgKiBNYXBzIGZyb20gdHlwZSB0byBwYXJlbnRTdWJzIChgaXRlbS5wYXJlbnRTdWIgPSBudWxsYCBmb3IgWUFycmF5KVxuICAgICAqIEB0eXBlIHtNYXA8QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+PixTZXQ8U3RyaW5nfG51bGw+Pn1cbiAgICAgKi9cbiAgICB0aGlzLmNoYW5nZWQgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBTdG9yZXMgdGhlIGV2ZW50cyBmb3IgdGhlIHR5cGVzIHRoYXQgb2JzZXJ2ZSBhbHNvIGNoaWxkIGVsZW1lbnRzLlxuICAgICAqIEl0IGlzIG1haW5seSB1c2VkIGJ5IGBvYnNlcnZlRGVlcGAuXG4gICAgICogQHR5cGUge01hcDxBYnN0cmFjdFR5cGU8WUV2ZW50PGFueT4+LEFycmF5PFlFdmVudDxhbnk+Pj59XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkUGFyZW50VHlwZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8QWJzdHJhY3RTdHJ1Y3Q+fVxuICAgICAqL1xuICAgIHRoaXMuX21lcmdlU3RydWN0cyA9IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLm9yaWdpbiA9IG9yaWdpblxuICAgIC8qKlxuICAgICAqIFN0b3JlcyBtZXRhIGluZm9ybWF0aW9uIG9uIHRoZSB0cmFuc2FjdGlvblxuICAgICAqIEB0eXBlIHtNYXA8YW55LGFueT59XG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGlzIGNoYW5nZSBvcmlnaW5hdGVzIGZyb20gdGhpcyBkb2MuXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5sb2NhbCA9IGxvY2FsXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc0FkZGVkID0gbmV3IFNldCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxEb2M+fVxuICAgICAqL1xuICAgIHRoaXMuc3ViZG9jc1JlbW92ZWQgPSBuZXcgU2V0KClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7U2V0PERvYz59XG4gICAgICovXG4gICAgdGhpcy5zdWJkb2NzTG9hZGVkID0gbmV3IFNldCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fbmVlZEZvcm1hdHRpbmdDbGVhbnVwID0gZmFsc2VcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBkYXRhIHdhcyB3cml0dGVuLlxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVcGRhdGVNZXNzYWdlRnJvbVRyYW5zYWN0aW9uID0gKGVuY29kZXIsIHRyYW5zYWN0aW9uKSA9PiB7XG4gIGlmICh0cmFuc2FjdGlvbi5kZWxldGVTZXQuY2xpZW50cy5zaXplID09PSAwICYmICFtYXAuYW55KHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUsIChjbG9jaywgY2xpZW50KSA9PiB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSAhPT0gY2xvY2spKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KHRyYW5zYWN0aW9uLmRlbGV0ZVNldClcbiAgd3JpdGVTdHJ1Y3RzRnJvbVRyYW5zYWN0aW9uKGVuY29kZXIsIHRyYW5zYWN0aW9uKVxuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQpXG4gIHJldHVybiB0cnVlXG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBuZXh0SUQgPSB0cmFuc2FjdGlvbiA9PiB7XG4gIGNvbnN0IHkgPSB0cmFuc2FjdGlvbi5kb2NcbiAgcmV0dXJuIGNyZWF0ZUlEKHkuY2xpZW50SUQsIGdldFN0YXRlKHkuc3RvcmUsIHkuY2xpZW50SUQpKVxufVxuXG4vKipcbiAqIElmIGB0eXBlLnBhcmVudGAgd2FzIGFkZGVkIGluIGN1cnJlbnQgdHJhbnNhY3Rpb24sIGB0eXBlYCB0ZWNobmljYWxseVxuICogZGlkIG5vdCBjaGFuZ2UsIGl0IHdhcyBqdXN0IGFkZGVkIGFuZCB3ZSBzaG91bGQgbm90IGZpcmUgZXZlbnRzIGZvciBgdHlwZWAuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPFlFdmVudDxhbnk+Pn0gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gcGFyZW50U3ViXG4gKi9cbmV4cG9ydCBjb25zdCBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24gPSAodHJhbnNhY3Rpb24sIHR5cGUsIHBhcmVudFN1YikgPT4ge1xuICBjb25zdCBpdGVtID0gdHlwZS5faXRlbVxuICBpZiAoaXRlbSA9PT0gbnVsbCB8fCAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApICYmICFpdGVtLmRlbGV0ZWQpKSB7XG4gICAgbWFwLnNldElmVW5kZWZpbmVkKHRyYW5zYWN0aW9uLmNoYW5nZWQsIHR5cGUsIHNldC5jcmVhdGUpLmFkZChwYXJlbnRTdWIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PEFic3RyYWN0U3RydWN0Pn0gc3RydWN0c1xuICogQHBhcmFtIHtudW1iZXJ9IHBvc1xuICogQHJldHVybiB7bnVtYmVyfSAjIG9mIG1lcmdlZCBzdHJ1Y3RzXG4gKi9cbmNvbnN0IHRyeVRvTWVyZ2VXaXRoTGVmdHMgPSAoc3RydWN0cywgcG9zKSA9PiB7XG4gIGxldCByaWdodCA9IHN0cnVjdHNbcG9zXVxuICBsZXQgbGVmdCA9IHN0cnVjdHNbcG9zIC0gMV1cbiAgbGV0IGkgPSBwb3NcbiAgZm9yICg7IGkgPiAwOyByaWdodCA9IGxlZnQsIGxlZnQgPSBzdHJ1Y3RzWy0taSAtIDFdKSB7XG4gICAgaWYgKGxlZnQuZGVsZXRlZCA9PT0gcmlnaHQuZGVsZXRlZCAmJiBsZWZ0LmNvbnN0cnVjdG9yID09PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgaWYgKGxlZnQubWVyZ2VXaXRoKHJpZ2h0KSkge1xuICAgICAgICBpZiAocmlnaHQgaW5zdGFuY2VvZiBJdGVtICYmIHJpZ2h0LnBhcmVudFN1YiAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHQucGFyZW50KS5fbWFwLmdldChyaWdodC5wYXJlbnRTdWIpID09PSByaWdodCkge1xuICAgICAgICAgIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChyaWdodC5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0LnBhcmVudFN1YiwgLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdCkpXG4gICAgICAgIH1cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG4gICAgYnJlYWtcbiAgfVxuICBjb25zdCBtZXJnZWQgPSBwb3MgLSBpXG4gIGlmIChtZXJnZWQpIHtcbiAgICAvLyByZW1vdmUgYWxsIG1lcmdlZCBzdHJ1Y3RzIGZyb20gdGhlIGFycmF5XG4gICAgc3RydWN0cy5zcGxpY2UocG9zICsgMSAtIG1lcmdlZCwgbWVyZ2VkKVxuICB9XG4gIHJldHVybiBtZXJnZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RlbGV0ZVNldH0gZHNcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKEl0ZW0pOmJvb2xlYW59IGdjRmlsdGVyXG4gKi9cbmNvbnN0IHRyeUdjRGVsZXRlU2V0ID0gKGRzLCBzdG9yZSwgZ2NGaWx0ZXIpID0+IHtcbiAgZm9yIChjb25zdCBbY2xpZW50LCBkZWxldGVJdGVtc10gb2YgZHMuY2xpZW50cy5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgZm9yIChsZXQgZGkgPSBkZWxldGVJdGVtcy5sZW5ndGggLSAxOyBkaSA+PSAwOyBkaS0tKSB7XG4gICAgICBjb25zdCBkZWxldGVJdGVtID0gZGVsZXRlSXRlbXNbZGldXG4gICAgICBjb25zdCBlbmREZWxldGVJdGVtQ2xvY2sgPSBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW5cbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IGZpbmRJbmRleFNTKHN0cnVjdHMsIGRlbGV0ZUl0ZW0uY2xvY2spLCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXTtcbiAgICAgICAgc2kgPCBzdHJ1Y3RzLmxlbmd0aCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPCBlbmREZWxldGVJdGVtQ2xvY2s7XG4gICAgICAgIHN0cnVjdCA9IHN0cnVjdHNbKytzaV1cbiAgICAgICkge1xuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBzdHJ1Y3RzW3NpXVxuICAgICAgICBpZiAoZGVsZXRlSXRlbS5jbG9jayArIGRlbGV0ZUl0ZW0ubGVuIDw9IHN0cnVjdC5pZC5jbG9jaykge1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0gJiYgc3RydWN0LmRlbGV0ZWQgJiYgIXN0cnVjdC5rZWVwICYmIGdjRmlsdGVyKHN0cnVjdCkpIHtcbiAgICAgICAgICBzdHJ1Y3QuZ2Moc3RvcmUsIGZhbHNlKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICovXG5jb25zdCB0cnlNZXJnZURlbGV0ZVNldCA9IChkcywgc3RvcmUpID0+IHtcbiAgLy8gdHJ5IHRvIG1lcmdlIGRlbGV0ZWQgLyBnYydkIGl0ZW1zXG4gIC8vIG1lcmdlIGZyb20gcmlnaHQgdG8gbGVmdCBmb3IgYmV0dGVyIGVmZmljaWVuY3kgYW5kIHNvIHdlIGRvbid0IG1pc3MgYW55IG1lcmdlIHRhcmdldHNcbiAgZHMuY2xpZW50cy5mb3JFYWNoKChkZWxldGVJdGVtcywgY2xpZW50KSA9PiB7XG4gICAgY29uc3Qgc3RydWN0cyA9IC8qKiBAdHlwZSB7QXJyYXk8R0N8SXRlbT59ICovIChzdG9yZS5jbGllbnRzLmdldChjbGllbnQpKVxuICAgIGZvciAobGV0IGRpID0gZGVsZXRlSXRlbXMubGVuZ3RoIC0gMTsgZGkgPj0gMDsgZGktLSkge1xuICAgICAgY29uc3QgZGVsZXRlSXRlbSA9IGRlbGV0ZUl0ZW1zW2RpXVxuICAgICAgLy8gc3RhcnQgd2l0aCBtZXJnaW5nIHRoZSBpdGVtIG5leHQgdG8gdGhlIGxhc3QgZGVsZXRlZCBpdGVtXG4gICAgICBjb25zdCBtb3N0UmlnaHRJbmRleFRvQ2hlY2sgPSBtYXRoLm1pbihzdHJ1Y3RzLmxlbmd0aCAtIDEsIDEgKyBmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBkZWxldGVJdGVtLmNsb2NrICsgZGVsZXRlSXRlbS5sZW4gLSAxKSlcbiAgICAgIGZvciAoXG4gICAgICAgIGxldCBzaSA9IG1vc3RSaWdodEluZGV4VG9DaGVjaywgc3RydWN0ID0gc3RydWN0c1tzaV07XG4gICAgICAgIHNpID4gMCAmJiBzdHJ1Y3QuaWQuY2xvY2sgPj0gZGVsZXRlSXRlbS5jbG9jaztcbiAgICAgICAgc3RydWN0ID0gc3RydWN0c1tzaV1cbiAgICAgICkge1xuICAgICAgICBzaSAtPSAxICsgdHJ5VG9NZXJnZVdpdGhMZWZ0cyhzdHJ1Y3RzLCBzaSlcbiAgICAgIH1cbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtEZWxldGVTZXR9IGRzXG4gKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtKTpib29sZWFufSBnY0ZpbHRlclxuICovXG5leHBvcnQgY29uc3QgdHJ5R2MgPSAoZHMsIHN0b3JlLCBnY0ZpbHRlcikgPT4ge1xuICB0cnlHY0RlbGV0ZVNldChkcywgc3RvcmUsIGdjRmlsdGVyKVxuICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxUcmFuc2FjdGlvbj59IHRyYW5zYWN0aW9uQ2xlYW51cHNcbiAqIEBwYXJhbSB7bnVtYmVyfSBpXG4gKi9cbmNvbnN0IGNsZWFudXBUcmFuc2FjdGlvbnMgPSAodHJhbnNhY3Rpb25DbGVhbnVwcywgaSkgPT4ge1xuICBpZiAoaSA8IHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbkNsZWFudXBzW2ldXG4gICAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gICAgY29uc3Qgc3RvcmUgPSBkb2Muc3RvcmVcbiAgICBjb25zdCBkcyA9IHRyYW5zYWN0aW9uLmRlbGV0ZVNldFxuICAgIGNvbnN0IG1lcmdlU3RydWN0cyA9IHRyYW5zYWN0aW9uLl9tZXJnZVN0cnVjdHNcbiAgICB0cnkge1xuICAgICAgc29ydEFuZE1lcmdlRGVsZXRlU2V0KGRzKVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZSA9IGdldFN0YXRlVmVjdG9yKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSlcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVPYnNlcnZlckNhbGxzJywgW3RyYW5zYWN0aW9uLCBkb2NdKVxuICAgICAgLyoqXG4gICAgICAgKiBBbiBhcnJheSBvZiBldmVudCBjYWxsYmFja3MuXG4gICAgICAgKlxuICAgICAgICogRWFjaCBjYWxsYmFjayBpcyBjYWxsZWQgZXZlbiBpZiB0aGUgb3RoZXIgb25lcyB0aHJvdyBlcnJvcnMuXG4gICAgICAgKlxuICAgICAgICogQHR5cGUge0FycmF5PGZ1bmN0aW9uKCk6dm9pZD59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZzID0gW11cbiAgICAgIC8vIG9ic2VydmUgZXZlbnRzIG9uIGNoYW5nZWQgdHlwZXNcbiAgICAgIHRyYW5zYWN0aW9uLmNoYW5nZWQuZm9yRWFjaCgoc3VicywgaXRlbXR5cGUpID0+XG4gICAgICAgIGZzLnB1c2goKCkgPT4ge1xuICAgICAgICAgIGlmIChpdGVtdHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhaXRlbXR5cGUuX2l0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgaXRlbXR5cGUuX2NhbGxPYnNlcnZlcih0cmFuc2FjdGlvbiwgc3VicylcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgICBmcy5wdXNoKCgpID0+IHtcbiAgICAgICAgLy8gZGVlcCBvYnNlcnZlIGV2ZW50c1xuICAgICAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuZm9yRWFjaCgoZXZlbnRzLCB0eXBlKSA9PiB7XG4gICAgICAgICAgLy8gV2UgbmVlZCB0byB0aGluayBhYm91dCB0aGUgcG9zc2liaWxpdHkgdGhhdCB0aGUgdXNlciB0cmFuc2Zvcm1zIHRoZVxuICAgICAgICAgIC8vIFkuRG9jIGluIHRoZSBldmVudC5cbiAgICAgICAgICBpZiAodHlwZS5fZEVILmwubGVuZ3RoID4gMCAmJiAodHlwZS5faXRlbSA9PT0gbnVsbCB8fCAhdHlwZS5faXRlbS5kZWxldGVkKSkge1xuICAgICAgICAgICAgZXZlbnRzID0gZXZlbnRzXG4gICAgICAgICAgICAgIC5maWx0ZXIoZXZlbnQgPT5cbiAgICAgICAgICAgICAgICBldmVudC50YXJnZXQuX2l0ZW0gPT09IG51bGwgfHwgIWV2ZW50LnRhcmdldC5faXRlbS5kZWxldGVkXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCA9IHR5cGVcbiAgICAgICAgICAgICAgICAvLyBwYXRoIGlzIHJlbGF0aXZlIHRvIHRoZSBjdXJyZW50IHRhcmdldFxuICAgICAgICAgICAgICAgIGV2ZW50Ll9wYXRoID0gbnVsbFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgLy8gc29ydCBldmVudHMgYnkgcGF0aCBsZW5ndGggc28gdGhhdCB0b3AtbGV2ZWwgZXZlbnRzIGFyZSBmaXJlZCBmaXJzdC5cbiAgICAgICAgICAgIGV2ZW50c1xuICAgICAgICAgICAgICAuc29ydCgoZXZlbnQxLCBldmVudDIpID0+IGV2ZW50MS5wYXRoLmxlbmd0aCAtIGV2ZW50Mi5wYXRoLmxlbmd0aClcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIGV2ZW50cy5sZW5ndGhcbiAgICAgICAgICAgIC8vIGJlY2F1c2Ugd2Uga25vdyBpdCBoYXMgYXQgbGVhc3Qgb25lIGVsZW1lbnRcbiAgICAgICAgICAgIGNhbGxFdmVudEhhbmRsZXJMaXN0ZW5lcnModHlwZS5fZEVILCBldmVudHMsIHRyYW5zYWN0aW9uKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgICBmcy5wdXNoKCgpID0+IGRvYy5lbWl0KCdhZnRlclRyYW5zYWN0aW9uJywgW3RyYW5zYWN0aW9uLCBkb2NdKSlcbiAgICAgIGNhbGxBbGwoZnMsIFtdKVxuICAgICAgaWYgKHRyYW5zYWN0aW9uLl9uZWVkRm9ybWF0dGluZ0NsZWFudXApIHtcbiAgICAgICAgY2xlYW51cFlUZXh0QWZ0ZXJUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgLy8gUmVwbGFjZSBkZWxldGVkIGl0ZW1zIHdpdGggSXRlbURlbGV0ZWQgLyBHQy5cbiAgICAgIC8vIFRoaXMgaXMgd2hlcmUgY29udGVudCBpcyBhY3R1YWxseSByZW1vdmUgZnJvbSB0aGUgWWpzIERvYy5cbiAgICAgIGlmIChkb2MuZ2MpIHtcbiAgICAgICAgdHJ5R2NEZWxldGVTZXQoZHMsIHN0b3JlLCBkb2MuZ2NGaWx0ZXIpXG4gICAgICB9XG4gICAgICB0cnlNZXJnZURlbGV0ZVNldChkcywgc3RvcmUpXG5cbiAgICAgIC8vIG9uIGFsbCBhZmZlY3RlZCBzdG9yZS5jbGllbnRzIHByb3BzLCB0cnkgdG8gbWVyZ2VcbiAgICAgIHRyYW5zYWN0aW9uLmFmdGVyU3RhdGUuZm9yRWFjaCgoY2xvY2ssIGNsaWVudCkgPT4ge1xuICAgICAgICBjb25zdCBiZWZvcmVDbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDBcbiAgICAgICAgaWYgKGJlZm9yZUNsb2NrICE9PSBjbG9jaykge1xuICAgICAgICAgIGNvbnN0IHN0cnVjdHMgPSAvKiogQHR5cGUge0FycmF5PEdDfEl0ZW0+fSAqLyAoc3RvcmUuY2xpZW50cy5nZXQoY2xpZW50KSlcbiAgICAgICAgICAvLyB3ZSBpdGVyYXRlIGZyb20gcmlnaHQgdG8gbGVmdCBzbyB3ZSBjYW4gc2FmZWx5IHJlbW92ZSBlbnRyaWVzXG4gICAgICAgICAgY29uc3QgZmlyc3RDaGFuZ2VQb3MgPSBtYXRoLm1heChmaW5kSW5kZXhTUyhzdHJ1Y3RzLCBiZWZvcmVDbG9jayksIDEpXG4gICAgICAgICAgZm9yIChsZXQgaSA9IHN0cnVjdHMubGVuZ3RoIC0gMTsgaSA+PSBmaXJzdENoYW5nZVBvczspIHtcbiAgICAgICAgICAgIGkgLT0gMSArIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgaSlcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAvLyB0cnkgdG8gbWVyZ2UgbWVyZ2VTdHJ1Y3RzXG4gICAgICAvLyBAdG9kbzogaXQgbWFrZXMgbW9yZSBzZW5zZSB0byB0cmFuc2Zvcm0gbWVyZ2VTdHJ1Y3RzIHRvIGEgRFMsIHNvcnQgaXQsIGFuZCBtZXJnZSBmcm9tIHJpZ2h0IHRvIGxlZnRcbiAgICAgIC8vICAgICAgICBidXQgYXQgdGhlIG1vbWVudCBEUyBkb2VzIG5vdCBoYW5kbGUgZHVwbGljYXRlc1xuICAgICAgZm9yIChsZXQgaSA9IG1lcmdlU3RydWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IG1lcmdlU3RydWN0c1tpXS5pZFxuICAgICAgICBjb25zdCBzdHJ1Y3RzID0gLyoqIEB0eXBlIHtBcnJheTxHQ3xJdGVtPn0gKi8gKHN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpXG4gICAgICAgIGNvbnN0IHJlcGxhY2VkU3RydWN0UG9zID0gZmluZEluZGV4U1Moc3RydWN0cywgY2xvY2spXG4gICAgICAgIGlmIChyZXBsYWNlZFN0cnVjdFBvcyArIDEgPCBzdHJ1Y3RzLmxlbmd0aCkge1xuICAgICAgICAgIGlmICh0cnlUb01lcmdlV2l0aExlZnRzKHN0cnVjdHMsIHJlcGxhY2VkU3RydWN0UG9zICsgMSkgPiAxKSB7XG4gICAgICAgICAgICBjb250aW51ZSAvLyBubyBuZWVkIHRvIHBlcmZvcm0gbmV4dCBjaGVjaywgYm90aCBhcmUgYWxyZWFkeSBtZXJnZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcGxhY2VkU3RydWN0UG9zID4gMCkge1xuICAgICAgICAgIHRyeVRvTWVyZ2VXaXRoTGVmdHMoc3RydWN0cywgcmVwbGFjZWRTdHJ1Y3RQb3MpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHJhbnNhY3Rpb24ubG9jYWwgJiYgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5nZXQoZG9jLmNsaWVudElEKSAhPT0gdHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGRvYy5jbGllbnRJRCkpIHtcbiAgICAgICAgbG9nZ2luZy5wcmludChsb2dnaW5nLk9SQU5HRSwgbG9nZ2luZy5CT0xELCAnW3lqc10gJywgbG9nZ2luZy5VTkJPTEQsIGxvZ2dpbmcuUkVELCAnQ2hhbmdlZCB0aGUgY2xpZW50LWlkIGJlY2F1c2UgYW5vdGhlciBjbGllbnQgc2VlbXMgdG8gYmUgdXNpbmcgaXQuJylcbiAgICAgICAgZG9jLmNsaWVudElEID0gZ2VuZXJhdGVOZXdDbGllbnRJZCgpXG4gICAgICB9XG4gICAgICAvLyBAdG9kbyBNZXJnZSBhbGwgdGhlIHRyYW5zYWN0aW9ucyBpbnRvIG9uZSBhbmQgcHJvdmlkZSBzZW5kIHRoZSBkYXRhIGFzIGEgc2luZ2xlIHVwZGF0ZSBtZXNzYWdlXG4gICAgICBkb2MuZW1pdCgnYWZ0ZXJUcmFuc2FjdGlvbkNsZWFudXAnLCBbdHJhbnNhY3Rpb24sIGRvY10pXG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGUnKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFVwZGF0ZUVuY29kZXJWMSgpXG4gICAgICAgIGNvbnN0IGhhc0NvbnRlbnQgPSB3cml0ZVVwZGF0ZU1lc3NhZ2VGcm9tVHJhbnNhY3Rpb24oZW5jb2RlciwgdHJhbnNhY3Rpb24pXG4gICAgICAgIGlmIChoYXNDb250ZW50KSB7XG4gICAgICAgICAgZG9jLmVtaXQoJ3VwZGF0ZScsIFtlbmNvZGVyLnRvVWludDhBcnJheSgpLCB0cmFuc2FjdGlvbi5vcmlnaW4sIGRvYywgdHJhbnNhY3Rpb25dKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZG9jLl9vYnNlcnZlcnMuaGFzKCd1cGRhdGVWMicpKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBuZXcgVXBkYXRlRW5jb2RlclYyKClcbiAgICAgICAgY29uc3QgaGFzQ29udGVudCA9IHdyaXRlVXBkYXRlTWVzc2FnZUZyb21UcmFuc2FjdGlvbihlbmNvZGVyLCB0cmFuc2FjdGlvbilcbiAgICAgICAgaWYgKGhhc0NvbnRlbnQpIHtcbiAgICAgICAgICBkb2MuZW1pdCgndXBkYXRlVjInLCBbZW5jb2Rlci50b1VpbnQ4QXJyYXkoKSwgdHJhbnNhY3Rpb24ub3JpZ2luLCBkb2MsIHRyYW5zYWN0aW9uXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgeyBzdWJkb2NzQWRkZWQsIHN1YmRvY3NMb2FkZWQsIHN1YmRvY3NSZW1vdmVkIH0gPSB0cmFuc2FjdGlvblxuICAgICAgaWYgKHN1YmRvY3NBZGRlZC5zaXplID4gMCB8fCBzdWJkb2NzUmVtb3ZlZC5zaXplID4gMCB8fCBzdWJkb2NzTG9hZGVkLnNpemUgPiAwKSB7XG4gICAgICAgIHN1YmRvY3NBZGRlZC5mb3JFYWNoKHN1YmRvYyA9PiB7XG4gICAgICAgICAgc3ViZG9jLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgICAgICAgaWYgKHN1YmRvYy5jb2xsZWN0aW9uaWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3ViZG9jLmNvbGxlY3Rpb25pZCA9IGRvYy5jb2xsZWN0aW9uaWRcbiAgICAgICAgICB9XG4gICAgICAgICAgZG9jLnN1YmRvY3MuYWRkKHN1YmRvYylcbiAgICAgICAgfSlcbiAgICAgICAgc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gZG9jLnN1YmRvY3MuZGVsZXRlKHN1YmRvYykpXG4gICAgICAgIGRvYy5lbWl0KCdzdWJkb2NzJywgW3sgbG9hZGVkOiBzdWJkb2NzTG9hZGVkLCBhZGRlZDogc3ViZG9jc0FkZGVkLCByZW1vdmVkOiBzdWJkb2NzUmVtb3ZlZCB9LCBkb2MsIHRyYW5zYWN0aW9uXSlcbiAgICAgICAgc3ViZG9jc1JlbW92ZWQuZm9yRWFjaChzdWJkb2MgPT4gc3ViZG9jLmRlc3Ryb3koKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoIDw9IGkgKyAxKSB7XG4gICAgICAgIGRvYy5fdHJhbnNhY3Rpb25DbGVhbnVwcyA9IFtdXG4gICAgICAgIGRvYy5lbWl0KCdhZnRlckFsbFRyYW5zYWN0aW9ucycsIFtkb2MsIHRyYW5zYWN0aW9uQ2xlYW51cHNdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xlYW51cFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbkNsZWFudXBzLCBpICsgMSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGB5LnRyYW5zYWN0KCgpPT57Li59KWBcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtEb2N9IGRvY1xuICogQHBhcmFtIHtmdW5jdGlvbihUcmFuc2FjdGlvbik6VH0gZlxuICogQHBhcmFtIHthbnl9IFtvcmlnaW49dHJ1ZV1cbiAqIEByZXR1cm4ge1R9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2FjdCA9IChkb2MsIGYsIG9yaWdpbiA9IG51bGwsIGxvY2FsID0gdHJ1ZSkgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbkNsZWFudXBzID0gZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzXG4gIGxldCBpbml0aWFsQ2FsbCA9IGZhbHNlXG4gIC8qKlxuICAgKiBAdHlwZSB7YW55fVxuICAgKi9cbiAgbGV0IHJlc3VsdCA9IG51bGxcbiAgaWYgKGRvYy5fdHJhbnNhY3Rpb24gPT09IG51bGwpIHtcbiAgICBpbml0aWFsQ2FsbCA9IHRydWVcbiAgICBkb2MuX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKGRvYywgb3JpZ2luLCBsb2NhbClcbiAgICB0cmFuc2FjdGlvbkNsZWFudXBzLnB1c2goZG9jLl90cmFuc2FjdGlvbilcbiAgICBpZiAodHJhbnNhY3Rpb25DbGVhbnVwcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGRvYy5lbWl0KCdiZWZvcmVBbGxUcmFuc2FjdGlvbnMnLCBbZG9jXSlcbiAgICB9XG4gICAgZG9jLmVtaXQoJ2JlZm9yZVRyYW5zYWN0aW9uJywgW2RvYy5fdHJhbnNhY3Rpb24sIGRvY10pXG4gIH1cbiAgdHJ5IHtcbiAgICByZXN1bHQgPSBmKGRvYy5fdHJhbnNhY3Rpb24pXG4gIH0gZmluYWxseSB7XG4gICAgaWYgKGluaXRpYWxDYWxsKSB7XG4gICAgICBjb25zdCBmaW5pc2hDbGVhbnVwID0gZG9jLl90cmFuc2FjdGlvbiA9PT0gdHJhbnNhY3Rpb25DbGVhbnVwc1swXVxuICAgICAgZG9jLl90cmFuc2FjdGlvbiA9IG51bGxcbiAgICAgIGlmIChmaW5pc2hDbGVhbnVwKSB7XG4gICAgICAgIC8vIFRoZSBmaXJzdCB0cmFuc2FjdGlvbiBlbmRlZCwgbm93IHByb2Nlc3Mgb2JzZXJ2ZXIgY2FsbHMuXG4gICAgICAgIC8vIE9ic2VydmVyIGNhbGwgbWF5IGNyZWF0ZSBuZXcgdHJhbnNhY3Rpb25zIGZvciB3aGljaCB3ZSBuZWVkIHRvIGNhbGwgdGhlIG9ic2VydmVycyBhbmQgZG8gY2xlYW51cC5cbiAgICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBuZXN0IHRoZXNlIGNhbGxzLCBzbyB3ZSBleGVjdXRlIHRoZXNlIGNhbGxzIG9uZSBhZnRlclxuICAgICAgICAvLyBhbm90aGVyLlxuICAgICAgICAvLyBBbHNvIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXQgYWxsIGNsZWFudXBzIGFyZSBjYWxsZWQsIGV2ZW4gaWYgdGhlXG4gICAgICAgIC8vIG9ic2VydmVzIHRocm93IGVycm9ycy5cbiAgICAgICAgLy8gVGhpcyBmaWxlIGlzIGZ1bGwgb2YgaGFja3kgdHJ5IHt9IGZpbmFsbHkge30gYmxvY2tzIHRvIGVuc3VyZSB0aGF0IGFuXG4gICAgICAgIC8vIGV2ZW50IGNhbiB0aHJvdyBlcnJvcnMgYW5kIGFsc28gdGhhdCB0aGUgY2xlYW51cCBpcyBjYWxsZWQuXG4gICAgICAgIGNsZWFudXBUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25DbGVhbnVwcywgMClcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuIiwgImltcG9ydCB7XG4gIG1lcmdlRGVsZXRlU2V0cyxcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLFxuICBrZWVwSXRlbSxcbiAgdHJhbnNhY3QsXG4gIGNyZWF0ZUlELFxuICByZWRvSXRlbSxcbiAgaXNQYXJlbnRPZixcbiAgZm9sbG93UmVkb25lLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgaXNEZWxldGVkLFxuICBhZGRUb0RlbGV0ZVNldCxcbiAgWUV2ZW50LCBUcmFuc2FjdGlvbiwgRG9jLCBJdGVtLCBHQywgRGVsZXRlU2V0LCBBYnN0cmFjdFR5cGUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lJ1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSAnbGliMC9sb2dnaW5nJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZVYyIH0gZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuXG5leHBvcnQgY2xhc3MgU3RhY2tJdGVtIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RGVsZXRlU2V0fSBkZWxldGlvbnNcbiAgICogQHBhcmFtIHtEZWxldGVTZXR9IGluc2VydGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkZWxldGlvbnMsIGluc2VydGlvbnMpIHtcbiAgICB0aGlzLmluc2VydGlvbnMgPSBpbnNlcnRpb25zXG4gICAgdGhpcy5kZWxldGlvbnMgPSBkZWxldGlvbnNcbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyB0byBzYXZlIGFuZCByZXN0b3JlIG1ldGFkYXRhIGxpa2Ugc2VsZWN0aW9uIHJhbmdlXG4gICAgICovXG4gICAgdGhpcy5tZXRhID0gbmV3IE1hcCgpXG4gIH1cbn1cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJcbiAqIEBwYXJhbSB7VW5kb01hbmFnZXJ9IHVtXG4gKiBAcGFyYW0ge1N0YWNrSXRlbX0gc3RhY2tJdGVtXG4gKi9cbmNvbnN0IGNsZWFyVW5kb01hbmFnZXJTdGFja0l0ZW0gPSAodHIsIHVtLCBzdGFja0l0ZW0pID0+IHtcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyLCBzdGFja0l0ZW0uZGVsZXRpb25zLCBpdGVtID0+IHtcbiAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0gJiYgdW0uc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgaXRlbSkpKSB7XG4gICAgICBrZWVwSXRlbShpdGVtLCBmYWxzZSlcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtVbmRvTWFuYWdlcn0gdW5kb01hbmFnZXJcbiAqIEBwYXJhbSB7QXJyYXk8U3RhY2tJdGVtPn0gc3RhY2tcbiAqIEBwYXJhbSB7J3VuZG8nfCdyZWRvJ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtTdGFja0l0ZW0/fVxuICovXG5jb25zdCBwb3BTdGFja0l0ZW0gPSAodW5kb01hbmFnZXIsIHN0YWNrLCBldmVudFR5cGUpID0+IHtcbiAgLyoqXG4gICAqIEtlZXAgYSByZWZlcmVuY2UgdG8gdGhlIHRyYW5zYWN0aW9uIHNvIHdlIGNhbiBmaXJlIHRoZSBldmVudCB3aXRoIHRoZSBjaGFuZ2VkUGFyZW50VHlwZXNcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBfdHIgPSBudWxsXG4gIGNvbnN0IGRvYyA9IHVuZG9NYW5hZ2VyLmRvY1xuICBjb25zdCBzY29wZSA9IHVuZG9NYW5hZ2VyLnNjb3BlXG4gIHRyYW5zYWN0KGRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwICYmIHVuZG9NYW5hZ2VyLmN1cnJTdGFja0l0ZW0gPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gICAgICBjb25zdCBzdGFja0l0ZW0gPSAvKiogQHR5cGUge1N0YWNrSXRlbX0gKi8gKHN0YWNrLnBvcCgpKVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBpdGVtc1RvUmVkbyA9IG5ldyBTZXQoKVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8SXRlbT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGl0ZW1zVG9EZWxldGUgPSBbXVxuICAgICAgbGV0IHBlcmZvcm1lZENoYW5nZSA9IGZhbHNlXG4gICAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHN0YWNrSXRlbS5pbnNlcnRpb25zLCBzdHJ1Y3QgPT4ge1xuICAgICAgICBpZiAoc3RydWN0IGluc3RhbmNlb2YgSXRlbSkge1xuICAgICAgICAgIGlmIChzdHJ1Y3QucmVkb25lICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgeyBpdGVtLCBkaWZmIH0gPSBmb2xsb3dSZWRvbmUoc3RvcmUsIHN0cnVjdC5pZClcbiAgICAgICAgICAgIGlmIChkaWZmID4gMCkge1xuICAgICAgICAgICAgICBpdGVtID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGl0ZW0uaWQuY2xpZW50LCBpdGVtLmlkLmNsb2NrICsgZGlmZikpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJ1Y3QgPSBpdGVtXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghc3RydWN0LmRlbGV0ZWQgJiYgc2NvcGUuc29tZSh0eXBlID0+IGlzUGFyZW50T2YodHlwZSwgLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RydWN0KSkpKSB7XG4gICAgICAgICAgICBpdGVtc1RvRGVsZXRlLnB1c2goc3RydWN0KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGl0ZXJhdGVEZWxldGVkU3RydWN0cyh0cmFuc2FjdGlvbiwgc3RhY2tJdGVtLmRlbGV0aW9ucywgc3RydWN0ID0+IHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHN0cnVjdCBpbnN0YW5jZW9mIEl0ZW0gJiZcbiAgICAgICAgICBzY29wZS5zb21lKHR5cGUgPT4gaXNQYXJlbnRPZih0eXBlLCBzdHJ1Y3QpKSAmJlxuICAgICAgICAgIC8vIE5ldmVyIHJlZG8gc3RydWN0cyBpbiBzdGFja0l0ZW0uaW5zZXJ0aW9ucyBiZWNhdXNlIHRoZXkgd2VyZSBjcmVhdGVkIGFuZCBkZWxldGVkIGluIHRoZSBzYW1lIGNhcHR1cmUgaW50ZXJ2YWwuXG4gICAgICAgICAgIWlzRGVsZXRlZChzdGFja0l0ZW0uaW5zZXJ0aW9ucywgc3RydWN0LmlkKVxuICAgICAgICApIHtcbiAgICAgICAgICBpdGVtc1RvUmVkby5hZGQoc3RydWN0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgaXRlbXNUb1JlZG8uZm9yRWFjaChzdHJ1Y3QgPT4ge1xuICAgICAgICBwZXJmb3JtZWRDaGFuZ2UgPSByZWRvSXRlbSh0cmFuc2FjdGlvbiwgc3RydWN0LCBpdGVtc1RvUmVkbywgc3RhY2tJdGVtLmluc2VydGlvbnMsIHVuZG9NYW5hZ2VyLmlnbm9yZVJlbW90ZU1hcENoYW5nZXMsIHVuZG9NYW5hZ2VyKSAhPT0gbnVsbCB8fCBwZXJmb3JtZWRDaGFuZ2VcbiAgICAgIH0pXG4gICAgICAvLyBXZSB3YW50IHRvIGRlbGV0ZSBpbiByZXZlcnNlIG9yZGVyIHNvIHRoYXQgY2hpbGRyZW4gYXJlIGRlbGV0ZWQgYmVmb3JlXG4gICAgICAvLyBwYXJlbnRzLCBzbyB3ZSBoYXZlIG1vcmUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIHdoZW4gaXRlbXMgYXJlIGZpbHRlcmVkLlxuICAgICAgZm9yIChsZXQgaSA9IGl0ZW1zVG9EZWxldGUubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGl0ZW1zVG9EZWxldGVbaV1cbiAgICAgICAgaWYgKHVuZG9NYW5hZ2VyLmRlbGV0ZUZpbHRlcihpdGVtKSkge1xuICAgICAgICAgIGl0ZW0uZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICAgIHBlcmZvcm1lZENoYW5nZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdW5kb01hbmFnZXIuY3VyclN0YWNrSXRlbSA9IHBlcmZvcm1lZENoYW5nZSA/IHN0YWNrSXRlbSA6IG51bGxcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24uY2hhbmdlZC5mb3JFYWNoKChzdWJQcm9wcywgdHlwZSkgPT4ge1xuICAgICAgLy8gZGVzdHJveSBzZWFyY2ggbWFya2VyIGlmIG5lY2Vzc2FyeVxuICAgICAgaWYgKHN1YlByb3BzLmhhcyhudWxsKSAmJiB0eXBlLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgICAgdHlwZS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9IDBcbiAgICAgIH1cbiAgICB9KVxuICAgIF90ciA9IHRyYW5zYWN0aW9uXG4gIH0sIHVuZG9NYW5hZ2VyKVxuICBjb25zdCByZXMgPSB1bmRvTWFuYWdlci5jdXJyU3RhY2tJdGVtXG4gIGlmIChyZXMgIT0gbnVsbCkge1xuICAgIGNvbnN0IGNoYW5nZWRQYXJlbnRUeXBlcyA9IF90ci5jaGFuZ2VkUGFyZW50VHlwZXNcbiAgICB1bmRvTWFuYWdlci5lbWl0KCdzdGFjay1pdGVtLXBvcHBlZCcsIFt7IHN0YWNrSXRlbTogcmVzLCB0eXBlOiBldmVudFR5cGUsIGNoYW5nZWRQYXJlbnRUeXBlcywgb3JpZ2luOiB1bmRvTWFuYWdlciB9LCB1bmRvTWFuYWdlcl0pXG4gICAgdW5kb01hbmFnZXIuY3VyclN0YWNrSXRlbSA9IG51bGxcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gVW5kb01hbmFnZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge251bWJlcn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5jYXB0dXJlVGltZW91dD01MDBdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKFRyYW5zYWN0aW9uKTpib29sZWFufSBbVW5kb01hbmFnZXJPcHRpb25zLmNhcHR1cmVUcmFuc2FjdGlvbl0gRG8gbm90IGNhcHR1cmUgY2hhbmdlcyBvZiBhIFRyYW5zYWN0aW9uIGlmIHJlc3VsdCBmYWxzZS5cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oSXRlbSk6Ym9vbGVhbn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy5kZWxldGVGaWx0ZXI9KCk9PnRydWVdIFNvbWV0aW1lc1xuICogaXQgaXMgbmVjZXNzYXJ5IHRvIGZpbHRlciB3aGF0IGFuIFVuZG8vUmVkbyBvcGVyYXRpb24gY2FuIGRlbGV0ZS4gSWYgdGhpc1xuICogZmlsdGVyIHJldHVybnMgZmFsc2UsIHRoZSB0eXBlL2l0ZW0gd29uJ3QgYmUgZGVsZXRlZCBldmVuIGl0IGlzIGluIHRoZVxuICogdW5kby9yZWRvIHNjb3BlLlxuICogQHByb3BlcnR5IHtTZXQ8YW55Pn0gW1VuZG9NYW5hZ2VyT3B0aW9ucy50cmFja2VkT3JpZ2lucz1uZXcgU2V0KFtudWxsXSldXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzXSBFeHBlcmltZW50YWwuIEJ5IGRlZmF1bHQsIHRoZSBVbmRvTWFuYWdlciB3aWxsIG5ldmVyIG92ZXJ3cml0ZSByZW1vdGUgY2hhbmdlcy4gRW5hYmxlIHRoaXMgcHJvcGVydHkgdG8gZW5hYmxlIG92ZXJ3cml0aW5nIHJlbW90ZSBjaGFuZ2VzIG9uIGtleS12YWx1ZSBjaGFuZ2VzIChZLk1hcCwgcHJvcGVydGllcyBvbiBZLlhtbCwgZXRjLi4pLlxuICogQHByb3BlcnR5IHtEb2N9IFtkb2NdIFRoZSBkb2N1bWVudCB0aGF0IHRoaXMgVW5kb01hbmFnZXIgb3BlcmF0ZXMgb24uIE9ubHkgbmVlZGVkIGlmIHR5cGVTY29wZSBpcyBlbXB0eS5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFN0YWNrSXRlbUV2ZW50XG4gKiBAcHJvcGVydHkge1N0YWNrSXRlbX0gU3RhY2tJdGVtRXZlbnQuc3RhY2tJdGVtXG4gKiBAcHJvcGVydHkge2FueX0gU3RhY2tJdGVtRXZlbnQub3JpZ2luXG4gKiBAcHJvcGVydHkgeyd1bmRvJ3wncmVkbyd9IFN0YWNrSXRlbUV2ZW50LnR5cGVcbiAqIEBwcm9wZXJ0eSB7TWFwPEFic3RyYWN0VHlwZTxZRXZlbnQ8YW55Pj4sQXJyYXk8WUV2ZW50PGFueT4+Pn0gU3RhY2tJdGVtRXZlbnQuY2hhbmdlZFBhcmVudFR5cGVzXG4gKi9cblxuLyoqXG4gKiBGaXJlcyAnc3RhY2staXRlbS1hZGRlZCcgZXZlbnQgd2hlbiBhIHN0YWNrIGl0ZW0gd2FzIGFkZGVkIHRvIGVpdGhlciB0aGUgdW5kby0gb3JcbiAqIHRoZSByZWRvLXN0YWNrLiBZb3UgbWF5IHN0b3JlIGFkZGl0aW9uYWwgc3RhY2sgaW5mb3JtYXRpb24gdmlhIHRoZVxuICogbWV0YWRhdGEgcHJvcGVydHkgb24gYGV2ZW50LnN0YWNrSXRlbS5tZXRhYCAoaXQgaXMgYSBgTWFwYCBvZiBtZXRhZGF0YSBwcm9wZXJ0aWVzKS5cbiAqIEZpcmVzICdzdGFjay1pdGVtLXBvcHBlZCcgZXZlbnQgd2hlbiBhIHN0YWNrIGl0ZW0gd2FzIHBvcHBlZCBmcm9tIGVpdGhlciB0aGVcbiAqIHVuZG8tIG9yIHRoZSByZWRvLXN0YWNrLiBZb3UgbWF5IHJlc3RvcmUgdGhlIHNhdmVkIHN0YWNrIGluZm9ybWF0aW9uIGZyb20gYGV2ZW50LnN0YWNrSXRlbS5tZXRhYC5cbiAqXG4gKiBAZXh0ZW5kcyB7T2JzZXJ2YWJsZVYyPHsnc3RhY2staXRlbS1hZGRlZCc6ZnVuY3Rpb24oU3RhY2tJdGVtRXZlbnQsIFVuZG9NYW5hZ2VyKTp2b2lkLCAnc3RhY2staXRlbS1wb3BwZWQnOiBmdW5jdGlvbihTdGFja0l0ZW1FdmVudCwgVW5kb01hbmFnZXIpOnZvaWQsICdzdGFjay1jbGVhcmVkJzogZnVuY3Rpb24oeyB1bmRvU3RhY2tDbGVhcmVkOiBib29sZWFuLCByZWRvU3RhY2tDbGVhcmVkOiBib29sZWFuIH0pOnZvaWQsICdzdGFjay1pdGVtLXVwZGF0ZWQnOiBmdW5jdGlvbihTdGFja0l0ZW1FdmVudCwgVW5kb01hbmFnZXIpOnZvaWQgfT59XG4gKi9cbmV4cG9ydCBjbGFzcyBVbmRvTWFuYWdlciBleHRlbmRzIE9ic2VydmFibGVWMiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fEFycmF5PEFic3RyYWN0VHlwZTxhbnk+Pn0gdHlwZVNjb3BlIEFjY2VwdHMgZWl0aGVyIGEgc2luZ2xlIHR5cGUsIG9yIGFuIGFycmF5IG9mIHR5cGVzXG4gICAqIEBwYXJhbSB7VW5kb01hbmFnZXJPcHRpb25zfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodHlwZVNjb3BlLCB7XG4gICAgY2FwdHVyZVRpbWVvdXQgPSA1MDAsXG4gICAgY2FwdHVyZVRyYW5zYWN0aW9uID0gX3RyID0+IHRydWUsXG4gICAgZGVsZXRlRmlsdGVyID0gKCkgPT4gdHJ1ZSxcbiAgICB0cmFja2VkT3JpZ2lucyA9IG5ldyBTZXQoW251bGxdKSxcbiAgICBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzID0gZmFsc2UsXG4gICAgZG9jID0gLyoqIEB0eXBlIHtEb2N9ICovIChhcnJheS5pc0FycmF5KHR5cGVTY29wZSkgPyB0eXBlU2NvcGVbMF0uZG9jIDogdHlwZVNjb3BlLmRvYylcbiAgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zY29wZSA9IFtdXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICB0aGlzLmFkZFRvU2NvcGUodHlwZVNjb3BlKVxuICAgIHRoaXMuZGVsZXRlRmlsdGVyID0gZGVsZXRlRmlsdGVyXG4gICAgdHJhY2tlZE9yaWdpbnMuYWRkKHRoaXMpXG4gICAgdGhpcy50cmFja2VkT3JpZ2lucyA9IHRyYWNrZWRPcmlnaW5zXG4gICAgdGhpcy5jYXB0dXJlVHJhbnNhY3Rpb24gPSBjYXB0dXJlVHJhbnNhY3Rpb25cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8U3RhY2tJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLnVuZG9TdGFjayA9IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PFN0YWNrSXRlbT59XG4gICAgICovXG4gICAgdGhpcy5yZWRvU3RhY2sgPSBbXVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNsaWVudCBpcyBjdXJyZW50bHkgdW5kb2luZyAoY2FsbGluZyBVbmRvTWFuYWdlci51bmRvKVxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy51bmRvaW5nID0gZmFsc2VcbiAgICB0aGlzLnJlZG9pbmcgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFRoZSBjdXJyZW50bHkgcG9wcGVkIHN0YWNrIGl0ZW0gaWYgVW5kb01hbmFnZXIudW5kb2luZyBvciBVbmRvTWFuYWdlci5yZWRvaW5nXG4gICAgICpcbiAgICAgKiBAdHlwZSB7U3RhY2tJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5jdXJyU3RhY2tJdGVtID0gbnVsbFxuICAgIHRoaXMubGFzdENoYW5nZSA9IDBcbiAgICB0aGlzLmlnbm9yZVJlbW90ZU1hcENoYW5nZXMgPSBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzXG4gICAgdGhpcy5jYXB0dXJlVGltZW91dCA9IGNhcHR1cmVUaW1lb3V0XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmFmdGVyVHJhbnNhY3Rpb25IYW5kbGVyID0gdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgLy8gT25seSB0cmFjayBjZXJ0YWluIHRyYW5zYWN0aW9uc1xuICAgICAgaWYgKFxuICAgICAgICAhdGhpcy5jYXB0dXJlVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHx8XG4gICAgICAgICF0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMuaGFzKHR5cGUpKSB8fFxuICAgICAgICAoIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbikgJiYgKCF0cmFuc2FjdGlvbi5vcmlnaW4gfHwgIXRoaXMudHJhY2tlZE9yaWdpbnMuaGFzKHRyYW5zYWN0aW9uLm9yaWdpbi5jb25zdHJ1Y3RvcikpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgdW5kb2luZyA9IHRoaXMudW5kb2luZ1xuICAgICAgY29uc3QgcmVkb2luZyA9IHRoaXMucmVkb2luZ1xuICAgICAgY29uc3Qgc3RhY2sgPSB1bmRvaW5nID8gdGhpcy5yZWRvU3RhY2sgOiB0aGlzLnVuZG9TdGFja1xuICAgICAgaWYgKHVuZG9pbmcpIHtcbiAgICAgICAgdGhpcy5zdG9wQ2FwdHVyaW5nKCkgLy8gbmV4dCB1bmRvIHNob3VsZCBub3QgYmUgYXBwZW5kZWQgdG8gbGFzdCBzdGFjayBpdGVtXG4gICAgICB9IGVsc2UgaWYgKCFyZWRvaW5nKSB7XG4gICAgICAgIC8vIG5laXRoZXIgdW5kb2luZyBub3IgcmVkb2luZzogZGVsZXRlIHJlZG9TdGFja1xuICAgICAgICB0aGlzLmNsZWFyKGZhbHNlLCB0cnVlKVxuICAgICAgfVxuICAgICAgY29uc3QgaW5zZXJ0aW9ucyA9IG5ldyBEZWxldGVTZXQoKVxuICAgICAgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5mb3JFYWNoKChlbmRDbG9jaywgY2xpZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXJ0Q2xvY2sgPSB0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoY2xpZW50KSB8fCAwXG4gICAgICAgIGNvbnN0IGxlbiA9IGVuZENsb2NrIC0gc3RhcnRDbG9ja1xuICAgICAgICBpZiAobGVuID4gMCkge1xuICAgICAgICAgIGFkZFRvRGVsZXRlU2V0KGluc2VydGlvbnMsIGNsaWVudCwgc3RhcnRDbG9jaywgbGVuKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgICAgY29uc3Qgbm93ID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBsZXQgZGlkQWRkID0gZmFsc2VcbiAgICAgIGlmICh0aGlzLmxhc3RDaGFuZ2UgPiAwICYmIG5vdyAtIHRoaXMubGFzdENoYW5nZSA8IHRoaXMuY2FwdHVyZVRpbWVvdXQgJiYgc3RhY2subGVuZ3RoID4gMCAmJiAhdW5kb2luZyAmJiAhcmVkb2luZykge1xuICAgICAgICAvLyBhcHBlbmQgY2hhbmdlIHRvIGxhc3Qgc3RhY2sgb3BcbiAgICAgICAgY29uc3QgbGFzdE9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV1cbiAgICAgICAgbGFzdE9wLmRlbGV0aW9ucyA9IG1lcmdlRGVsZXRlU2V0cyhbbGFzdE9wLmRlbGV0aW9ucywgdHJhbnNhY3Rpb24uZGVsZXRlU2V0XSlcbiAgICAgICAgbGFzdE9wLmluc2VydGlvbnMgPSBtZXJnZURlbGV0ZVNldHMoW2xhc3RPcC5pbnNlcnRpb25zLCBpbnNlcnRpb25zXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBzdGFjayBvcFxuICAgICAgICBzdGFjay5wdXNoKG5ldyBTdGFja0l0ZW0odHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpbnNlcnRpb25zKSlcbiAgICAgICAgZGlkQWRkID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCF1bmRvaW5nICYmICFyZWRvaW5nKSB7XG4gICAgICAgIHRoaXMubGFzdENoYW5nZSA9IG5vd1xuICAgICAgfVxuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgZGVsZXRlZCBzdHJ1Y3RzIGFyZSBub3QgZ2MnZFxuICAgICAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCB0cmFuc2FjdGlvbi5kZWxldGVTZXQsIC8qKiBAcGFyYW0ge0l0ZW18R0N9IGl0ZW0gKi8gaXRlbSA9PiB7XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSAmJiB0aGlzLnNjb3BlLnNvbWUodHlwZSA9PiBpc1BhcmVudE9mKHR5cGUsIGl0ZW0pKSkge1xuICAgICAgICAgIGtlZXBJdGVtKGl0ZW0sIHRydWUpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtbU3RhY2tJdGVtRXZlbnQsIFVuZG9NYW5hZ2VyXX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlRXZlbnQgPSBbeyBzdGFja0l0ZW06IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBvcmlnaW46IHRyYW5zYWN0aW9uLm9yaWdpbiwgdHlwZTogdW5kb2luZyA/ICdyZWRvJyA6ICd1bmRvJywgY2hhbmdlZFBhcmVudFR5cGVzOiB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXMgfSwgdGhpc11cbiAgICAgIGlmIChkaWRBZGQpIHtcbiAgICAgICAgdGhpcy5lbWl0KCdzdGFjay1pdGVtLWFkZGVkJywgY2hhbmdlRXZlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVtaXQoJ3N0YWNrLWl0ZW0tdXBkYXRlZCcsIGNoYW5nZUV2ZW50KVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmRvYy5vbignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpXG4gICAgdGhpcy5kb2Mub24oJ2Rlc3Ryb3knLCAoKSA9PiB7XG4gICAgICB0aGlzLmRlc3Ryb3koKVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheTxBYnN0cmFjdFR5cGU8YW55Pj4gfCBBYnN0cmFjdFR5cGU8YW55Pn0geXR5cGVzXG4gICAqL1xuICBhZGRUb1Njb3BlICh5dHlwZXMpIHtcbiAgICB5dHlwZXMgPSBhcnJheS5pc0FycmF5KHl0eXBlcykgPyB5dHlwZXMgOiBbeXR5cGVzXVxuICAgIHl0eXBlcy5mb3JFYWNoKHl0eXBlID0+IHtcbiAgICAgIGlmICh0aGlzLnNjb3BlLmV2ZXJ5KHl0ID0+IHl0ICE9PSB5dHlwZSkpIHtcbiAgICAgICAgaWYgKHl0eXBlLmRvYyAhPT0gdGhpcy5kb2MpIGxvZ2dpbmcud2FybignW3lqcyM1MDldIE5vdCBzYW1lIFkuRG9jJykgLy8gdXNlIE11bHRpRG9jVW5kb01hbmFnZXIgaW5zdGVhZC4gYWxzbyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzUwOVxuICAgICAgICB0aGlzLnNjb3BlLnB1c2goeXR5cGUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICBhZGRUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmFkZChvcmlnaW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG9yaWdpblxuICAgKi9cbiAgcmVtb3ZlVHJhY2tlZE9yaWdpbiAob3JpZ2luKSB7XG4gICAgdGhpcy50cmFja2VkT3JpZ2lucy5kZWxldGUob3JpZ2luKVxuICB9XG5cbiAgY2xlYXIgKGNsZWFyVW5kb1N0YWNrID0gdHJ1ZSwgY2xlYXJSZWRvU3RhY2sgPSB0cnVlKSB7XG4gICAgaWYgKChjbGVhclVuZG9TdGFjayAmJiB0aGlzLmNhblVuZG8oKSkgfHwgKGNsZWFyUmVkb1N0YWNrICYmIHRoaXMuY2FuUmVkbygpKSkge1xuICAgICAgdGhpcy5kb2MudHJhbnNhY3QodHIgPT4ge1xuICAgICAgICBpZiAoY2xlYXJVbmRvU3RhY2spIHtcbiAgICAgICAgICB0aGlzLnVuZG9TdGFjay5mb3JFYWNoKGl0ZW0gPT4gY2xlYXJVbmRvTWFuYWdlclN0YWNrSXRlbSh0ciwgdGhpcywgaXRlbSkpXG4gICAgICAgICAgdGhpcy51bmRvU3RhY2sgPSBbXVxuICAgICAgICB9XG4gICAgICAgIGlmIChjbGVhclJlZG9TdGFjaykge1xuICAgICAgICAgIHRoaXMucmVkb1N0YWNrLmZvckVhY2goaXRlbSA9PiBjbGVhclVuZG9NYW5hZ2VyU3RhY2tJdGVtKHRyLCB0aGlzLCBpdGVtKSlcbiAgICAgICAgICB0aGlzLnJlZG9TdGFjayA9IFtdXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdzdGFjay1jbGVhcmVkJywgW3sgdW5kb1N0YWNrQ2xlYXJlZDogY2xlYXJVbmRvU3RhY2ssIHJlZG9TdGFja0NsZWFyZWQ6IGNsZWFyUmVkb1N0YWNrIH1dKVxuICAgICAgfSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVW5kb01hbmFnZXIgbWVyZ2VzIFVuZG8tU3RhY2tJdGVtIGlmIHRoZXkgYXJlIGNyZWF0ZWQgd2l0aGluIHRpbWUtZ2FwXG4gICAqIHNtYWxsZXIgdGhhbiBgb3B0aW9ucy5jYXB0dXJlVGltZW91dGAuIENhbGwgYHVtLnN0b3BDYXB0dXJpbmcoKWAgc28gdGhhdCB0aGUgbmV4dFxuICAgKiBTdGFja0l0ZW0gd29uJ3QgYmUgbWVyZ2VkLlxuICAgKlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAgLy8gd2l0aG91dCBzdG9wQ2FwdHVyaW5nXG4gICAqICAgICB5dGV4dC5pbnNlcnQoMCwgJ2EnKVxuICAgKiAgICAgeXRleHQuaW5zZXJ0KDEsICdiJylcbiAgICogICAgIHVtLnVuZG8oKVxuICAgKiAgICAgeXRleHQudG9TdHJpbmcoKSAvLyA9PiAnJyAobm90ZSB0aGF0ICdhYicgd2FzIHJlbW92ZWQpXG4gICAqICAgICAvLyB3aXRoIHN0b3BDYXB0dXJpbmdcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYScpXG4gICAqICAgICB1bS5zdG9wQ2FwdHVyaW5nKClcbiAgICogICAgIHl0ZXh0Lmluc2VydCgwLCAnYicpXG4gICAqICAgICB1bS51bmRvKClcbiAgICogICAgIHl0ZXh0LnRvU3RyaW5nKCkgLy8gPT4gJ2EnIChub3RlIHRoYXQgb25seSAnYicgd2FzIHJlbW92ZWQpXG4gICAqXG4gICAqL1xuICBzdG9wQ2FwdHVyaW5nICgpIHtcbiAgICB0aGlzLmxhc3RDaGFuZ2UgPSAwXG4gIH1cblxuICAvKipcbiAgICogVW5kbyBsYXN0IGNoYW5nZXMgb24gdHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7U3RhY2tJdGVtP30gUmV0dXJucyBTdGFja0l0ZW0gaWYgYSBjaGFuZ2Ugd2FzIGFwcGxpZWRcbiAgICovXG4gIHVuZG8gKCkge1xuICAgIHRoaXMudW5kb2luZyA9IHRydWVcbiAgICBsZXQgcmVzXG4gICAgdHJ5IHtcbiAgICAgIHJlcyA9IHBvcFN0YWNrSXRlbSh0aGlzLCB0aGlzLnVuZG9TdGFjaywgJ3VuZG8nKVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLnVuZG9pbmcgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gcmVzXG4gIH1cblxuICAvKipcbiAgICogUmVkbyBsYXN0IHVuZG8gb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdGFja0l0ZW0/fSBSZXR1cm5zIFN0YWNrSXRlbSBpZiBhIGNoYW5nZSB3YXMgYXBwbGllZFxuICAgKi9cbiAgcmVkbyAoKSB7XG4gICAgdGhpcy5yZWRvaW5nID0gdHJ1ZVxuICAgIGxldCByZXNcbiAgICB0cnkge1xuICAgICAgcmVzID0gcG9wU3RhY2tJdGVtKHRoaXMsIHRoaXMucmVkb1N0YWNrLCAncmVkbycpXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMucmVkb2luZyA9IGZhbHNlXG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBBcmUgdW5kbyBzdGVwcyBhdmFpbGFibGU/XG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IGB0cnVlYCBpZiB1bmRvIGlzIHBvc3NpYmxlXG4gICAqL1xuICBjYW5VbmRvICgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvU3RhY2subGVuZ3RoID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIEFyZSByZWRvIHN0ZXBzIGF2YWlsYWJsZT9cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gYHRydWVgIGlmIHJlZG8gaXMgcG9zc2libGVcbiAgICovXG4gIGNhblJlZG8gKCkge1xuICAgIHJldHVybiB0aGlzLnJlZG9TdGFjay5sZW5ndGggPiAwXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLnRyYWNrZWRPcmlnaW5zLmRlbGV0ZSh0aGlzKVxuICAgIHRoaXMuZG9jLm9mZignYWZ0ZXJUcmFuc2FjdGlvbicsIHRoaXMuYWZ0ZXJUcmFuc2FjdGlvbkhhbmRsZXIpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cbn1cbiIsICJpbXBvcnQgKiBhcyBiaW5hcnkgZnJvbSAnbGliMC9iaW5hcnknXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBmIGZyb20gJ2xpYjAvZnVuY3Rpb24nXG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJ2xpYjAvbG9nZ2luZydcbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJ2xpYjAvc3RyaW5nJ1xuXG5pbXBvcnQge1xuICBDb250ZW50QW55LFxuICBDb250ZW50QmluYXJ5LFxuICBDb250ZW50RGVsZXRlZCxcbiAgQ29udGVudERvYyxcbiAgQ29udGVudEVtYmVkLFxuICBDb250ZW50Rm9ybWF0LFxuICBDb250ZW50SlNPTixcbiAgQ29udGVudFN0cmluZyxcbiAgQ29udGVudFR5cGUsXG4gIGNyZWF0ZUlELFxuICBkZWNvZGVTdGF0ZVZlY3RvcixcbiAgRFNFbmNvZGVyVjEsXG4gIERTRW5jb2RlclYyLFxuICBHQyxcbiAgSXRlbSxcbiAgbWVyZ2VEZWxldGVTZXRzLFxuICByZWFkRGVsZXRlU2V0LFxuICByZWFkSXRlbUNvbnRlbnQsXG4gIFNraXAsXG4gIFVwZGF0ZURlY29kZXJWMSxcbiAgVXBkYXRlRGVjb2RlclYyLFxuICBVcGRhdGVFbmNvZGVyVjEsXG4gIFVwZGF0ZUVuY29kZXJWMixcbiAgd3JpdGVEZWxldGVTZXQsXG4gIFlYbWxFbGVtZW50LFxuICBZWG1sSG9va1xufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqL1xuZnVuY3Rpb24gKiBsYXp5U3RydWN0UmVhZGVyR2VuZXJhdG9yIChkZWNvZGVyKSB7XG4gIGNvbnN0IG51bU9mU3RhdGVVcGRhdGVzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZlN0YXRlVXBkYXRlczsgaSsrKSB7XG4gICAgY29uc3QgbnVtYmVyT2ZTdHJ1Y3RzID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2Rlci5yZXN0RGVjb2RlcilcbiAgICBjb25zdCBjbGllbnQgPSBkZWNvZGVyLnJlYWRDbGllbnQoKVxuICAgIGxldCBjbG9jayA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJPZlN0cnVjdHM7IGkrKykge1xuICAgICAgY29uc3QgaW5mbyA9IGRlY29kZXIucmVhZEluZm8oKVxuICAgICAgLy8gQHRvZG8gdXNlIHN3aXRjaCBpbnN0ZWFkIG9mIGlmc1xuICAgICAgaWYgKGluZm8gPT09IDEwKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIucmVzdERlY29kZXIpXG4gICAgICAgIHlpZWxkIG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pXG4gICAgICAgIGNsb2NrICs9IGxlblxuICAgICAgfSBlbHNlIGlmICgoYmluYXJ5LkJJVFM1ICYgaW5mbykgIT09IDApIHtcbiAgICAgICAgY29uc3QgY2FudENvcHlQYXJlbnRJbmZvID0gKGluZm8gJiAoYmluYXJ5LkJJVDcgfCBiaW5hcnkuQklUOCkpID09PSAwXG4gICAgICAgIC8vIElmIHBhcmVudCA9IG51bGwgYW5kIG5laXRoZXIgbGVmdCBub3IgcmlnaHQgYXJlIGRlZmluZWQsIHRoZW4gd2Uga25vdyB0aGF0IGBwYXJlbnRgIGlzIGNoaWxkIG9mIGB5YFxuICAgICAgICAvLyBhbmQgd2UgcmVhZCB0aGUgbmV4dCBzdHJpbmcgYXMgcGFyZW50WUtleS5cbiAgICAgICAgLy8gSXQgaW5kaWNhdGVzIGhvdyB3ZSBzdG9yZS9yZXRyaWV2ZSBwYXJlbnQgZnJvbSBgeS5zaGFyZWBcbiAgICAgICAgLy8gQHR5cGUge3N0cmluZ3xudWxsfVxuICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgSXRlbShcbiAgICAgICAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrKSxcbiAgICAgICAgICBudWxsLCAvLyBsZWZ0XG4gICAgICAgICAgKGluZm8gJiBiaW5hcnkuQklUOCkgPT09IGJpbmFyeS5CSVQ4ID8gZGVjb2Rlci5yZWFkTGVmdElEKCkgOiBudWxsLCAvLyBvcmlnaW5cbiAgICAgICAgICBudWxsLCAvLyByaWdodFxuICAgICAgICAgIChpbmZvICYgYmluYXJ5LkJJVDcpID09PSBiaW5hcnkuQklUNyA/IGRlY29kZXIucmVhZFJpZ2h0SUQoKSA6IG51bGwsIC8vIHJpZ2h0IG9yaWdpblxuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgRm9yY2Ugd3JpdGluZyBhIHN0cmluZyBoZXJlLlxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyA/IChkZWNvZGVyLnJlYWRQYXJlbnRJbmZvKCkgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IGRlY29kZXIucmVhZExlZnRJRCgpKSA6IG51bGwsIC8vIHBhcmVudFxuICAgICAgICAgIGNhbnRDb3B5UGFyZW50SW5mbyAmJiAoaW5mbyAmIGJpbmFyeS5CSVQ2KSA9PT0gYmluYXJ5LkJJVDYgPyBkZWNvZGVyLnJlYWRTdHJpbmcoKSA6IG51bGwsIC8vIHBhcmVudFN1YlxuICAgICAgICAgIHJlYWRJdGVtQ29udGVudChkZWNvZGVyLCBpbmZvKSAvLyBpdGVtIGNvbnRlbnRcbiAgICAgICAgKVxuICAgICAgICB5aWVsZCBzdHJ1Y3RcbiAgICAgICAgY2xvY2sgKz0gc3RydWN0Lmxlbmd0aFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbGVuID0gZGVjb2Rlci5yZWFkTGVuKClcbiAgICAgICAgeWllbGQgbmV3IEdDKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2spLCBsZW4pXG4gICAgICAgIGNsb2NrICs9IGxlblxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGF6eVN0cnVjdFJlYWRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGZpbHRlclNraXBzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZGVjb2RlciwgZmlsdGVyU2tpcHMpIHtcbiAgICB0aGlzLmdlbiA9IGxhenlTdHJ1Y3RSZWFkZXJHZW5lcmF0b3IoZGVjb2RlcilcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEl0ZW0gfCBTa2lwIHwgR0N9XG4gICAgICovXG4gICAgdGhpcy5jdXJyID0gbnVsbFxuICAgIHRoaXMuZG9uZSA9IGZhbHNlXG4gICAgdGhpcy5maWx0ZXJTa2lwcyA9IGZpbHRlclNraXBzXG4gICAgdGhpcy5uZXh0KClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVtIHwgR0MgfCBTa2lwIHxudWxsfVxuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLy8gaWdub3JlIFwiU2tpcFwiIHN0cnVjdHNcbiAgICBkbyB7XG4gICAgICB0aGlzLmN1cnIgPSB0aGlzLmdlbi5uZXh0KCkudmFsdWUgfHwgbnVsbFxuICAgIH0gd2hpbGUgKHRoaXMuZmlsdGVyU2tpcHMgJiYgdGhpcy5jdXJyICE9PSBudWxsICYmIHRoaXMuY3Vyci5jb25zdHJ1Y3RvciA9PT0gU2tpcClcbiAgICByZXR1cm4gdGhpcy5jdXJyXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1VwZGF0ZSA9IHVwZGF0ZSA9PiBsb2dVcGRhdGVWMih1cGRhdGUsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gW1lEZWNvZGVyXVxuICpcbiAqL1xuZXhwb3J0IGNvbnN0IGxvZ1VwZGF0ZVYyID0gKHVwZGF0ZSwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3Qgc3RydWN0cyA9IFtdXG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKVxuICBjb25zdCBsYXp5RGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKHVwZGF0ZURlY29kZXIsIGZhbHNlKVxuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHN0cnVjdHMucHVzaChjdXJyKVxuICB9XG4gIGxvZ2dpbmcucHJpbnQoJ1N0cnVjdHM6ICcsIHN0cnVjdHMpXG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldCh1cGRhdGVEZWNvZGVyKVxuICBsb2dnaW5nLnByaW50KCdEZWxldGVTZXQ6ICcsIGRzKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKlxuICovXG5leHBvcnQgY29uc3QgZGVjb2RlVXBkYXRlID0gKHVwZGF0ZSkgPT4gZGVjb2RlVXBkYXRlVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZURlY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVEZWNvZGVyVjF9IFtZRGVjb2Rlcl1cbiAqXG4gKi9cbmV4cG9ydCBjb25zdCBkZWNvZGVVcGRhdGVWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0cnVjdHMgPSBbXVxuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSlcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSlcbiAgZm9yIChsZXQgY3VyciA9IGxhenlEZWNvZGVyLmN1cnI7IGN1cnIgIT09IG51bGw7IGN1cnIgPSBsYXp5RGVjb2Rlci5uZXh0KCkpIHtcbiAgICBzdHJ1Y3RzLnB1c2goY3VycilcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0cnVjdHMsXG4gICAgZHM6IHJlYWREZWxldGVTZXQodXBkYXRlRGVjb2RlcilcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTGF6eVN0cnVjdFdyaXRlciB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVuY29kZXIpIHtcbiAgICB0aGlzLmN1cnJDbGllbnQgPSAwXG4gICAgdGhpcy5zdGFydENsb2NrID0gMFxuICAgIHRoaXMud3JpdHRlbiA9IDBcbiAgICB0aGlzLmVuY29kZXIgPSBlbmNvZGVyXG4gICAgLyoqXG4gICAgICogV2Ugd2FudCB0byB3cml0ZSBvcGVyYXRpb25zIGxhemlseSwgYnV0IGFsc28gd2UgbmVlZCB0byBrbm93IGJlZm9yZWhhbmQgaG93IG1hbnkgb3BlcmF0aW9ucyB3ZSB3YW50IHRvIHdyaXRlIGZvciBlYWNoIGNsaWVudC5cbiAgICAgKlxuICAgICAqIFRoaXMga2luZCBvZiBtZXRhLWluZm9ybWF0aW9uICgjY2xpZW50cywgI3N0cnVjdHMtcGVyLWNsaWVudC13cml0dGVuKSBpcyB3cml0dGVuIHRvIHRoZSByZXN0RW5jb2Rlci5cbiAgICAgKlxuICAgICAqIFdlIGZyYWdtZW50IHRoZSByZXN0RW5jb2RlciBhbmQgc3RvcmUgYSBzbGljZSBvZiBpdCBwZXItY2xpZW50IHVudGlsIHdlIGtub3cgaG93IG1hbnkgY2xpZW50cyB0aGVyZSBhcmUuXG4gICAgICogV2hlbiB3ZSBmbHVzaCAodG9VaW50OEFycmF5KSB3ZSB3cml0ZSB0aGUgcmVzdEVuY29kZXIgdXNpbmcgdGhlIGZyYWdtZW50cyBhbmQgdGhlIG1ldGEtaW5mb3JtYXRpb24uXG4gICAgICpcbiAgICAgKiBAdHlwZSB7QXJyYXk8eyB3cml0dGVuOiBudW1iZXIsIHJlc3RFbmNvZGVyOiBVaW50OEFycmF5IH0+fVxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50U3RydWN0cyA9IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbWVyZ2VVcGRhdGVzID0gdXBkYXRlcyA9PiBtZXJnZVVwZGF0ZXNWMih1cGRhdGVzLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgRFNFbmNvZGVyVjEgfCB0eXBlb2YgRFNFbmNvZGVyVjJ9IFlFbmNvZGVyXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBZRGVjb2RlclxuICogQHJldHVybiB7VWludDhBcnJheX1cbiAqL1xuZXhwb3J0IGNvbnN0IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyID0gKHVwZGF0ZSwgWUVuY29kZXIgPSBEU0VuY29kZXJWMiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIpID0+IHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIGNvbnN0IHVwZGF0ZURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcihuZXcgWURlY29kZXIoZGVjb2RpbmcuY3JlYXRlRGVjb2Rlcih1cGRhdGUpKSwgZmFsc2UpXG4gIGxldCBjdXJyID0gdXBkYXRlRGVjb2Rlci5jdXJyXG4gIGlmIChjdXJyICE9PSBudWxsKSB7XG4gICAgbGV0IHNpemUgPSAwXG4gICAgbGV0IGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudFxuICAgIGxldCBzdG9wQ291bnRpbmcgPSBjdXJyLmlkLmNsb2NrICE9PSAwIC8vIG11c3Qgc3RhcnQgYXQgMFxuICAgIGxldCBjdXJyQ2xvY2sgPSBzdG9wQ291bnRpbmcgPyAwIDogY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoXG4gICAgZm9yICg7IGN1cnIgIT09IG51bGw7IGN1cnIgPSB1cGRhdGVEZWNvZGVyLm5leHQoKSkge1xuICAgICAgaWYgKGN1cnJDbGllbnQgIT09IGN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgIGlmIChjdXJyQ2xvY2sgIT09IDApIHtcbiAgICAgICAgICBzaXplKytcbiAgICAgICAgICAvLyBXZSBmb3VuZCBhIG5ldyBjbGllbnRcbiAgICAgICAgICAvLyB3cml0ZSB3aGF0IHdlIGhhdmUgdG8gdGhlIGVuY29kZXJcbiAgICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsaWVudClcbiAgICAgICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKVxuICAgICAgICB9XG4gICAgICAgIGN1cnJDbGllbnQgPSBjdXJyLmlkLmNsaWVudFxuICAgICAgICBjdXJyQ2xvY2sgPSAwXG4gICAgICAgIHN0b3BDb3VudGluZyA9IGN1cnIuaWQuY2xvY2sgIT09IDBcbiAgICAgIH1cbiAgICAgIC8vIHdlIGlnbm9yZSBza2lwc1xuICAgICAgaWYgKGN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgICAgc3RvcENvdW50aW5nID0gdHJ1ZVxuICAgICAgfVxuICAgICAgaWYgKCFzdG9wQ291bnRpbmcpIHtcbiAgICAgICAgY3VyckNsb2NrID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdyaXRlIHdoYXQgd2UgaGF2ZVxuICAgIGlmIChjdXJyQ2xvY2sgIT09IDApIHtcbiAgICAgIHNpemUrK1xuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIGN1cnJDbGllbnQpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2Rlci5yZXN0RW5jb2RlciwgY3VyckNsb2NrKVxuICAgIH1cbiAgICAvLyBwcmVwZW5kIHRoZSBzaXplIG9mIHRoZSBzdGF0ZSB2ZWN0b3JcbiAgICBjb25zdCBlbmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jLCBzaXplKVxuICAgIGVuY29kaW5nLndyaXRlQmluYXJ5RW5jb2RlcihlbmMsIGVuY29kZXIucmVzdEVuY29kZXIpXG4gICAgZW5jb2Rlci5yZXN0RW5jb2RlciA9IGVuY1xuICAgIHJldHVybiBlbmNvZGVyLnRvVWludDhBcnJheSgpXG4gIH0gZWxzZSB7XG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIDApXG4gICAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlID0gdXBkYXRlID0+IGVuY29kZVN0YXRlVmVjdG9yRnJvbVVwZGF0ZVYyKHVwZGF0ZSwgRFNFbmNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYxIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMn0gWURlY29kZXJcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVVwZGF0ZU1ldGFWMiA9ICh1cGRhdGUsIFlEZWNvZGVyID0gVXBkYXRlRGVjb2RlclYyKSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7TWFwPG51bWJlciwgbnVtYmVyPn1cbiAgICovXG4gIGNvbnN0IGZyb20gPSBuZXcgTWFwKClcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8bnVtYmVyLCBudW1iZXI+fVxuICAgKi9cbiAgY29uc3QgdG8gPSBuZXcgTWFwKClcbiAgY29uc3QgdXBkYXRlRGVjb2RlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpLCBmYWxzZSlcbiAgbGV0IGN1cnIgPSB1cGRhdGVEZWNvZGVyLmN1cnJcbiAgaWYgKGN1cnIgIT09IG51bGwpIHtcbiAgICBsZXQgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgbGV0IGN1cnJDbG9jayA9IGN1cnIuaWQuY2xvY2tcbiAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgIGZyb20uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jaylcbiAgICBmb3IgKDsgY3VyciAhPT0gbnVsbDsgY3VyciA9IHVwZGF0ZURlY29kZXIubmV4dCgpKSB7XG4gICAgICBpZiAoY3VyckNsaWVudCAhPT0gY3Vyci5pZC5jbGllbnQpIHtcbiAgICAgICAgLy8gV2UgZm91bmQgYSBuZXcgY2xpZW50XG4gICAgICAgIC8vIHdyaXRlIHRoZSBlbmQgdG8gYHRvYFxuICAgICAgICB0by5zZXQoY3VyckNsaWVudCwgY3VyckNsb2NrKVxuICAgICAgICAvLyB3cml0ZSB0aGUgYmVnaW5uaW5nIHRvIGBmcm9tYFxuICAgICAgICBmcm9tLnNldChjdXJyLmlkLmNsaWVudCwgY3Vyci5pZC5jbG9jaylcbiAgICAgICAgLy8gdXBkYXRlIGN1cnJDbGllbnRcbiAgICAgICAgY3VyckNsaWVudCA9IGN1cnIuaWQuY2xpZW50XG4gICAgICB9XG4gICAgICBjdXJyQ2xvY2sgPSBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGhcbiAgICB9XG4gICAgLy8gd3JpdGUgdGhlIGVuZCB0byBgdG9gXG4gICAgdG8uc2V0KGN1cnJDbGllbnQsIGN1cnJDbG9jaylcbiAgfVxuICByZXR1cm4geyBmcm9tLCB0byB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqIEByZXR1cm4ge3sgZnJvbTogTWFwPG51bWJlcixudW1iZXI+LCB0bzogTWFwPG51bWJlcixudW1iZXI+IH19XG4gKi9cbmV4cG9ydCBjb25zdCBwYXJzZVVwZGF0ZU1ldGEgPSB1cGRhdGUgPT4gcGFyc2VVcGRhdGVNZXRhVjIodXBkYXRlLCBVcGRhdGVEZWNvZGVyVjEpXG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgaW50ZW5kZWQgdG8gc2xpY2UgYW55IGtpbmQgb2Ygc3RydWN0IGFuZCByZXRyaWV2ZSB0aGUgcmlnaHQgcGFydC5cbiAqIEl0IGRvZXMgbm90IGhhbmRsZSBzaWRlLWVmZmVjdHMsIHNvIGl0IHNob3VsZCBvbmx5IGJlIHVzZWQgYnkgdGhlIGxhenktZW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0l0ZW0gfCBHQyB8IFNraXB9IGxlZnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaWZmXG4gKiBAcmV0dXJuIHtJdGVtIHwgR0N9XG4gKi9cbmNvbnN0IHNsaWNlU3RydWN0ID0gKGxlZnQsIGRpZmYpID0+IHtcbiAgaWYgKGxlZnQuY29uc3RydWN0b3IgPT09IEdDKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkXG4gICAgcmV0dXJuIG5ldyBHQyhjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksIGxlZnQubGVuZ3RoIC0gZGlmZilcbiAgfSBlbHNlIGlmIChsZWZ0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0LmlkXG4gICAgcmV0dXJuIG5ldyBTa2lwKGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmKSwgbGVmdC5sZW5ndGggLSBkaWZmKVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGxlZnRJdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAobGVmdClcbiAgICBjb25zdCB7IGNsaWVudCwgY2xvY2sgfSA9IGxlZnRJdGVtLmlkXG4gICAgcmV0dXJuIG5ldyBJdGVtKFxuICAgICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYpLFxuICAgICAgbnVsbCxcbiAgICAgIGNyZWF0ZUlEKGNsaWVudCwgY2xvY2sgKyBkaWZmIC0gMSksXG4gICAgICBudWxsLFxuICAgICAgbGVmdEl0ZW0ucmlnaHRPcmlnaW4sXG4gICAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgICBsZWZ0SXRlbS5wYXJlbnRTdWIsXG4gICAgICBsZWZ0SXRlbS5jb250ZW50LnNwbGljZShkaWZmKVxuICAgIClcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIHdvcmtzIHNpbWlsYXJseSB0byBgcmVhZFVwZGF0ZVYyYC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFVpbnQ4QXJyYXk+fSB1cGRhdGVzXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbWVyZ2VVcGRhdGVzVjIgPSAodXBkYXRlcywgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGlmICh1cGRhdGVzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB1cGRhdGVzWzBdXG4gIH1cbiAgY29uc3QgdXBkYXRlRGVjb2RlcnMgPSB1cGRhdGVzLm1hcCh1cGRhdGUgPT4gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSkpXG4gIGxldCBsYXp5U3RydWN0RGVjb2RlcnMgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiBuZXcgTGF6eVN0cnVjdFJlYWRlcihkZWNvZGVyLCB0cnVlKSlcblxuICAvKipcbiAgICogQHRvZG8gd2UgZG9uJ3QgbmVlZCBvZmZzZXQgYmVjYXVzZSB3ZSBhbHdheXMgc2xpY2UgYmVmb3JlXG4gICAqIEB0eXBlIHtudWxsIHwgeyBzdHJ1Y3Q6IEl0ZW0gfCBHQyB8IFNraXAsIG9mZnNldDogbnVtYmVyIH19XG4gICAqL1xuICBsZXQgY3VycldyaXRlID0gbnVsbFxuXG4gIGNvbnN0IHVwZGF0ZUVuY29kZXIgPSBuZXcgWUVuY29kZXIoKVxuICAvLyB3cml0ZSBzdHJ1Y3RzIGxhemlseVxuICBjb25zdCBsYXp5U3RydWN0RW5jb2RlciA9IG5ldyBMYXp5U3RydWN0V3JpdGVyKHVwZGF0ZUVuY29kZXIpXG5cbiAgLy8gTm90ZTogV2UgbmVlZCB0byBlbnN1cmUgdGhhdCBhbGwgbGF6eVN0cnVjdERlY29kZXJzIGFyZSBmdWxseSBjb25zdW1lZFxuICAvLyBOb3RlOiBTaG91bGQgbWVyZ2UgZG9jdW1lbnQgdXBkYXRlcyB3aGVuZXZlciBwb3NzaWJsZSAtIGV2ZW4gZnJvbSBkaWZmZXJlbnQgdXBkYXRlc1xuICAvLyBOb3RlOiBTaG91bGQgaGFuZGxlIHRoYXQgc29tZSBvcGVyYXRpb25zIGNhbm5vdCBiZSBhcHBsaWVkIHlldCAoKVxuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgLy8gV3JpdGUgaGlnaGVyIGNsaWVudHMgZmlyc3Qg4oeSIHNvcnQgYnkgY2xpZW50SUQgJiBjbG9jayBhbmQgcmVtb3ZlIGRlY29kZXJzIHdpdGhvdXQgY29udGVudFxuICAgIGxhenlTdHJ1Y3REZWNvZGVycyA9IGxhenlTdHJ1Y3REZWNvZGVycy5maWx0ZXIoZGVjID0+IGRlYy5jdXJyICE9PSBudWxsKVxuICAgIGxhenlTdHJ1Y3REZWNvZGVycy5zb3J0KFxuICAgICAgLyoqIEB0eXBlIHtmdW5jdGlvbihhbnksYW55KTpudW1iZXJ9ICovIChkZWMxLCBkZWMyKSA9PiB7XG4gICAgICAgIGlmIChkZWMxLmN1cnIuaWQuY2xpZW50ID09PSBkZWMyLmN1cnIuaWQuY2xpZW50KSB7XG4gICAgICAgICAgY29uc3QgY2xvY2tEaWZmID0gZGVjMS5jdXJyLmlkLmNsb2NrIC0gZGVjMi5jdXJyLmlkLmNsb2NrXG4gICAgICAgICAgaWYgKGNsb2NrRGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgLy8gQHRvZG8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gc2tpcCBzaW5jZSB0aGUgc3RydWN0RGVjb2RlcnMgbXVzdCBmaWx0ZXIgU2tpcHMuXG4gICAgICAgICAgICByZXR1cm4gZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBkZWMyLmN1cnIuY29uc3RydWN0b3JcbiAgICAgICAgICAgICAgPyAwXG4gICAgICAgICAgICAgIDogZGVjMS5jdXJyLmNvbnN0cnVjdG9yID09PSBTa2lwID8gMSA6IC0xIC8vIHdlIGFyZSBmaWx0ZXJpbmcgc2tpcHMgYW55d2F5LlxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2xvY2tEaWZmXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBkZWMyLmN1cnIuaWQuY2xpZW50IC0gZGVjMS5jdXJyLmlkLmNsaWVudFxuICAgICAgICB9XG4gICAgICB9XG4gICAgKVxuICAgIGlmIChsYXp5U3RydWN0RGVjb2RlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjb25zdCBjdXJyRGVjb2RlciA9IGxhenlTdHJ1Y3REZWNvZGVyc1swXVxuICAgIC8vIHdyaXRlIGZyb20gY3VyckRlY29kZXIgdW50aWwgdGhlIG5leHQgb3BlcmF0aW9uIGlzIGZyb20gYW5vdGhlciBjbGllbnQgb3IgaWYgZmlsbGVyLXN0cnVjdFxuICAgIC8vIHRoZW4gd2UgbmVlZCB0byByZW9yZGVyIHRoZSBkZWNvZGVycyBhbmQgZmluZCB0aGUgbmV4dCBvcGVyYXRpb24gdG8gd3JpdGVcbiAgICBjb25zdCBmaXJzdENsaWVudCA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VycikuaWQuY2xpZW50XG5cbiAgICBpZiAoY3VycldyaXRlICE9PSBudWxsKSB7XG4gICAgICBsZXQgY3VyciA9IC8qKiBAdHlwZSB7SXRlbSB8IEdDIHwgbnVsbH0gKi8gKGN1cnJEZWNvZGVyLmN1cnIpXG4gICAgICBsZXQgaXRlcmF0ZWQgPSBmYWxzZVxuXG4gICAgICAvLyBpdGVyYXRlIHVudGlsIHdlIGZpbmQgc29tZXRoaW5nIHRoYXQgd2UgaGF2ZW4ndCB3cml0dGVuIGFscmVhZHlcbiAgICAgIC8vIHJlbWVtYmVyOiBmaXJzdCB0aGUgaGlnaCBjbGllbnQtaWRzIGFyZSB3cml0dGVuXG4gICAgICB3aGlsZSAoY3VyciAhPT0gbnVsbCAmJiBjdXJyLmlkLmNsb2NrICsgY3Vyci5sZW5ndGggPD0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoICYmIGN1cnIuaWQuY2xpZW50ID49IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xpZW50KSB7XG4gICAgICAgIGN1cnIgPSBjdXJyRGVjb2Rlci5uZXh0KClcbiAgICAgICAgaXRlcmF0ZWQgPSB0cnVlXG4gICAgICB9XG4gICAgICBpZiAoXG4gICAgICAgIGN1cnIgPT09IG51bGwgfHwgLy8gY3VycmVudCBkZWNvZGVyIGlzIGVtcHR5XG4gICAgICAgIGN1cnIuaWQuY2xpZW50ICE9PSBmaXJzdENsaWVudCB8fCAvLyBjaGVjayB3aGV0aGVyIHRoZXJlIGlzIGFub3RoZXIgZGVjb2RlciB0aGF0IGhhcyBoYXMgdXBkYXRlcyBmcm9tIGBmaXJzdENsaWVudGBcbiAgICAgICAgKGl0ZXJhdGVkICYmIGN1cnIuaWQuY2xvY2sgPiBjdXJyV3JpdGUuc3RydWN0LmlkLmNsb2NrICsgY3VycldyaXRlLnN0cnVjdC5sZW5ndGgpIC8vIHRoZSBhYm92ZSB3aGlsZSBsb29wIHdhcyB1c2VkIGFuZCB3ZSBhcmUgcG90ZW50aWFsbHkgbWlzc2luZyB1cGRhdGVzXG4gICAgICApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGZpcnN0Q2xpZW50ICE9PSBjdXJyV3JpdGUuc3RydWN0LmlkLmNsaWVudCkge1xuICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldClcbiAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9XG4gICAgICAgIGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA8IGN1cnIuaWQuY2xvY2spIHtcbiAgICAgICAgICAvLyBAdG9kbyB3cml0ZSBjdXJyU3RydWN0ICYgc2V0IGN1cnJTdHJ1Y3QgPSBTa2lwKGNsb2NrID0gY3VyclN0cnVjdC5pZC5jbG9jayArIGN1cnJTdHJ1Y3QubGVuZ3RoLCBsZW5ndGggPSBjdXJyLmlkLmNsb2NrIC0gc2VsZi5jbG9jaylcbiAgICAgICAgICBpZiAoY3VycldyaXRlLnN0cnVjdC5jb25zdHJ1Y3RvciA9PT0gU2tpcCkge1xuICAgICAgICAgICAgLy8gZXh0ZW5kIGV4aXN0aW5nIHNraXBcbiAgICAgICAgICAgIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoID0gY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9ja1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0RW5jb2RlciwgY3VycldyaXRlLnN0cnVjdCwgY3VycldyaXRlLm9mZnNldClcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjdXJyLmlkLmNsb2NrIC0gY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayAtIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEB0eXBlIHtTa2lwfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBzdHJ1Y3QgPSBuZXcgU2tpcChjcmVhdGVJRChmaXJzdENsaWVudCwgY3VycldyaXRlLnN0cnVjdC5pZC5jbG9jayArIGN1cnJXcml0ZS5zdHJ1Y3QubGVuZ3RoKSwgZGlmZilcbiAgICAgICAgICAgIGN1cnJXcml0ZSA9IHsgc3RydWN0LCBvZmZzZXQ6IDAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gaWYgKGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCA+PSBjdXJyLmlkLmNsb2NrKSB7XG4gICAgICAgICAgY29uc3QgZGlmZiA9IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAtIGN1cnIuaWQuY2xvY2tcbiAgICAgICAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgICAgICAgIGlmIChjdXJyV3JpdGUuc3RydWN0LmNvbnN0cnVjdG9yID09PSBTa2lwKSB7XG4gICAgICAgICAgICAgIC8vIHByZWZlciB0byBzbGljZSBTa2lwIGJlY2F1c2UgdGhlIG90aGVyIHN0cnVjdCBtaWdodCBjb250YWluIG1vcmUgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgY3VycldyaXRlLnN0cnVjdC5sZW5ndGggLT0gZGlmZlxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY3VyciA9IHNsaWNlU3RydWN0KGN1cnIsIGRpZmYpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghY3VycldyaXRlLnN0cnVjdC5tZXJnZVdpdGgoLyoqIEB0eXBlIHthbnl9ICovIChjdXJyKSkpIHtcbiAgICAgICAgICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgICAgICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IGN1cnIsIG9mZnNldDogMCB9XG4gICAgICAgICAgICBjdXJyRGVjb2Rlci5uZXh0KClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3VycldyaXRlID0geyBzdHJ1Y3Q6IC8qKiBAdHlwZSB7SXRlbSB8IEdDfSAqLyAoY3VyckRlY29kZXIuY3VyciksIG9mZnNldDogMCB9XG4gICAgICBjdXJyRGVjb2Rlci5uZXh0KClcbiAgICB9XG4gICAgZm9yIChcbiAgICAgIGxldCBuZXh0ID0gY3VyckRlY29kZXIuY3VycjtcbiAgICAgIG5leHQgIT09IG51bGwgJiYgbmV4dC5pZC5jbGllbnQgPT09IGZpcnN0Q2xpZW50ICYmIG5leHQuaWQuY2xvY2sgPT09IGN1cnJXcml0ZS5zdHJ1Y3QuaWQuY2xvY2sgKyBjdXJyV3JpdGUuc3RydWN0Lmxlbmd0aCAmJiBuZXh0LmNvbnN0cnVjdG9yICE9PSBTa2lwO1xuICAgICAgbmV4dCA9IGN1cnJEZWNvZGVyLm5leHQoKVxuICAgICkge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdEVuY29kZXIsIGN1cnJXcml0ZS5zdHJ1Y3QsIGN1cnJXcml0ZS5vZmZzZXQpXG4gICAgICBjdXJyV3JpdGUgPSB7IHN0cnVjdDogbmV4dCwgb2Zmc2V0OiAwIH1cbiAgICB9XG4gIH1cbiAgaWYgKGN1cnJXcml0ZSAhPT0gbnVsbCkge1xuICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlTdHJ1Y3RFbmNvZGVyLCBjdXJyV3JpdGUuc3RydWN0LCBjdXJyV3JpdGUub2Zmc2V0KVxuICAgIGN1cnJXcml0ZSA9IG51bGxcbiAgfVxuICBmaW5pc2hMYXp5U3RydWN0V3JpdGluZyhsYXp5U3RydWN0RW5jb2RlcilcblxuICBjb25zdCBkc3MgPSB1cGRhdGVEZWNvZGVycy5tYXAoZGVjb2RlciA9PiByZWFkRGVsZXRlU2V0KGRlY29kZXIpKVxuICBjb25zdCBkcyA9IG1lcmdlRGVsZXRlU2V0cyhkc3MpXG4gIHdyaXRlRGVsZXRlU2V0KHVwZGF0ZUVuY29kZXIsIGRzKVxuICByZXR1cm4gdXBkYXRlRW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHN2XG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVEZWNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRGVjb2RlclYyfSBbWURlY29kZXJdXG4gKiBAcGFyYW0ge3R5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfCB0eXBlb2YgVXBkYXRlRW5jb2RlclYyfSBbWUVuY29kZXJdXG4gKi9cbmV4cG9ydCBjb25zdCBkaWZmVXBkYXRlVjIgPSAodXBkYXRlLCBzdiwgWURlY29kZXIgPSBVcGRhdGVEZWNvZGVyVjIsIFlFbmNvZGVyID0gVXBkYXRlRW5jb2RlclYyKSA9PiB7XG4gIGNvbnN0IHN0YXRlID0gZGVjb2RlU3RhdGVWZWN0b3Ioc3YpXG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgWUVuY29kZXIoKVxuICBjb25zdCBsYXp5U3RydWN0V3JpdGVyID0gbmV3IExhenlTdHJ1Y3RXcml0ZXIoZW5jb2RlcilcbiAgY29uc3QgZGVjb2RlciA9IG5ldyBZRGVjb2RlcihkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSkpXG4gIGNvbnN0IHJlYWRlciA9IG5ldyBMYXp5U3RydWN0UmVhZGVyKGRlY29kZXIsIGZhbHNlKVxuICB3aGlsZSAocmVhZGVyLmN1cnIpIHtcbiAgICBjb25zdCBjdXJyID0gcmVhZGVyLmN1cnJcbiAgICBjb25zdCBjdXJyQ2xpZW50ID0gY3Vyci5pZC5jbGllbnRcbiAgICBjb25zdCBzdkNsb2NrID0gc3RhdGUuZ2V0KGN1cnJDbGllbnQpIHx8IDBcbiAgICBpZiAocmVhZGVyLmN1cnIuY29uc3RydWN0b3IgPT09IFNraXApIHtcbiAgICAgIC8vIHRoZSBmaXJzdCB3cml0dGVuIHN0cnVjdCBzaG91bGRuJ3QgYmUgYSBza2lwXG4gICAgICByZWFkZXIubmV4dCgpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpZiAoY3Vyci5pZC5jbG9jayArIGN1cnIubGVuZ3RoID4gc3ZDbG9jaykge1xuICAgICAgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIobGF6eVN0cnVjdFdyaXRlciwgY3VyciwgbWF0aC5tYXgoc3ZDbG9jayAtIGN1cnIuaWQuY2xvY2ssIDApKVxuICAgICAgcmVhZGVyLm5leHQoKVxuICAgICAgd2hpbGUgKHJlYWRlci5jdXJyICYmIHJlYWRlci5jdXJyLmlkLmNsaWVudCA9PT0gY3VyckNsaWVudCkge1xuICAgICAgICB3cml0ZVN0cnVjdFRvTGF6eVN0cnVjdFdyaXRlcihsYXp5U3RydWN0V3JpdGVyLCByZWFkZXIuY3VyciwgMClcbiAgICAgICAgcmVhZGVyLm5leHQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWFkIHVudGlsIHNvbWV0aGluZyBuZXcgY29tZXMgdXBcbiAgICAgIHdoaWxlIChyZWFkZXIuY3VyciAmJiByZWFkZXIuY3Vyci5pZC5jbGllbnQgPT09IGN1cnJDbGllbnQgJiYgcmVhZGVyLmN1cnIuaWQuY2xvY2sgKyByZWFkZXIuY3Vyci5sZW5ndGggPD0gc3ZDbG9jaykge1xuICAgICAgICByZWFkZXIubmV4dCgpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZpbmlzaExhenlTdHJ1Y3RXcml0aW5nKGxhenlTdHJ1Y3RXcml0ZXIpXG4gIC8vIHdyaXRlIGRzXG4gIGNvbnN0IGRzID0gcmVhZERlbGV0ZVNldChkZWNvZGVyKVxuICB3cml0ZURlbGV0ZVNldChlbmNvZGVyLCBkcylcbiAgcmV0dXJuIGVuY29kZXIudG9VaW50OEFycmF5KClcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBzdlxuICovXG5leHBvcnQgY29uc3QgZGlmZlVwZGF0ZSA9ICh1cGRhdGUsIHN2KSA9PiBkaWZmVXBkYXRlVjIodXBkYXRlLCBzdiwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjEpXG5cbi8qKlxuICogQHBhcmFtIHtMYXp5U3RydWN0V3JpdGVyfSBsYXp5V3JpdGVyXG4gKi9cbmNvbnN0IGZsdXNoTGF6eVN0cnVjdFdyaXRlciA9IGxhenlXcml0ZXIgPT4ge1xuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCkge1xuICAgIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5wdXNoKHsgd3JpdHRlbjogbGF6eVdyaXRlci53cml0dGVuLCByZXN0RW5jb2RlcjogZW5jb2RpbmcudG9VaW50OEFycmF5KGxhenlXcml0ZXIuZW5jb2Rlci5yZXN0RW5jb2RlcikgfSlcbiAgICBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBsYXp5V3JpdGVyLndyaXR0ZW4gPSAwXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqIEBwYXJhbSB7SXRlbSB8IEdDfSBzdHJ1Y3RcbiAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAqL1xuY29uc3Qgd3JpdGVTdHJ1Y3RUb0xhenlTdHJ1Y3RXcml0ZXIgPSAobGF6eVdyaXRlciwgc3RydWN0LCBvZmZzZXQpID0+IHtcbiAgLy8gZmx1c2ggY3VyciBpZiB3ZSBzdGFydCBhbm90aGVyIGNsaWVudFxuICBpZiAobGF6eVdyaXRlci53cml0dGVuID4gMCAmJiBsYXp5V3JpdGVyLmN1cnJDbGllbnQgIT09IHN0cnVjdC5pZC5jbGllbnQpIHtcbiAgICBmbHVzaExhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlcilcbiAgfVxuICBpZiAobGF6eVdyaXRlci53cml0dGVuID09PSAwKSB7XG4gICAgbGF6eVdyaXRlci5jdXJyQ2xpZW50ID0gc3RydWN0LmlkLmNsaWVudFxuICAgIC8vIHdyaXRlIG5leHQgY2xpZW50XG4gICAgbGF6eVdyaXRlci5lbmNvZGVyLndyaXRlQ2xpZW50KHN0cnVjdC5pZC5jbGllbnQpXG4gICAgLy8gd3JpdGUgc3RhcnRDbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXIsIHN0cnVjdC5pZC5jbG9jayArIG9mZnNldClcbiAgfVxuICBzdHJ1Y3Qud3JpdGUobGF6eVdyaXRlci5lbmNvZGVyLCBvZmZzZXQpXG4gIGxhenlXcml0ZXIud3JpdHRlbisrXG59XG4vKipcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHdlIGNvbGxlY3RlZCBhbGwgcGFydHMgYW5kIHdhbnQgdG9cbiAqIHB1dCBhbGwgdGhlIHBhcnRzIHRvZ2V0aGVyLiBBZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kLFxuICogeW91IGNhbiBjb250aW51ZSB1c2luZyB0aGUgVXBkYXRlRW5jb2Rlci5cbiAqXG4gKiBAcGFyYW0ge0xhenlTdHJ1Y3RXcml0ZXJ9IGxhenlXcml0ZXJcbiAqL1xuY29uc3QgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcgPSAobGF6eVdyaXRlcikgPT4ge1xuICBmbHVzaExhenlTdHJ1Y3RXcml0ZXIobGF6eVdyaXRlcilcblxuICAvLyB0aGlzIGlzIGEgZnJlc2ggZW5jb2RlciBiZWNhdXNlIHdlIGNhbGxlZCBmbHVzaEN1cnJcbiAgY29uc3QgcmVzdEVuY29kZXIgPSBsYXp5V3JpdGVyLmVuY29kZXIucmVzdEVuY29kZXJcblxuICAvKipcbiAgICogTm93IHdlIHB1dCBhbGwgdGhlIGZyYWdtZW50cyB0b2dldGhlci5cbiAgICogVGhpcyB3b3JrcyBzaW1pbGFybHkgdG8gYHdyaXRlQ2xpZW50c1N0cnVjdHNgXG4gICAqL1xuXG4gIC8vIHdyaXRlICMgc3RhdGVzIHRoYXQgd2VyZSB1cGRhdGVkIC0gaS5lLiB0aGUgY2xpZW50c1xuICBlbmNvZGluZy53cml0ZVZhclVpbnQocmVzdEVuY29kZXIsIGxhenlXcml0ZXIuY2xpZW50U3RydWN0cy5sZW5ndGgpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXp5V3JpdGVyLmNsaWVudFN0cnVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBwYXJ0U3RydWN0cyA9IGxhenlXcml0ZXIuY2xpZW50U3RydWN0c1tpXVxuICAgIC8qKlxuICAgICAqIFdvcmtzIHNpbWlsYXJseSB0byBgd3JpdGVTdHJ1Y3RzYFxuICAgICAqL1xuICAgIC8vIHdyaXRlICMgZW5jb2RlZCBzdHJ1Y3RzXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KHJlc3RFbmNvZGVyLCBwYXJ0U3RydWN0cy53cml0dGVuKVxuICAgIC8vIHdyaXRlIHRoZSByZXN0IG9mIHRoZSBmcmFnbWVudFxuICAgIGVuY29kaW5nLndyaXRlVWludDhBcnJheShyZXN0RW5jb2RlciwgcGFydFN0cnVjdHMucmVzdEVuY29kZXIpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihJdGVtfEdDfFNraXApOkl0ZW18R0N8U2tpcH0gYmxvY2tUcmFuc2Zvcm1lclxuICogQHBhcmFtIHt0eXBlb2YgVXBkYXRlRGVjb2RlclYyIHwgdHlwZW9mIFVwZGF0ZURlY29kZXJWMX0gWURlY29kZXJcbiAqIEBwYXJhbSB7dHlwZW9mIFVwZGF0ZUVuY29kZXJWMiB8IHR5cGVvZiBVcGRhdGVFbmNvZGVyVjEgfSBZRW5jb2RlclxuICovXG5leHBvcnQgY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdCA9ICh1cGRhdGUsIGJsb2NrVHJhbnNmb3JtZXIsIFlEZWNvZGVyLCBZRW5jb2RlcikgPT4ge1xuICBjb25zdCB1cGRhdGVEZWNvZGVyID0gbmV3IFlEZWNvZGVyKGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKSlcbiAgY29uc3QgbGF6eURlY29kZXIgPSBuZXcgTGF6eVN0cnVjdFJlYWRlcih1cGRhdGVEZWNvZGVyLCBmYWxzZSlcbiAgY29uc3QgdXBkYXRlRW5jb2RlciA9IG5ldyBZRW5jb2RlcigpXG4gIGNvbnN0IGxhenlXcml0ZXIgPSBuZXcgTGF6eVN0cnVjdFdyaXRlcih1cGRhdGVFbmNvZGVyKVxuICBmb3IgKGxldCBjdXJyID0gbGF6eURlY29kZXIuY3VycjsgY3VyciAhPT0gbnVsbDsgY3VyciA9IGxhenlEZWNvZGVyLm5leHQoKSkge1xuICAgIHdyaXRlU3RydWN0VG9MYXp5U3RydWN0V3JpdGVyKGxhenlXcml0ZXIsIGJsb2NrVHJhbnNmb3JtZXIoY3VyciksIDApXG4gIH1cbiAgZmluaXNoTGF6eVN0cnVjdFdyaXRpbmcobGF6eVdyaXRlcilcbiAgY29uc3QgZHMgPSByZWFkRGVsZXRlU2V0KHVwZGF0ZURlY29kZXIpXG4gIHdyaXRlRGVsZXRlU2V0KHVwZGF0ZUVuY29kZXIsIGRzKVxuICByZXR1cm4gdXBkYXRlRW5jb2Rlci50b1VpbnQ4QXJyYXkoKVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE9iZnVzY2F0b3JPcHRpb25zXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy5mb3JtYXR0aW5nPXRydWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy5zdWJkb2NzPXRydWVdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtPYmZ1c2NhdG9yT3B0aW9ucy55eG1sPXRydWVdIFdoZXRoZXIgdG8gb2JmdXNjYXRlIG5vZGVOYW1lIC8gaG9va05hbWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7T2JmdXNjYXRvck9wdGlvbnN9IG9iZnVzY2F0b3JcbiAqL1xuY29uc3QgY3JlYXRlT2JmdXNjYXRvciA9ICh7IGZvcm1hdHRpbmcgPSB0cnVlLCBzdWJkb2NzID0gdHJ1ZSwgeXhtbCA9IHRydWUgfSA9IHt9KSA9PiB7XG4gIGxldCBpID0gMFxuICBjb25zdCBtYXBLZXlDYWNoZSA9IG1hcC5jcmVhdGUoKVxuICBjb25zdCBub2RlTmFtZUNhY2hlID0gbWFwLmNyZWF0ZSgpXG4gIGNvbnN0IGZvcm1hdHRpbmdLZXlDYWNoZSA9IG1hcC5jcmVhdGUoKVxuICBjb25zdCBmb3JtYXR0aW5nVmFsdWVDYWNoZSA9IG1hcC5jcmVhdGUoKVxuICBmb3JtYXR0aW5nVmFsdWVDYWNoZS5zZXQobnVsbCwgbnVsbCkgLy8gZW5kIG9mIGEgZm9ybWF0dGluZyByYW5nZSBzaG91bGQgYWx3YXlzIGJlIHRoZSBlbmQgb2YgYSBmb3JtYXR0aW5nIHJhbmdlXG4gIC8qKlxuICAgKiBAcGFyYW0ge0l0ZW18R0N8U2tpcH0gYmxvY2tcbiAgICogQHJldHVybiB7SXRlbXxHQ3xTa2lwfVxuICAgKi9cbiAgcmV0dXJuIGJsb2NrID0+IHtcbiAgICBzd2l0Y2ggKGJsb2NrLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIEdDOlxuICAgICAgY2FzZSBTa2lwOlxuICAgICAgICByZXR1cm4gYmxvY2tcbiAgICAgIGNhc2UgSXRlbToge1xuICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoYmxvY2spXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpdGVtLmNvbnRlbnRcbiAgICAgICAgc3dpdGNoIChjb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50RGVsZXRlZDpcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgY2FzZSBDb250ZW50VHlwZToge1xuICAgICAgICAgICAgaWYgKHl4bWwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChjb250ZW50KS50eXBlXG4gICAgICAgICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWVhtbEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0eXBlLm5vZGVOYW1lID0gbWFwLnNldElmVW5kZWZpbmVkKG5vZGVOYW1lQ2FjaGUsIHR5cGUubm9kZU5hbWUsICgpID0+ICdub2RlLScgKyBpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICh0eXBlIGluc3RhbmNlb2YgWVhtbEhvb2spIHtcbiAgICAgICAgICAgICAgICB0eXBlLmhvb2tOYW1lID0gbWFwLnNldElmVW5kZWZpbmVkKG5vZGVOYW1lQ2FjaGUsIHR5cGUuaG9va05hbWUsICgpID0+ICdob29rLScgKyBpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRBbnk6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRBbnl9ICovIChjb250ZW50KVxuICAgICAgICAgICAgYy5hcnIgPSBjLmFyci5tYXAoKCkgPT4gaSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEJpbmFyeToge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEJpbmFyeX0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBjLmNvbnRlbnQgPSBuZXcgVWludDhBcnJheShbaV0pXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnREb2M6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnREb2N9ICovIChjb250ZW50KVxuICAgICAgICAgICAgaWYgKHN1YmRvY3MpIHtcbiAgICAgICAgICAgICAgYy5vcHRzID0ge31cbiAgICAgICAgICAgICAgYy5kb2MuZ3VpZCA9IGkgKyAnJ1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50RW1iZWQ6IHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSAvKiogQHR5cGUge0NvbnRlbnRFbWJlZH0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBjLmVtYmVkID0ge31cbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgQ29udGVudEZvcm1hdDoge1xuICAgICAgICAgICAgY29uc3QgYyA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBpZiAoZm9ybWF0dGluZykge1xuICAgICAgICAgICAgICBjLmtleSA9IG1hcC5zZXRJZlVuZGVmaW5lZChmb3JtYXR0aW5nS2V5Q2FjaGUsIGMua2V5LCAoKSA9PiBpICsgJycpXG4gICAgICAgICAgICAgIGMudmFsdWUgPSBtYXAuc2V0SWZVbmRlZmluZWQoZm9ybWF0dGluZ1ZhbHVlQ2FjaGUsIGMudmFsdWUsICgpID0+ICh7IGkgfSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIENvbnRlbnRKU09OOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50SlNPTn0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgICBjLmFyciA9IGMuYXJyLm1hcCgoKSA9PiBpKVxuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOiB7XG4gICAgICAgICAgICBjb25zdCBjID0gLyoqIEB0eXBlIHtDb250ZW50U3RyaW5nfSAqLyAoY29udGVudClcbiAgICAgICAgICAgIGMuc3RyID0gc3RyaW5nLnJlcGVhdCgoaSAlIDEwKSArICcnLCBjLnN0ci5sZW5ndGgpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gdW5rbm93biBjb250ZW50IHR5cGVcbiAgICAgICAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5wYXJlbnRTdWIpIHtcbiAgICAgICAgICBpdGVtLnBhcmVudFN1YiA9IG1hcC5zZXRJZlVuZGVmaW5lZChtYXBLZXlDYWNoZSwgaXRlbS5wYXJlbnRTdWIsICgpID0+IGkgKyAnJylcbiAgICAgICAgfVxuICAgICAgICBpKytcbiAgICAgICAgcmV0dXJuIGJsb2NrXG4gICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyB1bmtub3duIGJsb2NrLXR5cGVcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gb2JmdXNjYXRlcyB0aGUgY29udGVudCBvZiBhIFlqcyB1cGRhdGUuIFRoaXMgaXMgdXNlZnVsIHRvIHNoYXJlXG4gKiBidWdneSBZanMgZG9jdW1lbnRzIHdoaWxlIHNpZ25pZmljYW50bHkgbGltaXRpbmcgdGhlIHBvc3NpYmlsaXR5IHRoYXQgYVxuICogZGV2ZWxvcGVyIGNhbiBvbiB0aGUgdXNlci4gTm90ZSB0aGF0IGl0IG1pZ2h0IHN0aWxsIGJlIHBvc3NpYmxlIHRvIGRlZHVjZVxuICogc29tZSBpbmZvcm1hdGlvbiBieSBhbmFseXppbmcgdGhlIFwic3RydWN0dXJlXCIgb2YgdGhlIGRvY3VtZW50IG9yIGJ5IGFuYWx5emluZ1xuICogdGhlIHR5cGluZyBiZWhhdmlvciB1c2luZyB0aGUgQ1JEVC1yZWxhdGVkIG1ldGFkYXRhIHRoYXQgaXMgc3RpbGwga2VwdCBmdWxseVxuICogaW50YWN0LlxuICpcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge09iZnVzY2F0b3JPcHRpb25zfSBbb3B0c11cbiAqL1xuZXhwb3J0IGNvbnN0IG9iZnVzY2F0ZVVwZGF0ZSA9ICh1cGRhdGUsIG9wdHMpID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBjcmVhdGVPYmZ1c2NhdG9yKG9wdHMpLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMSlcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtPYmZ1c2NhdG9yT3B0aW9uc30gW29wdHNdXG4gKi9cbmV4cG9ydCBjb25zdCBvYmZ1c2NhdGVVcGRhdGVWMiA9ICh1cGRhdGUsIG9wdHMpID0+IGNvbnZlcnRVcGRhdGVGb3JtYXQodXBkYXRlLCBjcmVhdGVPYmZ1c2NhdG9yKG9wdHMpLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMilcblxuLyoqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3QgY29udmVydFVwZGF0ZUZvcm1hdFYxVG9WMiA9IHVwZGF0ZSA9PiBjb252ZXJ0VXBkYXRlRm9ybWF0KHVwZGF0ZSwgZi5pZCwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIpXG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAqL1xuZXhwb3J0IGNvbnN0IGNvbnZlcnRVcGRhdGVGb3JtYXRWMlRvVjEgPSB1cGRhdGUgPT4gY29udmVydFVwZGF0ZUZvcm1hdCh1cGRhdGUsIGYuaWQsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxKVxuIiwgImltcG9ydCB7XG4gIGlzRGVsZXRlZCxcbiAgSXRlbSwgQWJzdHJhY3RUeXBlLCBUcmFuc2FjdGlvbiwgQWJzdHJhY3RTdHJ1Y3QgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIHNldCBmcm9tICdsaWIwL3NldCdcbmltcG9ydCAqIGFzIGFycmF5IGZyb20gJ2xpYjAvYXJyYXknXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5jb25zdCBlcnJvckNvbXB1dGVDaGFuZ2VzID0gJ1lvdSBtdXN0IG5vdCBjb21wdXRlIGNoYW5nZXMgYWZ0ZXIgdGhlIGV2ZW50LWhhbmRsZXIgZmlyZWQuJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSB7QWJzdHJhY3RUeXBlPGFueT59IFRcbiAqIFlFdmVudCBkZXNjcmliZXMgdGhlIGNoYW5nZXMgb24gYSBZVHlwZS5cbiAqL1xuZXhwb3J0IGNsYXNzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHRhcmdldCBUaGUgY2hhbmdlZCB0eXBlLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3IgKHRhcmdldCwgdHJhbnNhY3Rpb24pIHtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvbiB3aGljaCB0aGlzIGV2ZW50IHdhcyBjcmVhdGVkIG9uLlxuICAgICAqIEB0eXBlIHtUfVxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0XG4gICAgLyoqXG4gICAgICogVGhlIGN1cnJlbnQgdGFyZ2V0IG9uIHdoaWNoIHRoZSBvYnNlcnZlIGNhbGxiYWNrIGlzIGNhbGxlZC5cbiAgICAgKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59XG4gICAgICovXG4gICAgdGhpcy5jdXJyZW50VGFyZ2V0ID0gdGFyZ2V0XG4gICAgLyoqXG4gICAgICogVGhlIHRyYW5zYWN0aW9uIHRoYXQgdHJpZ2dlcmVkIHRoaXMgZXZlbnQuXG4gICAgICogQHR5cGUge1RyYW5zYWN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtPYmplY3R8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9jaGFuZ2VzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgTWFwPHN0cmluZywgeyBhY3Rpb246ICdhZGQnIHwgJ3VwZGF0ZScgfCAnZGVsZXRlJywgb2xkVmFsdWU6IGFueSwgbmV3VmFsdWU6IGFueSB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9rZXlzID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgQXJyYXk8eyBpbnNlcnQ/OiBzdHJpbmcgfCBBcnJheTxhbnk+IHwgb2JqZWN0IHwgQWJzdHJhY3RUeXBlPGFueT4sIHJldGFpbj86IG51bWJlciwgZGVsZXRlPzogbnVtYmVyLCBhdHRyaWJ1dGVzPzogT2JqZWN0PHN0cmluZywgYW55PiB9Pn1cbiAgICAgKi9cbiAgICB0aGlzLl9kZWx0YSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8c3RyaW5nfG51bWJlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9wYXRoID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBwYXRoIGZyb20gYHlgIHRvIHRoZSBjaGFuZ2VkIHR5cGUuXG4gICAqXG4gICAqIEB0b2RvIHYxNCBzaG91bGQgc3RhbmRhcmRpemUgb24gcGF0aDogQXJyYXk8e3BhcmVudCwgaW5kZXh9PiBiZWNhdXNlIHRoYXQgaXMgZWFzaWVyIHRvIHdvcmsgd2l0aC5cbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBwcm9wZXJ0eSBob2xkczpcbiAgICogQGV4YW1wbGVcbiAgICogICBsZXQgdHlwZSA9IHlcbiAgICogICBldmVudC5wYXRoLmZvckVhY2goZGlyID0+IHtcbiAgICogICAgIHR5cGUgPSB0eXBlLmdldChkaXIpXG4gICAqICAgfSlcbiAgICogICB0eXBlID09PSBldmVudC50YXJnZXQgLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZ2V0IHBhdGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoIHx8ICh0aGlzLl9wYXRoID0gZ2V0UGF0aFRvKHRoaXMuY3VycmVudFRhcmdldCwgdGhpcy50YXJnZXQpKVxuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgc3RydWN0IGlzIGRlbGV0ZWQgYnkgdGhpcyBldmVudC5cbiAgICpcbiAgICogSW4gY29udHJhc3QgdG8gY2hhbmdlLmRlbGV0ZWQsIHRoaXMgbWV0aG9kIGFsc28gcmV0dXJucyB0cnVlIGlmIHRoZSBzdHJ1Y3Qgd2FzIGFkZGVkIGFuZCB0aGVuIGRlbGV0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTdHJ1Y3R9IHN0cnVjdFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgZGVsZXRlcyAoc3RydWN0KSB7XG4gICAgcmV0dXJuIGlzRGVsZXRlZCh0aGlzLnRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgc3RydWN0LmlkKVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLCB7IGFjdGlvbjogJ2FkZCcgfCAndXBkYXRlJyB8ICdkZWxldGUnLCBvbGRWYWx1ZTogYW55LCBuZXdWYWx1ZTogYW55IH0+fVxuICAgKi9cbiAgZ2V0IGtleXMgKCkge1xuICAgIGlmICh0aGlzLl9rZXlzID09PSBudWxsKSB7XG4gICAgICBpZiAodGhpcy50cmFuc2FjdGlvbi5kb2MuX3RyYW5zYWN0aW9uQ2xlYW51cHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IGVycm9yLmNyZWF0ZShlcnJvckNvbXB1dGVDaGFuZ2VzKVxuICAgICAgfVxuICAgICAgY29uc3Qga2V5cyA9IG5ldyBNYXAoKVxuICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRcbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKVxuICAgICAgY2hhbmdlZC5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBpdGVtID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAodGFyZ2V0Ll9tYXAuZ2V0KGtleSkpXG4gICAgICAgICAgLyoqXG4gICAgICAgICAgICogQHR5cGUgeydkZWxldGUnIHwgJ2FkZCcgfCAndXBkYXRlJ31cbiAgICAgICAgICAgKi9cbiAgICAgICAgICBsZXQgYWN0aW9uXG4gICAgICAgICAgbGV0IG9sZFZhbHVlXG4gICAgICAgICAgaWYgKHRoaXMuYWRkcyhpdGVtKSkge1xuICAgICAgICAgICAgbGV0IHByZXYgPSBpdGVtLmxlZnRcbiAgICAgICAgICAgIHdoaWxlIChwcmV2ICE9PSBudWxsICYmIHRoaXMuYWRkcyhwcmV2KSkge1xuICAgICAgICAgICAgICBwcmV2ID0gcHJldi5sZWZ0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdkZWxldGUnXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChwcmV2ICE9PSBudWxsICYmIHRoaXMuZGVsZXRlcyhwcmV2KSkge1xuICAgICAgICAgICAgICAgIGFjdGlvbiA9ICd1cGRhdGUnXG4gICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KHByZXYuY29udGVudC5nZXRDb250ZW50KCkpXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uID0gJ2FkZCdcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZSA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgb2xkVmFsdWUgPSBhcnJheS5sYXN0KC8qKiBAdHlwZSB7SXRlbX0gKi8gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKSlcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiAvLyBub3BcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAga2V5cy5zZXQoa2V5LCB7IGFjdGlvbiwgb2xkVmFsdWUgfSlcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIHRoaXMuX2tleXMgPSBrZXlzXG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9rZXlzXG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyBhIGNvbXB1dGVkIHByb3BlcnR5LiBOb3RlIHRoYXQgdGhpcyBjYW4gb25seSBiZSBzYWZlbHkgY29tcHV0ZWQgZHVyaW5nIHRoZVxuICAgKiBldmVudCBjYWxsLiBDb21wdXRpbmcgdGhpcyBwcm9wZXJ0eSBhZnRlciBvdGhlciBjaGFuZ2VzIGhhcHBlbmVkIG1pZ2h0IHJlc3VsdCBpblxuICAgKiB1bmV4cGVjdGVkIGJlaGF2aW9yIChpbmNvcnJlY3QgY29tcHV0YXRpb24gb2YgZGVsdGFzKS4gQSBzYWZlIHdheSB0byBjb2xsZWN0IGNoYW5nZXNcbiAgICogaXMgdG8gc3RvcmUgdGhlIGBjaGFuZ2VzYCBvciB0aGUgYGRlbHRhYCBvYmplY3QuIEF2b2lkIHN0b3JpbmcgdGhlIGB0cmFuc2FjdGlvbmAgb2JqZWN0LlxuICAgKlxuICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydD86IHN0cmluZyB8IEFycmF5PGFueT4gfCBvYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55PiwgcmV0YWluPzogbnVtYmVyLCBkZWxldGU/OiBudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLCBhbnk+fT59XG4gICAqL1xuICBnZXQgZGVsdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXMuZGVsdGFcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHN0cnVjdCBpcyBhZGRlZCBieSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBJbiBjb250cmFzdCB0byBjaGFuZ2UuZGVsZXRlZCwgdGhpcyBtZXRob2QgYWxzbyByZXR1cm5zIHRydWUgaWYgdGhlIHN0cnVjdCB3YXMgYWRkZWQgYW5kIHRoZW4gZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0cnVjdH0gc3RydWN0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBhZGRzIChzdHJ1Y3QpIHtcbiAgICByZXR1cm4gc3RydWN0LmlkLmNsb2NrID49ICh0aGlzLnRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChzdHJ1Y3QuaWQuY2xpZW50KSB8fCAwKVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYSBjb21wdXRlZCBwcm9wZXJ0eS4gTm90ZSB0aGF0IHRoaXMgY2FuIG9ubHkgYmUgc2FmZWx5IGNvbXB1dGVkIGR1cmluZyB0aGVcbiAgICogZXZlbnQgY2FsbC4gQ29tcHV0aW5nIHRoaXMgcHJvcGVydHkgYWZ0ZXIgb3RoZXIgY2hhbmdlcyBoYXBwZW5lZCBtaWdodCByZXN1bHQgaW5cbiAgICogdW5leHBlY3RlZCBiZWhhdmlvciAoaW5jb3JyZWN0IGNvbXB1dGF0aW9uIG9mIGRlbHRhcykuIEEgc2FmZSB3YXkgdG8gY29sbGVjdCBjaGFuZ2VzXG4gICAqIGlzIHRvIHN0b3JlIHRoZSBgY2hhbmdlc2Agb3IgdGhlIGBkZWx0YWAgb2JqZWN0LiBBdm9pZCBzdG9yaW5nIHRoZSBgdHJhbnNhY3Rpb25gIG9iamVjdC5cbiAgICpcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBsZXQgY2hhbmdlcyA9IHRoaXMuX2NoYW5nZXNcbiAgICBpZiAoY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMudHJhbnNhY3Rpb24uZG9jLl90cmFuc2FjdGlvbkNsZWFudXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoZXJyb3JDb21wdXRlQ2hhbmdlcylcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudGFyZ2V0XG4gICAgICBjb25zdCBhZGRlZCA9IHNldC5jcmVhdGUoKVxuICAgICAgY29uc3QgZGVsZXRlZCA9IHNldC5jcmVhdGUoKVxuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7QXJyYXk8e2luc2VydDpBcnJheTxhbnk+fXx7ZGVsZXRlOm51bWJlcn18e3JldGFpbjpudW1iZXJ9Pn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgZGVsdGEgPSBbXVxuICAgICAgY2hhbmdlcyA9IHtcbiAgICAgICAgYWRkZWQsXG4gICAgICAgIGRlbGV0ZWQsXG4gICAgICAgIGRlbHRhLFxuICAgICAgICBrZXlzOiB0aGlzLmtleXNcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5nZWQgPSAvKiogQHR5cGUgU2V0PHN0cmluZ3xudWxsPiAqLyAodGhpcy50cmFuc2FjdGlvbi5jaGFuZ2VkLmdldCh0YXJnZXQpKVxuICAgICAgaWYgKGNoYW5nZWQuaGFzKG51bGwpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7YW55fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGxhc3RPcCA9IG51bGxcbiAgICAgICAgY29uc3QgcGFja09wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChsYXN0T3ApIHtcbiAgICAgICAgICAgIGRlbHRhLnB1c2gobGFzdE9wKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpdGVtID0gdGFyZ2V0Ll9zdGFydDsgaXRlbSAhPT0gbnVsbDsgaXRlbSA9IGl0ZW0ucmlnaHQpIHtcbiAgICAgICAgICBpZiAoaXRlbS5kZWxldGVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxldGVzKGl0ZW0pICYmICF0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuZGVsZXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKVxuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgZGVsZXRlOiAwIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AuZGVsZXRlICs9IGl0ZW0ubGVuZ3RoXG4gICAgICAgICAgICAgIGRlbGV0ZWQuYWRkKGl0ZW0pXG4gICAgICAgICAgICB9IC8vIGVsc2Ugbm9wXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZHMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AuaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKVxuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgaW5zZXJ0OiBbXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGFzdE9wLmluc2VydCA9IGxhc3RPcC5pbnNlcnQuY29uY2F0KGl0ZW0uY29udGVudC5nZXRDb250ZW50KCkpXG4gICAgICAgICAgICAgIGFkZGVkLmFkZChpdGVtKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGxhc3RPcCA9PT0gbnVsbCB8fCBsYXN0T3AucmV0YWluID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrT3AoKVxuICAgICAgICAgICAgICAgIGxhc3RPcCA9IHsgcmV0YWluOiAwIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsYXN0T3AucmV0YWluICs9IGl0ZW0ubGVuZ3RoXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0T3AgIT09IG51bGwgJiYgbGFzdE9wLnJldGFpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcGFja09wKClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2hhbmdlcyA9IGNoYW5nZXNcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7YW55fSAqLyAoY2hhbmdlcylcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHBhdGggZnJvbSB0aGlzIHR5cGUgdG8gdGhlIHNwZWNpZmllZCB0YXJnZXQuXG4gKlxuICogQGV4YW1wbGVcbiAqICAgLy8gYGNoaWxkYCBzaG91bGQgYmUgYWNjZXNzaWJsZSB2aWEgYHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKS4uYFxuICogICBjb25zdCBwYXRoID0gdHlwZS5nZXRQYXRoVG8oY2hpbGQpXG4gKiAgIC8vIGFzc3VtaW5nIGB0eXBlIGluc3RhbmNlb2YgWUFycmF5YFxuICogICBjb25zb2xlLmxvZyhwYXRoKSAvLyBtaWdodCBsb29rIGxpa2UgPT4gWzIsICdrZXkxJ11cbiAqICAgY2hpbGQgPT09IHR5cGUuZ2V0KHBhdGhbMF0pLmdldChwYXRoWzFdKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gY2hpbGQgdGFyZ2V0XG4gKiBAcmV0dXJuIHtBcnJheTxzdHJpbmd8bnVtYmVyPn0gUGF0aCB0byB0aGUgdGFyZ2V0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBnZXRQYXRoVG8gPSAocGFyZW50LCBjaGlsZCkgPT4ge1xuICBjb25zdCBwYXRoID0gW11cbiAgd2hpbGUgKGNoaWxkLl9pdGVtICE9PSBudWxsICYmIGNoaWxkICE9PSBwYXJlbnQpIHtcbiAgICBpZiAoY2hpbGQuX2l0ZW0ucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAvLyBwYXJlbnQgaXMgbWFwLWlzaFxuICAgICAgcGF0aC51bnNoaWZ0KGNoaWxkLl9pdGVtLnBhcmVudFN1YilcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIGFycmF5LWlzaFxuICAgICAgbGV0IGkgPSAwXG4gICAgICBsZXQgYyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpLl9zdGFydFxuICAgICAgd2hpbGUgKGMgIT09IGNoaWxkLl9pdGVtICYmIGMgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKCFjLmRlbGV0ZWQgJiYgYy5jb3VudGFibGUpIHtcbiAgICAgICAgICBpICs9IGMubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgICAgYyA9IGMucmlnaHRcbiAgICAgIH1cbiAgICAgIHBhdGgudW5zaGlmdChpKVxuICAgIH1cbiAgICBjaGlsZCA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChjaGlsZC5faXRlbS5wYXJlbnQpXG4gIH1cbiAgcmV0dXJuIHBhdGhcbn1cbiIsICJpbXBvcnQge1xuICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcixcbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyxcbiAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIsXG4gIGNyZWF0ZUV2ZW50SGFuZGxlcixcbiAgZ2V0U3RhdGUsXG4gIGlzVmlzaWJsZSxcbiAgQ29udGVudFR5cGUsXG4gIGNyZWF0ZUlELFxuICBDb250ZW50QW55LFxuICBDb250ZW50QmluYXJ5LFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgQ29udGVudERvYywgWVRleHQsIFlBcnJheSwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIERvYywgU25hcHNob3QsIFRyYW5zYWN0aW9uLCBFdmVudEhhbmRsZXIsIFlFdmVudCwgSXRlbSwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIG1hcCBmcm9tICdsaWIwL21hcCdcbmltcG9ydCAqIGFzIGl0ZXJhdG9yIGZyb20gJ2xpYjAvaXRlcmF0b3InXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5cbmNvbnN0IG1heFNlYXJjaE1hcmtlciA9IDgwXG5cbi8qKlxuICogQSB1bmlxdWUgdGltZXN0YW1wIHRoYXQgaWRlbnRpZmllcyBlYWNoIG1hcmtlci5cbiAqXG4gKiBUaW1lIGlzIHJlbGF0aXZlLC4uIHRoaXMgaXMgbW9yZSBsaWtlIGFuIGV2ZXItaW5jcmVhc2luZyBjbG9jay5cbiAqXG4gKiBAdHlwZSB7bnVtYmVyfVxuICovXG5sZXQgZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wID0gMFxuXG5leHBvcnQgY2xhc3MgQXJyYXlTZWFyY2hNYXJrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtJdGVtfSBwXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHAsIGluZGV4KSB7XG4gICAgcC5tYXJrZXIgPSB0cnVlXG4gICAgdGhpcy5wID0gcFxuICAgIHRoaXMuaW5kZXggPSBpbmRleFxuICAgIHRoaXMudGltZXN0YW1wID0gZ2xvYmFsU2VhcmNoTWFya2VyVGltZXN0YW1wKytcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXlTZWFyY2hNYXJrZXJ9IG1hcmtlclxuICovXG5jb25zdCByZWZyZXNoTWFya2VyVGltZXN0YW1wID0gbWFya2VyID0+IHsgbWFya2VyLnRpbWVzdGFtcCA9IGdsb2JhbFNlYXJjaE1hcmtlclRpbWVzdGFtcCsrIH1cblxuLyoqXG4gKiBUaGlzIGlzIHJhdGhlciBjb21wbGV4IHNvIHRoaXMgZnVuY3Rpb24gaXMgdGhlIG9ubHkgdGhpbmcgdGhhdCBzaG91bGQgb3ZlcndyaXRlIGEgbWFya2VyXG4gKlxuICogQHBhcmFtIHtBcnJheVNlYXJjaE1hcmtlcn0gbWFya2VyXG4gKiBAcGFyYW0ge0l0ZW19IHBcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICovXG5jb25zdCBvdmVyd3JpdGVNYXJrZXIgPSAobWFya2VyLCBwLCBpbmRleCkgPT4ge1xuICBtYXJrZXIucC5tYXJrZXIgPSBmYWxzZVxuICBtYXJrZXIucCA9IHBcbiAgcC5tYXJrZXIgPSB0cnVlXG4gIG1hcmtlci5pbmRleCA9IGluZGV4XG4gIG1hcmtlci50aW1lc3RhbXAgPSBnbG9iYWxTZWFyY2hNYXJrZXJUaW1lc3RhbXArK1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXlTZWFyY2hNYXJrZXI+fSBzZWFyY2hNYXJrZXJcbiAqIEBwYXJhbSB7SXRlbX0gcFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmNvbnN0IG1hcmtQb3NpdGlvbiA9IChzZWFyY2hNYXJrZXIsIHAsIGluZGV4KSA9PiB7XG4gIGlmIChzZWFyY2hNYXJrZXIubGVuZ3RoID49IG1heFNlYXJjaE1hcmtlcikge1xuICAgIC8vIG92ZXJyaWRlIG9sZGVzdCBtYXJrZXIgKHdlIGRvbid0IHdhbnQgdG8gY3JlYXRlIG1vcmUgb2JqZWN0cylcbiAgICBjb25zdCBtYXJrZXIgPSBzZWFyY2hNYXJrZXIucmVkdWNlKChhLCBiKSA9PiBhLnRpbWVzdGFtcCA8IGIudGltZXN0YW1wID8gYSA6IGIpXG4gICAgb3ZlcndyaXRlTWFya2VyKG1hcmtlciwgcCwgaW5kZXgpXG4gICAgcmV0dXJuIG1hcmtlclxuICB9IGVsc2Uge1xuICAgIC8vIGNyZWF0ZSBuZXcgbWFya2VyXG4gICAgY29uc3QgcG0gPSBuZXcgQXJyYXlTZWFyY2hNYXJrZXIocCwgaW5kZXgpXG4gICAgc2VhcmNoTWFya2VyLnB1c2gocG0pXG4gICAgcmV0dXJuIHBtXG4gIH1cbn1cblxuLyoqXG4gKiBTZWFyY2ggbWFya2VyIGhlbHAgdXMgdG8gZmluZCBwb3NpdGlvbnMgaW4gdGhlIGFzc29jaWF0aXZlIGFycmF5IGZhc3Rlci5cbiAqXG4gKiBUaGV5IHNwZWVkIHVwIHRoZSBwcm9jZXNzIG9mIGZpbmRpbmcgYSBwb3NpdGlvbiB3aXRob3V0IG11Y2ggYm9va2tlZXBpbmcuXG4gKlxuICogQSBtYXhpbXVtIG9mIGBtYXhTZWFyY2hNYXJrZXJgIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhbHdheXMgcmV0dXJucyBhIHJlZnJlc2hlZCBtYXJrZXIgKHVwZGF0ZWQgdGltZXN0YW1wKVxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHlhcnJheVxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKi9cbmV4cG9ydCBjb25zdCBmaW5kTWFya2VyID0gKHlhcnJheSwgaW5kZXgpID0+IHtcbiAgaWYgKHlhcnJheS5fc3RhcnQgPT09IG51bGwgfHwgaW5kZXggPT09IDAgfHwgeWFycmF5Ll9zZWFyY2hNYXJrZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIGNvbnN0IG1hcmtlciA9IHlhcnJheS5fc2VhcmNoTWFya2VyLmxlbmd0aCA9PT0gMCA/IG51bGwgOiB5YXJyYXkuX3NlYXJjaE1hcmtlci5yZWR1Y2UoKGEsIGIpID0+IG1hdGguYWJzKGluZGV4IC0gYS5pbmRleCkgPCBtYXRoLmFicyhpbmRleCAtIGIuaW5kZXgpID8gYSA6IGIpXG4gIGxldCBwID0geWFycmF5Ll9zdGFydFxuICBsZXQgcGluZGV4ID0gMFxuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgcCA9IG1hcmtlci5wXG4gICAgcGluZGV4ID0gbWFya2VyLmluZGV4XG4gICAgcmVmcmVzaE1hcmtlclRpbWVzdGFtcChtYXJrZXIpIC8vIHdlIHVzZWQgaXQsIHdlIG1pZ2h0IG5lZWQgdG8gdXNlIGl0IGFnYWluXG4gIH1cbiAgLy8gaXRlcmF0ZSB0byByaWdodCBpZiBwb3NzaWJsZVxuICB3aGlsZSAocC5yaWdodCAhPT0gbnVsbCAmJiBwaW5kZXggPCBpbmRleCkge1xuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPCBwaW5kZXggKyBwLmxlbmd0aCkge1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcGluZGV4ICs9IHAubGVuZ3RoXG4gICAgfVxuICAgIHAgPSBwLnJpZ2h0XG4gIH1cbiAgLy8gaXRlcmF0ZSB0byBsZWZ0IGlmIG5lY2Vzc2FyeSAobWlnaHQgYmUgdGhhdCBwaW5kZXggPiBpbmRleClcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwaW5kZXggPiBpbmRleCkge1xuICAgIHAgPSBwLmxlZnRcbiAgICBpZiAoIXAuZGVsZXRlZCAmJiBwLmNvdW50YWJsZSkge1xuICAgICAgcGluZGV4IC09IHAubGVuZ3RoXG4gICAgfVxuICB9XG4gIC8vIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgcCBjYW4ndCBiZSBtZXJnZWQgd2l0aCBsZWZ0LCBiZWNhdXNlIHRoYXQgd291bGQgc2NyZXcgdXAgZXZlcnl0aGluZ1xuICAvLyBpbiB0aGF0IGNhcyBqdXN0IHJldHVybiB3aGF0IHdlIGhhdmUgKGl0IGlzIG1vc3QgbGlrZWx5IHRoZSBiZXN0IG1hcmtlciBhbnl3YXkpXG4gIC8vIGl0ZXJhdGUgdG8gbGVmdCB1bnRpbCBwIGNhbid0IGJlIG1lcmdlZCB3aXRoIGxlZnRcbiAgd2hpbGUgKHAubGVmdCAhPT0gbnVsbCAmJiBwLmxlZnQuaWQuY2xpZW50ID09PSBwLmlkLmNsaWVudCAmJiBwLmxlZnQuaWQuY2xvY2sgKyBwLmxlZnQubGVuZ3RoID09PSBwLmlkLmNsb2NrKSB7XG4gICAgcCA9IHAubGVmdFxuICAgIGlmICghcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICBwaW5kZXggLT0gcC5sZW5ndGhcbiAgICB9XG4gIH1cblxuICAvLyBAdG9kbyByZW1vdmUhXG4gIC8vIGFzc3VyZSBwb3NpdGlvblxuICAvLyB7XG4gIC8vICAgbGV0IHN0YXJ0ID0geWFycmF5Ll9zdGFydFxuICAvLyAgIGxldCBwb3MgPSAwXG4gIC8vICAgd2hpbGUgKHN0YXJ0ICE9PSBwKSB7XG4gIC8vICAgICBpZiAoIXN0YXJ0LmRlbGV0ZWQgJiYgc3RhcnQuY291bnRhYmxlKSB7XG4gIC8vICAgICAgIHBvcyArPSBzdGFydC5sZW5ndGhcbiAgLy8gICAgIH1cbiAgLy8gICAgIHN0YXJ0ID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAoc3RhcnQucmlnaHQpXG4gIC8vICAgfVxuICAvLyAgIGlmIChwb3MgIT09IHBpbmRleCkge1xuICAvLyAgICAgZGVidWdnZXJcbiAgLy8gICAgIHRocm93IG5ldyBFcnJvcignR290Y2hhIHBvc2l0aW9uIGZhaWwhJylcbiAgLy8gICB9XG4gIC8vIH1cbiAgLy8gaWYgKG1hcmtlcikge1xuICAvLyAgIGlmICh3aW5kb3cubGVuZ3RoZXMgPT0gbnVsbCkge1xuICAvLyAgICAgd2luZG93Lmxlbmd0aGVzID0gW11cbiAgLy8gICAgIHdpbmRvdy5nZXRMZW5ndGhlcyA9ICgpID0+IHdpbmRvdy5sZW5ndGhlcy5zb3J0KChhLCBiKSA9PiBhIC0gYilcbiAgLy8gICB9XG4gIC8vICAgd2luZG93Lmxlbmd0aGVzLnB1c2gobWFya2VyLmluZGV4IC0gcGluZGV4KVxuICAvLyAgIGNvbnNvbGUubG9nKCdkaXN0YW5jZScsIG1hcmtlci5pbmRleCAtIHBpbmRleCwgJ2xlbicsIHAgJiYgcC5wYXJlbnQubGVuZ3RoKVxuICAvLyB9XG4gIGlmIChtYXJrZXIgIT09IG51bGwgJiYgbWF0aC5hYnMobWFya2VyLmluZGV4IC0gcGluZGV4KSA8IC8qKiBAdHlwZSB7WVRleHR8WUFycmF5PGFueT59ICovIChwLnBhcmVudCkubGVuZ3RoIC8gbWF4U2VhcmNoTWFya2VyKSB7XG4gICAgLy8gYWRqdXN0IGV4aXN0aW5nIG1hcmtlclxuICAgIG92ZXJ3cml0ZU1hcmtlcihtYXJrZXIsIHAsIHBpbmRleClcbiAgICByZXR1cm4gbWFya2VyXG4gIH0gZWxzZSB7XG4gICAgLy8gY3JlYXRlIG5ldyBtYXJrZXJcbiAgICByZXR1cm4gbWFya1Bvc2l0aW9uKHlhcnJheS5fc2VhcmNoTWFya2VyLCBwLCBwaW5kZXgpXG4gIH1cbn1cblxuLyoqXG4gKiBVcGRhdGUgbWFya2VycyB3aGVuIGEgY2hhbmdlIGhhcHBlbmVkLlxuICpcbiAqIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgZG9pbmcgYSBkZWxldGlvbiFcbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn0gc2VhcmNoTWFya2VyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW4gSWYgaW5zZXJ0aW9uLCBsZW4gaXMgcG9zaXRpdmUuIElmIGRlbGV0aW9uLCBsZW4gaXMgbmVnYXRpdmUuXG4gKi9cbmV4cG9ydCBjb25zdCB1cGRhdGVNYXJrZXJDaGFuZ2VzID0gKHNlYXJjaE1hcmtlciwgaW5kZXgsIGxlbikgPT4ge1xuICBmb3IgKGxldCBpID0gc2VhcmNoTWFya2VyLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgY29uc3QgbSA9IHNlYXJjaE1hcmtlcltpXVxuICAgIGlmIChsZW4gPiAwKSB7XG4gICAgICAvKipcbiAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgKi9cbiAgICAgIGxldCBwID0gbS5wXG4gICAgICBwLm1hcmtlciA9IGZhbHNlXG4gICAgICAvLyBJZGVhbGx5IHdlIGp1c3Qgd2FudCB0byBkbyBhIHNpbXBsZSBwb3NpdGlvbiBjb21wYXJpc29uLCBidXQgdGhpcyB3aWxsIG9ubHkgd29yayBpZlxuICAgICAgLy8gc2VhcmNoIG1hcmtlcnMgZG9uJ3QgcG9pbnQgdG8gZGVsZXRlZCBpdGVtcyBmb3IgZm9ybWF0cy5cbiAgICAgIC8vIEl0ZXJhdGUgbWFya2VyIHRvIHByZXYgdW5kZWxldGVkIGNvdW50YWJsZSBwb3NpdGlvbiBzbyB3ZSBrbm93IHdoYXQgdG8gZG8gd2hlbiB1cGRhdGluZyBhIHBvc2l0aW9uXG4gICAgICB3aGlsZSAocCAmJiAocC5kZWxldGVkIHx8ICFwLmNvdW50YWJsZSkpIHtcbiAgICAgICAgcCA9IHAubGVmdFxuICAgICAgICBpZiAocCAmJiAhcC5kZWxldGVkICYmIHAuY291bnRhYmxlKSB7XG4gICAgICAgICAgLy8gYWRqdXN0IHBvc2l0aW9uLiB0aGUgbG9vcCBzaG91bGQgYnJlYWsgbm93XG4gICAgICAgICAgbS5pbmRleCAtPSBwLmxlbmd0aFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocCA9PT0gbnVsbCB8fCBwLm1hcmtlciA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyByZW1vdmUgc2VhcmNoIG1hcmtlciBpZiB1cGRhdGVkIHBvc2l0aW9uIGlzIG51bGwgb3IgaWYgcG9zaXRpb24gaXMgYWxyZWFkeSBtYXJrZWRcbiAgICAgICAgc2VhcmNoTWFya2VyLnNwbGljZShpLCAxKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbS5wID0gcFxuICAgICAgcC5tYXJrZXIgPSB0cnVlXG4gICAgfVxuICAgIGlmIChpbmRleCA8IG0uaW5kZXggfHwgKGxlbiA+IDAgJiYgaW5kZXggPT09IG0uaW5kZXgpKSB7IC8vIGEgc2ltcGxlIGluZGV4IDw9IG0uaW5kZXggY2hlY2sgd291bGQgYWN0dWFsbHkgc3VmZmljZVxuICAgICAgbS5pbmRleCA9IG1hdGgubWF4KGluZGV4LCBtLmluZGV4ICsgbGVuKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGUgYWxsIChsaXN0KSBjaGlsZHJlbiBvZiBhIHR5cGUgYW5kIHJldHVybiB0aGVtIGFzIGFuIEFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHRcbiAqIEByZXR1cm4ge0FycmF5PEl0ZW0+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0VHlwZUNoaWxkcmVuID0gdCA9PiB7XG4gIGxldCBzID0gdC5fc3RhcnRcbiAgY29uc3QgYXJyID0gW11cbiAgd2hpbGUgKHMpIHtcbiAgICBhcnIucHVzaChzKVxuICAgIHMgPSBzLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIGFyclxufVxuXG4vKipcbiAqIENhbGwgZXZlbnQgbGlzdGVuZXJzIHdpdGggYW4gZXZlbnQuIFRoaXMgd2lsbCBhbHNvIGFkZCBhbiBldmVudCB0byBhbGxcbiAqIHBhcmVudHMgKGZvciBgLm9ic2VydmVEZWVwYCBoYW5kbGVycykuXG4gKlxuICogQHRlbXBsYXRlIEV2ZW50VHlwZVxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8RXZlbnRUeXBlPn0gdHlwZVxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7RXZlbnRUeXBlfSBldmVudFxuICovXG5leHBvcnQgY29uc3QgY2FsbFR5cGVPYnNlcnZlcnMgPSAodHlwZSwgdHJhbnNhY3Rpb24sIGV2ZW50KSA9PiB7XG4gIGNvbnN0IGNoYW5nZWRUeXBlID0gdHlwZVxuICBjb25zdCBjaGFuZ2VkUGFyZW50VHlwZXMgPSB0cmFuc2FjdGlvbi5jaGFuZ2VkUGFyZW50VHlwZXNcbiAgd2hpbGUgKHRydWUpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgbWFwLnNldElmVW5kZWZpbmVkKGNoYW5nZWRQYXJlbnRUeXBlcywgdHlwZSwgKCkgPT4gW10pLnB1c2goZXZlbnQpXG4gICAgaWYgKHR5cGUuX2l0ZW0gPT09IG51bGwpIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIHR5cGUgPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodHlwZS5faXRlbS5wYXJlbnQpXG4gIH1cbiAgY2FsbEV2ZW50SGFuZGxlckxpc3RlbmVycyhjaGFuZ2VkVHlwZS5fZUgsIGV2ZW50LCB0cmFuc2FjdGlvbilcbn1cblxuLyoqXG4gKiBAdGVtcGxhdGUgRXZlbnRUeXBlXG4gKiBBYnN0cmFjdCBZanMgVHlwZSBjbGFzc1xuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RUeXBlIHtcbiAgY29uc3RydWN0b3IgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5faXRlbSA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZyxJdGVtPn1cbiAgICAgKi9cbiAgICB0aGlzLl9tYXAgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMuX3N0YXJ0ID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRvYyA9IG51bGxcbiAgICB0aGlzLl9sZW5ndGggPSAwXG4gICAgLyoqXG4gICAgICogRXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEV2ZW50VHlwZSxUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fZUggPSBjcmVhdGVFdmVudEhhbmRsZXIoKVxuICAgIC8qKlxuICAgICAqIERlZXAgZXZlbnQgaGFuZGxlcnNcbiAgICAgKiBAdHlwZSB7RXZlbnRIYW5kbGVyPEFycmF5PFlFdmVudDxhbnk+PixUcmFuc2FjdGlvbj59XG4gICAgICovXG4gICAgdGhpcy5fZEVIID0gY3JlYXRlRXZlbnRIYW5kbGVyKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbCB8IEFycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPGFueT58bnVsbH1cbiAgICovXG4gIGdldCBwYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLl9pdGVtID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMuX2l0ZW0ucGFyZW50KSA6IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHRoaXMuZG9jID0geVxuICAgIHRoaXMuX2l0ZW0gPSBpdGVtXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7QWJzdHJhY3RUeXBlPEV2ZW50VHlwZT59XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IF9lbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKF9lbmNvZGVyKSB7IH1cblxuICAvKipcbiAgICogVGhlIGZpcnN0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBfZmlyc3QgKCkge1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnRcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZRXZlbnQgYW5kIGNhbGxzIGFsbCB0eXBlIG9ic2VydmVycy5cbiAgICogTXVzdCBiZSBpbXBsZW1lbnRlZCBieSBlYWNoIHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gX3BhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIF9wYXJlbnRTdWJzKSB7XG4gICAgaWYgKCF0cmFuc2FjdGlvbi5sb2NhbCAmJiB0aGlzLl9zZWFyY2hNYXJrZXIpIHtcbiAgICAgIHRoaXMuX3NlYXJjaE1hcmtlci5sZW5ndGggPSAwXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE9ic2VydmUgYWxsIGV2ZW50cyB0aGF0IGFyZSBjcmVhdGVkIG9uIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihFdmVudFR5cGUsIFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlIChmKSB7XG4gICAgYWRkRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpXG4gIH1cblxuICAvKipcbiAgICogT2JzZXJ2ZSBhbGwgZXZlbnRzIHRoYXQgYXJlIGNyZWF0ZWQgYnkgdGhpcyB0eXBlIGFuZCBpdHMgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQXJyYXk8WUV2ZW50PGFueT4+LFRyYW5zYWN0aW9uKTp2b2lkfSBmIE9ic2VydmVyIGZ1bmN0aW9uXG4gICAqL1xuICBvYnNlcnZlRGVlcCAoZikge1xuICAgIGFkZEV2ZW50SGFuZGxlckxpc3RlbmVyKHRoaXMuX2RFSCwgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVyIGFuIG9ic2VydmVyIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEV2ZW50VHlwZSxUcmFuc2FjdGlvbik6dm9pZH0gZiBPYnNlcnZlciBmdW5jdGlvblxuICAgKi9cbiAgdW5vYnNlcnZlIChmKSB7XG4gICAgcmVtb3ZlRXZlbnRIYW5kbGVyTGlzdGVuZXIodGhpcy5fZUgsIGYpXG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlciBhbiBvYnNlcnZlciBmdW5jdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihBcnJheTxZRXZlbnQ8YW55Pj4sVHJhbnNhY3Rpb24pOnZvaWR9IGYgT2JzZXJ2ZXIgZnVuY3Rpb25cbiAgICovXG4gIHVub2JzZXJ2ZURlZXAgKGYpIHtcbiAgICByZW1vdmVFdmVudEhhbmRsZXJMaXN0ZW5lcih0aGlzLl9kRUgsIGYpXG4gIH1cblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge2FueX1cbiAgICovXG4gIHRvSlNPTiAoKSB7fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtudW1iZXJ9IGVuZFxuICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdFNsaWNlID0gKHR5cGUsIHN0YXJ0LCBlbmQpID0+IHtcbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdHlwZS5fbGVuZ3RoICsgc3RhcnRcbiAgfVxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCA9IHR5cGUuX2xlbmd0aCArIGVuZFxuICB9XG4gIGxldCBsZW4gPSBlbmQgLSBzdGFydFxuICBjb25zdCBjcyA9IFtdXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwgJiYgbGVuID4gMCkge1xuICAgIGlmIChuLmNvdW50YWJsZSAmJiAhbi5kZWxldGVkKSB7XG4gICAgICBjb25zdCBjID0gbi5jb250ZW50LmdldENvbnRlbnQoKVxuICAgICAgaWYgKGMubGVuZ3RoIDw9IHN0YXJ0KSB7XG4gICAgICAgIHN0YXJ0IC09IGMubGVuZ3RoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBjLmxlbmd0aCAmJiBsZW4gPiAwOyBpKyspIHtcbiAgICAgICAgICBjcy5wdXNoKGNbaV0pXG4gICAgICAgICAgbGVuLS1cbiAgICAgICAgfVxuICAgICAgICBzdGFydCA9IDBcbiAgICAgIH1cbiAgICB9XG4gICAgbiA9IG4ucmlnaHRcbiAgfVxuICByZXR1cm4gY3Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0VG9BcnJheSA9IHR5cGUgPT4ge1xuICBjb25zdCBjcyA9IFtdXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgIW4uZGVsZXRlZCkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjcy5wdXNoKGNbaV0pXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbiAgcmV0dXJuIGNzXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RUb0FycmF5U25hcHNob3QgPSAodHlwZSwgc25hcHNob3QpID0+IHtcbiAgY29uc3QgY3MgPSBbXVxuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmIGlzVmlzaWJsZShuLCBzbmFwc2hvdCkpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3MucHVzaChjW2ldKVxuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodFxuICB9XG4gIHJldHVybiBjc1xufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICpcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LG51bWJlcixhbnkpOnZvaWR9IGYgQSBmdW5jdGlvbiB0byBleGVjdXRlIG9uIGV2ZXJ5IGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RGb3JFYWNoID0gKHR5cGUsIGYpID0+IHtcbiAgbGV0IGluZGV4ID0gMFxuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIHdoaWxlIChuICE9PSBudWxsKSB7XG4gICAgaWYgKG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpIHtcbiAgICAgIGNvbnN0IGMgPSBuLmNvbnRlbnQuZ2V0Q29udGVudCgpXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZihjW2ldLCBpbmRleCsrLCB0eXBlKVxuICAgICAgfVxuICAgIH1cbiAgICBuID0gbi5yaWdodFxuICB9XG59XG5cbi8qKlxuICogQHRlbXBsYXRlIEMsUlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihDLG51bWJlcixBYnN0cmFjdFR5cGU8YW55Pik6Un0gZlxuICogQHJldHVybiB7QXJyYXk8Uj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RNYXAgPSAodHlwZSwgZikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAqL1xuICBjb25zdCByZXN1bHQgPSBbXVxuICB0eXBlTGlzdEZvckVhY2godHlwZSwgKGMsIGkpID0+IHtcbiAgICByZXN1bHQucHVzaChmKGMsIGksIHR5cGUpKVxuICB9KVxuICByZXR1cm4gcmVzdWx0XG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVMaXN0Q3JlYXRlSXRlcmF0b3IgPSB0eXBlID0+IHtcbiAgbGV0IG4gPSB0eXBlLl9zdGFydFxuICAvKipcbiAgICogQHR5cGUge0FycmF5PGFueT58bnVsbH1cbiAgICovXG4gIGxldCBjdXJyZW50Q29udGVudCA9IG51bGxcbiAgbGV0IGN1cnJlbnRDb250ZW50SW5kZXggPSAwXG4gIHJldHVybiB7XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICB9LFxuICAgIG5leHQ6ICgpID0+IHtcbiAgICAgIC8vIGZpbmQgc29tZSBjb250ZW50XG4gICAgICBpZiAoY3VycmVudENvbnRlbnQgPT09IG51bGwpIHtcbiAgICAgICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICAgICAgbiA9IG4ucmlnaHRcbiAgICAgICAgfVxuICAgICAgICAvLyBjaGVjayBpZiB3ZSByZWFjaGVkIHRoZSBlbmQsIG5vIG5lZWQgdG8gY2hlY2sgY3VycmVudENvbnRlbnQsIGJlY2F1c2UgaXQgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gd2UgZm91bmQgbiwgc28gd2UgY2FuIHNldCBjdXJyZW50Q29udGVudFxuICAgICAgICBjdXJyZW50Q29udGVudCA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgICAgY3VycmVudENvbnRlbnRJbmRleCA9IDBcbiAgICAgICAgbiA9IG4ucmlnaHQgLy8gd2UgdXNlZCB0aGUgY29udGVudCBvZiBuLCBub3cgaXRlcmF0ZSB0byBuZXh0XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZSA9IGN1cnJlbnRDb250ZW50W2N1cnJlbnRDb250ZW50SW5kZXgrK11cbiAgICAgIC8vIGNoZWNrIGlmIHdlIG5lZWQgdG8gZW1wdHkgY3VycmVudENvbnRlbnRcbiAgICAgIGlmIChjdXJyZW50Q29udGVudC5sZW5ndGggPD0gY3VycmVudENvbnRlbnRJbmRleCkge1xuICAgICAgICBjdXJyZW50Q29udGVudCA9IG51bGxcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb24gb25jZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICogT3BlcmF0ZXMgb24gYSBzbmFwc2hvdHRlZCBzdGF0ZSBvZiB0aGUgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gdHlwZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksbnVtYmVyLEFic3RyYWN0VHlwZTxhbnk+KTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICogQHBhcmFtIHtTbmFwc2hvdH0gc25hcHNob3RcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEZvckVhY2hTbmFwc2hvdCA9ICh0eXBlLCBmLCBzbmFwc2hvdCkgPT4ge1xuICBsZXQgaW5kZXggPSAwXG4gIGxldCBuID0gdHlwZS5fc3RhcnRcbiAgd2hpbGUgKG4gIT09IG51bGwpIHtcbiAgICBpZiAobi5jb3VudGFibGUgJiYgaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgY29uc3QgYyA9IG4uY29udGVudC5nZXRDb250ZW50KClcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmKGNbaV0sIGluZGV4KyssIHR5cGUpXG4gICAgICB9XG4gICAgfVxuICAgIG4gPSBuLnJpZ2h0XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSB0eXBlXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEByZXR1cm4ge2FueX1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEdldCA9ICh0eXBlLCBpbmRleCkgPT4ge1xuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHR5cGUsIGluZGV4KVxuICBsZXQgbiA9IHR5cGUuX3N0YXJ0XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnBcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXhcbiAgfVxuICBmb3IgKDsgbiAhPT0gbnVsbDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG4uY29udGVudC5nZXRDb250ZW50KClbaW5kZXhdXG4gICAgICB9XG4gICAgICBpbmRleCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbT99IHJlZmVyZW5jZUl0ZW1cbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58Ym9vbGVhbnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgcmVmZXJlbmNlSXRlbSwgY29udGVudCkgPT4ge1xuICBsZXQgbGVmdCA9IHJlZmVyZW5jZUl0ZW1cbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEXG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gIGNvbnN0IHJpZ2h0ID0gcmVmZXJlbmNlSXRlbSA9PT0gbnVsbCA/IHBhcmVudC5fc3RhcnQgOiByZWZlcmVuY2VJdGVtLnJpZ2h0XG4gIC8qKlxuICAgKiBAdHlwZSB7QXJyYXk8T2JqZWN0fEFycmF5PGFueT58bnVtYmVyfG51bGw+fVxuICAgKi9cbiAgbGV0IGpzb25Db250ZW50ID0gW11cbiAgY29uc3QgcGFja0pzb25Db250ZW50ID0gKCkgPT4ge1xuICAgIGlmIChqc29uQ29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRBbnkoanNvbkNvbnRlbnQpKVxuICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgICBqc29uQ29udGVudCA9IFtdXG4gICAgfVxuICB9XG4gIGNvbnRlbnQuZm9yRWFjaChjID0+IHtcbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAganNvbkNvbnRlbnQucHVzaChjKVxuICAgIH0gZWxzZSB7XG4gICAgICBzd2l0Y2ggKGMuY29uc3RydWN0b3IpIHtcbiAgICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICBjYXNlIEJvb2xlYW46XG4gICAgICAgIGNhc2UgQXJyYXk6XG4gICAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICAgIGpzb25Db250ZW50LnB1c2goYylcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHBhY2tKc29uQ29udGVudCgpXG4gICAgICAgICAgc3dpdGNoIChjLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICAgICAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgICAgICAgICBsZWZ0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRCaW5hcnkobmV3IFVpbnQ4QXJyYXkoLyoqIEB0eXBlIHtVaW50OEFycmF5fSAqLyAoYykpKSlcbiAgICAgICAgICAgICAgbGVmdC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICBjYXNlIERvYzpcbiAgICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50RG9jKC8qKiBAdHlwZSB7RG9jfSAqLyAoYykpKVxuICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIGlmIChjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlKSB7XG4gICAgICAgICAgICAgICAgbGVmdCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShzdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50VHlwZShjKSlcbiAgICAgICAgICAgICAgICBsZWZ0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgY29udGVudCB0eXBlIGluIGluc2VydCBvcGVyYXRpb24nKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgcGFja0pzb25Db250ZW50KClcbn1cblxuY29uc3QgbGVuZ3RoRXhjZWVkZWQgPSAoKSA9PiBlcnJvci5jcmVhdGUoJ0xlbmd0aCBleGNlZWRlZCEnKVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHtBcnJheTxPYmplY3Q8c3RyaW5nLGFueT58QXJyYXk8YW55PnxudW1iZXJ8bnVsbHxzdHJpbmd8VWludDhBcnJheT59IGNvbnRlbnRcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTGlzdEluc2VydEdlbmVyaWNzID0gKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGluZGV4LCBjb250ZW50KSA9PiB7XG4gIGlmIChpbmRleCA+IHBhcmVudC5fbGVuZ3RoKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWQoKVxuICB9XG4gIGlmIChpbmRleCA9PT0gMCkge1xuICAgIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgaW5kZXgsIGNvbnRlbnQubGVuZ3RoKVxuICAgIH1cbiAgICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG51bGwsIGNvbnRlbnQpXG4gIH1cbiAgY29uc3Qgc3RhcnRJbmRleCA9IGluZGV4XG4gIGNvbnN0IG1hcmtlciA9IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleClcbiAgbGV0IG4gPSBwYXJlbnQuX3N0YXJ0XG4gIGlmIChtYXJrZXIgIT09IG51bGwpIHtcbiAgICBuID0gbWFya2VyLnBcbiAgICBpbmRleCAtPSBtYXJrZXIuaW5kZXhcbiAgICAvLyB3ZSBuZWVkIHRvIGl0ZXJhdGUgb25lIHRvIHRoZSBsZWZ0IHNvIHRoYXQgdGhlIGFsZ29yaXRobSB3b3Jrc1xuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgLy8gQHRvZG8gcmVmYWN0b3IgdGhpcyBhcyBpdCBhY3R1YWxseSBkb2Vzbid0IGNvbnNpZGVyIGZvcm1hdHNcbiAgICAgIG4gPSBuLnByZXYgLy8gaW1wb3J0YW50ISBnZXQgdGhlIGxlZnQgdW5kZWxldGVkIGl0ZW0gc28gdGhhdCB3ZSBjYW4gYWN0dWFsbHkgZGVjcmVhc2UgaW5kZXhcbiAgICAgIGluZGV4ICs9IChuICYmIG4uY291bnRhYmxlICYmICFuLmRlbGV0ZWQpID8gbi5sZW5ndGggOiAwXG4gICAgfVxuICB9XG4gIGZvciAoOyBuICE9PSBudWxsOyBuID0gbi5yaWdodCkge1xuICAgIGlmICghbi5kZWxldGVkICYmIG4uY291bnRhYmxlKSB7XG4gICAgICBpZiAoaW5kZXggPD0gbi5sZW5ndGgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgICAvLyBpbnNlcnQgaW4tYmV0d2VlblxuICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGluZGV4KSlcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGhcbiAgICB9XG4gIH1cbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgc3RhcnRJbmRleCwgY29udGVudC5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3NBZnRlcih0cmFuc2FjdGlvbiwgcGFyZW50LCBuLCBjb250ZW50KVxufVxuXG4vKipcbiAqIFB1c2hpbmcgY29udGVudCBpcyBzcGVjaWFsIGFzIHdlIGdlbmVyYWxseSB3YW50IHRvIHB1c2ggYWZ0ZXIgdGhlIGxhc3QgaXRlbS4gU28gd2UgZG9uJ3QgaGF2ZSB0byB1cGRhdGVcbiAqIHRoZSBzZXJhY2ggbWFya2VyLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7QXJyYXk8T2JqZWN0PHN0cmluZyxhbnk+fEFycmF5PGFueT58bnVtYmVyfG51bGx8c3RyaW5nfFVpbnQ4QXJyYXk+fSBjb250ZW50XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3RQdXNoR2VuZXJpY3MgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY29udGVudCkgPT4ge1xuICAvLyBVc2UgdGhlIG1hcmtlciB3aXRoIHRoZSBoaWdoZXN0IGluZGV4IGFuZCBpdGVyYXRlIHRvIHRoZSByaWdodC5cbiAgY29uc3QgbWFya2VyID0gKHBhcmVudC5fc2VhcmNoTWFya2VyIHx8IFtdKS5yZWR1Y2UoKG1heE1hcmtlciwgY3Vyck1hcmtlcikgPT4gY3Vyck1hcmtlci5pbmRleCA+IG1heE1hcmtlci5pbmRleCA/IGN1cnJNYXJrZXIgOiBtYXhNYXJrZXIsIHsgaW5kZXg6IDAsIHA6IHBhcmVudC5fc3RhcnQgfSlcbiAgbGV0IG4gPSBtYXJrZXIucFxuICBpZiAobikge1xuICAgIHdoaWxlIChuLnJpZ2h0KSB7XG4gICAgICBuID0gbi5yaWdodFxuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCBwYXJlbnQsIG4sIGNvbnRlbnQpXG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZUxpc3REZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgaW5kZXgsIGxlbmd0aCkgPT4ge1xuICBpZiAobGVuZ3RoID09PSAwKSB7IHJldHVybiB9XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBpbmRleFxuICBjb25zdCBzdGFydExlbmd0aCA9IGxlbmd0aFxuICBjb25zdCBtYXJrZXIgPSBmaW5kTWFya2VyKHBhcmVudCwgaW5kZXgpXG4gIGxldCBuID0gcGFyZW50Ll9zdGFydFxuICBpZiAobWFya2VyICE9PSBudWxsKSB7XG4gICAgbiA9IG1hcmtlci5wXG4gICAgaW5kZXggLT0gbWFya2VyLmluZGV4XG4gIH1cbiAgLy8gY29tcHV0ZSB0aGUgZmlyc3QgaXRlbSB0byBiZSBkZWxldGVkXG4gIGZvciAoOyBuICE9PSBudWxsICYmIGluZGV4ID4gMDsgbiA9IG4ucmlnaHQpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCAmJiBuLmNvdW50YWJsZSkge1xuICAgICAgaWYgKGluZGV4IDwgbi5sZW5ndGgpIHtcbiAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKG4uaWQuY2xpZW50LCBuLmlkLmNsb2NrICsgaW5kZXgpKVxuICAgICAgfVxuICAgICAgaW5kZXggLT0gbi5sZW5ndGhcbiAgICB9XG4gIH1cbiAgLy8gZGVsZXRlIGFsbCBpdGVtcyB1bnRpbCBkb25lXG4gIHdoaWxlIChsZW5ndGggPiAwICYmIG4gIT09IG51bGwpIHtcbiAgICBpZiAoIW4uZGVsZXRlZCkge1xuICAgICAgaWYgKGxlbmd0aCA8IG4ubGVuZ3RoKSB7XG4gICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChuLmlkLmNsaWVudCwgbi5pZC5jbG9jayArIGxlbmd0aCkpXG4gICAgICB9XG4gICAgICBuLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIGxlbmd0aCAtPSBuLmxlbmd0aFxuICAgIH1cbiAgICBuID0gbi5yaWdodFxuICB9XG4gIGlmIChsZW5ndGggPiAwKSB7XG4gICAgdGhyb3cgbGVuZ3RoRXhjZWVkZWQoKVxuICB9XG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIHN0YXJ0SW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aCAvKiBpbiBjYXNlIHdlIHJlbW92ZSB0aGUgYWJvdmUgZXhjZXB0aW9uICovKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVNYXBEZWxldGUgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IGMgPSBwYXJlbnQuX21hcC5nZXQoa2V5KVxuICBpZiAoYyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgYy5kZWxldGUodHJhbnNhY3Rpb24pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge09iamVjdHxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fSB2YWx1ZVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVNYXBTZXQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwga2V5LCB2YWx1ZSkgPT4ge1xuICBjb25zdCBsZWZ0ID0gcGFyZW50Ll9tYXAuZ2V0KGtleSkgfHwgbnVsbFxuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgbGV0IGNvbnRlbnRcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSlcbiAgfSBlbHNlIHtcbiAgICBzd2l0Y2ggKHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICBjYXNlIE51bWJlcjpcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBBcnJheTpcbiAgICAgIGNhc2UgU3RyaW5nOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRBbnkoW3ZhbHVlXSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgVWludDhBcnJheTpcbiAgICAgICAgY29udGVudCA9IG5ldyBDb250ZW50QmluYXJ5KC8qKiBAdHlwZSB7VWludDhBcnJheX0gKi8gKHZhbHVlKSlcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgRG9jOlxuICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnREb2MoLyoqIEB0eXBlIHtEb2N9ICovICh2YWx1ZSkpXG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUpIHtcbiAgICAgICAgICBjb250ZW50ID0gbmV3IENvbnRlbnRUeXBlKHZhbHVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBjb250ZW50IHR5cGUnKVxuICAgICAgICB9XG4gICAgfVxuICB9XG4gIG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIG51bGwsIG51bGwsIHBhcmVudCwga2V5LCBjb250ZW50KS5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG59XG5cbi8qKlxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcEdldCA9IChwYXJlbnQsIGtleSkgPT4ge1xuICBjb25zdCB2YWwgPSBwYXJlbnQuX21hcC5nZXQoa2V5KVxuICByZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgJiYgIXZhbC5kZWxldGVkID8gdmFsLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZhbC5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZFxufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHJldHVybiB7T2JqZWN0PHN0cmluZyxPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWQ+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHR5cGVNYXBHZXRBbGwgPSAocGFyZW50KSA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgKi9cbiAgY29uc3QgcmVzID0ge31cbiAgcGFyZW50Ll9tYXAuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGlmICghdmFsdWUuZGVsZXRlZCkge1xuICAgICAgcmVzW2tleV0gPSB2YWx1ZS5jb250ZW50LmdldENvbnRlbnQoKVt2YWx1ZS5sZW5ndGggLSAxXVxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlTWFwSGFzID0gKHBhcmVudCwga2V5KSA9PiB7XG4gIGNvbnN0IHZhbCA9IHBhcmVudC5fbWFwLmdldChrZXkpXG4gIHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCAmJiAhdmFsLmRlbGV0ZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLGFueT58bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pnx1bmRlZmluZWR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcEdldFNuYXBzaG90ID0gKHBhcmVudCwga2V5LCBzbmFwc2hvdCkgPT4ge1xuICBsZXQgdiA9IHBhcmVudC5fbWFwLmdldChrZXkpIHx8IG51bGxcbiAgd2hpbGUgKHYgIT09IG51bGwgJiYgKCFzbmFwc2hvdC5zdi5oYXModi5pZC5jbGllbnQpIHx8IHYuaWQuY2xvY2sgPj0gKHNuYXBzaG90LnN2LmdldCh2LmlkLmNsaWVudCkgfHwgMCkpKSB7XG4gICAgdiA9IHYubGVmdFxuICB9XG4gIHJldHVybiB2ICE9PSBudWxsICYmIGlzVmlzaWJsZSh2LCBzbmFwc2hvdCkgPyB2LmNvbnRlbnQuZ2V0Q29udGVudCgpW3YubGVuZ3RoIC0gMV0gOiB1bmRlZmluZWRcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7U25hcHNob3R9IHNuYXBzaG90XG4gKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLE9iamVjdDxzdHJpbmcsYW55PnxudW1iZXJ8bnVsbHxBcnJheTxhbnk+fHN0cmluZ3xVaW50OEFycmF5fEFic3RyYWN0VHlwZTxhbnk+fHVuZGVmaW5lZD59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgdHlwZU1hcEdldEFsbFNuYXBzaG90ID0gKHBhcmVudCwgc25hcHNob3QpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59XG4gICAqL1xuICBjb25zdCByZXMgPSB7fVxuICBwYXJlbnQuX21hcC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgdiA9IHZhbHVlXG4gICAgd2hpbGUgKHYgIT09IG51bGwgJiYgKCFzbmFwc2hvdC5zdi5oYXModi5pZC5jbGllbnQpIHx8IHYuaWQuY2xvY2sgPj0gKHNuYXBzaG90LnN2LmdldCh2LmlkLmNsaWVudCkgfHwgMCkpKSB7XG4gICAgICB2ID0gdi5sZWZ0XG4gICAgfVxuICAgIGlmICh2ICE9PSBudWxsICYmIGlzVmlzaWJsZSh2LCBzbmFwc2hvdCkpIHtcbiAgICAgIHJlc1trZXldID0gdi5jb250ZW50LmdldENvbnRlbnQoKVt2Lmxlbmd0aCAtIDFdXG4gICAgfVxuICB9KVxuICByZXR1cm4gcmVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtNYXA8c3RyaW5nLEl0ZW0+fSBtYXBcbiAqIEByZXR1cm4ge0l0ZXJhYmxlSXRlcmF0b3I8QXJyYXk8YW55Pj59XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlTWFwSXRlcmF0b3IgPSBtYXAgPT4gaXRlcmF0b3IuaXRlcmF0b3JGaWx0ZXIobWFwLmVudHJpZXMoKSwgLyoqIEBwYXJhbSB7YW55fSBlbnRyeSAqLyBlbnRyeSA9PiAhZW50cnlbMV0uZGVsZXRlZClcbiIsICIvKipcbiAqIEBtb2R1bGUgWUFycmF5XG4gKi9cblxuaW1wb3J0IHtcbiAgWUV2ZW50LFxuICBBYnN0cmFjdFR5cGUsXG4gIHR5cGVMaXN0R2V0LFxuICB0eXBlTGlzdFRvQXJyYXksXG4gIHR5cGVMaXN0Rm9yRWFjaCxcbiAgdHlwZUxpc3RDcmVhdGVJdGVyYXRvcixcbiAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyxcbiAgdHlwZUxpc3RQdXNoR2VuZXJpY3MsXG4gIHR5cGVMaXN0RGVsZXRlLFxuICB0eXBlTGlzdE1hcCxcbiAgWUFycmF5UmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgQXJyYXlTZWFyY2hNYXJrZXIsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBUcmFuc2FjdGlvbiwgSXRlbSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcbmltcG9ydCB7IHR5cGVMaXN0U2xpY2UgfSBmcm9tICcuL0Fic3RyYWN0VHlwZS5qcydcblxuLyoqXG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlBcnJheVxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIFlFdmVudDxZQXJyYXk8VD4+XG4gKi9cbmV4cG9ydCBjbGFzcyBZQXJyYXlFdmVudCBleHRlbmRzIFlFdmVudCB7fVxuXG4vKipcbiAqIEEgc2hhcmVkIEFycmF5IGltcGxlbWVudGF0aW9uLlxuICogQHRlbXBsYXRlIFRcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZQXJyYXlFdmVudDxUPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxUPn1cbiAqL1xuZXhwb3J0IGNsYXNzIFlBcnJheSBleHRlbmRzIEFic3RyYWN0VHlwZSB7XG4gIGNvbnN0cnVjdG9yICgpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT4/fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdXG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PEFycmF5U2VhcmNoTWFya2VyPn1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXVxuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhIG5ldyBZQXJyYXkgY29udGFpbmluZyB0aGUgc3BlY2lmaWVkIGl0ZW1zLlxuICAgKiBAdGVtcGxhdGUge09iamVjdDxzdHJpbmcsYW55PnxBcnJheTxhbnk+fG51bWJlcnxudWxsfHN0cmluZ3xVaW50OEFycmF5fSBUXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGl0ZW1zXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIHN0YXRpYyBmcm9tIChpdGVtcykge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZQXJyYXk8VD59XG4gICAgICovXG4gICAgY29uc3QgYSA9IG5ldyBZQXJyYXkoKVxuICAgIGEucHVzaChpdGVtcylcbiAgICByZXR1cm4gYVxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSlcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lBcnJheTxUPn1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlBcnJheSgpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WUFycmF5PFQ+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZQXJyYXk8VD59XG4gICAgICovXG4gICAgY29uc3QgYXJyID0gbmV3IFlBcnJheSgpXG4gICAgYXJyLmluc2VydCgwLCB0aGlzLnRvQXJyYXkoKS5tYXAoZWwgPT5cbiAgICAgIGVsIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gLyoqIEB0eXBlIHt0eXBlb2YgZWx9ICovIChlbC5jbG9uZSgpKSA6IGVsXG4gICAgKSlcbiAgICByZXR1cm4gYXJyXG4gIH1cblxuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcHJlbGltQ29udGVudCA9PT0gbnVsbCA/IHRoaXMuX2xlbmd0aCA6IHRoaXMuX3ByZWxpbUNvbnRlbnQubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBZQXJyYXlFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKVxuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWUFycmF5RXZlbnQodGhpcywgdHJhbnNhY3Rpb24pKVxuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydHMgbmV3IGNvbnRlbnQgYXQgYW4gaW5kZXguXG4gICAqXG4gICAqIEltcG9ydGFudDogVGhpcyBmdW5jdGlvbiBleHBlY3RzIGFuIGFycmF5IG9mIGNvbnRlbnQuIE5vdCBqdXN0IGEgY29udGVudFxuICAgKiBvYmplY3QuIFRoZSByZWFzb24gZm9yIHRoaXMgXCJ3ZWlyZG5lc3NcIiBpcyB0aGF0IGluc2VydGluZyBzZXZlcmFsIGVsZW1lbnRzXG4gICAqIGlzIHZlcnkgZWZmaWNpZW50IHdoZW4gaXQgaXMgZG9uZSBhcyBhIHNpbmdsZSBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqICAvLyBJbnNlcnQgY2hhcmFjdGVyICdhJyBhdCBwb3NpdGlvbiAwXG4gICAqICB5YXJyYXkuaW5zZXJ0KDAsIFsnYSddKVxuICAgKiAgLy8gSW5zZXJ0IG51bWJlcnMgMSwgMiBhdCBwb3NpdGlvbiAxXG4gICAqICB5YXJyYXkuaW5zZXJ0KDEsIFsxLCAyXSlcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IFRoZSBpbmRleCB0byBpbnNlcnQgY29udGVudCBhdC5cbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBUaGUgYXJyYXkgb2YgY29udGVudFxuICAgKi9cbiAgaW5zZXJ0IChpbmRleCwgY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljcyh0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIC8qKiBAdHlwZSB7YW55fSAqLyAoY29udGVudCkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgY29udGVudCB0byB0aGlzIFlBcnJheS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTxUPn0gY29udGVudCBBcnJheSBvZiBjb250ZW50IHRvIGFwcGVuZC5cbiAgICpcbiAgICogQHRvZG8gVXNlIHRoZSBmb2xsb3dpbmcgaW1wbGVtZW50YXRpb24gaW4gYWxsIHR5cGVzLlxuICAgKi9cbiAgcHVzaCAoY29udGVudCkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3RQdXNoR2VuZXJpY3ModHJhbnNhY3Rpb24sIHRoaXMsIC8qKiBAdHlwZSB7YW55fSAqLyAoY29udGVudCkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5wdXNoKC4uLmNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8VD59IGNvbnRlbnQgQXJyYXkgb2YgY29udGVudCB0byBwcmVwZW5kLlxuICAgKi9cbiAgdW5zaGlmdCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KDAsIGNvbnRlbnQpXG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBlbGVtZW50cyBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcgZWxlbWVudHNcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGRlbGV0ZSAoaW5kZXgsIGxlbmd0aCA9IDEpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0RGVsZXRlKHRyYW5zYWN0aW9uLCB0aGlzLCBpbmRleCwgbGVuZ3RoKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuc3BsaWNlKGluZGV4LCBsZW5ndGgpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7VH1cbiAgICovXG4gIGdldCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RHZXQodGhpcywgaW5kZXgpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgdG9BcnJheSAoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0VG9BcnJheSh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwb3J0aW9uIG9mIHRoaXMgWUFycmF5IGludG8gYSBKYXZhU2NyaXB0IEFycmF5IHNlbGVjdGVkXG4gICAqIGZyb20gc3RhcnQgdG8gZW5kIChlbmQgbm90IGluY2x1ZGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFQ+fVxuICAgKi9cbiAgc2xpY2UgKHN0YXJ0ID0gMCwgZW5kID0gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdHlwZUxpc3RTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybXMgdGhpcyBTaGFyZWQgVHlwZSB0byBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXAoYyA9PiBjIGluc3RhbmNlb2YgQWJzdHJhY3RUeXBlID8gYy50b0pTT04oKSA6IGMpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBBcnJheSB3aXRoIHRoZSByZXN1bHQgb2YgY2FsbGluZyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIGV2ZXJ5XG4gICAqIGVsZW1lbnQgb2YgdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSBNXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oVCxudW1iZXIsWUFycmF5PFQ+KTpNfSBmIEZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gZWxlbWVudCBvZiB0aGUgbmV3IEFycmF5XG4gICAqIEByZXR1cm4ge0FycmF5PE0+fSBBIG5ldyBhcnJheSB3aXRoIGVhY2ggZWxlbWVudCBiZWluZyB0aGUgcmVzdWx0IG9mIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICovXG4gIG1hcCAoZikge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCAvKiogQHR5cGUge2FueX0gKi8gKGYpKVxuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgcHJvdmlkZWQgZnVuY3Rpb24gb25jZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKFQsbnVtYmVyLFlBcnJheTxUPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0eXBlTGlzdEZvckVhY2godGhpcywgZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFQ+fVxuICAgKi9cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0eXBlTGlzdENyZWF0ZUl0ZXJhdG9yKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlBcnJheVJlZklEKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFlBcnJheSA9IF9kZWNvZGVyID0+IG5ldyBZQXJyYXkoKVxuIiwgIi8qKlxuICogQG1vZHVsZSBZTWFwXG4gKi9cblxuaW1wb3J0IHtcbiAgWUV2ZW50LFxuICBBYnN0cmFjdFR5cGUsXG4gIHR5cGVNYXBEZWxldGUsXG4gIHR5cGVNYXBTZXQsXG4gIHR5cGVNYXBHZXQsXG4gIHR5cGVNYXBIYXMsXG4gIGNyZWF0ZU1hcEl0ZXJhdG9yLFxuICBZTWFwUmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBEb2MsIFRyYW5zYWN0aW9uLCBJdGVtIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBpdGVyYXRvciBmcm9tICdsaWIwL2l0ZXJhdG9yJ1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBUXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WU1hcDxUPj5cbiAqIEV2ZW50IHRoYXQgZGVzY3JpYmVzIHRoZSBjaGFuZ2VzIG9uIGEgWU1hcC5cbiAqL1xuZXhwb3J0IGNsYXNzIFlNYXBFdmVudCBleHRlbmRzIFlFdmVudCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1lNYXA8VD59IHltYXAgVGhlIFlBcnJheSB0aGF0IGNoYW5nZWQuXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkLlxuICAgKi9cbiAgY29uc3RydWN0b3IgKHltYXAsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeW1hcCwgdHJhbnNhY3Rpb24pXG4gICAgdGhpcy5rZXlzQ2hhbmdlZCA9IHN1YnNcbiAgfVxufVxuXG4vKipcbiAqIEB0ZW1wbGF0ZSBNYXBUeXBlXG4gKiBBIHNoYXJlZCBNYXAgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQGV4dGVuZHMgQWJzdHJhY3RUeXBlPFlNYXBFdmVudDxNYXBUeXBlPj5cbiAqIEBpbXBsZW1lbnRzIHtJdGVyYWJsZTxbc3RyaW5nLCBNYXBUeXBlXT59XG4gKi9cbmV4cG9ydCBjbGFzcyBZTWFwIGV4dGVuZHMgQWJzdHJhY3RUeXBlIHtcbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7SXRlcmFibGU8cmVhZG9ubHkgW3N0cmluZywgYW55XT49fSBlbnRyaWVzIC0gYW4gb3B0aW9uYWwgaXRlcmFibGUgdG8gaW5pdGlhbGl6ZSB0aGUgWU1hcFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGVudHJpZXMpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsYW55Pj99XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuXG4gICAgaWYgKGVudHJpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcHJlbGltQ29udGVudCA9IG5ldyBNYXAoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbmV3IE1hcChlbnRyaWVzKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlZ3JhdGUgdGhpcyB0eXBlIGludG8gdGhlIFlqcyBpbnN0YW5jZS5cbiAgICpcbiAgICogKiBTYXZlIHRoaXMgc3RydWN0IGluIHRoZSBvc1xuICAgKiAqIFRoaXMgdHlwZSBpcyBzZW50IHRvIG90aGVyIGNsaWVudFxuICAgKiAqIE9ic2VydmVyIGZ1bmN0aW9ucyBhcmUgZmlyZWRcbiAgICpcbiAgICogQHBhcmFtIHtEb2N9IHkgVGhlIFlqcyBpbnN0YW5jZVxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIF9pbnRlZ3JhdGUgKHksIGl0ZW0pIHtcbiAgICBzdXBlci5faW50ZWdyYXRlKHksIGl0ZW0pXG4gICAgOy8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpXG4gICAgfSlcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1lNYXA8TWFwVHlwZT59XG4gICAqL1xuICBfY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBZTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZTWFwPE1hcFR5cGU+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZTWFwPE1hcFR5cGU+fVxuICAgICAqL1xuICAgIGNvbnN0IG1hcCA9IG5ldyBZTWFwKClcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IC8qKiBAdHlwZSB7dHlwZW9mIHZhbHVlfSAqLyAodmFsdWUuY2xvbmUoKSkgOiB2YWx1ZSlcbiAgICB9KVxuICAgIHJldHVybiBtYXBcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIFlNYXBFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBjYWxsVHlwZU9ic2VydmVycyh0aGlzLCB0cmFuc2FjdGlvbiwgbmV3IFlNYXBFdmVudCh0aGlzLCB0cmFuc2FjdGlvbiwgcGFyZW50U3VicykpXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFNoYXJlZCBUeXBlIHRvIGEgSlNPTiBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICovXG4gIHRvSlNPTiAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsTWFwVHlwZT59XG4gICAgICovXG4gICAgY29uc3QgbWFwID0ge31cbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBjb25zdCB2ID0gaXRlbS5jb250ZW50LmdldENvbnRlbnQoKVtpdGVtLmxlbmd0aCAtIDFdXG4gICAgICAgIG1hcFtrZXldID0gdiBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IHYudG9KU09OKCkgOiB2XG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gbWFwXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc2l6ZSBvZiB0aGUgWU1hcCAoY291bnQgb2Yga2V5L3ZhbHVlIHBhaXJzKVxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgc2l6ZSAoKSB7XG4gICAgcmV0dXJuIFsuLi5jcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApXS5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBrZXlzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxzdHJpbmc+fVxuICAgKi9cbiAga2V5cyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMF0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWVzIGZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIFlNYXAgVHlwZS5cbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxNYXBUeXBlPn1cbiAgICovXG4gIHZhbHVlcyAoKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yLml0ZXJhdG9yTWFwKGNyZWF0ZU1hcEl0ZXJhdG9yKHRoaXMuX21hcCksIC8qKiBAcGFyYW0ge2FueX0gdiAqLyB2ID0+IHZbMV0uY29udGVudC5nZXRDb250ZW50KClbdlsxXS5sZW5ndGggLSAxXSlcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIEl0ZXJhdG9yIG9mIFtrZXksIHZhbHVlXSBwYWlyc1xuICAgKlxuICAgKiBAcmV0dXJuIHtJdGVyYWJsZUl0ZXJhdG9yPFtzdHJpbmcsIE1hcFR5cGVdPn1cbiAgICovXG4gIGVudHJpZXMgKCkge1xuICAgIHJldHVybiBpdGVyYXRvci5pdGVyYXRvck1hcChjcmVhdGVNYXBJdGVyYXRvcih0aGlzLl9tYXApLCAvKiogQHBhcmFtIHthbnl9IHYgKi8gdiA9PiAvKiogQHR5cGUge2FueX0gKi8gKFt2WzBdLCB2WzFdLmNvbnRlbnQuZ2V0Q29udGVudCgpW3ZbMV0ubGVuZ3RoIC0gMV1dKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gZXZlcnkga2V5LXZhbHVlIHBhaXIuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oTWFwVHlwZSxzdHJpbmcsWU1hcDxNYXBUeXBlPik6dm9pZH0gZiBBIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgZWxlbWVudCBvZiB0aGlzIFlBcnJheS5cbiAgICovXG4gIGZvckVhY2ggKGYpIHtcbiAgICB0aGlzLl9tYXAuZm9yRWFjaCgoaXRlbSwga2V5KSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBmKGl0ZW0uY29udGVudC5nZXRDb250ZW50KClbaXRlbS5sZW5ndGggLSAxXSwga2V5LCB0aGlzKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBJdGVyYXRvciBvZiBba2V5LCB2YWx1ZV0gcGFpcnNcbiAgICpcbiAgICogQHJldHVybiB7SXRlcmFibGVJdGVyYXRvcjxbc3RyaW5nLCBNYXBUeXBlXT59XG4gICAqL1xuICBbU3ltYm9sLml0ZXJhdG9yXSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGEgc3BlY2lmaWVkIGVsZW1lbnQgZnJvbSB0aGlzIFlNYXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZWxlbWVudCB0byByZW1vdmUuXG4gICAqL1xuICBkZWxldGUgKGtleSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywga2V5KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fSAqLyAodGhpcy5fcHJlbGltQ29udGVudCkuZGVsZXRlKGtleSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBvciB1cGRhdGVzIGFuIGVsZW1lbnQgd2l0aCBhIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlLlxuICAgKiBAdGVtcGxhdGUge01hcFR5cGV9IFZBTFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVsZW1lbnQgdG8gYWRkIHRvIHRoaXMgWU1hcFxuICAgKiBAcGFyYW0ge1ZBTH0gdmFsdWUgVGhlIHZhbHVlIG9mIHRoZSBlbGVtZW50IHRvIGFkZFxuICAgKiBAcmV0dXJuIHtWQUx9XG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGtleSwgLyoqIEB0eXBlIHthbnl9ICovICh2YWx1ZSkpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsIGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KS5zZXQoa2V5LCB2YWx1ZSlcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHNwZWNpZmllZCBlbGVtZW50IGZyb20gdGhpcyBZTWFwLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAqIEByZXR1cm4ge01hcFR5cGV8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0IChrZXkpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGtleSkpXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQga2V5IGV4aXN0cyBvciBub3QuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaGFzIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZU1hcEhhcyh0aGlzLCBrZXkpXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgZWxlbWVudHMgZnJvbSB0aGlzIFlNYXAuXG4gICAqL1xuICBjbGVhciAoKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKF92YWx1ZSwga2V5LCBtYXApIHtcbiAgICAgICAgICB0eXBlTWFwRGVsZXRlKHRyYW5zYWN0aW9uLCBtYXAsIGtleSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUNvbnRlbnQpLmNsZWFyKClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlNYXBSZWZJRClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBfZGVjb2RlclxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZTWFwID0gX2RlY29kZXIgPT4gbmV3IFlNYXAoKVxuIiwgIi8qKlxuICogQG1vZHVsZSBZVGV4dFxuICovXG5cbmltcG9ydCB7XG4gIFlFdmVudCxcbiAgQWJzdHJhY3RUeXBlLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgZ2V0U3RhdGUsXG4gIGlzVmlzaWJsZSxcbiAgY3JlYXRlSUQsXG4gIFlUZXh0UmVmSUQsXG4gIGNhbGxUeXBlT2JzZXJ2ZXJzLFxuICB0cmFuc2FjdCxcbiAgQ29udGVudEVtYmVkLFxuICBHQyxcbiAgQ29udGVudEZvcm1hdCxcbiAgQ29udGVudFN0cmluZyxcbiAgc3BsaXRTbmFwc2hvdEFmZmVjdGVkU3RydWN0cyxcbiAgaXRlcmF0ZURlbGV0ZWRTdHJ1Y3RzLFxuICBpdGVyYXRlU3RydWN0cyxcbiAgZmluZE1hcmtlcixcbiAgdHlwZU1hcERlbGV0ZSxcbiAgdHlwZU1hcFNldCxcbiAgdHlwZU1hcEdldCxcbiAgdHlwZU1hcEdldEFsbCxcbiAgdXBkYXRlTWFya2VyQ2hhbmdlcyxcbiAgQ29udGVudFR5cGUsXG4gIEFycmF5U2VhcmNoTWFya2VyLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIElELCBEb2MsIEl0ZW0sIFNuYXBzaG90LCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgb2JqZWN0IGZyb20gJ2xpYjAvb2JqZWN0J1xuaW1wb3J0ICogYXMgbWFwIGZyb20gJ2xpYjAvbWFwJ1xuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcGFyYW0ge2FueX0gYVxuICogQHBhcmFtIHthbnl9IGJcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmNvbnN0IGVxdWFsQXR0cnMgPSAoYSwgYikgPT4gYSA9PT0gYiB8fCAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBiID09PSAnb2JqZWN0JyAmJiBhICYmIGIgJiYgb2JqZWN0LmVxdWFsRmxhdChhLCBiKSlcblxuZXhwb3J0IGNsYXNzIEl0ZW1UZXh0TGlzdFBvc2l0aW9uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSBsZWZ0XG4gICAqIEBwYXJhbSB7SXRlbXxudWxsfSByaWdodFxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJlbnRBdHRyaWJ1dGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAobGVmdCwgcmlnaHQsIGluZGV4LCBjdXJyZW50QXR0cmlidXRlcykge1xuICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICB0aGlzLnJpZ2h0ID0gcmlnaHRcbiAgICB0aGlzLmluZGV4ID0gaW5kZXhcbiAgICB0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzID0gY3VycmVudEF0dHJpYnV0ZXNcbiAgfVxuXG4gIC8qKlxuICAgKiBPbmx5IGNhbGwgdGhpcyBpZiB5b3Uga25vdyB0aGF0IHRoaXMucmlnaHQgaXMgZGVmaW5lZFxuICAgKi9cbiAgZm9yd2FyZCAoKSB7XG4gICAgaWYgKHRoaXMucmlnaHQgPT09IG51bGwpIHtcbiAgICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgICB9XG4gICAgc3dpdGNoICh0aGlzLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCF0aGlzLnJpZ2h0LmRlbGV0ZWQpIHtcbiAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyh0aGlzLmN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovICh0aGlzLnJpZ2h0LmNvbnRlbnQpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXRoaXMucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHRoaXMuaW5kZXggKz0gdGhpcy5yaWdodC5sZW5ndGhcbiAgICAgICAgfVxuICAgICAgICBicmVha1xuICAgIH1cbiAgICB0aGlzLmxlZnQgPSB0aGlzLnJpZ2h0XG4gICAgdGhpcy5yaWdodCA9IHRoaXMucmlnaHQucmlnaHRcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBwb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCBzdGVwcyB0byBtb3ZlIGZvcndhcmRcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZmluZE5leHRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcG9zLCBjb3VudCkgPT4ge1xuICB3aGlsZSAocG9zLnJpZ2h0ICE9PSBudWxsICYmIGNvdW50ID4gMCkge1xuICAgIHN3aXRjaCAocG9zLnJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgIGNhc2UgQ29udGVudEZvcm1hdDpcbiAgICAgICAgaWYgKCFwb3MucmlnaHQuZGVsZXRlZCkge1xuICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKHBvcy5jdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAocG9zLnJpZ2h0LmNvbnRlbnQpKVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAoIXBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICAgICAgaWYgKGNvdW50IDwgcG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcmlnaHRcbiAgICAgICAgICAgIGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBjcmVhdGVJRChwb3MucmlnaHQuaWQuY2xpZW50LCBwb3MucmlnaHQuaWQuY2xvY2sgKyBjb3VudCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcy5pbmRleCArPSBwb3MucmlnaHQubGVuZ3RoXG4gICAgICAgICAgY291bnQgLT0gcG9zLnJpZ2h0Lmxlbmd0aFxuICAgICAgICB9XG4gICAgICAgIGJyZWFrXG4gICAgfVxuICAgIHBvcy5sZWZ0ID0gcG9zLnJpZ2h0XG4gICAgcG9zLnJpZ2h0ID0gcG9zLnJpZ2h0LnJpZ2h0XG4gICAgLy8gcG9zLmZvcndhcmQoKSAtIHdlIGRvbid0IGZvcndhcmQgYmVjYXVzZSB0aGF0IHdvdWxkIGhhbHZlIHRoZSBwZXJmb3JtYW5jZSBiZWNhdXNlIHdlIGFscmVhZHkgZG8gdGhlIGNoZWNrcyBhYm92ZVxuICB9XG4gIHJldHVybiBwb3Ncbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdXNlU2VhcmNoTWFya2VyXG4gKiBAcmV0dXJuIHtJdGVtVGV4dExpc3RQb3NpdGlvbn1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZpbmRQb3NpdGlvbiA9ICh0cmFuc2FjdGlvbiwgcGFyZW50LCBpbmRleCwgdXNlU2VhcmNoTWFya2VyKSA9PiB7XG4gIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpXG4gIGNvbnN0IG1hcmtlciA9IHVzZVNlYXJjaE1hcmtlciA/IGZpbmRNYXJrZXIocGFyZW50LCBpbmRleCkgOiBudWxsXG4gIGlmIChtYXJrZXIpIHtcbiAgICBjb25zdCBwb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obWFya2VyLnAubGVmdCwgbWFya2VyLnAsIG1hcmtlci5pbmRleCwgY3VycmVudEF0dHJpYnV0ZXMpXG4gICAgcmV0dXJuIGZpbmROZXh0UG9zaXRpb24odHJhbnNhY3Rpb24sIHBvcywgaW5kZXggLSBtYXJrZXIuaW5kZXgpXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcG9zID0gbmV3IEl0ZW1UZXh0TGlzdFBvc2l0aW9uKG51bGwsIHBhcmVudC5fc3RhcnQsIDAsIGN1cnJlbnRBdHRyaWJ1dGVzKVxuICAgIHJldHVybiBmaW5kTmV4dFBvc2l0aW9uKHRyYW5zYWN0aW9uLCBwb3MsIGluZGV4KVxuICB9XG59XG5cbi8qKlxuICogTmVnYXRlIGFwcGxpZWQgZm9ybWF0c1xuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fSBwYXJlbnRcbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7TWFwPHN0cmluZyxhbnk+fSBuZWdhdGVkQXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gY2hlY2sgaWYgd2UgcmVhbGx5IG5lZWQgdG8gcmVtb3ZlIGF0dHJpYnV0ZXNcbiAgd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiYgKFxuICAgICAgY3VyclBvcy5yaWdodC5kZWxldGVkID09PSB0cnVlIHx8IChcbiAgICAgICAgY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmXG4gICAgICAgIGVxdWFsQXR0cnMobmVnYXRlZEF0dHJpYnV0ZXMuZ2V0KC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudCkua2V5KSwgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS52YWx1ZSlcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBuZWdhdGVkQXR0cmlidXRlcy5kZWxldGUoLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KS5rZXkpXG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpXG4gIH1cbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEXG4gIG5lZ2F0ZWRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgY29uc3QgbGVmdCA9IGN1cnJQb3MubGVmdFxuICAgIGNvbnN0IHJpZ2h0ID0gY3VyclBvcy5yaWdodFxuICAgIGNvbnN0IG5leHRGb3JtYXQgPSBuZXcgSXRlbShjcmVhdGVJRChvd25DbGllbnRJZCwgZ2V0U3RhdGUoZG9jLnN0b3JlLCBvd25DbGllbnRJZCkpLCBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLCByaWdodCwgcmlnaHQgJiYgcmlnaHQuaWQsIHBhcmVudCwgbnVsbCwgbmV3IENvbnRlbnRGb3JtYXQoa2V5LCB2YWwpKVxuICAgIG5leHRGb3JtYXQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgIGN1cnJQb3MucmlnaHQgPSBuZXh0Rm9ybWF0XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge01hcDxzdHJpbmcsYW55Pn0gY3VycmVudEF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7Q29udGVudEZvcm1hdH0gZm9ybWF0XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyA9IChjdXJyZW50QXR0cmlidXRlcywgZm9ybWF0KSA9PiB7XG4gIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gZm9ybWF0XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpXG4gIH0gZWxzZSB7XG4gICAgY3VycmVudEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgbWluaW1pemVBdHRyaWJ1dGVDaGFuZ2VzID0gKGN1cnJQb3MsIGF0dHJpYnV0ZXMpID0+IHtcbiAgLy8gZ28gcmlnaHQgd2hpbGUgYXR0cmlidXRlc1tyaWdodC5rZXldID09PSByaWdodC52YWx1ZSAob3IgcmlnaHQgaXMgZGVsZXRlZClcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoY3VyclBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgYnJlYWtcbiAgICB9IGVsc2UgaWYgKGN1cnJQb3MucmlnaHQuZGVsZXRlZCB8fCAoY3VyclBvcy5yaWdodC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0ICYmIGVxdWFsQXR0cnMoYXR0cmlidXRlc1soLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY3VyclBvcy5yaWdodC5jb250ZW50KSkua2V5XSA/PyBudWxsLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChjdXJyUG9zLnJpZ2h0LmNvbnRlbnQpLnZhbHVlKSkpIHtcbiAgICAgIC8vXG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrXG4gICAgfVxuICAgIGN1cnJQb3MuZm9yd2FyZCgpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBYnN0cmFjdFR5cGU8YW55Pn0gcGFyZW50XG4gKiBAcGFyYW0ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufSBjdXJyUG9zXG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICogQHJldHVybiB7TWFwPHN0cmluZyxhbnk+fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydEF0dHJpYnV0ZXMgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcykgPT4ge1xuICBjb25zdCBkb2MgPSB0cmFuc2FjdGlvbi5kb2NcbiAgY29uc3Qgb3duQ2xpZW50SWQgPSBkb2MuY2xpZW50SURcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBuZXcgTWFwKClcbiAgLy8gaW5zZXJ0IGZvcm1hdC1zdGFydCBpdGVtc1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgdmFsID0gYXR0cmlidXRlc1trZXldXG4gICAgY29uc3QgY3VycmVudFZhbCA9IGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbFxuICAgIGlmICghZXF1YWxBdHRycyhjdXJyZW50VmFsLCB2YWwpKSB7XG4gICAgICAvLyBzYXZlIG5lZ2F0ZWQgYXR0cmlidXRlIChzZXQgbnVsbCBpZiBjdXJyZW50VmFsIHVuZGVmaW5lZClcbiAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLnNldChrZXksIGN1cnJlbnRWYWwpXG4gICAgICBjb25zdCB7IGxlZnQsIHJpZ2h0IH0gPSBjdXJyUG9zXG4gICAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgbGVmdCwgbGVmdCAmJiBsZWZ0Lmxhc3RJZCwgcmlnaHQsIHJpZ2h0ICYmIHJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50Rm9ybWF0KGtleSwgdmFsKSlcbiAgICAgIGN1cnJQb3MucmlnaHQuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgICAgY3VyclBvcy5mb3J3YXJkKClcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5lZ2F0ZWRBdHRyaWJ1dGVzXG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fEFic3RyYWN0VHlwZTxhbnk+fSB0ZXh0XG4gKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsYW55Pn0gYXR0cmlidXRlc1xuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqKi9cbmNvbnN0IGluc2VydFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgdGV4dCwgYXR0cmlidXRlcykgPT4ge1xuICBjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKF92YWwsIGtleSkgPT4ge1xuICAgIGlmIChhdHRyaWJ1dGVzW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgYXR0cmlidXRlc1trZXldID0gbnVsbFxuICAgIH1cbiAgfSlcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IG93bkNsaWVudElkID0gZG9jLmNsaWVudElEXG4gIG1pbmltaXplQXR0cmlidXRlQ2hhbmdlcyhjdXJyUG9zLCBhdHRyaWJ1dGVzKVxuICBjb25zdCBuZWdhdGVkQXR0cmlidXRlcyA9IGluc2VydEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgYXR0cmlidXRlcylcbiAgLy8gaW5zZXJ0IGNvbnRlbnRcbiAgY29uc3QgY29udGVudCA9IHRleHQuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IG5ldyBDb250ZW50U3RyaW5nKC8qKiBAdHlwZSB7c3RyaW5nfSAqLyAodGV4dCkpIDogKHRleHQgaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBuZXcgQ29udGVudFR5cGUodGV4dCkgOiBuZXcgQ29udGVudEVtYmVkKHRleHQpKVxuICBsZXQgeyBsZWZ0LCByaWdodCwgaW5kZXggfSA9IGN1cnJQb3NcbiAgaWYgKHBhcmVudC5fc2VhcmNoTWFya2VyKSB7XG4gICAgdXBkYXRlTWFya2VyQ2hhbmdlcyhwYXJlbnQuX3NlYXJjaE1hcmtlciwgY3VyclBvcy5pbmRleCwgY29udGVudC5nZXRMZW5ndGgoKSlcbiAgfVxuICByaWdodCA9IG5ldyBJdGVtKGNyZWF0ZUlEKG93bkNsaWVudElkLCBnZXRTdGF0ZShkb2Muc3RvcmUsIG93bkNsaWVudElkKSksIGxlZnQsIGxlZnQgJiYgbGVmdC5sYXN0SWQsIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCwgcGFyZW50LCBudWxsLCBjb250ZW50KVxuICByaWdodC5pbnRlZ3JhdGUodHJhbnNhY3Rpb24sIDApXG4gIGN1cnJQb3MucmlnaHQgPSByaWdodFxuICBjdXJyUG9zLmluZGV4ID0gaW5kZXhcbiAgY3VyclBvcy5mb3J3YXJkKClcbiAgaW5zZXJ0TmVnYXRlZEF0dHJpYnV0ZXModHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbmVnYXRlZEF0dHJpYnV0ZXMpXG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHBhcmVudFxuICogQHBhcmFtIHtJdGVtVGV4dExpc3RQb3NpdGlvbn0gY3VyclBvc1xuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT59IGF0dHJpYnV0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmNvbnN0IGZvcm1hdFRleHQgPSAodHJhbnNhY3Rpb24sIHBhcmVudCwgY3VyclBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKSA9PiB7XG4gIGNvbnN0IGRvYyA9IHRyYW5zYWN0aW9uLmRvY1xuICBjb25zdCBvd25DbGllbnRJZCA9IGRvYy5jbGllbnRJRFxuICBtaW5pbWl6ZUF0dHJpYnV0ZUNoYW5nZXMoY3VyclBvcywgYXR0cmlidXRlcylcbiAgY29uc3QgbmVnYXRlZEF0dHJpYnV0ZXMgPSBpbnNlcnRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIGF0dHJpYnV0ZXMpXG4gIC8vIGl0ZXJhdGUgdW50aWwgZmlyc3Qgbm9uLWZvcm1hdCBvciBudWxsIGlzIGZvdW5kXG4gIC8vIGRlbGV0ZSBhbGwgZm9ybWF0cyB3aXRoIGF0dHJpYnV0ZXNbZm9ybWF0LmtleV0gIT0gbnVsbFxuICAvLyBhbHNvIGNoZWNrIHRoZSBhdHRyaWJ1dGVzIGFmdGVyIHRoZSBmaXJzdCBub24tZm9ybWF0IGFzIHdlIGRvIG5vdCB3YW50IHRvIGluc2VydCByZWR1bmRhbnQgbmVnYXRlZCBhdHRyaWJ1dGVzIHRoZXJlXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgaXRlcmF0aW9uTG9vcDogd2hpbGUgKFxuICAgIGN1cnJQb3MucmlnaHQgIT09IG51bGwgJiZcbiAgICAobGVuZ3RoID4gMCB8fFxuICAgICAgKFxuICAgICAgICBuZWdhdGVkQXR0cmlidXRlcy5zaXplID4gMCAmJlxuICAgICAgICAoY3VyclBvcy5yaWdodC5kZWxldGVkIHx8IGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdClcbiAgICAgIClcbiAgICApXG4gICkge1xuICAgIGlmICghY3VyclBvcy5yaWdodC5kZWxldGVkKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGN1cnJQb3MucmlnaHQuY29udGVudClcbiAgICAgICAgICBjb25zdCBhdHRyID0gYXR0cmlidXRlc1trZXldXG4gICAgICAgICAgaWYgKGF0dHIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKGVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgIG5lZ2F0ZWRBdHRyaWJ1dGVzLmRlbGV0ZShrZXkpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gbm8gbmVlZCB0byBmdXJ0aGVyIGV4dGVuZCBuZWdhdGVkQXR0cmlidXRlc1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sYWJlbHNcbiAgICAgICAgICAgICAgICBicmVhayBpdGVyYXRpb25Mb29wXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbmVnYXRlZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyUG9zLnJpZ2h0LmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3VyclBvcy5jdXJyZW50QXR0cmlidXRlcy5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxuICAvLyBRdWlsbCBqdXN0IGFzc3VtZXMgdGhhdCB0aGUgZWRpdG9yIHN0YXJ0cyB3aXRoIGEgbmV3bGluZSBhbmQgdGhhdCBpdCBhbHdheXNcbiAgLy8gZW5kcyB3aXRoIGEgbmV3bGluZS4gV2Ugb25seSBpbnNlcnQgdGhhdCBuZXdsaW5lIHdoZW4gYSBuZXcgbmV3bGluZSBpc1xuICAvLyBpbnNlcnRlZCAtIGkuZSB3aGVuIGxlbmd0aCBpcyBiaWdnZXIgdGhhbiB0eXBlLmxlbmd0aFxuICBpZiAobGVuZ3RoID4gMCkge1xuICAgIGxldCBuZXdsaW5lcyA9ICcnXG4gICAgZm9yICg7IGxlbmd0aCA+IDA7IGxlbmd0aC0tKSB7XG4gICAgICBuZXdsaW5lcyArPSAnXFxuJ1xuICAgIH1cbiAgICBjdXJyUG9zLnJpZ2h0ID0gbmV3IEl0ZW0oY3JlYXRlSUQob3duQ2xpZW50SWQsIGdldFN0YXRlKGRvYy5zdG9yZSwgb3duQ2xpZW50SWQpKSwgY3VyclBvcy5sZWZ0LCBjdXJyUG9zLmxlZnQgJiYgY3VyclBvcy5sZWZ0Lmxhc3RJZCwgY3VyclBvcy5yaWdodCwgY3VyclBvcy5yaWdodCAmJiBjdXJyUG9zLnJpZ2h0LmlkLCBwYXJlbnQsIG51bGwsIG5ldyBDb250ZW50U3RyaW5nKG5ld2xpbmVzKSlcbiAgICBjdXJyUG9zLnJpZ2h0LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgICBjdXJyUG9zLmZvcndhcmQoKVxuICB9XG4gIGluc2VydE5lZ2F0ZWRBdHRyaWJ1dGVzKHRyYW5zYWN0aW9uLCBwYXJlbnQsIGN1cnJQb3MsIG5lZ2F0ZWRBdHRyaWJ1dGVzKVxufVxuXG4vKipcbiAqIENhbGwgdGhpcyBmdW5jdGlvbiBhZnRlciBzdHJpbmcgY29udGVudCBoYXMgYmVlbiBkZWxldGVkIGluIG9yZGVyIHRvXG4gKiBjbGVhbiB1cCBmb3JtYXR0aW5nIEl0ZW1zLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IHN0YXJ0XG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gY3VyciBleGNsdXNpdmUgZW5kLCBhdXRvbWF0aWNhbGx5IGl0ZXJhdGVzIHRvIHRoZSBuZXh0IENvbnRlbnQgSXRlbVxuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IHN0YXJ0QXR0cmlidXRlc1xuICogQHBhcmFtIHtNYXA8c3RyaW5nLGFueT59IGN1cnJBdHRyaWJ1dGVzXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBhbW91bnQgb2YgZm9ybWF0dGluZyBJdGVtcyBkZWxldGVkLlxuICpcbiAqIEBmdW5jdGlvblxuICovXG5jb25zdCBjbGVhbnVwRm9ybWF0dGluZ0dhcCA9ICh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnIsIHN0YXJ0QXR0cmlidXRlcywgY3VyckF0dHJpYnV0ZXMpID0+IHtcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgZW5kID0gc3RhcnRcbiAgLyoqXG4gICAqIEB0eXBlIHtNYXA8c3RyaW5nLENvbnRlbnRGb3JtYXQ+fVxuICAgKi9cbiAgY29uc3QgZW5kRm9ybWF0cyA9IG1hcC5jcmVhdGUoKVxuICB3aGlsZSAoZW5kICYmICghZW5kLmNvdW50YWJsZSB8fCBlbmQuZGVsZXRlZCkpIHtcbiAgICBpZiAoIWVuZC5kZWxldGVkICYmIGVuZC5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50Rm9ybWF0KSB7XG4gICAgICBjb25zdCBjZiA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KVxuICAgICAgZW5kRm9ybWF0cy5zZXQoY2Yua2V5LCBjZilcbiAgICB9XG4gICAgZW5kID0gZW5kLnJpZ2h0XG4gIH1cbiAgbGV0IGNsZWFudXBzID0gMFxuICBsZXQgcmVhY2hlZEN1cnIgPSBmYWxzZVxuICB3aGlsZSAoc3RhcnQgIT09IGVuZCkge1xuICAgIGlmIChjdXJyID09PSBzdGFydCkge1xuICAgICAgcmVhY2hlZEN1cnIgPSB0cnVlXG4gICAgfVxuICAgIGlmICghc3RhcnQuZGVsZXRlZCkge1xuICAgICAgY29uc3QgY29udGVudCA9IHN0YXJ0LmNvbnRlbnRcbiAgICAgIHN3aXRjaCAoY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRGb3JtYXQ6IHtcbiAgICAgICAgICBjb25zdCB7IGtleSwgdmFsdWUgfSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGNvbnRlbnQpXG4gICAgICAgICAgY29uc3Qgc3RhcnRBdHRyVmFsdWUgPSBzdGFydEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbFxuICAgICAgICAgIGlmIChlbmRGb3JtYXRzLmdldChrZXkpICE9PSBjb250ZW50IHx8IHN0YXJ0QXR0clZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgLy8gRWl0aGVyIHRoaXMgZm9ybWF0IGlzIG92ZXJ3cml0dGVuIG9yIGl0IGlzIG5vdCBuZWNlc3NhcnkgYmVjYXVzZSB0aGUgYXR0cmlidXRlIGFscmVhZHkgZXhpc3RlZC5cbiAgICAgICAgICAgIHN0YXJ0LmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgIGNsZWFudXBzKytcbiAgICAgICAgICAgIGlmICghcmVhY2hlZEN1cnIgJiYgKGN1cnJBdHRyaWJ1dGVzLmdldChrZXkpID8/IG51bGwpID09PSB2YWx1ZSAmJiBzdGFydEF0dHJWYWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgaWYgKHN0YXJ0QXR0clZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY3VyckF0dHJpYnV0ZXMuZGVsZXRlKGtleSlcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJyQXR0cmlidXRlcy5zZXQoa2V5LCBzdGFydEF0dHJWYWx1ZSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXJlYWNoZWRDdXJyICYmICFzdGFydC5kZWxldGVkKSB7XG4gICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyQXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoY29udGVudCkpXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovIChzdGFydC5yaWdodClcbiAgfVxuICByZXR1cm4gY2xlYW51cHNcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gaXRlbVxuICovXG5jb25zdCBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwID0gKHRyYW5zYWN0aW9uLCBpdGVtKSA9PiB7XG4gIC8vIGl0ZXJhdGUgdW50aWwgaXRlbS5yaWdodCBpcyBudWxsIG9yIGNvbnRlbnRcbiAgd2hpbGUgKGl0ZW0gJiYgaXRlbS5yaWdodCAmJiAoaXRlbS5yaWdodC5kZWxldGVkIHx8ICFpdGVtLnJpZ2h0LmNvdW50YWJsZSkpIHtcbiAgICBpdGVtID0gaXRlbS5yaWdodFxuICB9XG4gIGNvbnN0IGF0dHJzID0gbmV3IFNldCgpXG4gIC8vIGl0ZXJhdGUgYmFjayB1bnRpbCBhIGNvbnRlbnQgaXRlbSBpcyBmb3VuZFxuICB3aGlsZSAoaXRlbSAmJiAoaXRlbS5kZWxldGVkIHx8ICFpdGVtLmNvdW50YWJsZSkpIHtcbiAgICBpZiAoIWl0ZW0uZGVsZXRlZCAmJiBpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgIGNvbnN0IGtleSA9IC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGl0ZW0uY29udGVudCkua2V5XG4gICAgICBpZiAoYXR0cnMuaGFzKGtleSkpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRycy5hZGQoa2V5KVxuICAgICAgfVxuICAgIH1cbiAgICBpdGVtID0gaXRlbS5sZWZ0XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIGV4cGVyaW1lbnRhbCBhbmQgc3ViamVjdCB0byBjaGFuZ2UgLyBiZSByZW1vdmVkLlxuICpcbiAqIElkZWFsbHksIHdlIGRvbid0IG5lZWQgdGhpcyBmdW5jdGlvbiBhdCBhbGwuIEZvcm1hdHRpbmcgYXR0cmlidXRlcyBzaG91bGQgYmUgY2xlYW5lZCB1cFxuICogYXV0b21hdGljYWxseSBhZnRlciBlYWNoIGNoYW5nZS4gVGhpcyBmdW5jdGlvbiBpdGVyYXRlcyB0d2ljZSBvdmVyIHRoZSBjb21wbGV0ZSBZVGV4dCB0eXBlXG4gKiBhbmQgcmVtb3ZlcyB1bm5lY2Vzc2FyeSBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuIFRoaXMgaXMgYWxzbyBoZWxwZnVsIGZvciB0ZXN0aW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd29uJ3QgYmUgZXhwb3J0ZWQgYW55bW9yZSBhcyBzb29uIGFzIHRoZXJlIGlzIGNvbmZpZGVuY2UgdGhhdCB0aGUgWVRleHQgdHlwZSB3b3JrcyBhcyBpbnRlbmRlZC5cbiAqXG4gKiBAcGFyYW0ge1lUZXh0fSB0eXBlXG4gKiBAcmV0dXJuIHtudW1iZXJ9IEhvdyBtYW55IGZvcm1hdHRpbmcgYXR0cmlidXRlcyBoYXZlIGJlZW4gY2xlYW5lZCB1cC5cbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFudXBZVGV4dEZvcm1hdHRpbmcgPSB0eXBlID0+IHtcbiAgbGV0IHJlcyA9IDBcbiAgdHJhbnNhY3QoLyoqIEB0eXBlIHtEb2N9ICovICh0eXBlLmRvYyksIHRyYW5zYWN0aW9uID0+IHtcbiAgICBsZXQgc3RhcnQgPSAvKiogQHR5cGUge0l0ZW19ICovICh0eXBlLl9zdGFydClcbiAgICBsZXQgZW5kID0gdHlwZS5fc3RhcnRcbiAgICBsZXQgc3RhcnRBdHRyaWJ1dGVzID0gbWFwLmNyZWF0ZSgpXG4gICAgY29uc3QgY3VycmVudEF0dHJpYnV0ZXMgPSBtYXAuY29weShzdGFydEF0dHJpYnV0ZXMpXG4gICAgd2hpbGUgKGVuZCkge1xuICAgICAgaWYgKGVuZC5kZWxldGVkID09PSBmYWxzZSkge1xuICAgICAgICBzd2l0Y2ggKGVuZC5jb250ZW50LmNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgdXBkYXRlQ3VycmVudEF0dHJpYnV0ZXMoY3VycmVudEF0dHJpYnV0ZXMsIC8qKiBAdHlwZSB7Q29udGVudEZvcm1hdH0gKi8gKGVuZC5jb250ZW50KSlcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJlcyArPSBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGVuZCwgc3RhcnRBdHRyaWJ1dGVzLCBjdXJyZW50QXR0cmlidXRlcylcbiAgICAgICAgICAgIHN0YXJ0QXR0cmlidXRlcyA9IG1hcC5jb3B5KGN1cnJlbnRBdHRyaWJ1dGVzKVxuICAgICAgICAgICAgc3RhcnQgPSBlbmRcbiAgICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZC5yaWdodFxuICAgIH1cbiAgfSlcbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFRoaXMgd2lsbCBiZSBjYWxsZWQgYnkgdGhlIHRyYW5zY3Rpb24gb25jZSB0aGUgZXZlbnQgaGFuZGxlcnMgYXJlIGNhbGxlZCB0byBwb3RlbnRpYWxseSBjbGVhbnVwXG4gKiBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuXG4gKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFudXBZVGV4dEFmdGVyVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiA9PiB7XG4gIC8qKlxuICAgKiBAdHlwZSB7U2V0PFlUZXh0Pn1cbiAgICovXG4gIGNvbnN0IG5lZWRGdWxsQ2xlYW51cCA9IG5ldyBTZXQoKVxuICAvLyBjaGVjayBpZiBhbm90aGVyIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWRcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGZvciAoY29uc3QgW2NsaWVudCwgYWZ0ZXJDbG9ja10gb2YgdHJhbnNhY3Rpb24uYWZ0ZXJTdGF0ZS5lbnRyaWVzKCkpIHtcbiAgICBjb25zdCBjbG9jayA9IHRyYW5zYWN0aW9uLmJlZm9yZVN0YXRlLmdldChjbGllbnQpIHx8IDBcbiAgICBpZiAoYWZ0ZXJDbG9jayA9PT0gY2xvY2spIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuICAgIGl0ZXJhdGVTdHJ1Y3RzKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0FycmF5PEl0ZW18R0M+fSAqLyAoZG9jLnN0b3JlLmNsaWVudHMuZ2V0KGNsaWVudCkpLCBjbG9jaywgYWZ0ZXJDbG9jaywgaXRlbSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgICFpdGVtLmRlbGV0ZWQgJiYgLyoqIEB0eXBlIHtJdGVtfSAqLyAoaXRlbSkuY29udGVudC5jb25zdHJ1Y3RvciA9PT0gQ29udGVudEZvcm1hdCAmJiBpdGVtLmNvbnN0cnVjdG9yICE9PSBHQ1xuICAgICAgKSB7XG4gICAgICAgIG5lZWRGdWxsQ2xlYW51cC5hZGQoLyoqIEB0eXBlIHthbnl9ICovIChpdGVtKS5wYXJlbnQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuICAvLyBjbGVhbnVwIGluIGEgbmV3IHRyYW5zYWN0aW9uXG4gIHRyYW5zYWN0KGRvYywgKHQpID0+IHtcbiAgICBpdGVyYXRlRGVsZXRlZFN0cnVjdHModHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9uLmRlbGV0ZVNldCwgaXRlbSA9PiB7XG4gICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEdDIHx8ICEoLyoqIEB0eXBlIHtZVGV4dH0gKi8gKGl0ZW0ucGFyZW50KS5faGFzRm9ybWF0dGluZykgfHwgbmVlZEZ1bGxDbGVhbnVwLmhhcygvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcmVudCA9IC8qKiBAdHlwZSB7WVRleHR9ICovIChpdGVtLnBhcmVudClcbiAgICAgIGlmIChpdGVtLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IENvbnRlbnRGb3JtYXQpIHtcbiAgICAgICAgbmVlZEZ1bGxDbGVhbnVwLmFkZChwYXJlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBubyBmb3JtYXR0aW5nIGF0dHJpYnV0ZSB3YXMgaW5zZXJ0ZWQgb3IgZGVsZXRlZCwgd2UgY2FuIG1ha2UgZHVlIHdpdGggY29udGV4dGxlc3NcbiAgICAgICAgLy8gZm9ybWF0dGluZyBjbGVhbnVwcy5cbiAgICAgICAgLy8gQ29udGV4dGxlc3M6IGl0IGlzIG5vdCBuZWNlc3NhcnkgdG8gY29tcHV0ZSBjdXJyZW50QXR0cmlidXRlcyBmb3IgdGhlIGFmZmVjdGVkIHBvc2l0aW9uLlxuICAgICAgICBjbGVhbnVwQ29udGV4dGxlc3NGb3JtYXR0aW5nR2FwKHQsIGl0ZW0pXG4gICAgICB9XG4gICAgfSlcbiAgICAvLyBJZiBhIGZvcm1hdHRpbmcgaXRlbSB3YXMgaW5zZXJ0ZWQsIHdlIHNpbXBseSBjbGVhbiB0aGUgd2hvbGUgdHlwZS5cbiAgICAvLyBXZSBuZWVkIHRvIGNvbXB1dGUgY3VycmVudEF0dHJpYnV0ZXMgZm9yIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFueXdheS5cbiAgICBmb3IgKGNvbnN0IHlUZXh0IG9mIG5lZWRGdWxsQ2xlYW51cCkge1xuICAgICAgY2xlYW51cFlUZXh0Rm9ybWF0dGluZyh5VGV4dClcbiAgICB9XG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SXRlbVRleHRMaXN0UG9zaXRpb259IGN1cnJQb3NcbiAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGhcbiAqIEByZXR1cm4ge0l0ZW1UZXh0TGlzdFBvc2l0aW9ufVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuY29uc3QgZGVsZXRlVGV4dCA9ICh0cmFuc2FjdGlvbiwgY3VyclBvcywgbGVuZ3RoKSA9PiB7XG4gIGNvbnN0IHN0YXJ0TGVuZ3RoID0gbGVuZ3RoXG4gIGNvbnN0IHN0YXJ0QXR0cnMgPSBtYXAuY29weShjdXJyUG9zLmN1cnJlbnRBdHRyaWJ1dGVzKVxuICBjb25zdCBzdGFydCA9IGN1cnJQb3MucmlnaHRcbiAgd2hpbGUgKGxlbmd0aCA+IDAgJiYgY3VyclBvcy5yaWdodCAhPT0gbnVsbCkge1xuICAgIGlmIChjdXJyUG9zLnJpZ2h0LmRlbGV0ZWQgPT09IGZhbHNlKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJQb3MucmlnaHQuY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICBjYXNlIENvbnRlbnRUeXBlOlxuICAgICAgICBjYXNlIENvbnRlbnRFbWJlZDpcbiAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgIGlmIChsZW5ndGggPCBjdXJyUG9zLnJpZ2h0Lmxlbmd0aCkge1xuICAgICAgICAgICAgZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGNyZWF0ZUlEKGN1cnJQb3MucmlnaHQuaWQuY2xpZW50LCBjdXJyUG9zLnJpZ2h0LmlkLmNsb2NrICsgbGVuZ3RoKSlcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoIC09IGN1cnJQb3MucmlnaHQubGVuZ3RoXG4gICAgICAgICAgY3VyclBvcy5yaWdodC5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gICAgY3VyclBvcy5mb3J3YXJkKClcbiAgfVxuICBpZiAoc3RhcnQpIHtcbiAgICBjbGVhbnVwRm9ybWF0dGluZ0dhcCh0cmFuc2FjdGlvbiwgc3RhcnQsIGN1cnJQb3MucmlnaHQsIHN0YXJ0QXR0cnMsIGN1cnJQb3MuY3VycmVudEF0dHJpYnV0ZXMpXG4gIH1cbiAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKC8qKiBAdHlwZSB7SXRlbX0gKi8gKGN1cnJQb3MubGVmdCB8fCBjdXJyUG9zLnJpZ2h0KS5wYXJlbnQpXG4gIGlmIChwYXJlbnQuX3NlYXJjaE1hcmtlcikge1xuICAgIHVwZGF0ZU1hcmtlckNoYW5nZXMocGFyZW50Ll9zZWFyY2hNYXJrZXIsIGN1cnJQb3MuaW5kZXgsIC1zdGFydExlbmd0aCArIGxlbmd0aClcbiAgfVxuICByZXR1cm4gY3VyclBvc1xufVxuXG4vKipcbiAqIFRoZSBRdWlsbCBEZWx0YSBmb3JtYXQgcmVwcmVzZW50cyBjaGFuZ2VzIG9uIGEgdGV4dCBkb2N1bWVudCB3aXRoXG4gKiBmb3JtYXR0aW5nIGluZm9ybWF0aW9uLiBGb3IgbW9yIGluZm9ybWF0aW9uIHZpc2l0IHtAbGluayBodHRwczovL3F1aWxsanMuY29tL2RvY3MvZGVsdGEvfFF1aWxsIERlbHRhfVxuICpcbiAqIEBleGFtcGxlXG4gKiAgIHtcbiAqICAgICBvcHM6IFtcbiAqICAgICAgIHsgaW5zZXJ0OiAnR2FuZGFsZicsIGF0dHJpYnV0ZXM6IHsgYm9sZDogdHJ1ZSB9IH0sXG4gKiAgICAgICB7IGluc2VydDogJyB0aGUgJyB9LFxuICogICAgICAgeyBpbnNlcnQ6ICdHcmV5JywgYXR0cmlidXRlczogeyBjb2xvcjogJyNjY2NjY2MnIH0gfVxuICogICAgIF1cbiAqICAgfVxuICpcbiAqL1xuXG4vKipcbiAgKiBBdHRyaWJ1dGVzIHRoYXQgY2FuIGJlIGFzc2lnbmVkIHRvIGEgc2VsZWN0aW9uIG9mIHRleHQuXG4gICpcbiAgKiBAZXhhbXBsZVxuICAqICAge1xuICAqICAgICBib2xkOiB0cnVlLFxuICAqICAgICBmb250LXNpemU6ICc0MHB4J1xuICAqICAgfVxuICAqXG4gICogQHR5cGVkZWYge09iamVjdH0gVGV4dEF0dHJpYnV0ZXNcbiAgKi9cblxuLyoqXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WVRleHQ+XG4gKiBFdmVudCB0aGF0IGRlc2NyaWJlcyB0aGUgY2hhbmdlcyBvbiBhIFlUZXh0IHR5cGUuXG4gKi9cbmV4cG9ydCBjbGFzcyBZVGV4dEV2ZW50IGV4dGVuZHMgWUV2ZW50IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WVRleHR9IHl0ZXh0XG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PGFueT59IHN1YnMgVGhlIGtleXMgdGhhdCBjaGFuZ2VkXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoeXRleHQsIHRyYW5zYWN0aW9uLCBzdWJzKSB7XG4gICAgc3VwZXIoeXRleHQsIHRyYW5zYWN0aW9uKVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICogQHR5cGUge0Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLmNoaWxkTGlzdENoYW5nZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIFNldCBvZiBhbGwgY2hhbmdlZCBhdHRyaWJ1dGVzLlxuICAgICAqIEB0eXBlIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICB0aGlzLmtleXNDaGFuZ2VkID0gbmV3IFNldCgpXG4gICAgc3Vicy5mb3JFYWNoKChzdWIpID0+IHtcbiAgICAgIGlmIChzdWIgPT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5jaGlsZExpc3RDaGFuZ2VkID0gdHJ1ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5rZXlzQ2hhbmdlZC5hZGQoc3ViKVxuICAgICAgfVxuICAgIH0pXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge3thZGRlZDpTZXQ8SXRlbT4sZGVsZXRlZDpTZXQ8SXRlbT4sa2V5czpNYXA8c3RyaW5nLHthY3Rpb246J2FkZCd8J3VwZGF0ZSd8J2RlbGV0ZScsb2xkVmFsdWU6YW55fT4sZGVsdGE6QXJyYXk8e2luc2VydD86QXJyYXk8YW55PnxzdHJpbmcsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICovXG4gIGdldCBjaGFuZ2VzICgpIHtcbiAgICBpZiAodGhpcy5fY2hhbmdlcyA9PT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7e2FkZGVkOlNldDxJdGVtPixkZWxldGVkOlNldDxJdGVtPixrZXlzOk1hcDxzdHJpbmcse2FjdGlvbjonYWRkJ3wndXBkYXRlJ3wnZGVsZXRlJyxvbGRWYWx1ZTphbnl9PixkZWx0YTpBcnJheTx7aW5zZXJ0PzpBcnJheTxhbnk+fHN0cmluZ3xBYnN0cmFjdFR5cGU8YW55PnxvYmplY3QsIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlcn0+fX1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY2hhbmdlcyA9IHtcbiAgICAgICAga2V5czogdGhpcy5rZXlzLFxuICAgICAgICBkZWx0YTogdGhpcy5kZWx0YSxcbiAgICAgICAgYWRkZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgZGVsZXRlZDogbmV3IFNldCgpXG4gICAgICB9XG4gICAgICB0aGlzLl9jaGFuZ2VzID0gY2hhbmdlc1xuICAgIH1cbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0aGlzLl9jaGFuZ2VzKVxuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGUgdGhlIGNoYW5nZXMgaW4gdGhlIGRlbHRhIGZvcm1hdC5cbiAgICogQSB7QGxpbmsgaHR0cHM6Ly9xdWlsbGpzLmNvbS9kb2NzL2RlbHRhL3xRdWlsbCBEZWx0YX0pIHRoYXQgcmVwcmVzZW50cyB0aGUgY2hhbmdlcyBvbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtBcnJheTx7aW5zZXJ0PzpzdHJpbmd8b2JqZWN0fEFic3RyYWN0VHlwZTxhbnk+LCBkZWxldGU/Om51bWJlciwgcmV0YWluPzpudW1iZXIsIGF0dHJpYnV0ZXM/OiBPYmplY3Q8c3RyaW5nLGFueT59Pn1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0IGRlbHRhICgpIHtcbiAgICBpZiAodGhpcy5fZGVsdGEgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHkgPSAvKiogQHR5cGUge0RvY30gKi8gKHRoaXMudGFyZ2V0LmRvYylcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PHtpbnNlcnQ/OnN0cmluZ3xvYmplY3R8QWJzdHJhY3RUeXBlPGFueT4sIGRlbGV0ZT86bnVtYmVyLCByZXRhaW4/Om51bWJlciwgYXR0cmlidXRlcz86IE9iamVjdDxzdHJpbmcsYW55Pn0+fVxuICAgICAgICovXG4gICAgICBjb25zdCBkZWx0YSA9IFtdXG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpIC8vIHNhdmVzIGFsbCBjdXJyZW50IGF0dHJpYnV0ZXMgZm9yIGluc2VydFxuICAgICAgICBjb25zdCBvbGRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpXG4gICAgICAgIGxldCBpdGVtID0gdGhpcy50YXJnZXQuX3N0YXJ0XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7c3RyaW5nP31cbiAgICAgICAgICovXG4gICAgICAgIGxldCBhY3Rpb24gPSBudWxsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9IC8vIGNvdW50cyBhZGRlZCBvciByZW1vdmVkIG5ldyBhdHRyaWJ1dGVzIGZvciByZXRhaW5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtzdHJpbmd8b2JqZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGluc2VydCA9ICcnXG4gICAgICAgIGxldCByZXRhaW4gPSAwXG4gICAgICAgIGxldCBkZWxldGVMZW4gPSAwXG4gICAgICAgIGNvbnN0IGFkZE9wID0gKCkgPT4ge1xuICAgICAgICAgIGlmIChhY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHR5cGUge2FueX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IG9wID0gbnVsbFxuICAgICAgICAgICAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgY2FzZSAnZGVsZXRlJzpcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlTGVuID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AgPSB7IGRlbGV0ZTogZGVsZXRlTGVuIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuID0gMFxuICAgICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgICAgIGNhc2UgJ2luc2VydCc6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnNlcnQgPT09ICdvYmplY3QnIHx8IGluc2VydC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICBvcCA9IHsgaW5zZXJ0IH1cbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0ge31cbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEF0dHJpYnV0ZXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3AuYXR0cmlidXRlc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluc2VydCA9ICcnXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAncmV0YWluJzpcbiAgICAgICAgICAgICAgICBpZiAocmV0YWluID4gMCkge1xuICAgICAgICAgICAgICAgICAgb3AgPSB7IHJldGFpbiB9XG4gICAgICAgICAgICAgICAgICBpZiAoIW9iamVjdC5pc0VtcHR5KGF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wLmF0dHJpYnV0ZXMgPSBvYmplY3QuYXNzaWduKHt9LCBhdHRyaWJ1dGVzKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gPSAwXG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvcCkgZGVsdGEucHVzaChvcClcbiAgICAgICAgICAgIGFjdGlvbiA9IG51bGxcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGl0ZW0gIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKGl0ZW0uY29udGVudC5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZTpcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgIGFjdGlvbiA9ICdpbnNlcnQnXG4gICAgICAgICAgICAgICAgICBpbnNlcnQgPSBpdGVtLmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdXG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAnZGVsZXRlJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGVMZW4gKz0gMVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ3JldGFpbidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0YWluICs9IDFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50U3RyaW5nOlxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdpbnNlcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2luc2VydCdcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGluc2VydCArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChpdGVtLmNvbnRlbnQpLnN0clxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uICE9PSAnZGVsZXRlJykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgYWN0aW9uID0gJ2RlbGV0ZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlTGVuICs9IGl0ZW0ubGVuZ3RoXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gIT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICBhZGRPcCgpXG4gICAgICAgICAgICAgICAgICBhY3Rpb24gPSAncmV0YWluJ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXRhaW4gKz0gaXRlbS5sZW5ndGhcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OiB7XG4gICAgICAgICAgICAgIGNvbnN0IHsga2V5LCB2YWx1ZSB9ID0gLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KVxuICAgICAgICAgICAgICBpZiAodGhpcy5hZGRzKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmRlbGV0ZXMoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbCA9IGN1cnJlbnRBdHRyaWJ1dGVzLmdldChrZXkpID8/IG51bGxcbiAgICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAncmV0YWluJykge1xuICAgICAgICAgICAgICAgICAgICAgIGFkZE9wKClcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXF1YWxBdHRycyh2YWx1ZSwgKG9sZEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJpYnV0ZXNba2V5XVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGVsZXRlcyhpdGVtKSkge1xuICAgICAgICAgICAgICAgIG9sZEF0dHJpYnV0ZXMuc2V0KGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgY29uc3QgY3VyVmFsID0gY3VycmVudEF0dHJpYnV0ZXMuZ2V0KGtleSkgPz8gbnVsbFxuICAgICAgICAgICAgICAgIGlmICghZXF1YWxBdHRycyhjdXJWYWwsIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGFjdGlvbiA9PT0gJ3JldGFpbicpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlc1trZXldID0gY3VyVmFsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBvbGRBdHRyaWJ1dGVzLnNldChrZXksIHZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHIgPSBhdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICAgICAgICBpZiAoYXR0ciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIWVxdWFsQXR0cnMoYXR0ciwgdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhY3Rpb24gPT09ICdyZXRhaW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBhdHRyaWJ1dGVzW2tleV1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzW2tleV0gPSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGF0dHIgIT09IG51bGwpIHsgLy8gdGhpcyB3aWxsIGJlIGNsZWFuZWQgdXAgYXV0b21hdGljYWxseSBieSB0aGUgY29udGV4dGxlc3MgY2xlYW51cCBmdW5jdGlvblxuICAgICAgICAgICAgICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aW9uID09PSAnaW5zZXJ0Jykge1xuICAgICAgICAgICAgICAgICAgYWRkT3AoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVDdXJyZW50QXR0cmlidXRlcyhjdXJyZW50QXR0cmlidXRlcywgLyoqIEB0eXBlIHtDb250ZW50Rm9ybWF0fSAqLyAoaXRlbS5jb250ZW50KSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtID0gaXRlbS5yaWdodFxuICAgICAgICB9XG4gICAgICAgIGFkZE9wKClcbiAgICAgICAgd2hpbGUgKGRlbHRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjb25zdCBsYXN0T3AgPSBkZWx0YVtkZWx0YS5sZW5ndGggLSAxXVxuICAgICAgICAgIGlmIChsYXN0T3AucmV0YWluICE9PSB1bmRlZmluZWQgJiYgbGFzdE9wLmF0dHJpYnV0ZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gcmV0YWluIGRlbHRhJ3MgaWYgdGhleSBkb24ndCBhc3NpZ24gYXR0cmlidXRlc1xuICAgICAgICAgICAgZGVsdGEucG9wKClcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9kZWx0YSA9IGRlbHRhXG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUge2FueX0gKi8gKHRoaXMuX2RlbHRhKVxuICB9XG59XG5cbi8qKlxuICogVHlwZSB0aGF0IHJlcHJlc2VudHMgdGV4dCB3aXRoIGZvcm1hdHRpbmcgaW5mb3JtYXRpb24uXG4gKlxuICogVGhpcyB0eXBlIHJlcGxhY2VzIHktcmljaHRleHQgYXMgdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBhYmxlIHRvIGhhbmRsZVxuICogYmxvY2sgZm9ybWF0cyAoZm9ybWF0IGluZm9ybWF0aW9uIG9uIGEgcGFyYWdyYXBoKSwgZW1iZWRzIChjb21wbGV4IGVsZW1lbnRzXG4gKiBsaWtlIHBpY3R1cmVzIGFuZCB2aWRlb3MpLCBhbmQgdGV4dCBmb3JtYXRzICgqKmJvbGQqKiwgKml0YWxpYyopLlxuICpcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZVGV4dEV2ZW50PlxuICovXG5leHBvcnQgY2xhc3MgWVRleHQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtzdHJpbmddIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBZVGV4dC5cbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHJpbmcpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGVuZGluZyBvcGVyYXRpb25zIG9uIHRoaXMgdHlwZVxuICAgICAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbigpOnZvaWQ+P31cbiAgICAgKi9cbiAgICB0aGlzLl9wZW5kaW5nID0gc3RyaW5nICE9PSB1bmRlZmluZWQgPyBbKCkgPT4gdGhpcy5pbnNlcnQoMCwgc3RyaW5nKV0gOiBbXVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxBcnJheVNlYXJjaE1hcmtlcj58bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLl9zZWFyY2hNYXJrZXIgPSBbXVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBZVGV4dCBjb250YWlucyBmb3JtYXR0aW5nIGF0dHJpYnV0ZXMuXG4gICAgICogVGhpcyBmbGFnIGlzIHVwZGF0ZWQgd2hlbiBhIGZvcm1hdHRpbmcgaXRlbSBpcyBpbnRlZ3JhdGVkIChzZWUgQ29udGVudEZvcm1hdC5pbnRlZ3JhdGUpXG4gICAgICovXG4gICAgdGhpcy5faGFzRm9ybWF0dGluZyA9IGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTnVtYmVyIG9mIGNoYXJhY3RlcnMgb2YgdGhpcyB0ZXh0IHR5cGUuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqL1xuICBnZXQgbGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtEb2N9IHlcbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBfaW50ZWdyYXRlICh5LCBpdGVtKSB7XG4gICAgc3VwZXIuX2ludGVncmF0ZSh5LCBpdGVtKVxuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLmZvckVhY2goZiA9PiBmKCkpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcihlKVxuICAgIH1cbiAgICB0aGlzLl9wZW5kaW5nID0gbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVRleHQoKVxuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSlcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVRleHRFdmVudCBhbmQgY2FsbHMgb2JzZXJ2ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1NldDxudWxsfHN0cmluZz59IHBhcmVudFN1YnMgS2V5cyBjaGFuZ2VkIG9uIHRoaXMgdHlwZS4gYG51bGxgIGlmIGxpc3Qgd2FzIG1vZGlmaWVkLlxuICAgKi9cbiAgX2NhbGxPYnNlcnZlciAodHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpIHtcbiAgICBzdXBlci5fY2FsbE9ic2VydmVyKHRyYW5zYWN0aW9uLCBwYXJlbnRTdWJzKVxuICAgIGNvbnN0IGV2ZW50ID0gbmV3IFlUZXh0RXZlbnQodGhpcywgdHJhbnNhY3Rpb24sIHBhcmVudFN1YnMpXG4gICAgY2FsbFR5cGVPYnNlcnZlcnModGhpcywgdHJhbnNhY3Rpb24sIGV2ZW50KVxuICAgIC8vIElmIGEgcmVtb3RlIGNoYW5nZSBoYXBwZW5lZCwgd2UgdHJ5IHRvIGNsZWFudXAgcG90ZW50aWFsIGZvcm1hdHRpbmcgZHVwbGljYXRlcy5cbiAgICBpZiAoIXRyYW5zYWN0aW9uLmxvY2FsICYmIHRoaXMuX2hhc0Zvcm1hdHRpbmcpIHtcbiAgICAgIHRyYW5zYWN0aW9uLl9uZWVkRm9ybWF0dGluZ0NsZWFudXAgPSB0cnVlXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvU3RyaW5nICgpIHtcbiAgICBsZXQgc3RyID0gJydcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAqL1xuICAgIGxldCBuID0gdGhpcy5fc3RhcnRcbiAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFuLmRlbGV0ZWQgJiYgbi5jb3VudGFibGUgJiYgbi5jb250ZW50LmNvbnN0cnVjdG9yID09PSBDb250ZW50U3RyaW5nKSB7XG4gICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0clxuICAgICAgfVxuICAgICAgbiA9IG4ucmlnaHRcbiAgICB9XG4gICAgcmV0dXJuIHN0clxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHVuZm9ybWF0dGVkIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGlzIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQXBwbHkgYSB7QGxpbmsgRGVsdGF9IG9uIHRoaXMgc2hhcmVkIFlUZXh0IHR5cGUuXG4gICAqXG4gICAqIEBwYXJhbSB7YW55fSBkZWx0YSBUaGUgY2hhbmdlcyB0byBhcHBseSBvbiB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgb3B0c1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLnNhbml0aXplXSBTYW5pdGl6ZSBpbnB1dCBkZWx0YS4gUmVtb3ZlcyBlbmRpbmcgbmV3bGluZXMgaWYgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFwcGx5RGVsdGEgKGRlbHRhLCB7IHNhbml0aXplID0gdHJ1ZSB9ID0ge30pIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJQb3MgPSBuZXcgSXRlbVRleHRMaXN0UG9zaXRpb24obnVsbCwgdGhpcy5fc3RhcnQsIDAsIG5ldyBNYXAoKSlcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWx0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG9wID0gZGVsdGFbaV1cbiAgICAgICAgICBpZiAob3AuaW5zZXJ0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIFF1aWxsIGFzc3VtZXMgdGhhdCB0aGUgY29udGVudCBzdGFydHMgd2l0aCBhbiBlbXB0eSBwYXJhZ3JhcGguXG4gICAgICAgICAgICAvLyBZanMvWS5UZXh0IGFzc3VtZXMgdGhhdCBpdCBzdGFydHMgZW1wdHkuIFdlIGFsd2F5cyBoaWRlIHRoYXRcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIGEgbmV3bGluZSBhdCB0aGUgZW5kIG9mIHRoZSBjb250ZW50LlxuICAgICAgICAgICAgLy8gSWYgd2Ugb21pdCB0aGlzIHN0ZXAsIGNsaWVudHMgd2lsbCBzZWUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mXG4gICAgICAgICAgICAvLyBwYXJhZ3JhcGhzLCBidXQgbm90aGluZyBiYWQgd2lsbCBoYXBwZW4uXG4gICAgICAgICAgICBjb25zdCBpbnMgPSAoIXNhbml0aXplICYmIHR5cGVvZiBvcC5pbnNlcnQgPT09ICdzdHJpbmcnICYmIGkgPT09IGRlbHRhLmxlbmd0aCAtIDEgJiYgY3VyclBvcy5yaWdodCA9PT0gbnVsbCAmJiBvcC5pbnNlcnQuc2xpY2UoLTEpID09PSAnXFxuJykgPyBvcC5pbnNlcnQuc2xpY2UoMCwgLTEpIDogb3AuaW5zZXJ0XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucyAhPT0gJ3N0cmluZycgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgY3VyclBvcywgaW5zLCBvcC5hdHRyaWJ1dGVzIHx8IHt9KVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAob3AucmV0YWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvcm1hdFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIGN1cnJQb3MsIG9wLnJldGFpbiwgb3AuYXR0cmlidXRlcyB8fCB7fSlcbiAgICAgICAgICB9IGVsc2UgaWYgKG9wLmRlbGV0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBkZWxldGVUZXh0KHRyYW5zYWN0aW9uLCBjdXJyUG9zLCBvcC5kZWxldGUpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5hcHBseURlbHRhKGRlbHRhKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgRGVsdGEgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBZVGV4dCB0eXBlLlxuICAgKlxuICAgKiBAcGFyYW0ge1NuYXBzaG90fSBbc25hcHNob3RdXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtwcmV2U25hcHNob3RdXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oJ3JlbW92ZWQnIHwgJ2FkZGVkJywgSUQpOmFueX0gW2NvbXB1dGVZQ2hhbmdlXVxuICAgKiBAcmV0dXJuIHthbnl9IFRoZSBEZWx0YSByZXByZXNlbnRhdGlvbiBvZiB0aGlzIHR5cGUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRGVsdGEgKHNuYXBzaG90LCBwcmV2U25hcHNob3QsIGNvbXB1dGVZQ2hhbmdlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGV7QXJyYXk8YW55Pn1cbiAgICAgKi9cbiAgICBjb25zdCBvcHMgPSBbXVxuICAgIGNvbnN0IGN1cnJlbnRBdHRyaWJ1dGVzID0gbmV3IE1hcCgpXG4gICAgY29uc3QgZG9jID0gLyoqIEB0eXBlIHtEb2N9ICovICh0aGlzLmRvYylcbiAgICBsZXQgc3RyID0gJydcbiAgICBsZXQgbiA9IHRoaXMuX3N0YXJ0XG4gICAgZnVuY3Rpb24gcGFja1N0ciAoKSB7XG4gICAgICBpZiAoc3RyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gcGFjayBzdHIgd2l0aCBhdHRyaWJ1dGVzIHRvIG9wc1xuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSB7fVxuICAgICAgICBsZXQgYWRkQXR0cmlidXRlcyA9IGZhbHNlXG4gICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgICBhZGRBdHRyaWJ1dGVzID0gdHJ1ZVxuICAgICAgICAgIGF0dHJpYnV0ZXNba2V5XSA9IHZhbHVlXG4gICAgICAgIH0pXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7T2JqZWN0PHN0cmluZyxhbnk+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3Qgb3AgPSB7IGluc2VydDogc3RyIH1cbiAgICAgICAgaWYgKGFkZEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0gYXR0cmlidXRlc1xuICAgICAgICB9XG4gICAgICAgIG9wcy5wdXNoKG9wKVxuICAgICAgICBzdHIgPSAnJ1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb21wdXRlRGVsdGEgPSAoKSA9PiB7XG4gICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSB8fCAocHJldlNuYXBzaG90ICE9PSB1bmRlZmluZWQgJiYgaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpKSB7XG4gICAgICAgICAgc3dpdGNoIChuLmNvbnRlbnQuY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgQ29udGVudFN0cmluZzoge1xuICAgICAgICAgICAgICBjb25zdCBjdXIgPSBjdXJyZW50QXR0cmlidXRlcy5nZXQoJ3ljaGFuZ2UnKVxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIGlmIChjdXIgPT09IHVuZGVmaW5lZCB8fCBjdXIudXNlciAhPT0gbi5pZC5jbGllbnQgfHwgY3VyLnR5cGUgIT09ICdyZW1vdmVkJykge1xuICAgICAgICAgICAgICAgICAgcGFja1N0cigpXG4gICAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5zZXQoJ3ljaGFuZ2UnLCBjb21wdXRlWUNoYW5nZSA/IGNvbXB1dGVZQ2hhbmdlKCdyZW1vdmVkJywgbi5pZCkgOiB7IHR5cGU6ICdyZW1vdmVkJyB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmV2U25hcHNob3QgIT09IHVuZGVmaW5lZCAmJiAhaXNWaXNpYmxlKG4sIHByZXZTbmFwc2hvdCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyID09PSB1bmRlZmluZWQgfHwgY3VyLnVzZXIgIT09IG4uaWQuY2xpZW50IHx8IGN1ci50eXBlICE9PSAnYWRkZWQnKSB7XG4gICAgICAgICAgICAgICAgICBwYWNrU3RyKClcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRBdHRyaWJ1dGVzLnNldCgneWNoYW5nZScsIGNvbXB1dGVZQ2hhbmdlID8gY29tcHV0ZVlDaGFuZ2UoJ2FkZGVkJywgbi5pZCkgOiB7IHR5cGU6ICdhZGRlZCcgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwYWNrU3RyKClcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5kZWxldGUoJ3ljaGFuZ2UnKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0ciArPSAvKiogQHR5cGUge0NvbnRlbnRTdHJpbmd9ICovIChuLmNvbnRlbnQpLnN0clxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50VHlwZTpcbiAgICAgICAgICAgIGNhc2UgQ29udGVudEVtYmVkOiB7XG4gICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICogQHR5cGUge09iamVjdDxzdHJpbmcsYW55Pn1cbiAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgICAgIGluc2VydDogbi5jb250ZW50LmdldENvbnRlbnQoKVswXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChjdXJyZW50QXR0cmlidXRlcy5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJzID0gLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLGFueT59ICovICh7fSlcbiAgICAgICAgICAgICAgICBvcC5hdHRyaWJ1dGVzID0gYXR0cnNcbiAgICAgICAgICAgICAgICBjdXJyZW50QXR0cmlidXRlcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICBhdHRyc1trZXldID0gdmFsdWVcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG9wcy5wdXNoKG9wKVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb250ZW50Rm9ybWF0OlxuICAgICAgICAgICAgICBpZiAoaXNWaXNpYmxlKG4sIHNuYXBzaG90KSkge1xuICAgICAgICAgICAgICAgIHBhY2tTdHIoKVxuICAgICAgICAgICAgICAgIHVwZGF0ZUN1cnJlbnRBdHRyaWJ1dGVzKGN1cnJlbnRBdHRyaWJ1dGVzLCAvKiogQHR5cGUge0NvbnRlbnRGb3JtYXR9ICovIChuLmNvbnRlbnQpKVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG4gPSBuLnJpZ2h0XG4gICAgICB9XG4gICAgICBwYWNrU3RyKClcbiAgICB9XG4gICAgaWYgKHNuYXBzaG90IHx8IHByZXZTbmFwc2hvdCkge1xuICAgICAgLy8gc25hcHNob3RzIGFyZSBtZXJnZWQgYWdhaW4gYWZ0ZXIgdGhlIHRyYW5zYWN0aW9uLCBzbyB3ZSBuZWVkIHRvIGtlZXAgdGhlXG4gICAgICAvLyB0cmFuc2FjdGlvbiBhbGl2ZSB1bnRpbCB3ZSBhcmUgZG9uZVxuICAgICAgdHJhbnNhY3QoZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGlmIChzbmFwc2hvdCkge1xuICAgICAgICAgIHNwbGl0U25hcHNob3RBZmZlY3RlZFN0cnVjdHModHJhbnNhY3Rpb24sIHNuYXBzaG90KVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U25hcHNob3QpIHtcbiAgICAgICAgICBzcGxpdFNuYXBzaG90QWZmZWN0ZWRTdHJ1Y3RzKHRyYW5zYWN0aW9uLCBwcmV2U25hcHNob3QpXG4gICAgICAgIH1cbiAgICAgICAgY29tcHV0ZURlbHRhKClcbiAgICAgIH0sICdjbGVhbnVwJylcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcHV0ZURlbHRhKClcbiAgICB9XG4gICAgcmV0dXJuIG9wc1xuICB9XG5cbiAgLyoqXG4gICAqIEluc2VydCB0ZXh0IGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgaW5zZXJ0aW5nLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGV4dCB0byBpbnNlcnQgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbi5cbiAgICogQHBhcmFtIHtUZXh0QXR0cmlidXRlc30gW2F0dHJpYnV0ZXNdIE9wdGlvbmFsbHkgZGVmaW5lIHNvbWUgZm9ybWF0dGluZ1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZSBpbnNlcnRlZFxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRleHQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpIHtcbiAgICBpZiAodGV4dC5sZW5ndGggPD0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvY1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHBvcyA9IGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsICFhdHRyaWJ1dGVzKVxuICAgICAgICBpZiAoIWF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBhdHRyaWJ1dGVzID0ge31cbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcG9zLmN1cnJlbnRBdHRyaWJ1dGVzLmZvckVhY2goKHYsIGspID0+IHsgYXR0cmlidXRlc1trXSA9IHYgfSlcbiAgICAgICAgfVxuICAgICAgICBpbnNlcnRUZXh0KHRyYW5zYWN0aW9uLCB0aGlzLCBwb3MsIHRleHQsIGF0dHJpYnV0ZXMpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5pbnNlcnQoaW5kZXgsIHRleHQsIGF0dHJpYnV0ZXMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIGFuIGVtYmVkIGF0IGEgaW5kZXguXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IHRoZSBlbWJlZCBhdC5cbiAgICogQHBhcmFtIHtPYmplY3QgfCBBYnN0cmFjdFR5cGU8YW55Pn0gZW1iZWQgVGhlIE9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGVtYmVkLlxuICAgKiBAcGFyYW0ge1RleHRBdHRyaWJ1dGVzfSBbYXR0cmlidXRlc10gQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVtYmVkXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGluc2VydEVtYmVkIChpbmRleCwgZW1iZWQsIGF0dHJpYnV0ZXMpIHtcbiAgICBjb25zdCB5ID0gdGhpcy5kb2NcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCAhYXR0cmlidXRlcylcbiAgICAgICAgaW5zZXJ0VGV4dCh0cmFuc2FjdGlvbiwgdGhpcywgcG9zLCBlbWJlZCwgYXR0cmlidXRlcyB8fCB7fSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLmluc2VydEVtYmVkKGluZGV4LCBlbWJlZCwgYXR0cmlidXRlcyB8fCB7fSkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgdGV4dCBzdGFydGluZyBmcm9tIGFuIGluZGV4LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggYXQgd2hpY2ggdG8gc3RhcnQgZGVsZXRpbmcuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIHRvIHJlbW92ZS4gRGVmYXVsdHMgdG8gMS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoKSB7XG4gICAgaWYgKGxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGNvbnN0IHkgPSB0aGlzLmRvY1xuICAgIGlmICh5ICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh5LCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGRlbGV0ZVRleHQodHJhbnNhY3Rpb24sIGZpbmRQb3NpdGlvbih0cmFuc2FjdGlvbiwgdGhpcywgaW5kZXgsIHRydWUpLCBsZW5ndGgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge0FycmF5PGZ1bmN0aW9uPn0gKi8gKHRoaXMuX3BlbmRpbmcpLnB1c2goKCkgPT4gdGhpcy5kZWxldGUoaW5kZXgsIGxlbmd0aCkpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgcHJvcGVydGllcyB0byBhIHJhbmdlIG9mIHRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgcG9zaXRpb24gd2hlcmUgdG8gc3RhcnQgZm9ybWF0dGluZy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCBUaGUgYW1vdW50IG9mIGNoYXJhY3RlcnMgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8uXG4gICAqIEBwYXJhbSB7VGV4dEF0dHJpYnV0ZXN9IGF0dHJpYnV0ZXMgQXR0cmlidXRlIGluZm9ybWF0aW9uIHRvIGFwcGx5IG9uIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvcm1hdCAoaW5kZXgsIGxlbmd0aCwgYXR0cmlidXRlcykge1xuICAgIGlmIChsZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjb25zdCB5ID0gdGhpcy5kb2NcbiAgICBpZiAoeSAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QoeSwgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICBjb25zdCBwb3MgPSBmaW5kUG9zaXRpb24odHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBmYWxzZSlcbiAgICAgICAgaWYgKHBvcy5yaWdodCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGZvcm1hdFRleHQodHJhbnNhY3Rpb24sIHRoaXMsIHBvcywgbGVuZ3RoLCBhdHRyaWJ1dGVzKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuZm9ybWF0KGluZGV4LCBsZW5ndGgsIGF0dHJpYnV0ZXMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZU1hcERlbGV0ZSh0cmFuc2FjdGlvbiwgdGhpcywgYXR0cmlidXRlTmFtZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24+fSAqLyAodGhpcy5fcGVuZGluZykucHVzaCgoKSA9PiB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHthbnl9IGF0dHJpYnV0ZVZhbHVlIFRoZSBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBpcyB0byBiZSBzZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNldEF0dHJpYnV0ZSAoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBTZXQodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLyoqIEB0eXBlIHtBcnJheTxmdW5jdGlvbj59ICovICh0aGlzLl9wZW5kaW5nKS5wdXNoKCgpID0+IHRoaXMuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbiBhdHRyaWJ1dGUgdmFsdWUgdGhhdCBiZWxvbmdzIHRvIHRoZSBhdHRyaWJ1dGUgbmFtZS5cbiAgICpcbiAgICogQG5vdGUgWG1sLVRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBhdHRyaWJ1dGVzLiBZb3UgY2FuIHVzZSB0aGlzIGZlYXR1cmUgdG8gYXNzaWduIHByb3BlcnRpZXMgdG8gY29tcGxldGUgdGV4dC1ibG9ja3MuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlkZW50aWZpZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgdmFsdWUuXG4gICAqIEByZXR1cm4ge2FueX0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEBub3RlIFhtbC1UZXh0IG5vZGVzIGRvbid0IGhhdmUgYXR0cmlidXRlcy4gWW91IGNhbiB1c2UgdGhpcyBmZWF0dXJlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzIHRvIGNvbXBsZXRlIHRleHQtYmxvY2tzLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBBIEpTT04gT2JqZWN0IHRoYXQgZGVzY3JpYmVzIHRoZSBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGVzICgpIHtcbiAgICByZXR1cm4gdHlwZU1hcEdldEFsbCh0aGlzKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZVGV4dFJlZklEKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IF9kZWNvZGVyXG4gKiBAcmV0dXJuIHtZVGV4dH1cbiAqXG4gKiBAcHJpdmF0ZVxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWVRleHQgPSBfZGVjb2RlciA9PiBuZXcgWVRleHQoKVxuIiwgIi8qKlxuICogQG1vZHVsZSBZWG1sXG4gKi9cblxuaW1wb3J0IHtcbiAgWVhtbEV2ZW50LFxuICBZWG1sRWxlbWVudCxcbiAgQWJzdHJhY3RUeXBlLFxuICB0eXBlTGlzdE1hcCxcbiAgdHlwZUxpc3RGb3JFYWNoLFxuICB0eXBlTGlzdEluc2VydEdlbmVyaWNzLFxuICB0eXBlTGlzdEluc2VydEdlbmVyaWNzQWZ0ZXIsXG4gIHR5cGVMaXN0RGVsZXRlLFxuICB0eXBlTGlzdFRvQXJyYXksXG4gIFlYbWxGcmFnbWVudFJlZklELFxuICBjYWxsVHlwZU9ic2VydmVycyxcbiAgdHJhbnNhY3QsXG4gIHR5cGVMaXN0R2V0LFxuICB0eXBlTGlzdFNsaWNlLFxuICBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIERvYywgQ29udGVudFR5cGUsIFRyYW5zYWN0aW9uLCBJdGVtLCBZWG1sVGV4dCwgWVhtbEhvb2sgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBhcnJheSBmcm9tICdsaWIwL2FycmF5J1xuXG4vKipcbiAqIERlZmluZSB0aGUgZWxlbWVudHMgdG8gd2hpY2ggYSBzZXQgb2YgQ1NTIHF1ZXJpZXMgYXBwbHkuXG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NTU19TZWxlY3RvcnN8Q1NTX1NlbGVjdG9yc31cbiAqXG4gKiBAZXhhbXBsZVxuICogICBxdWVyeSA9ICcuY2xhc3NTZWxlY3RvcidcbiAqICAgcXVlcnkgPSAnbm9kZVNlbGVjdG9yJ1xuICogICBxdWVyeSA9ICcjaWRTZWxlY3RvcidcbiAqXG4gKiBAdHlwZWRlZiB7c3RyaW5nfSBDU1NfU2VsZWN0b3JcbiAqL1xuXG4vKipcbiAqIERvbSBmaWx0ZXIgZnVuY3Rpb24uXG4gKlxuICogQGNhbGxiYWNrIGRvbUZpbHRlclxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIFRoZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtNYXB9IGF0dHJpYnV0ZXMgVGhlIG1hcCBvZiBhdHRyaWJ1dGVzLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciB0byBpbmNsdWRlIHRoZSBEb20gbm9kZSBpbiB0aGUgWVhtbEVsZW1lbnQuXG4gKi9cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc3Vic2V0IG9mIHRoZSBub2RlcyBvZiBhIFlYbWxFbGVtZW50IC8gWVhtbEZyYWdtZW50IGFuZCBhXG4gKiBwb3NpdGlvbiB3aXRoaW4gdGhlbS5cbiAqXG4gKiBDYW4gYmUgY3JlYXRlZCB3aXRoIHtAbGluayBZWG1sRnJhZ21lbnQjY3JlYXRlVHJlZVdhbGtlcn1cbiAqXG4gKiBAcHVibGljXG4gKiBAaW1wbGVtZW50cyB7SXRlcmFibGU8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEVsZW1lbnR8WVhtbEhvb2s+fVxuICovXG5leHBvcnQgY2xhc3MgWVhtbFRyZWVXYWxrZXIge1xuICAvKipcbiAgICogQHBhcmFtIHtZWG1sRnJhZ21lbnQgfCBZWG1sRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKEFic3RyYWN0VHlwZTxhbnk+KTpib29sZWFufSBbZl1cbiAgICovXG4gIGNvbnN0cnVjdG9yIChyb290LCBmID0gKCkgPT4gdHJ1ZSkge1xuICAgIHRoaXMuX2ZpbHRlciA9IGZcbiAgICB0aGlzLl9yb290ID0gcm9vdFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJdGVtfVxuICAgICAqL1xuICAgIHRoaXMuX2N1cnJlbnROb2RlID0gLyoqIEB0eXBlIHtJdGVtfSAqLyAocm9vdC5fc3RhcnQpXG4gICAgdGhpcy5fZmlyc3RDYWxsID0gdHJ1ZVxuICB9XG5cbiAgW1N5bWJvbC5pdGVyYXRvcl0gKCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBuZXh0IG5vZGUuXG4gICAqXG4gICAqIEByZXR1cm4ge0l0ZXJhdG9yUmVzdWx0PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rPn0gVGhlIG5leHQgbm9kZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgbmV4dCAoKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgKi9cbiAgICBsZXQgbiA9IHRoaXMuX2N1cnJlbnROb2RlXG4gICAgbGV0IHR5cGUgPSBuICYmIG4uY29udGVudCAmJiAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgIGlmIChuICE9PSBudWxsICYmICghdGhpcy5fZmlyc3RDYWxsIHx8IG4uZGVsZXRlZCB8fCAhdGhpcy5fZmlsdGVyKHR5cGUpKSkgeyAvLyBpZiBmaXJzdCBjYWxsLCB3ZSBjaGVjayBpZiB3ZSBjYW4gdXNlIHRoZSBmaXJzdCBpdGVtXG4gICAgICBkbyB7XG4gICAgICAgIHR5cGUgPSAvKiogQHR5cGUge2FueX0gKi8gKG4uY29udGVudCkudHlwZVxuICAgICAgICBpZiAoIW4uZGVsZXRlZCAmJiAodHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEVsZW1lbnQgfHwgdHlwZS5jb25zdHJ1Y3RvciA9PT0gWVhtbEZyYWdtZW50KSAmJiB0eXBlLl9zdGFydCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIHdhbGsgZG93biBpbiB0aGUgdHJlZVxuICAgICAgICAgIG4gPSB0eXBlLl9zdGFydFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdhbGsgcmlnaHQgb3IgdXAgaW4gdGhlIHRyZWVcbiAgICAgICAgICB3aGlsZSAobiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG4ucmlnaHQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbiA9IG4ucmlnaHRcbiAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobi5wYXJlbnQgPT09IHRoaXMuX3Jvb3QpIHtcbiAgICAgICAgICAgICAgbiA9IG51bGxcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG4gPSAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobi5wYXJlbnQpLl9pdGVtXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IHdoaWxlIChuICE9PSBudWxsICYmIChuLmRlbGV0ZWQgfHwgIXRoaXMuX2ZpbHRlcigvKiogQHR5cGUge0NvbnRlbnRUeXBlfSAqLyAobi5jb250ZW50KS50eXBlKSkpXG4gICAgfVxuICAgIHRoaXMuX2ZpcnN0Q2FsbCA9IGZhbHNlXG4gICAgaWYgKG4gPT09IG51bGwpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfVxuICAgIH1cbiAgICB0aGlzLl9jdXJyZW50Tm9kZSA9IG5cbiAgICByZXR1cm4geyB2YWx1ZTogLyoqIEB0eXBlIHthbnl9ICovIChuLmNvbnRlbnQpLnR5cGUsIGRvbmU6IGZhbHNlIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBsaXN0IG9mIHtAbGluayBZWG1sRWxlbWVudH0uYW5kIHtAbGluayBZWG1sVGV4dH0gdHlwZXMuXG4gKiBBIFl4bWxGcmFnbWVudCBpcyBzaW1pbGFyIHRvIGEge0BsaW5rIFlYbWxFbGVtZW50fSwgYnV0IGl0IGRvZXMgbm90IGhhdmUgYVxuICogbm9kZU5hbWUgYW5kIGl0IGRvZXMgbm90IGhhdmUgYXR0cmlidXRlcy4gVGhvdWdoIGl0IGNhbiBiZSBib3VuZCB0byBhIERPTVxuICogZWxlbWVudCAtIGluIHRoaXMgY2FzZSB0aGUgYXR0cmlidXRlcyBhbmQgdGhlIG5vZGVOYW1lIGFyZSBub3Qgc2hhcmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleHRlbmRzIEFic3RyYWN0VHlwZTxZWG1sRXZlbnQ+XG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sRnJhZ21lbnQgZXh0ZW5kcyBBYnN0cmFjdFR5cGUge1xuICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgc3VwZXIoKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQ29udGVudCA9IFtdXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgZmlyc3RDaGlsZCAoKSB7XG4gICAgY29uc3QgZmlyc3QgPSB0aGlzLl9maXJzdFxuICAgIHJldHVybiBmaXJzdCA/IGZpcnN0LmNvbnRlbnQuZ2V0Q29udGVudCgpWzBdIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICB0aGlzLmluc2VydCgwLCAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KSlcbiAgICB0aGlzLl9wcmVsaW1Db250ZW50ID0gbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbEZyYWdtZW50KClcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBhIGNvcHkgb2YgdGhpcyBkYXRhIHR5cGUgdGhhdCBjYW4gYmUgaW5jbHVkZWQgc29tZXdoZXJlIGVsc2UuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGUgY29udGVudCBpcyBvbmx5IHJlYWRhYmxlIF9hZnRlcl8gaXQgaGFzIGJlZW4gaW5jbHVkZWQgc29tZXdoZXJlIGluIHRoZSBZZG9jLlxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRnJhZ21lbnR9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEZyYWdtZW50KClcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZWwuaW5zZXJ0KDAsIHRoaXMudG9BcnJheSgpLm1hcChpdGVtID0+IGl0ZW0gaW5zdGFuY2VvZiBBYnN0cmFjdFR5cGUgPyBpdGVtLmNsb25lKCkgOiBpdGVtKSlcbiAgICByZXR1cm4gZWxcbiAgfVxuXG4gIGdldCBsZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLl9wcmVsaW1Db250ZW50ID09PSBudWxsID8gdGhpcy5fbGVuZ3RoIDogdGhpcy5fcHJlbGltQ29udGVudC5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBzdWJ0cmVlIG9mIGNoaWxkTm9kZXMuXG4gICAqXG4gICAqIEBleGFtcGxlXG4gICAqIGNvbnN0IHdhbGtlciA9IGVsZW0uY3JlYXRlVHJlZVdhbGtlcihkb20gPT4gZG9tLm5vZGVOYW1lID09PSAnZGl2JylcbiAgICogZm9yIChsZXQgbm9kZSBpbiB3YWxrZXIpIHtcbiAgICogICAvLyBgbm9kZWAgaXMgYSBkaXYgbm9kZVxuICAgKiAgIG5vcChub2RlKVxuICAgKiB9XG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oQWJzdHJhY3RUeXBlPGFueT4pOmJvb2xlYW59IGZpbHRlciBGdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbiBlYWNoIGNoaWxkIGVsZW1lbnQgYW5kXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5zIGEgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNoaWxkXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICBpcyB0byBiZSBpbmNsdWRlZCBpbiB0aGUgc3VidHJlZS5cbiAgICogQHJldHVybiB7WVhtbFRyZWVXYWxrZXJ9IEEgc3VidHJlZSBhbmQgYSBwb3NpdGlvbiB3aXRoaW4gaXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNyZWF0ZVRyZWVXYWxrZXIgKGZpbHRlcikge1xuICAgIHJldHVybiBuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZmlsdGVyKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZpcnN0IFlYbWxFbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgcXVlcnkuXG4gICAqIFNpbWlsYXIgdG8gRE9NJ3Mge0BsaW5rIHF1ZXJ5U2VsZWN0b3J9LlxuICAgKlxuICAgKiBRdWVyeSBzdXBwb3J0OlxuICAgKiAgIC0gdGFnbmFtZVxuICAgKiBUT0RPOlxuICAgKiAgIC0gaWRcbiAgICogICAtIGF0dHJpYnV0ZVxuICAgKlxuICAgKiBAcGFyYW0ge0NTU19TZWxlY3Rvcn0gcXVlcnkgVGhlIHF1ZXJ5IG9uIHRoZSBjaGlsZHJlbi5cbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEhvb2t8bnVsbH0gVGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBtYXRjaGVzIHRoZSBxdWVyeSBvciBudWxsLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBxdWVyeVNlbGVjdG9yIChxdWVyeSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkudG9VcHBlckNhc2UoKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCBpdGVyYXRvciA9IG5ldyBZWG1sVHJlZVdhbGtlcih0aGlzLCBlbGVtZW50ID0+IGVsZW1lbnQubm9kZU5hbWUgJiYgZWxlbWVudC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBxdWVyeSlcbiAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpXG4gICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5leHQudmFsdWVcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhbGwgWVhtbEVsZW1lbnRzIHRoYXQgbWF0Y2ggdGhlIHF1ZXJ5LlxuICAgKiBTaW1pbGFyIHRvIERvbSdzIHtAbGluayBxdWVyeVNlbGVjdG9yQWxsfS5cbiAgICpcbiAgICogQHRvZG8gRG9lcyBub3QgeWV0IHN1cHBvcnQgYWxsIHF1ZXJpZXMuIEN1cnJlbnRseSBvbmx5IHF1ZXJ5IGJ5IHRhZ05hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7Q1NTX1NlbGVjdG9yfSBxdWVyeSBUaGUgcXVlcnkgb24gdGhlIGNoaWxkcmVuXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rfG51bGw+fSBUaGUgZWxlbWVudHMgdGhhdCBtYXRjaCB0aGlzIHF1ZXJ5LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBxdWVyeVNlbGVjdG9yQWxsIChxdWVyeSkge1xuICAgIHF1ZXJ5ID0gcXVlcnkudG9VcHBlckNhc2UoKVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gYXJyYXkuZnJvbShuZXcgWVhtbFRyZWVXYWxrZXIodGhpcywgZWxlbWVudCA9PiBlbGVtZW50Lm5vZGVOYW1lICYmIGVsZW1lbnQubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gcXVlcnkpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgWVhtbEV2ZW50IGFuZCBjYWxscyBvYnNlcnZlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U2V0PG51bGx8c3RyaW5nPn0gcGFyZW50U3VicyBLZXlzIGNoYW5nZWQgb24gdGhpcyB0eXBlLiBgbnVsbGAgaWYgbGlzdCB3YXMgbW9kaWZpZWQuXG4gICAqL1xuICBfY2FsbE9ic2VydmVyICh0cmFuc2FjdGlvbiwgcGFyZW50U3Vicykge1xuICAgIGNhbGxUeXBlT2JzZXJ2ZXJzKHRoaXMsIHRyYW5zYWN0aW9uLCBuZXcgWVhtbEV2ZW50KHRoaXMsIHBhcmVudFN1YnMsIHRyYW5zYWN0aW9uKSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiBhbGwgdGhlIGNoaWxkcmVuIG9mIHRoaXMgWVhtbEZyYWdtZW50LlxuICAgKlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYWxsIGNoaWxkcmVuLlxuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdE1hcCh0aGlzLCB4bWwgPT4geG1sLnRvU3RyaW5nKCkpLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdDxzdHJpbmcsIGFueT59IFtob29rcz17fV0gT3B0aW9uYWwgcHJvcGVydHkgdG8gY3VzdG9taXplIGhvdyBob29rc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZSBwcmVzZW50ZWQgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge2FueX0gW2JpbmRpbmddIFlvdSBzaG91bGQgbm90IHNldCB0aGlzIHByb3BlcnR5LiBUaGlzIGlzXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVzZWQgaWYgRG9tQmluZGluZyB3YW50cyB0byBjcmVhdGUgYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvbiB0byB0aGUgY3JlYXRlZCBET00gdHlwZS5cbiAgICogQHJldHVybiB7Tm9kZX0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgZnJhZ21lbnQgPSBfZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpXG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZnJhZ21lbnQsIHRoaXMpXG4gICAgfVxuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCB4bWxUeXBlID0+IHtcbiAgICAgIGZyYWdtZW50Lmluc2VydEJlZm9yZSh4bWxUeXBlLnRvRE9NKF9kb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpLCBudWxsKVxuICAgIH0pXG4gICAgcmV0dXJuIGZyYWdtZW50XG4gIH1cblxuICAvKipcbiAgICogSW5zZXJ0cyBuZXcgY29udGVudCBhdCBhbiBpbmRleC5cbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogIC8vIEluc2VydCBjaGFyYWN0ZXIgJ2EnIGF0IHBvc2l0aW9uIDBcbiAgICogIHhtbC5pbnNlcnQoMCwgW25ldyBZLlhtbFRleHQoJ3RleHQnKV0pXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXRcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICovXG4gIGluc2VydCAoaW5kZXgsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVMaXN0SW5zZXJ0R2VuZXJpY3ModHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBjb250ZW50KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQHRzLWlnbm9yZSBfcHJlbGltQ29udGVudCBpcyBkZWZpbmVkIGJlY2F1c2UgdGhpcyBpcyBub3QgeWV0IGludGVncmF0ZWRcbiAgICAgIHRoaXMuX3ByZWxpbUNvbnRlbnQuc3BsaWNlKGluZGV4LCAwLCAuLi5jb250ZW50KVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBJbnNlcnRzIG5ldyBjb250ZW50IGF0IGFuIGluZGV4LlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgLy8gSW5zZXJ0IGNoYXJhY3RlciAnYScgYXQgcG9zaXRpb24gMFxuICAgKiAgeG1sLmluc2VydCgwLCBbbmV3IFkuWG1sVGV4dCgndGV4dCcpXSlcbiAgICpcbiAgICogQHBhcmFtIHtudWxsfEl0ZW18WVhtbEVsZW1lbnR8WVhtbFRleHR9IHJlZiBUaGUgaW5kZXggdG8gaW5zZXJ0IGNvbnRlbnQgYXRcbiAgICogQHBhcmFtIHtBcnJheTxZWG1sRWxlbWVudHxZWG1sVGV4dD59IGNvbnRlbnQgVGhlIGFycmF5IG9mIGNvbnRlbnRcbiAgICovXG4gIGluc2VydEFmdGVyIChyZWYsIGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIGNvbnN0IHJlZkl0ZW0gPSAocmVmICYmIHJlZiBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSkgPyByZWYuX2l0ZW0gOiByZWZcbiAgICAgICAgdHlwZUxpc3RJbnNlcnRHZW5lcmljc0FmdGVyKHRyYW5zYWN0aW9uLCB0aGlzLCByZWZJdGVtLCBjb250ZW50KVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGMgPSAvKiogQHR5cGUge0FycmF5PGFueT59ICovICh0aGlzLl9wcmVsaW1Db250ZW50KVxuICAgICAgY29uc3QgaW5kZXggPSByZWYgPT09IG51bGwgPyAwIDogcGMuZmluZEluZGV4KGVsID0+IGVsID09PSByZWYpICsgMVxuICAgICAgaWYgKGluZGV4ID09PSAwICYmIHJlZiAhPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBlcnJvci5jcmVhdGUoJ1JlZmVyZW5jZSBpdGVtIG5vdCBmb3VuZCcpXG4gICAgICB9XG4gICAgICBwYy5zcGxpY2UoaW5kZXgsIDAsIC4uLmNvbnRlbnQpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgZWxlbWVudHMgc3RhcnRpbmcgZnJvbSBhbiBpbmRleC5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIHN0YXJ0IGRlbGV0aW5nIGVsZW1lbnRzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gcmVtb3ZlLiBEZWZhdWx0cyB0byAxLlxuICAgKi9cbiAgZGVsZXRlIChpbmRleCwgbGVuZ3RoID0gMSkge1xuICAgIGlmICh0aGlzLmRvYyAhPT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3QodGhpcy5kb2MsIHRyYW5zYWN0aW9uID0+IHtcbiAgICAgICAgdHlwZUxpc3REZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGluZGV4LCBsZW5ndGgpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBAdHMtaWdub3JlIF9wcmVsaW1Db250ZW50IGlzIGRlZmluZWQgYmVjYXVzZSB0aGlzIGlzIG5vdCB5ZXQgaW50ZWdyYXRlZFxuICAgICAgdGhpcy5fcHJlbGltQ29udGVudC5zcGxpY2UoaW5kZXgsIGxlbmd0aClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtcyB0aGlzIFlBcnJheSB0byBhIEphdmFTY3JpcHQgQXJyYXkuXG4gICAqXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0fFlYbWxIb29rPn1cbiAgICovXG4gIHRvQXJyYXkgKCkge1xuICAgIHJldHVybiB0eXBlTGlzdFRvQXJyYXkodGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gYXBwZW5kLlxuICAgKi9cbiAgcHVzaCAoY29udGVudCkge1xuICAgIHRoaXMuaW5zZXJ0KHRoaXMubGVuZ3RoLCBjb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFByZXBlbmRzIGNvbnRlbnQgdG8gdGhpcyBZQXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8WVhtbEVsZW1lbnR8WVhtbFRleHQ+fSBjb250ZW50IEFycmF5IG9mIGNvbnRlbnQgdG8gcHJlcGVuZC5cbiAgICovXG4gIHVuc2hpZnQgKGNvbnRlbnQpIHtcbiAgICB0aGlzLmluc2VydCgwLCBjb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGktdGggZWxlbWVudCBmcm9tIGEgWUFycmF5LlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJldHVybiBmcm9tIHRoZSBZQXJyYXlcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnR8WVhtbFRleHR9XG4gICAqL1xuICBnZXQgKGluZGV4KSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0R2V0KHRoaXMsIGluZGV4KVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBwb3J0aW9uIG9mIHRoaXMgWVhtbEZyYWdtZW50IGludG8gYSBKYXZhU2NyaXB0IEFycmF5IHNlbGVjdGVkXG4gICAqIGZyb20gc3RhcnQgdG8gZW5kIChlbmQgbm90IGluY2x1ZGVkKS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydF1cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmRdXG4gICAqIEByZXR1cm4ge0FycmF5PFlYbWxFbGVtZW50fFlYbWxUZXh0Pn1cbiAgICovXG4gIHNsaWNlIChzdGFydCA9IDAsIGVuZCA9IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHR5cGVMaXN0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHByb3ZpZGVkIGZ1bmN0aW9uIG9uIG9uY2Ugb24gZXZlcnkgY2hpbGQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihZWG1sRWxlbWVudHxZWG1sVGV4dCxudW1iZXIsIHR5cGVvZiBzZWxmKTp2b2lkfSBmIEEgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbiBldmVyeSBlbGVtZW50IG9mIHRoaXMgWUFycmF5LlxuICAgKi9cbiAgZm9yRWFjaCAoZikge1xuICAgIHR5cGVMaXN0Rm9yRWFjaCh0aGlzLCBmKVxuICB9XG5cbiAgLyoqXG4gICAqIFRyYW5zZm9ybSB0aGUgcHJvcGVydGllcyBvZiB0aGlzIHR5cGUgdG8gYmluYXJ5IGFuZCB3cml0ZSBpdCB0byBhblxuICAgKiBCaW5hcnlFbmNvZGVyLlxuICAgKlxuICAgKiBUaGlzIGlzIGNhbGxlZCB3aGVuIHRoaXMgSXRlbSBpcyBzZW50IHRvIGEgcmVtb3RlIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqL1xuICBfd3JpdGUgKGVuY29kZXIpIHtcbiAgICBlbmNvZGVyLndyaXRlVHlwZVJlZihZWG1sRnJhZ21lbnRSZWZJRClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBfZGVjb2RlclxuICogQHJldHVybiB7WVhtbEZyYWdtZW50fVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sRnJhZ21lbnQgPSBfZGVjb2RlciA9PiBuZXcgWVhtbEZyYWdtZW50KClcbiIsICJpbXBvcnQgKiBhcyBvYmplY3QgZnJvbSAnbGliMC9vYmplY3QnXG5cbmltcG9ydCB7XG4gIFlYbWxGcmFnbWVudCxcbiAgdHJhbnNhY3QsXG4gIHR5cGVNYXBEZWxldGUsXG4gIHR5cGVNYXBIYXMsXG4gIHR5cGVNYXBTZXQsXG4gIHR5cGVNYXBHZXQsXG4gIHR5cGVNYXBHZXRBbGwsXG4gIHR5cGVNYXBHZXRBbGxTbmFwc2hvdCxcbiAgdHlwZUxpc3RGb3JFYWNoLFxuICBZWG1sRWxlbWVudFJlZklELFxuICBTbmFwc2hvdCwgWVhtbFRleHQsIENvbnRlbnRUeXBlLCBBYnN0cmFjdFR5cGUsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgRG9jLCBJdGVtIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R8bnVtYmVyfG51bGx8QXJyYXk8YW55PnxzdHJpbmd8VWludDhBcnJheXxBYnN0cmFjdFR5cGU8YW55Pn0gVmFsdWVUeXBlc1xuICovXG5cbi8qKlxuICogQW4gWVhtbEVsZW1lbnQgaW1pdGF0ZXMgdGhlIGJlaGF2aW9yIG9mIGFcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9FbGVtZW50fERvbSBFbGVtZW50XG4gKlxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgYXR0cmlidXRlcyAoa2V5IHZhbHVlIHBhaXJzKVxuICogKiBBbiBZWG1sRWxlbWVudCBoYXMgY2hpbGRFbGVtZW50cyB0aGF0IG11c3QgaW5oZXJpdCBmcm9tIFlYbWxFbGVtZW50XG4gKlxuICogQHRlbXBsYXRlIHt7IFtrZXk6IHN0cmluZ106IFZhbHVlVHlwZXMgfX0gW0tWPXsgW2tleTogc3RyaW5nXTogc3RyaW5nIH1dXG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sRWxlbWVudCBleHRlbmRzIFlYbWxGcmFnbWVudCB7XG4gIGNvbnN0cnVjdG9yIChub2RlTmFtZSA9ICdVTkRFRklORUQnKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubm9kZU5hbWUgPSBub2RlTmFtZVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBhbnk+fG51bGx9XG4gICAgICovXG4gICAgdGhpcy5fcHJlbGltQXR0cnMgPSBuZXcgTWFwKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbFxuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIEludGVncmF0ZSB0aGlzIHR5cGUgaW50byB0aGUgWWpzIGluc3RhbmNlLlxuICAgKlxuICAgKiAqIFNhdmUgdGhpcyBzdHJ1Y3QgaW4gdGhlIG9zXG4gICAqICogVGhpcyB0eXBlIGlzIHNlbnQgdG8gb3RoZXIgY2xpZW50XG4gICAqICogT2JzZXJ2ZXIgZnVuY3Rpb25zIGFyZSBmaXJlZFxuICAgKlxuICAgKiBAcGFyYW0ge0RvY30geSBUaGUgWWpzIGluc3RhbmNlXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgX2ludGVncmF0ZSAoeSwgaXRlbSkge1xuICAgIHN1cGVyLl9pbnRlZ3JhdGUoeSwgaXRlbSlcbiAgICA7KC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKSkuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICB9KVxuICAgIHRoaXMuX3ByZWxpbUF0dHJzID0gbnVsbFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gSXRlbSB3aXRoIHRoZSBzYW1lIGVmZmVjdCBhcyB0aGlzIEl0ZW0gKHdpdGhvdXQgcG9zaXRpb24gZWZmZWN0KVxuICAgKlxuICAgKiBAcmV0dXJuIHtZWG1sRWxlbWVudH1cbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WVhtbEVsZW1lbnQ8S1Y+fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtZWG1sRWxlbWVudDxLVj59XG4gICAgICovXG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEVsZW1lbnQodGhpcy5ub2RlTmFtZSlcbiAgICBjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlcygpXG4gICAgb2JqZWN0LmZvckVhY2goYXR0cnMsICh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9KVxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBlbC5pbnNlcnQoMCwgdGhpcy50b0FycmF5KCkubWFwKGl0ZW0gPT4gaXRlbSBpbnN0YW5jZW9mIEFic3RyYWN0VHlwZSA/IGl0ZW0uY2xvbmUoKSA6IGl0ZW0pKVxuICAgIHJldHVybiBlbFxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIFhNTCBzZXJpYWxpemF0aW9uIG9mIHRoaXMgWVhtbEVsZW1lbnQuXG4gICAqIFRoZSBhdHRyaWJ1dGVzIGFyZSBvcmRlcmVkIGJ5IGF0dHJpYnV0ZS1uYW1lLCBzbyB5b3UgY2FuIGVhc2lseSB1c2UgdGhpc1xuICAgKiBtZXRob2QgdG8gY29tcGFyZSBZWG1sRWxlbWVudHNcbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoaXMgdHlwZS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9TdHJpbmcgKCkge1xuICAgIGNvbnN0IGF0dHJzID0gdGhpcy5nZXRBdHRyaWJ1dGVzKClcbiAgICBjb25zdCBzdHJpbmdCdWlsZGVyID0gW11cbiAgICBjb25zdCBrZXlzID0gW11cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBhdHRycykge1xuICAgICAga2V5cy5wdXNoKGtleSlcbiAgICB9XG4gICAga2V5cy5zb3J0KClcbiAgICBjb25zdCBrZXlzTGVuID0ga2V5cy5sZW5ndGhcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleXNMZW47IGkrKykge1xuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXVxuICAgICAgc3RyaW5nQnVpbGRlci5wdXNoKGtleSArICc9XCInICsgYXR0cnNba2V5XSArICdcIicpXG4gICAgfVxuICAgIGNvbnN0IG5vZGVOYW1lID0gdGhpcy5ub2RlTmFtZS50b0xvY2FsZUxvd2VyQ2FzZSgpXG4gICAgY29uc3QgYXR0cnNTdHJpbmcgPSBzdHJpbmdCdWlsZGVyLmxlbmd0aCA+IDAgPyAnICcgKyBzdHJpbmdCdWlsZGVyLmpvaW4oJyAnKSA6ICcnXG4gICAgcmV0dXJuIGA8JHtub2RlTmFtZX0ke2F0dHJzU3RyaW5nfT4ke3N1cGVyLnRvU3RyaW5nKCl9PC8ke25vZGVOYW1lfT5gXG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdHRyaWJ1dGUgZnJvbSB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpcyB0byBiZSByZW1vdmVkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBpZiAodGhpcy5kb2MgIT09IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0KHRoaXMuZG9jLCB0cmFuc2FjdGlvbiA9PiB7XG4gICAgICAgIHR5cGVNYXBEZWxldGUodHJhbnNhY3Rpb24sIHRoaXMsIGF0dHJpYnV0ZU5hbWUpXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAvKiogQHR5cGUge01hcDxzdHJpbmcsYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5kZWxldGUoYXR0cmlidXRlTmFtZSlcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBvciB1cGRhdGVzIGFuIGF0dHJpYnV0ZS5cbiAgICpcbiAgICogQHRlbXBsYXRlIHtrZXlvZiBLViAmIHN0cmluZ30gS0VZXG4gICAqXG4gICAqIEBwYXJhbSB7S0VZfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0aGF0IGlzIHRvIGJlIHNldC5cbiAgICogQHBhcmFtIHtLVltLRVldfSBhdHRyaWJ1dGVWYWx1ZSBUaGUgYXR0cmlidXRlIHZhbHVlIHRoYXQgaXMgdG8gYmUgc2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUsIGF0dHJpYnV0ZVZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZG9jICE9PSBudWxsKSB7XG4gICAgICB0cmFuc2FjdCh0aGlzLmRvYywgdHJhbnNhY3Rpb24gPT4ge1xuICAgICAgICB0eXBlTWFwU2V0KHRyYW5zYWN0aW9uLCB0aGlzLCBhdHRyaWJ1dGVOYW1lLCBhdHRyaWJ1dGVWYWx1ZSlcbiAgICAgIH0pXG4gICAgfSBlbHNlIHtcbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn0gKi8gKHRoaXMuX3ByZWxpbUF0dHJzKS5zZXQoYXR0cmlidXRlTmFtZSwgYXR0cmlidXRlVmFsdWUpXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXR0cmlidXRlIHZhbHVlIHRoYXQgYmVsb25ncyB0byB0aGUgYXR0cmlidXRlIG5hbWUuXG4gICAqXG4gICAqIEB0ZW1wbGF0ZSB7a2V5b2YgS1YgJiBzdHJpbmd9IEtFWVxuICAgKlxuICAgKiBAcGFyYW0ge0tFWX0gYXR0cmlidXRlTmFtZSBUaGUgYXR0cmlidXRlIG5hbWUgdGhhdCBpZGVudGlmaWVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWVyaWVkIHZhbHVlLlxuICAgKiBAcmV0dXJuIHtLVltLRVldfHVuZGVmaW5lZH0gVGhlIHF1ZXJpZWQgYXR0cmlidXRlIHZhbHVlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBnZXRBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwR2V0KHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlciBhbiBhdHRyaWJ1dGUgZXhpc3RzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVOYW1lIFRoZSBhdHRyaWJ1dGUgbmFtZSB0byBjaGVjayBmb3IgZXhpc3RlbmNlLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3aGV0aGVyIHRoZSBhdHRyaWJ1dGUgZXhpc3RzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBoYXNBdHRyaWJ1dGUgKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovICh0eXBlTWFwSGFzKHRoaXMsIGF0dHJpYnV0ZU5hbWUpKVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYWxsIGF0dHJpYnV0ZSBuYW1lL3ZhbHVlIHBhaXJzIGluIGEgSlNPTiBPYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U25hcHNob3R9IFtzbmFwc2hvdF1cbiAgICogQHJldHVybiB7eyBbS2V5IGluIEV4dHJhY3Q8a2V5b2YgS1Ysc3RyaW5nPl0/OiBLVltLZXldfX0gQSBKU09OIE9iamVjdCB0aGF0IGRlc2NyaWJlcyB0aGUgYXR0cmlidXRlcy5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZ2V0QXR0cmlidXRlcyAoc25hcHNob3QpIHtcbiAgICByZXR1cm4gLyoqIEB0eXBlIHthbnl9ICovIChzbmFwc2hvdCA/IHR5cGVNYXBHZXRBbGxTbmFwc2hvdCh0aGlzLCBzbmFwc2hvdCkgOiB0eXBlTWFwR2V0QWxsKHRoaXMpKVxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sRWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3M9e31dIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge05vZGV9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MgPSB7fSwgYmluZGluZykge1xuICAgIGNvbnN0IGRvbSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KHRoaXMubm9kZU5hbWUpXG4gICAgY29uc3QgYXR0cnMgPSB0aGlzLmdldEF0dHJpYnV0ZXMoKVxuICAgIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGF0dHJzW2tleV1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGRvbS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSlcbiAgICAgIH1cbiAgICB9XG4gICAgdHlwZUxpc3RGb3JFYWNoKHRoaXMsIHl4bWwgPT4ge1xuICAgICAgZG9tLmFwcGVuZENoaWxkKHl4bWwudG9ET00oX2RvY3VtZW50LCBob29rcywgYmluZGluZykpXG4gICAgfSlcbiAgICBpZiAoYmluZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBiaW5kaW5nLl9jcmVhdGVBc3NvY2lhdGlvbihkb20sIHRoaXMpXG4gICAgfVxuICAgIHJldHVybiBkb21cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKi9cbiAgX3dyaXRlIChlbmNvZGVyKSB7XG4gICAgZW5jb2Rlci53cml0ZVR5cGVSZWYoWVhtbEVsZW1lbnRSZWZJRClcbiAgICBlbmNvZGVyLndyaXRlS2V5KHRoaXMubm9kZU5hbWUpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbEVsZW1lbnR9XG4gKlxuICogQGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkWVhtbEVsZW1lbnQgPSBkZWNvZGVyID0+IG5ldyBZWG1sRWxlbWVudChkZWNvZGVyLnJlYWRLZXkoKSlcbiIsICJpbXBvcnQge1xuICBZRXZlbnQsXG4gIFlYbWxUZXh0LCBZWG1sRWxlbWVudCwgWVhtbEZyYWdtZW50LCBUcmFuc2FjdGlvbiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBAZXh0ZW5kcyBZRXZlbnQ8WVhtbEVsZW1lbnR8WVhtbFRleHR8WVhtbEZyYWdtZW50PlxuICogQW4gRXZlbnQgdGhhdCBkZXNjcmliZXMgY2hhbmdlcyBvbiBhIFlYbWwgRWxlbWVudCBvciBZeG1sIEZyYWdtZW50XG4gKi9cbmV4cG9ydCBjbGFzcyBZWG1sRXZlbnQgZXh0ZW5kcyBZRXZlbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtZWG1sRWxlbWVudHxZWG1sVGV4dHxZWG1sRnJhZ21lbnR9IHRhcmdldCBUaGUgdGFyZ2V0IG9uIHdoaWNoIHRoZSBldmVudCBpcyBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge1NldDxzdHJpbmd8bnVsbD59IHN1YnMgVGhlIHNldCBvZiBjaGFuZ2VkIGF0dHJpYnV0ZXMuIGBudWxsYCBpcyBpbmNsdWRlZCBpZiB0aGVcbiAgICogICAgICAgICAgICAgICAgICAgY2hpbGQgbGlzdCBjaGFuZ2VkLlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvbiBUaGUgdHJhbnNhY3Rpb24gaW5zdGFuY2Ugd2l0aCB3aWNoIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2Ugd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodGFyZ2V0LCBzdWJzLCB0cmFuc2FjdGlvbikge1xuICAgIHN1cGVyKHRhcmdldCwgdHJhbnNhY3Rpb24pXG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuY2hpbGRMaXN0Q2hhbmdlZCA9IGZhbHNlXG4gICAgLyoqXG4gICAgICogU2V0IG9mIGFsbCBjaGFuZ2VkIGF0dHJpYnV0ZXMuXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuYXR0cmlidXRlc0NoYW5nZWQgPSBuZXcgU2V0KClcbiAgICBzdWJzLmZvckVhY2goKHN1YikgPT4ge1xuICAgICAgaWYgKHN1YiA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNoaWxkTGlzdENoYW5nZWQgPSB0cnVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZXNDaGFuZ2VkLmFkZChzdWIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFlNYXAsXG4gIFlYbWxIb29rUmVmSUQsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuLyoqXG4gKiBZb3UgY2FuIG1hbmFnZSBiaW5kaW5nIHRvIGEgY3VzdG9tIHR5cGUgd2l0aCBZWG1sSG9vay5cbiAqXG4gKiBAZXh0ZW5kcyB7WU1hcDxhbnk+fVxuICovXG5leHBvcnQgY2xhc3MgWVhtbEhvb2sgZXh0ZW5kcyBZTWFwIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBob29rTmFtZSBub2RlTmFtZSBvZiB0aGUgRG9tIE5vZGUuXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaG9va05hbWUpIHtcbiAgICBzdXBlcigpXG4gICAgLyoqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLmhvb2tOYW1lID0gaG9va05hbWVcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIEl0ZW0gd2l0aCB0aGUgc2FtZSBlZmZlY3QgYXMgdGhpcyBJdGVtICh3aXRob3V0IHBvc2l0aW9uIGVmZmVjdClcbiAgICovXG4gIF9jb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IFlYbWxIb29rKHRoaXMuaG9va05hbWUpXG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgYSBjb3B5IG9mIHRoaXMgZGF0YSB0eXBlIHRoYXQgY2FuIGJlIGluY2x1ZGVkIHNvbWV3aGVyZSBlbHNlLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhlIGNvbnRlbnQgaXMgb25seSByZWFkYWJsZSBfYWZ0ZXJfIGl0IGhhcyBiZWVuIGluY2x1ZGVkIHNvbWV3aGVyZSBpbiB0aGUgWWRvYy5cbiAgICpcbiAgICogQHJldHVybiB7WVhtbEhvb2t9XG4gICAqL1xuICBjbG9uZSAoKSB7XG4gICAgY29uc3QgZWwgPSBuZXcgWVhtbEhvb2sodGhpcy5ob29rTmFtZSlcbiAgICB0aGlzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGVsLnNldChrZXksIHZhbHVlKVxuICAgIH0pXG4gICAgcmV0dXJuIGVsXG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIERvbSBFbGVtZW50IHRoYXQgbWlycm9ycyB0aGlzIFlYbWxFbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge0RvY3VtZW50fSBbX2RvY3VtZW50PWRvY3VtZW50XSBUaGUgZG9jdW1lbnQgb2JqZWN0ICh5b3UgbXVzdCBkZWZpbmVcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcyB3aGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgaW5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZWpzKVxuICAgKiBAcGFyYW0ge09iamVjdC48c3RyaW5nLCBhbnk+fSBbaG9va3NdIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGVcbiAgICogQHJldHVybiB7RWxlbWVudH0gVGhlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvRWxlbWVudHxEb20gRWxlbWVudH1cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdG9ET00gKF9kb2N1bWVudCA9IGRvY3VtZW50LCBob29rcyA9IHt9LCBiaW5kaW5nKSB7XG4gICAgY29uc3QgaG9vayA9IGhvb2tzW3RoaXMuaG9va05hbWVdXG4gICAgbGV0IGRvbVxuICAgIGlmIChob29rICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGRvbSA9IGhvb2suY3JlYXRlRG9tKHRoaXMpXG4gICAgfSBlbHNlIHtcbiAgICAgIGRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5ob29rTmFtZSlcbiAgICB9XG4gICAgZG9tLnNldEF0dHJpYnV0ZSgnZGF0YS15anMtaG9vaycsIHRoaXMuaG9va05hbWUpXG4gICAgaWYgKGJpbmRpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYmluZGluZy5fY3JlYXRlQXNzb2NpYXRpb24oZG9tLCB0aGlzKVxuICAgIH1cbiAgICByZXR1cm4gZG9tXG4gIH1cblxuICAvKipcbiAgICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIG9mIHRoaXMgdHlwZSB0byBiaW5hcnkgYW5kIHdyaXRlIGl0IHRvIGFuXG4gICAqIEJpbmFyeUVuY29kZXIuXG4gICAqXG4gICAqIFRoaXMgaXMgY2FsbGVkIHdoZW4gdGhpcyBJdGVtIGlzIHNlbnQgdG8gYSByZW1vdGUgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXIgVGhlIGVuY29kZXIgdG8gd3JpdGUgZGF0YSB0by5cbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxIb29rUmVmSUQpXG4gICAgZW5jb2Rlci53cml0ZUtleSh0aGlzLmhvb2tOYW1lKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge1lYbWxIb29rfVxuICpcbiAqIEBwcml2YXRlXG4gKiBAZnVuY3Rpb25cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRZWG1sSG9vayA9IGRlY29kZXIgPT5cbiAgbmV3IFlYbWxIb29rKGRlY29kZXIucmVhZEtleSgpKVxuIiwgImltcG9ydCB7XG4gIFlUZXh0LFxuICBZWG1sVGV4dFJlZklELFxuICBDb250ZW50VHlwZSwgWVhtbEVsZW1lbnQsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbi8qKlxuICogUmVwcmVzZW50cyB0ZXh0IGluIGEgRG9tIEVsZW1lbnQuIEluIHRoZSBmdXR1cmUgdGhpcyB0eXBlIHdpbGwgYWxzbyBoYW5kbGVcbiAqIHNpbXBsZSBmb3JtYXR0aW5nIGluZm9ybWF0aW9uIGxpa2UgYm9sZCBhbmQgaXRhbGljLlxuICovXG5leHBvcnQgY2xhc3MgWVhtbFRleHQgZXh0ZW5kcyBZVGV4dCB7XG4gIC8qKlxuICAgKiBAdHlwZSB7WVhtbEVsZW1lbnR8WVhtbFRleHR8bnVsbH1cbiAgICovXG4gIGdldCBuZXh0U2libGluZyAoKSB7XG4gICAgY29uc3QgbiA9IHRoaXMuX2l0ZW0gPyB0aGlzLl9pdGVtLm5leHQgOiBudWxsXG4gICAgcmV0dXJuIG4gPyAvKiogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fSAqLyAoLyoqIEB0eXBlIHtDb250ZW50VHlwZX0gKi8gKG4uY29udGVudCkudHlwZSkgOiBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1lYbWxFbGVtZW50fFlYbWxUZXh0fG51bGx9XG4gICAqL1xuICBnZXQgcHJldlNpYmxpbmcgKCkge1xuICAgIGNvbnN0IG4gPSB0aGlzLl9pdGVtID8gdGhpcy5faXRlbS5wcmV2IDogbnVsbFxuICAgIHJldHVybiBuID8gLyoqIEB0eXBlIHtZWG1sRWxlbWVudHxZWG1sVGV4dH0gKi8gKC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChuLmNvbnRlbnQpLnR5cGUpIDogbnVsbFxuICB9XG5cbiAgX2NvcHkgKCkge1xuICAgIHJldHVybiBuZXcgWVhtbFRleHQoKVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2VzIGEgY29weSBvZiB0aGlzIGRhdGEgdHlwZSB0aGF0IGNhbiBiZSBpbmNsdWRlZCBzb21ld2hlcmUgZWxzZS5cbiAgICpcbiAgICogTm90ZSB0aGF0IHRoZSBjb250ZW50IGlzIG9ubHkgcmVhZGFibGUgX2FmdGVyXyBpdCBoYXMgYmVlbiBpbmNsdWRlZCBzb21ld2hlcmUgaW4gdGhlIFlkb2MuXG4gICAqXG4gICAqIEByZXR1cm4ge1lYbWxUZXh0fVxuICAgKi9cbiAgY2xvbmUgKCkge1xuICAgIGNvbnN0IHRleHQgPSBuZXcgWVhtbFRleHQoKVxuICAgIHRleHQuYXBwbHlEZWx0YSh0aGlzLnRvRGVsdGEoKSlcbiAgICByZXR1cm4gdGV4dFxuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBEb20gRWxlbWVudCB0aGF0IG1pcnJvcnMgdGhpcyBZWG1sVGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtEb2N1bWVudH0gW19kb2N1bWVudD1kb2N1bWVudF0gVGhlIGRvY3VtZW50IG9iamVjdCAoeW91IG11c3QgZGVmaW5lXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMgd2hlbiBjYWxsaW5nIHRoaXMgbWV0aG9kIGluXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVqcylcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBbaG9va3NdIE9wdGlvbmFsIHByb3BlcnR5IHRvIGN1c3RvbWl6ZSBob3cgaG9va3NcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmUgcHJlc2VudGVkIGluIHRoZSBET01cbiAgICogQHBhcmFtIHthbnl9IFtiaW5kaW5nXSBZb3Ugc2hvdWxkIG5vdCBzZXQgdGhpcyBwcm9wZXJ0eS4gVGhpcyBpc1xuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGlmIERvbUJpbmRpbmcgd2FudHMgdG8gY3JlYXRlIGFcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzb2NpYXRpb24gdG8gdGhlIGNyZWF0ZWQgRE9NIHR5cGUuXG4gICAqIEByZXR1cm4ge1RleHR9IFRoZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnR8RG9tIEVsZW1lbnR9XG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHRvRE9NIChfZG9jdW1lbnQgPSBkb2N1bWVudCwgaG9va3MsIGJpbmRpbmcpIHtcbiAgICBjb25zdCBkb20gPSBfZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGhpcy50b1N0cmluZygpKVxuICAgIGlmIChiaW5kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGJpbmRpbmcuX2NyZWF0ZUFzc29jaWF0aW9uKGRvbSwgdGhpcylcbiAgICB9XG4gICAgcmV0dXJuIGRvbVxuICB9XG5cbiAgdG9TdHJpbmcgKCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gdGhpcy50b0RlbHRhKCkubWFwKGRlbHRhID0+IHtcbiAgICAgIGNvbnN0IG5lc3RlZE5vZGVzID0gW11cbiAgICAgIGZvciAoY29uc3Qgbm9kZU5hbWUgaW4gZGVsdGEuYXR0cmlidXRlcykge1xuICAgICAgICBjb25zdCBhdHRycyA9IFtdXG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdKSB7XG4gICAgICAgICAgYXR0cnMucHVzaCh7IGtleSwgdmFsdWU6IGRlbHRhLmF0dHJpYnV0ZXNbbm9kZU5hbWVdW2tleV0gfSlcbiAgICAgICAgfVxuICAgICAgICAvLyBzb3J0IGF0dHJpYnV0ZXMgdG8gZ2V0IGEgdW5pcXVlIG9yZGVyXG4gICAgICAgIGF0dHJzLnNvcnQoKGEsIGIpID0+IGEua2V5IDwgYi5rZXkgPyAtMSA6IDEpXG4gICAgICAgIG5lc3RlZE5vZGVzLnB1c2goeyBub2RlTmFtZSwgYXR0cnMgfSlcbiAgICAgIH1cbiAgICAgIC8vIHNvcnQgbm9kZSBvcmRlciB0byBnZXQgYSB1bmlxdWUgb3JkZXJcbiAgICAgIG5lc3RlZE5vZGVzLnNvcnQoKGEsIGIpID0+IGEubm9kZU5hbWUgPCBiLm5vZGVOYW1lID8gLTEgOiAxKVxuICAgICAgLy8gbm93IGNvbnZlcnQgdG8gZG9tIHN0cmluZ1xuICAgICAgbGV0IHN0ciA9ICcnXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5lc3RlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXN0ZWROb2Rlc1tpXVxuICAgICAgICBzdHIgKz0gYDwke25vZGUubm9kZU5hbWV9YFxuICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG5vZGUuYXR0cnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBjb25zdCBhdHRyID0gbm9kZS5hdHRyc1tqXVxuICAgICAgICAgIHN0ciArPSBgICR7YXR0ci5rZXl9PVwiJHthdHRyLnZhbHVlfVwiYFxuICAgICAgICB9XG4gICAgICAgIHN0ciArPSAnPidcbiAgICAgIH1cbiAgICAgIHN0ciArPSBkZWx0YS5pbnNlcnRcbiAgICAgIGZvciAobGV0IGkgPSBuZXN0ZWROb2Rlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICBzdHIgKz0gYDwvJHtuZXN0ZWROb2Rlc1tpXS5ub2RlTmFtZX0+YFxuICAgICAgfVxuICAgICAgcmV0dXJuIHN0clxuICAgIH0pLmpvaW4oJycpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICovXG4gIF93cml0ZSAoZW5jb2Rlcikge1xuICAgIGVuY29kZXIud3JpdGVUeXBlUmVmKFlYbWxUZXh0UmVmSUQpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7WVhtbFRleHR9XG4gKlxuICogQHByaXZhdGVcbiAqIEBmdW5jdGlvblxuICovXG5leHBvcnQgY29uc3QgcmVhZFlYbWxUZXh0ID0gZGVjb2RlciA9PiBuZXcgWVhtbFRleHQoKVxuIiwgImltcG9ydCB7XG4gIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBJRCwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdFN0cnVjdCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0lEfSBpZFxuICAgKiBAcGFyYW0ge251bWJlcn0gbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoaWQsIGxlbmd0aCkge1xuICAgIHRoaXMuaWQgPSBpZFxuICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogTWVyZ2UgdGhpcyBzdHJ1Y3Qgd2l0aCB0aGUgaXRlbSB0byB0aGUgcmlnaHQuXG4gICAqIFRoaXMgbWV0aG9kIGlzIGFscmVhZHkgYXNzdW1pbmcgdGhhdCBgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSB0aGlzLmlkLmNsb2NrYC5cbiAgICogQWxzbyB0aGlzIG1ldGhvZCBkb2VzICpub3QqIHJlbW92ZSByaWdodCBmcm9tIFN0cnVjdFN0b3JlIVxuICAgKiBAcGFyYW0ge0Fic3RyYWN0U3RydWN0fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufSB3ZXRoZXIgdGhpcyBtZXJnZWQgd2l0aCByaWdodFxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyIFRoZSBlbmNvZGVyIHRvIHdyaXRlIGRhdGEgdG8uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHBhcmFtIHtudW1iZXJ9IGVuY29kaW5nUmVmXG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0LCBlbmNvZGluZ1JlZikge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIGFkZFN0cnVjdCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIElEIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY29uc3Qgc3RydWN0R0NSZWZOdW1iZXIgPSAwXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIEdDIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGRlbGV0ZSAoKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0dDfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yICE9PSByaWdodC5jb25zdHJ1Y3Rvcikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgb2Zmc2V0KSB7XG4gICAgaWYgKG9mZnNldCA+IDApIHtcbiAgICAgIHRoaXMuaWQuY2xvY2sgKz0gb2Zmc2V0XG4gICAgICB0aGlzLmxlbmd0aCAtPSBvZmZzZXRcbiAgICB9XG4gICAgYWRkU3RydWN0KHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgdGhpcylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0R0NSZWZOdW1iZXIpXG4gICAgZW5jb2Rlci53cml0ZUxlbih0aGlzLmxlbmd0aCAtIG9mZnNldClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcmV0dXJuIHtudWxsIHwgbnVtYmVyfVxuICAgKi9cbiAgZ2V0TWlzc2luZyAodHJhbnNhY3Rpb24sIHN0b3JlKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIEl0ZW0sIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG5leHBvcnQgY2xhc3MgQ29udGVudEJpbmFyeSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb250ZW50KSB7XG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmNvbnRlbnRdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRCaW5hcnkodGhpcy5jb250ZW50KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEJpbmFyeX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QmluYXJ5fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBlbmNvZGVyLndyaXRlQnVmKHRoaXMuY29udGVudClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAzXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRCaW5hcnl9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudEJpbmFyeSA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRCaW5hcnkoZGVjb2Rlci5yZWFkQnVmKCkpXG4iLCAiaW1wb3J0IHtcbiAgYWRkVG9EZWxldGVTZXQsXG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIEl0ZW0sIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5leHBvcnQgY2xhc3MgQ29udGVudERlbGV0ZWQge1xuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGxlblxuICAgKi9cbiAgY29uc3RydWN0b3IgKGxlbikge1xuICAgIHRoaXMubGVuID0gbGVuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RGVsZXRlZH1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudERlbGV0ZWQodGhpcy5sZW4gLSBvZmZzZXQpXG4gICAgdGhpcy5sZW4gPSBvZmZzZXRcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREZWxldGVkfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMubGVuICs9IHJpZ2h0LmxlblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCBpdGVtLmlkLmNsaWVudCwgaXRlbS5pZC5jbG9jaywgdGhpcy5sZW4pXG4gICAgaXRlbS5tYXJrRGVsZXRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVMZW4odGhpcy5sZW4gLSBvZmZzZXQpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMiB9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnREZWxldGVkfVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnREZWxldGVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudERlbGV0ZWQoZGVjb2Rlci5yZWFkTGVuKCkpXG4iLCAiaW1wb3J0IHtcbiAgRG9jLCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFN0cnVjdFN0b3JlLCBUcmFuc2FjdGlvbiwgSXRlbSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcblxuaW1wb3J0ICogYXMgZXJyb3IgZnJvbSAnbGliMC9lcnJvcidcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZ3VpZFxuICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLCBhbnk+fSBvcHRzXG4gKi9cbmNvbnN0IGNyZWF0ZURvY0Zyb21PcHRzID0gKGd1aWQsIG9wdHMpID0+IG5ldyBEb2MoeyBndWlkLCAuLi5vcHRzLCBzaG91bGRMb2FkOiBvcHRzLnNob3VsZExvYWQgfHwgb3B0cy5hdXRvTG9hZCB8fCBmYWxzZSB9KVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZW50RG9jIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7RG9jfSBkb2NcbiAgICovXG4gIGNvbnN0cnVjdG9yIChkb2MpIHtcbiAgICBpZiAoZG9jLl9pdGVtKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdUaGlzIGRvY3VtZW50IHdhcyBhbHJlYWR5IGludGVncmF0ZWQgYXMgYSBzdWItZG9jdW1lbnQuIFlvdSBzaG91bGQgY3JlYXRlIGEgc2Vjb25kIGluc3RhbmNlIGluc3RlYWQgd2l0aCB0aGUgc2FtZSBndWlkLicpXG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtEb2N9XG4gICAgICovXG4gICAgdGhpcy5kb2MgPSBkb2NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIGNvbnN0IG9wdHMgPSB7fVxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICBpZiAoIWRvYy5nYykge1xuICAgICAgb3B0cy5nYyA9IGZhbHNlXG4gICAgfVxuICAgIGlmIChkb2MuYXV0b0xvYWQpIHtcbiAgICAgIG9wdHMuYXV0b0xvYWQgPSB0cnVlXG4gICAgfVxuICAgIGlmIChkb2MubWV0YSAhPT0gbnVsbCkge1xuICAgICAgb3B0cy5tZXRhID0gZG9jLm1ldGFcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0FycmF5PGFueT59XG4gICAqL1xuICBnZXRDb250ZW50ICgpIHtcbiAgICByZXR1cm4gW3RoaXMuZG9jXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZW50RG9jKGNyZWF0ZURvY0Zyb21PcHRzKHRoaXMuZG9jLmd1aWQsIHRoaXMub3B0cykpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnREb2N9IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7XG4gICAgLy8gdGhpcyBuZWVkcyB0byBiZSByZWZsZWN0ZWQgaW4gZG9jLmRlc3Ryb3kgYXMgd2VsbFxuICAgIHRoaXMuZG9jLl9pdGVtID0gaXRlbVxuICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NBZGRlZC5hZGQodGhpcy5kb2MpXG4gICAgaWYgKHRoaXMuZG9jLnNob3VsZExvYWQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLnN1YmRvY3NMb2FkZWQuYWRkKHRoaXMuZG9jKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0cmFuc2FjdGlvbi5zdWJkb2NzQWRkZWQuaGFzKHRoaXMuZG9jKSkge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc0FkZGVkLmRlbGV0ZSh0aGlzLmRvYylcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24uc3ViZG9jc1JlbW92ZWQuYWRkKHRoaXMuZG9jKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7IH1cblxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcodGhpcy5kb2MuZ3VpZClcbiAgICBlbmNvZGVyLndyaXRlQW55KHRoaXMub3B0cylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA5XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RG9jfVxuICovXG5leHBvcnQgY29uc3QgcmVhZENvbnRlbnREb2MgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50RG9jKGNyZWF0ZURvY0Zyb21PcHRzKGRlY29kZXIucmVhZFN0cmluZygpLCBkZWNvZGVyLnJlYWRBbnkoKSkpXG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgSXRlbSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRFbWJlZCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge09iamVjdH0gZW1iZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yIChlbWJlZCkge1xuICAgIHRoaXMuZW1iZWQgPSBlbWJlZFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIFt0aGlzLmVtYmVkXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRFbWJlZCh0aGlzLmVtYmVkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICogQHJldHVybiB7Q29udGVudEVtYmVkfVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRFbWJlZH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKi9cbiAgZGVsZXRlICh0cmFuc2FjdGlvbikge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqL1xuICBnYyAoc3RvcmUpIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy5lbWJlZClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA1XG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50RW1iZWR9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudEVtYmVkID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEVtYmVkKGRlY29kZXIucmVhZEpTT04oKSlcbiIsICJpbXBvcnQge1xuICBZVGV4dCwgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBJdGVtLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24gLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRGb3JtYXQge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5rZXkgPSBrZXlcbiAgICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEZvcm1hdCh0aGlzLmtleSwgdGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gX29mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50Rm9ybWF0fVxuICAgKi9cbiAgc3BsaWNlIChfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50Rm9ybWF0fSBfcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAoX3JpZ2h0KSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gX3RyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlIChfdHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICAvLyBAdG9kbyBzZWFyY2htYXJrZXIgYXJlIGN1cnJlbnRseSB1bnN1cHBvcnRlZCBmb3IgcmljaCB0ZXh0IGRvY3VtZW50c1xuICAgIGNvbnN0IHAgPSAvKiogQHR5cGUge1lUZXh0fSAqLyAoaXRlbS5wYXJlbnQpXG4gICAgcC5fc2VhcmNoTWFya2VyID0gbnVsbFxuICAgIHAuX2hhc0Zvcm1hdHRpbmcgPSB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVLZXkodGhpcy5rZXkpXG4gICAgZW5jb2Rlci53cml0ZUpTT04odGhpcy52YWx1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA2XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEZvcm1hdH1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50Rm9ybWF0ID0gZGVjb2RlciA9PiBuZXcgQ29udGVudEZvcm1hdChkZWNvZGVyLnJlYWRLZXkoKSwgZGVjb2Rlci5yZWFkSlNPTigpKVxuIiwgImltcG9ydCB7XG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgVHJhbnNhY3Rpb24sIEl0ZW0sIFN0cnVjdFN0b3JlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZW50SlNPTiB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PGFueT59IGFyclxuICAgKi9cbiAgY29uc3RydWN0b3IgKGFycikge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBcnJheTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMuYXJyID0gYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5hcnIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLmFyclxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudEpTT04odGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgY29uc3QgcmlnaHQgPSBuZXcgQ29udGVudEpTT04odGhpcy5hcnIuc2xpY2Uob2Zmc2V0KSlcbiAgICB0aGlzLmFyciA9IHRoaXMuYXJyLnNsaWNlKDAsIG9mZnNldClcbiAgICByZXR1cm4gcmlnaHRcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0NvbnRlbnRKU09OfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGhcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldClcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXVxuICAgICAgZW5jb2Rlci53cml0ZVN0cmluZyhjID09PSB1bmRlZmluZWQgPyAndW5kZWZpbmVkJyA6IEpTT04uc3RyaW5naWZ5KGMpKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiAyXG4gIH1cbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcmV0dXJuIHtDb250ZW50SlNPTn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50SlNPTiA9IGRlY29kZXIgPT4ge1xuICBjb25zdCBsZW4gPSBkZWNvZGVyLnJlYWRMZW4oKVxuICBjb25zdCBjcyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjID0gZGVjb2Rlci5yZWFkU3RyaW5nKClcbiAgICBpZiAoYyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNzLnB1c2godW5kZWZpbmVkKVxuICAgIH0gZWxzZSB7XG4gICAgICBjcy5wdXNoKEpTT04ucGFyc2UoYykpXG4gICAgfVxuICB9XG4gIHJldHVybiBuZXcgQ29udGVudEpTT04oY3MpXG59XG4iLCAiaW1wb3J0IHtcbiAgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBUcmFuc2FjdGlvbiwgSXRlbSwgU3RydWN0U3RvcmUgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufSBmcm9tICcuLi9pbnRlcm5hbHMuanMnXG5cbmV4cG9ydCBjbGFzcyBDb250ZW50QW55IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gYXJyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoYXJyKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0FycmF5PGFueT59XG4gICAgICovXG4gICAgdGhpcy5hcnIgPSBhcnJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtBcnJheTxhbnk+fVxuICAgKi9cbiAgZ2V0Q29udGVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXJyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ291bnRhYmxlICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge0NvbnRlbnRBbnl9XG4gICAqL1xuICBjb3B5ICgpIHtcbiAgICByZXR1cm4gbmV3IENvbnRlbnRBbnkodGhpcy5hcnIpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50QW55fVxuICAgKi9cbiAgc3BsaWNlIChvZmZzZXQpIHtcbiAgICBjb25zdCByaWdodCA9IG5ldyBDb250ZW50QW55KHRoaXMuYXJyLnNsaWNlKG9mZnNldCkpXG4gICAgdGhpcy5hcnIgPSB0aGlzLmFyci5zbGljZSgwLCBvZmZzZXQpXG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50QW55fSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuYXJyID0gdGhpcy5hcnIuY29uY2F0KHJpZ2h0LmFycilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlICh0cmFuc2FjdGlvbiwgaXRlbSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKHRyYW5zYWN0aW9uKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge31cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICBjb25zdCBsZW4gPSB0aGlzLmFyci5sZW5ndGhcbiAgICBlbmNvZGVyLndyaXRlTGVuKGxlbiAtIG9mZnNldClcbiAgICBmb3IgKGxldCBpID0gb2Zmc2V0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IGMgPSB0aGlzLmFycltpXVxuICAgICAgZW5jb2Rlci53cml0ZUFueShjKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRSZWYgKCkge1xuICAgIHJldHVybiA4XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudEFueX1cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRDb250ZW50QW55ID0gZGVjb2RlciA9PiB7XG4gIGNvbnN0IGxlbiA9IGRlY29kZXIucmVhZExlbigpXG4gIGNvbnN0IGNzID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNzLnB1c2goZGVjb2Rlci5yZWFkQW55KCkpXG4gIH1cbiAgcmV0dXJuIG5ldyBDb250ZW50QW55KGNzKVxufVxuIiwgImltcG9ydCB7XG4gIFVwZGF0ZURlY29kZXJWMSwgVXBkYXRlRGVjb2RlclYyLCBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgVHJhbnNhY3Rpb24sIEl0ZW0sIFN0cnVjdFN0b3JlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBDb250ZW50U3RyaW5nIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAgICovXG4gIGNvbnN0cnVjdG9yIChzdHIpIHtcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHRoaXMuc3RyID0gc3RyXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0TGVuZ3RoICgpIHtcbiAgICByZXR1cm4gdGhpcy5zdHIubGVuZ3RoXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnN0ci5zcGxpdCgnJylcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNDb3VudGFibGUgKCkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Q29udGVudFN0cmluZ31cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFN0cmluZyh0aGlzLnN0cilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gICAqL1xuICBzcGxpY2UgKG9mZnNldCkge1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3IENvbnRlbnRTdHJpbmcodGhpcy5zdHIuc2xpY2Uob2Zmc2V0KSlcbiAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldClcblxuICAgIC8vIFByZXZlbnQgZW5jb2RpbmcgaW52YWxpZCBkb2N1bWVudHMgYmVjYXVzZSBvZiBzcGxpdHRpbmcgb2Ygc3Vycm9nYXRlIHBhaXJzOiBodHRwczovL2dpdGh1Yi5jb20veWpzL3lqcy9pc3N1ZXMvMjQ4XG4gICAgY29uc3QgZmlyc3RDaGFyQ29kZSA9IHRoaXMuc3RyLmNoYXJDb2RlQXQob2Zmc2V0IC0gMSlcbiAgICBpZiAoZmlyc3RDaGFyQ29kZSA+PSAweEQ4MDAgJiYgZmlyc3RDaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgIC8vIExhc3QgY2hhcmFjdGVyIG9mIHRoZSBsZWZ0IHNwbGl0IGlzIHRoZSBzdGFydCBvZiBhIHN1cnJvZ2F0ZSB1dGYxNi91Y3MyIHBhaXIuXG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHNwbGl0dGluZyBvZiBzdXJyb2dhdGUgcGFpcnMgYmVjYXVzZSB0aGlzIG1heSBsZWFkIHRvIGludmFsaWQgZG9jdW1lbnRzLlxuICAgICAgLy8gUmVwbGFjZSB0aGUgaW52YWxpZCBjaGFyYWN0ZXIgd2l0aCBhIHVuaWNvZGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyICjvv70gLyBVK0ZGRkQpXG4gICAgICB0aGlzLnN0ciA9IHRoaXMuc3RyLnNsaWNlKDAsIG9mZnNldCAtIDEpICsgJ++/vSdcbiAgICAgIC8vIHJlcGxhY2UgcmlnaHQgYXMgd2VsbFxuICAgICAgcmlnaHQuc3RyID0gJ++/vScgKyByaWdodC5zdHIuc2xpY2UoMSlcbiAgICB9XG4gICAgcmV0dXJuIHJpZ2h0XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50U3RyaW5nfSByaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChyaWdodCkge1xuICAgIHRoaXMuc3RyICs9IHJpZ2h0LnN0clxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtXG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBpdGVtKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHt9XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKi9cbiAgZ2MgKHN0b3JlKSB7fVxuICAvKipcbiAgICogQHBhcmFtIHtVcGRhdGVFbmNvZGVyVjEgfCBVcGRhdGVFbmNvZGVyVjJ9IGVuY29kZXJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKi9cbiAgd3JpdGUgKGVuY29kZXIsIG9mZnNldCkge1xuICAgIGVuY29kZXIud3JpdGVTdHJpbmcob2Zmc2V0ID09PSAwID8gdGhpcy5zdHIgOiB0aGlzLnN0ci5zbGljZShvZmZzZXQpKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFJlZiAoKSB7XG4gICAgcmV0dXJuIDRcbiAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjJ9IGRlY29kZXJcbiAqIEByZXR1cm4ge0NvbnRlbnRTdHJpbmd9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudFN0cmluZyA9IGRlY29kZXIgPT4gbmV3IENvbnRlbnRTdHJpbmcoZGVjb2Rlci5yZWFkU3RyaW5nKCkpXG4iLCAiaW1wb3J0IHtcbiAgcmVhZFlBcnJheSxcbiAgcmVhZFlNYXAsXG4gIHJlYWRZVGV4dCxcbiAgcmVhZFlYbWxFbGVtZW50LFxuICByZWFkWVhtbEZyYWdtZW50LFxuICByZWFkWVhtbEhvb2ssXG4gIHJlYWRZWG1sVGV4dCxcbiAgVXBkYXRlRGVjb2RlclYxLCBVcGRhdGVEZWNvZGVyVjIsIFVwZGF0ZUVuY29kZXJWMSwgVXBkYXRlRW5jb2RlclYyLCBTdHJ1Y3RTdG9yZSwgVHJhbnNhY3Rpb24sIEl0ZW0sIFlFdmVudCwgQWJzdHJhY3RUeXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuXG4vKipcbiAqIEB0eXBlIHtBcnJheTxmdW5jdGlvbihVcGRhdGVEZWNvZGVyVjEgfCBVcGRhdGVEZWNvZGVyVjIpOkFic3RyYWN0VHlwZTxhbnk+Pn1cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCB0eXBlUmVmcyA9IFtcbiAgcmVhZFlBcnJheSxcbiAgcmVhZFlNYXAsXG4gIHJlYWRZVGV4dCxcbiAgcmVhZFlYbWxFbGVtZW50LFxuICByZWFkWVhtbEZyYWdtZW50LFxuICByZWFkWVhtbEhvb2ssXG4gIHJlYWRZWG1sVGV4dFxuXVxuXG5leHBvcnQgY29uc3QgWUFycmF5UmVmSUQgPSAwXG5leHBvcnQgY29uc3QgWU1hcFJlZklEID0gMVxuZXhwb3J0IGNvbnN0IFlUZXh0UmVmSUQgPSAyXG5leHBvcnQgY29uc3QgWVhtbEVsZW1lbnRSZWZJRCA9IDNcbmV4cG9ydCBjb25zdCBZWG1sRnJhZ21lbnRSZWZJRCA9IDRcbmV4cG9ydCBjb25zdCBZWG1sSG9va1JlZklEID0gNVxuZXhwb3J0IGNvbnN0IFlYbWxUZXh0UmVmSUQgPSA2XG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIENvbnRlbnRUeXBlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RUeXBlPGFueT59IHR5cGVcbiAgICovXG4gIGNvbnN0cnVjdG9yICh0eXBlKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fVxuICAgICAqL1xuICAgIHRoaXMudHlwZSA9IHR5cGVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRMZW5ndGggKCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHJldHVybiBbdGhpcy50eXBlXVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIGNvcHkgKCkge1xuICAgIHJldHVybiBuZXcgQ29udGVudFR5cGUodGhpcy50eXBlLl9jb3B5KCkpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICAgKiBAcmV0dXJuIHtDb250ZW50VHlwZX1cbiAgICovXG4gIHNwbGljZSAob2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtDb250ZW50VHlwZX0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIGl0ZW0pIHtcbiAgICB0aGlzLnR5cGUuX2ludGVncmF0ZSh0cmFuc2FjdGlvbi5kb2MsIGl0ZW0pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBsZXQgaXRlbSA9IHRoaXMudHlwZS5fc3RhcnRcbiAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFpdGVtLmRlbGV0ZWQpIHtcbiAgICAgICAgaXRlbS5kZWxldGUodHJhbnNhY3Rpb24pXG4gICAgICB9IGVsc2UgaWYgKGl0ZW0uaWQuY2xvY2sgPCAodHJhbnNhY3Rpb24uYmVmb3JlU3RhdGUuZ2V0KGl0ZW0uaWQuY2xpZW50KSB8fCAwKSkge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgZ2MnZCBsYXRlciBhbmQgd2Ugd2FudCB0byBtZXJnZSBpdCBpZiBwb3NzaWJsZVxuICAgICAgICAvLyBXZSB0cnkgdG8gbWVyZ2UgYWxsIGRlbGV0ZWQgaXRlbXMgYWZ0ZXIgZWFjaCB0cmFuc2FjdGlvbixcbiAgICAgICAgLy8gYnV0IHdlIGhhdmUgbm8ga25vd2xlZGdlIGFib3V0IHRoYXQgdGhpcyBuZWVkcyB0byBiZSBtZXJnZWRcbiAgICAgICAgLy8gc2luY2UgaXQgaXMgbm90IGluIHRyYW5zYWN0aW9uLmRzLiBIZW5jZSB3ZSBhZGQgaXQgdG8gdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0c1xuICAgICAgICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2goaXRlbSlcbiAgICAgIH1cbiAgICAgIGl0ZW0gPSBpdGVtLnJpZ2h0XG4gICAgfVxuICAgIHRoaXMudHlwZS5fbWFwLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBpZiAoIWl0ZW0uZGVsZXRlZCkge1xuICAgICAgICBpdGVtLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH0gZWxzZSBpZiAoaXRlbS5pZC5jbG9jayA8ICh0cmFuc2FjdGlvbi5iZWZvcmVTdGF0ZS5nZXQoaXRlbS5pZC5jbGllbnQpIHx8IDApKSB7XG4gICAgICAgIC8vIHNhbWUgYXMgYWJvdmVcbiAgICAgICAgdHJhbnNhY3Rpb24uX21lcmdlU3RydWN0cy5wdXNoKGl0ZW0pXG4gICAgICB9XG4gICAgfSlcbiAgICB0cmFuc2FjdGlvbi5jaGFuZ2VkLmRlbGV0ZSh0aGlzLnR5cGUpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJ1Y3RTdG9yZX0gc3RvcmVcbiAgICovXG4gIGdjIChzdG9yZSkge1xuICAgIGxldCBpdGVtID0gdGhpcy50eXBlLl9zdGFydFxuICAgIHdoaWxlIChpdGVtICE9PSBudWxsKSB7XG4gICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKVxuICAgICAgaXRlbSA9IGl0ZW0ucmlnaHRcbiAgICB9XG4gICAgdGhpcy50eXBlLl9zdGFydCA9IG51bGxcbiAgICB0aGlzLnR5cGUuX21hcC5mb3JFYWNoKC8qKiBAcGFyYW0ge0l0ZW0gfCBudWxsfSBpdGVtICovIChpdGVtKSA9PiB7XG4gICAgICB3aGlsZSAoaXRlbSAhPT0gbnVsbCkge1xuICAgICAgICBpdGVtLmdjKHN0b3JlLCB0cnVlKVxuICAgICAgICBpdGVtID0gaXRlbS5sZWZ0XG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnR5cGUuX21hcCA9IG5ldyBNYXAoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBlbmNvZGVyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIHdyaXRlIChlbmNvZGVyLCBvZmZzZXQpIHtcbiAgICB0aGlzLnR5cGUuX3dyaXRlKGVuY29kZXIpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICByZXR1cm4gN1xuICB9XG59XG5cbi8qKlxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1VwZGF0ZURlY29kZXJWMSB8IFVwZGF0ZURlY29kZXJWMn0gZGVjb2RlclxuICogQHJldHVybiB7Q29udGVudFR5cGV9XG4gKi9cbmV4cG9ydCBjb25zdCByZWFkQ29udGVudFR5cGUgPSBkZWNvZGVyID0+IG5ldyBDb250ZW50VHlwZSh0eXBlUmVmc1tkZWNvZGVyLnJlYWRUeXBlUmVmKCldKGRlY29kZXIpKVxuIiwgImltcG9ydCB7XG4gIEdDLFxuICBnZXRTdGF0ZSxcbiAgQWJzdHJhY3RTdHJ1Y3QsXG4gIHJlcGxhY2VTdHJ1Y3QsXG4gIGFkZFN0cnVjdCxcbiAgYWRkVG9EZWxldGVTZXQsXG4gIGZpbmRSb290VHlwZUtleSxcbiAgY29tcGFyZUlEcyxcbiAgZ2V0SXRlbSxcbiAgZ2V0SXRlbUNsZWFuRW5kLFxuICBnZXRJdGVtQ2xlYW5TdGFydCxcbiAgcmVhZENvbnRlbnREZWxldGVkLFxuICByZWFkQ29udGVudEJpbmFyeSxcbiAgcmVhZENvbnRlbnRKU09OLFxuICByZWFkQ29udGVudEFueSxcbiAgcmVhZENvbnRlbnRTdHJpbmcsXG4gIHJlYWRDb250ZW50RW1iZWQsXG4gIHJlYWRDb250ZW50RG9jLFxuICBjcmVhdGVJRCxcbiAgcmVhZENvbnRlbnRGb3JtYXQsXG4gIHJlYWRDb250ZW50VHlwZSxcbiAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uLFxuICBpc0RlbGV0ZWQsXG4gIFN0YWNrSXRlbSwgRGVsZXRlU2V0LCBVcGRhdGVEZWNvZGVyVjEsIFVwZGF0ZURlY29kZXJWMiwgVXBkYXRlRW5jb2RlclYxLCBVcGRhdGVFbmNvZGVyVjIsIENvbnRlbnRUeXBlLCBDb250ZW50RGVsZXRlZCwgU3RydWN0U3RvcmUsIElELCBBYnN0cmFjdFR5cGUsIFRyYW5zYWN0aW9uIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbn0gZnJvbSAnLi4vaW50ZXJuYWxzLmpzJ1xuXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgYmluYXJ5IGZyb20gJ2xpYjAvYmluYXJ5J1xuaW1wb3J0ICogYXMgYXJyYXkgZnJvbSAnbGliMC9hcnJheSdcblxuLyoqXG4gKiBAdG9kbyBUaGlzIHNob3VsZCByZXR1cm4gc2V2ZXJhbCBpdGVtc1xuICpcbiAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEfSBpZFxuICogQHJldHVybiB7e2l0ZW06SXRlbSwgZGlmZjpudW1iZXJ9fVxuICovXG5leHBvcnQgY29uc3QgZm9sbG93UmVkb25lID0gKHN0b3JlLCBpZCkgPT4ge1xuICAvKipcbiAgICogQHR5cGUge0lEfG51bGx9XG4gICAqL1xuICBsZXQgbmV4dElEID0gaWRcbiAgbGV0IGRpZmYgPSAwXG4gIGxldCBpdGVtXG4gIGRvIHtcbiAgICBpZiAoZGlmZiA+IDApIHtcbiAgICAgIG5leHRJRCA9IGNyZWF0ZUlEKG5leHRJRC5jbGllbnQsIG5leHRJRC5jbG9jayArIGRpZmYpXG4gICAgfVxuICAgIGl0ZW0gPSBnZXRJdGVtKHN0b3JlLCBuZXh0SUQpXG4gICAgZGlmZiA9IG5leHRJRC5jbG9jayAtIGl0ZW0uaWQuY2xvY2tcbiAgICBuZXh0SUQgPSBpdGVtLnJlZG9uZVxuICB9IHdoaWxlIChuZXh0SUQgIT09IG51bGwgJiYgaXRlbSBpbnN0YW5jZW9mIEl0ZW0pXG4gIHJldHVybiB7XG4gICAgaXRlbSwgZGlmZlxuICB9XG59XG5cbi8qKlxuICogTWFrZSBzdXJlIHRoYXQgbmVpdGhlciBpdGVtIG5vciBhbnkgb2YgaXRzIHBhcmVudHMgaXMgZXZlciBkZWxldGVkLlxuICpcbiAqIFRoaXMgcHJvcGVydHkgZG9lcyBub3QgcGVyc2lzdCB3aGVuIHN0b3JpbmcgaXQgaW50byBhIGRhdGFiYXNlIG9yIHdoZW5cbiAqIHNlbmRpbmcgaXQgdG8gb3RoZXIgcGVlcnNcbiAqXG4gKiBAcGFyYW0ge0l0ZW18bnVsbH0gaXRlbVxuICogQHBhcmFtIHtib29sZWFufSBrZWVwXG4gKi9cbmV4cG9ydCBjb25zdCBrZWVwSXRlbSA9IChpdGVtLCBrZWVwKSA9PiB7XG4gIHdoaWxlIChpdGVtICE9PSBudWxsICYmIGl0ZW0ua2VlcCAhPT0ga2VlcCkge1xuICAgIGl0ZW0ua2VlcCA9IGtlZXBcbiAgICBpdGVtID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KS5faXRlbVxuICB9XG59XG5cbi8qKlxuICogU3BsaXQgbGVmdEl0ZW0gaW50byB0d28gaXRlbXNcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge0l0ZW19IGxlZnRJdGVtXG4gKiBAcGFyYW0ge251bWJlcn0gZGlmZlxuICogQHJldHVybiB7SXRlbX1cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBzcGxpdEl0ZW0gPSAodHJhbnNhY3Rpb24sIGxlZnRJdGVtLCBkaWZmKSA9PiB7XG4gIC8vIGNyZWF0ZSByaWdodEl0ZW1cbiAgY29uc3QgeyBjbGllbnQsIGNsb2NrIH0gPSBsZWZ0SXRlbS5pZFxuICBjb25zdCByaWdodEl0ZW0gPSBuZXcgSXRlbShcbiAgICBjcmVhdGVJRChjbGllbnQsIGNsb2NrICsgZGlmZiksXG4gICAgbGVmdEl0ZW0sXG4gICAgY3JlYXRlSUQoY2xpZW50LCBjbG9jayArIGRpZmYgLSAxKSxcbiAgICBsZWZ0SXRlbS5yaWdodCxcbiAgICBsZWZ0SXRlbS5yaWdodE9yaWdpbixcbiAgICBsZWZ0SXRlbS5wYXJlbnQsXG4gICAgbGVmdEl0ZW0ucGFyZW50U3ViLFxuICAgIGxlZnRJdGVtLmNvbnRlbnQuc3BsaWNlKGRpZmYpXG4gIClcbiAgaWYgKGxlZnRJdGVtLmRlbGV0ZWQpIHtcbiAgICByaWdodEl0ZW0ubWFya0RlbGV0ZWQoKVxuICB9XG4gIGlmIChsZWZ0SXRlbS5rZWVwKSB7XG4gICAgcmlnaHRJdGVtLmtlZXAgPSB0cnVlXG4gIH1cbiAgaWYgKGxlZnRJdGVtLnJlZG9uZSAhPT0gbnVsbCkge1xuICAgIHJpZ2h0SXRlbS5yZWRvbmUgPSBjcmVhdGVJRChsZWZ0SXRlbS5yZWRvbmUuY2xpZW50LCBsZWZ0SXRlbS5yZWRvbmUuY2xvY2sgKyBkaWZmKVxuICB9XG4gIC8vIHVwZGF0ZSBsZWZ0IChkbyBub3Qgc2V0IGxlZnRJdGVtLnJpZ2h0T3JpZ2luIGFzIGl0IHdpbGwgbGVhZCB0byBwcm9ibGVtcyB3aGVuIHN5bmNpbmcpXG4gIGxlZnRJdGVtLnJpZ2h0ID0gcmlnaHRJdGVtXG4gIC8vIHVwZGF0ZSByaWdodFxuICBpZiAocmlnaHRJdGVtLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgcmlnaHRJdGVtLnJpZ2h0LmxlZnQgPSByaWdodEl0ZW1cbiAgfVxuICAvLyByaWdodCBpcyBtb3JlIHNwZWNpZmljLlxuICB0cmFuc2FjdGlvbi5fbWVyZ2VTdHJ1Y3RzLnB1c2gocmlnaHRJdGVtKVxuICAvLyB1cGRhdGUgcGFyZW50Ll9tYXBcbiAgaWYgKHJpZ2h0SXRlbS5wYXJlbnRTdWIgIT09IG51bGwgJiYgcmlnaHRJdGVtLnJpZ2h0ID09PSBudWxsKSB7XG4gICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHJpZ2h0SXRlbS5wYXJlbnQpLl9tYXAuc2V0KHJpZ2h0SXRlbS5wYXJlbnRTdWIsIHJpZ2h0SXRlbSlcbiAgfVxuICBsZWZ0SXRlbS5sZW5ndGggPSBkaWZmXG4gIHJldHVybiByaWdodEl0ZW1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0FycmF5PFN0YWNrSXRlbT59IHN0YWNrXG4gKiBAcGFyYW0ge0lEfSBpZFxuICovXG5jb25zdCBpc0RlbGV0ZWRCeVVuZG9TdGFjayA9IChzdGFjaywgaWQpID0+IGFycmF5LnNvbWUoc3RhY2ssIC8qKiBAcGFyYW0ge1N0YWNrSXRlbX0gcyAqLyBzID0+IGlzRGVsZXRlZChzLmRlbGV0aW9ucywgaWQpKVxuXG4vKipcbiAqIFJlZG9lcyB0aGUgZWZmZWN0IG9mIHRoaXMgb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uIFRoZSBZanMgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW1cbiAqIEBwYXJhbSB7U2V0PEl0ZW0+fSByZWRvaXRlbXNcbiAqIEBwYXJhbSB7RGVsZXRlU2V0fSBpdGVtc1RvRGVsZXRlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZVJlbW90ZU1hcENoYW5nZXNcbiAqIEBwYXJhbSB7aW1wb3J0KCcuLi91dGlscy9VbmRvTWFuYWdlci5qcycpLlVuZG9NYW5hZ2VyfSB1bVxuICpcbiAqIEByZXR1cm4ge0l0ZW18bnVsbH1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgcmVkb0l0ZW0gPSAodHJhbnNhY3Rpb24sIGl0ZW0sIHJlZG9pdGVtcywgaXRlbXNUb0RlbGV0ZSwgaWdub3JlUmVtb3RlTWFwQ2hhbmdlcywgdW0pID0+IHtcbiAgY29uc3QgZG9jID0gdHJhbnNhY3Rpb24uZG9jXG4gIGNvbnN0IHN0b3JlID0gZG9jLnN0b3JlXG4gIGNvbnN0IG93bkNsaWVudElEID0gZG9jLmNsaWVudElEXG4gIGNvbnN0IHJlZG9uZSA9IGl0ZW0ucmVkb25lXG4gIGlmIChyZWRvbmUgIT09IG51bGwpIHtcbiAgICByZXR1cm4gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIHJlZG9uZSlcbiAgfVxuICBsZXQgcGFyZW50SXRlbSA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChpdGVtLnBhcmVudCkuX2l0ZW1cbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgbGVmdCA9IG51bGxcbiAgLyoqXG4gICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAqL1xuICBsZXQgcmlnaHRcbiAgLy8gbWFrZSBzdXJlIHRoYXQgcGFyZW50IGlzIHJlZG9uZVxuICBpZiAocGFyZW50SXRlbSAhPT0gbnVsbCAmJiBwYXJlbnRJdGVtLmRlbGV0ZWQgPT09IHRydWUpIHtcbiAgICAvLyB0cnkgdG8gdW5kbyBwYXJlbnQgaWYgaXQgd2lsbCBiZSB1bmRvbmUgYW55d2F5XG4gICAgaWYgKHBhcmVudEl0ZW0ucmVkb25lID09PSBudWxsICYmICghcmVkb2l0ZW1zLmhhcyhwYXJlbnRJdGVtKSB8fCByZWRvSXRlbSh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbSwgcmVkb2l0ZW1zLCBpdGVtc1RvRGVsZXRlLCBpZ25vcmVSZW1vdGVNYXBDaGFuZ2VzLCB1bSkgPT09IG51bGwpKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cbiAgICB3aGlsZSAocGFyZW50SXRlbS5yZWRvbmUgIT09IG51bGwpIHtcbiAgICAgIHBhcmVudEl0ZW0gPSBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcGFyZW50SXRlbS5yZWRvbmUpXG4gICAgfVxuICB9XG4gIGNvbnN0IHBhcmVudFR5cGUgPSBwYXJlbnRJdGVtID09PSBudWxsID8gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKGl0ZW0ucGFyZW50KSA6IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGVcblxuICBpZiAoaXRlbS5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAvLyBJcyBhbiBhcnJheSBpdGVtLiBJbnNlcnQgYXQgdGhlIG9sZCBwb3NpdGlvblxuICAgIGxlZnQgPSBpdGVtLmxlZnRcbiAgICByaWdodCA9IGl0ZW1cbiAgICAvLyBmaW5kIG5leHQgY2xvbmVkX3JlZG8gaXRlbXNcbiAgICB3aGlsZSAobGVmdCAhPT0gbnVsbCkge1xuICAgICAgLyoqXG4gICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICovXG4gICAgICBsZXQgbGVmdFRyYWNlID0gbGVmdFxuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAobGVmdFRyYWNlICE9PSBudWxsICYmIC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovIChsZWZ0VHJhY2UucGFyZW50KS5faXRlbSAhPT0gcGFyZW50SXRlbSkge1xuICAgICAgICBsZWZ0VHJhY2UgPSBsZWZ0VHJhY2UucmVkb25lID09PSBudWxsID8gbnVsbCA6IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCBsZWZ0VHJhY2UucmVkb25lKVxuICAgICAgfVxuICAgICAgaWYgKGxlZnRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAobGVmdFRyYWNlLnBhcmVudCkuX2l0ZW0gPT09IHBhcmVudEl0ZW0pIHtcbiAgICAgICAgbGVmdCA9IGxlZnRUcmFjZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgbGVmdCA9IGxlZnQubGVmdFxuICAgIH1cbiAgICB3aGlsZSAocmlnaHQgIT09IG51bGwpIHtcbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0l0ZW18bnVsbH1cbiAgICAgICAqL1xuICAgICAgbGV0IHJpZ2h0VHJhY2UgPSByaWdodFxuICAgICAgLy8gdHJhY2UgcmVkb25lIHVudGlsIHBhcmVudCBtYXRjaGVzXG4gICAgICB3aGlsZSAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtICE9PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0VHJhY2UgPSByaWdodFRyYWNlLnJlZG9uZSA9PT0gbnVsbCA/IG51bGwgOiBnZXRJdGVtQ2xlYW5TdGFydCh0cmFuc2FjdGlvbiwgcmlnaHRUcmFjZS5yZWRvbmUpXG4gICAgICB9XG4gICAgICBpZiAocmlnaHRUcmFjZSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAocmlnaHRUcmFjZS5wYXJlbnQpLl9pdGVtID09PSBwYXJlbnRJdGVtKSB7XG4gICAgICAgIHJpZ2h0ID0gcmlnaHRUcmFjZVxuICAgICAgICBicmVha1xuICAgICAgfVxuICAgICAgcmlnaHQgPSByaWdodC5yaWdodFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByaWdodCA9IG51bGxcbiAgICBpZiAoaXRlbS5yaWdodCAmJiAhaWdub3JlUmVtb3RlTWFwQ2hhbmdlcykge1xuICAgICAgbGVmdCA9IGl0ZW1cbiAgICAgIC8vIEl0ZXJhdGUgcmlnaHQgd2hpbGUgcmlnaHQgaXMgaW4gaXRlbXNUb0RlbGV0ZVxuICAgICAgLy8gSWYgaXQgaXMgaW50ZW5kZWQgdG8gZGVsZXRlIHJpZ2h0IHdoaWxlIGl0ZW0gaXMgcmVkb25lLCB3ZSBjYW4gZXhwZWN0IHRoYXQgaXRlbSBzaG91bGQgcmVwbGFjZSByaWdodC5cbiAgICAgIHdoaWxlIChsZWZ0ICE9PSBudWxsICYmIGxlZnQucmlnaHQgIT09IG51bGwgJiYgKGxlZnQucmlnaHQucmVkb25lIHx8IGlzRGVsZXRlZChpdGVtc1RvRGVsZXRlLCBsZWZ0LnJpZ2h0LmlkKSB8fCBpc0RlbGV0ZWRCeVVuZG9TdGFjayh1bS51bmRvU3RhY2ssIGxlZnQucmlnaHQuaWQpIHx8IGlzRGVsZXRlZEJ5VW5kb1N0YWNrKHVtLnJlZG9TdGFjaywgbGVmdC5yaWdodC5pZCkpKSB7XG4gICAgICAgIGxlZnQgPSBsZWZ0LnJpZ2h0XG4gICAgICAgIC8vIGZvbGxvdyByZWRvbmVcbiAgICAgICAgd2hpbGUgKGxlZnQucmVkb25lKSBsZWZ0ID0gZ2V0SXRlbUNsZWFuU3RhcnQodHJhbnNhY3Rpb24sIGxlZnQucmVkb25lKVxuICAgICAgfVxuICAgICAgaWYgKGxlZnQgJiYgbGVmdC5yaWdodCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJdCBpcyBub3QgcG9zc2libGUgdG8gcmVkbyB0aGlzIGl0ZW0gYmVjYXVzZSBpdCBjb25mbGljdHMgd2l0aCBhXG4gICAgICAgIC8vIGNoYW5nZSBmcm9tIGFub3RoZXIgY2xpZW50XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxlZnQgPSBwYXJlbnRUeXBlLl9tYXAuZ2V0KGl0ZW0ucGFyZW50U3ViKSB8fCBudWxsXG4gICAgfVxuICB9XG4gIGNvbnN0IG5leHRDbG9jayA9IGdldFN0YXRlKHN0b3JlLCBvd25DbGllbnRJRClcbiAgY29uc3QgbmV4dElkID0gY3JlYXRlSUQob3duQ2xpZW50SUQsIG5leHRDbG9jaylcbiAgY29uc3QgcmVkb25lSXRlbSA9IG5ldyBJdGVtKFxuICAgIG5leHRJZCxcbiAgICBsZWZ0LCBsZWZ0ICYmIGxlZnQubGFzdElkLFxuICAgIHJpZ2h0LCByaWdodCAmJiByaWdodC5pZCxcbiAgICBwYXJlbnRUeXBlLFxuICAgIGl0ZW0ucGFyZW50U3ViLFxuICAgIGl0ZW0uY29udGVudC5jb3B5KClcbiAgKVxuICBpdGVtLnJlZG9uZSA9IG5leHRJZFxuICBrZWVwSXRlbShyZWRvbmVJdGVtLCB0cnVlKVxuICByZWRvbmVJdGVtLmludGVncmF0ZSh0cmFuc2FjdGlvbiwgMClcbiAgcmV0dXJuIHJlZG9uZUl0ZW1cbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYW55IGNvbnRlbnQuXG4gKi9cbmV4cG9ydCBjbGFzcyBJdGVtIGV4dGVuZHMgQWJzdHJhY3RTdHJ1Y3Qge1xuICAvKipcbiAgICogQHBhcmFtIHtJRH0gaWRcbiAgICogQHBhcmFtIHtJdGVtIHwgbnVsbH0gbGVmdFxuICAgKiBAcGFyYW0ge0lEIHwgbnVsbH0gb3JpZ2luXG4gICAqIEBwYXJhbSB7SXRlbSB8IG51bGx9IHJpZ2h0XG4gICAqIEBwYXJhbSB7SUQgfCBudWxsfSByaWdodE9yaWdpblxuICAgKiBAcGFyYW0ge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9IHBhcmVudCBJcyBhIHR5cGUgaWYgaW50ZWdyYXRlZCwgaXMgbnVsbCBpZiBpdCBpcyBwb3NzaWJsZSB0byBjb3B5IHBhcmVudCBmcm9tIGxlZnQgb3IgcmlnaHQsIGlzIElEIGJlZm9yZSBpbnRlZ3JhdGlvbiB0byBzZWFyY2ggZm9yIGl0LlxuICAgKiBAcGFyYW0ge3N0cmluZyB8IG51bGx9IHBhcmVudFN1YlxuICAgKiBAcGFyYW0ge0Fic3RyYWN0Q29udGVudH0gY29udGVudFxuICAgKi9cbiAgY29uc3RydWN0b3IgKGlkLCBsZWZ0LCBvcmlnaW4sIHJpZ2h0LCByaWdodE9yaWdpbiwgcGFyZW50LCBwYXJlbnRTdWIsIGNvbnRlbnQpIHtcbiAgICBzdXBlcihpZCwgY29udGVudC5nZXRMZW5ndGgoKSlcbiAgICAvKipcbiAgICAgKiBUaGUgaXRlbSB0aGF0IHdhcyBvcmlnaW5hbGx5IHRvIHRoZSBsZWZ0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMub3JpZ2luID0gb3JpZ2luXG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIGxlZnQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJdGVtIHwgbnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmxlZnQgPSBsZWZ0XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCBpcyBjdXJyZW50bHkgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgaXRlbS5cbiAgICAgKiBAdHlwZSB7SXRlbSB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0XG4gICAgLyoqXG4gICAgICogVGhlIGl0ZW0gdGhhdCB3YXMgb3JpZ2luYWxseSB0byB0aGUgcmlnaHQgb2YgdGhpcyBpdGVtLlxuICAgICAqIEB0eXBlIHtJRCB8IG51bGx9XG4gICAgICovXG4gICAgdGhpcy5yaWdodE9yaWdpbiA9IHJpZ2h0T3JpZ2luXG4gICAgLyoqXG4gICAgICogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fElEfG51bGx9XG4gICAgICovXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgcGFyZW50IHJlZmVycyB0byB0aGlzIGl0ZW0gd2l0aCBzb21lIGtpbmQgb2Yga2V5IChlLmcuIFlNYXAsIHRoZVxuICAgICAqIGtleSBpcyBzcGVjaWZpZWQgaGVyZS4gVGhlIGtleSBpcyB0aGVuIHVzZWQgdG8gcmVmZXIgdG8gdGhlIGxpc3QgaW4gd2hpY2hcbiAgICAgKiB0byBpbnNlcnQgdGhpcyBpdGVtLiBJZiBgcGFyZW50U3ViID0gbnVsbGAgdHlwZS5fc3RhcnQgaXMgdGhlIGxpc3QgaW5cbiAgICAgKiB3aGljaCB0byBpbnNlcnQgdG8uIE90aGVyd2lzZSBpdCBpcyBgcGFyZW50Ll9tYXBgLlxuICAgICAqIEB0eXBlIHtTdHJpbmcgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucGFyZW50U3ViID0gcGFyZW50U3ViXG4gICAgLyoqXG4gICAgICogSWYgdGhpcyB0eXBlJ3MgZWZmZWN0IGlzIHJlZG9uZSB0aGlzIHR5cGUgcmVmZXJzIHRvIHRoZSB0eXBlIHRoYXQgdW5kaWRcbiAgICAgKiB0aGlzIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7SUQgfCBudWxsfVxuICAgICAqL1xuICAgIHRoaXMucmVkb25lID0gbnVsbFxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtBYnN0cmFjdENvbnRlbnR9XG4gICAgICovXG4gICAgdGhpcy5jb250ZW50ID0gY29udGVudFxuICAgIC8qKlxuICAgICAqIGJpdDE6IGtlZXBcbiAgICAgKiBiaXQyOiBjb3VudGFibGVcbiAgICAgKiBiaXQzOiBkZWxldGVkXG4gICAgICogYml0NDogbWFyayAtIG1hcmsgbm9kZSBhcyBmYXN0LXNlYXJjaC1tYXJrZXJcbiAgICAgKiBAdHlwZSB7bnVtYmVyfSBieXRlXG4gICAgICovXG4gICAgdGhpcy5pbmZvID0gdGhpcy5jb250ZW50LmlzQ291bnRhYmxlKCkgPyBiaW5hcnkuQklUMiA6IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHVzZWQgdG8gbWFyayB0aGUgaXRlbSBhcyBhbiBpbmRleGVkIGZhc3Qtc2VhcmNoIG1hcmtlclxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIHNldCBtYXJrZXIgKGlzTWFya2VkKSB7XG4gICAgaWYgKCgodGhpcy5pbmZvICYgYmluYXJ5LkJJVDQpID4gMCkgIT09IGlzTWFya2VkKSB7XG4gICAgICB0aGlzLmluZm8gXj0gYmluYXJ5LkJJVDRcbiAgICB9XG4gIH1cblxuICBnZXQgbWFya2VyICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQ0KSA+IDBcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiB0cnVlLCBkbyBub3QgZ2FyYmFnZSBjb2xsZWN0IHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBrZWVwICgpIHtcbiAgICByZXR1cm4gKHRoaXMuaW5mbyAmIGJpbmFyeS5CSVQxKSA+IDBcbiAgfVxuXG4gIHNldCBrZWVwIChkb0tlZXApIHtcbiAgICBpZiAodGhpcy5rZWVwICE9PSBkb0tlZXApIHtcbiAgICAgIHRoaXMuaW5mbyBePSBiaW5hcnkuQklUMVxuICAgIH1cbiAgfVxuXG4gIGdldCBjb3VudGFibGUgKCkge1xuICAgIHJldHVybiAodGhpcy5pbmZvICYgYmluYXJ5LkJJVDIpID4gMFxuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyBpdGVtIHdhcyBkZWxldGVkIG9yIG5vdC5cbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgZGVsZXRlZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLmluZm8gJiBiaW5hcnkuQklUMykgPiAwXG4gIH1cblxuICBzZXQgZGVsZXRlZCAoZG9EZWxldGUpIHtcbiAgICBpZiAodGhpcy5kZWxldGVkICE9PSBkb0RlbGV0ZSkge1xuICAgICAgdGhpcy5pbmZvIF49IGJpbmFyeS5CSVQzXG4gICAgfVxuICB9XG5cbiAgbWFya0RlbGV0ZWQgKCkge1xuICAgIHRoaXMuaW5mbyB8PSBiaW5hcnkuQklUM1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgY3JlYXRvciBjbGllbnRJRCBvZiB0aGUgbWlzc2luZyBvcCBvciBkZWZpbmUgbWlzc2luZyBpdGVtcyBhbmQgcmV0dXJuIG51bGwuXG4gICAqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICBpZiAodGhpcy5vcmlnaW4gJiYgdGhpcy5vcmlnaW4uY2xpZW50ICE9PSB0aGlzLmlkLmNsaWVudCAmJiB0aGlzLm9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5vcmlnaW4uY2xpZW50KSkge1xuICAgICAgcmV0dXJuIHRoaXMub3JpZ2luLmNsaWVudFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbiAmJiB0aGlzLnJpZ2h0T3JpZ2luLmNsaWVudCAhPT0gdGhpcy5pZC5jbGllbnQgJiYgdGhpcy5yaWdodE9yaWdpbi5jbG9jayA+PSBnZXRTdGF0ZShzdG9yZSwgdGhpcy5yaWdodE9yaWdpbi5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5yaWdodE9yaWdpbi5jbGllbnRcbiAgICB9XG4gICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCAmJiB0aGlzLmlkLmNsaWVudCAhPT0gdGhpcy5wYXJlbnQuY2xpZW50ICYmIHRoaXMucGFyZW50LmNsb2NrID49IGdldFN0YXRlKHN0b3JlLCB0aGlzLnBhcmVudC5jbGllbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQuY2xpZW50XG4gICAgfVxuXG4gICAgLy8gV2UgaGF2ZSBhbGwgbWlzc2luZyBpZHMsIG5vdyBmaW5kIHRoZSBpdGVtc1xuXG4gICAgaWYgKHRoaXMub3JpZ2luKSB7XG4gICAgICB0aGlzLmxlZnQgPSBnZXRJdGVtQ2xlYW5FbmQodHJhbnNhY3Rpb24sIHN0b3JlLCB0aGlzLm9yaWdpbilcbiAgICAgIHRoaXMub3JpZ2luID0gdGhpcy5sZWZ0Lmxhc3RJZFxuICAgIH1cbiAgICBpZiAodGhpcy5yaWdodE9yaWdpbikge1xuICAgICAgdGhpcy5yaWdodCA9IGdldEl0ZW1DbGVhblN0YXJ0KHRyYW5zYWN0aW9uLCB0aGlzLnJpZ2h0T3JpZ2luKVxuICAgICAgdGhpcy5yaWdodE9yaWdpbiA9IHRoaXMucmlnaHQuaWRcbiAgICB9XG4gICAgaWYgKCh0aGlzLmxlZnQgJiYgdGhpcy5sZWZ0LmNvbnN0cnVjdG9yID09PSBHQykgfHwgKHRoaXMucmlnaHQgJiYgdGhpcy5yaWdodC5jb25zdHJ1Y3RvciA9PT0gR0MpKSB7XG4gICAgICB0aGlzLnBhcmVudCA9IG51bGxcbiAgICB9IGVsc2UgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgLy8gb25seSBzZXQgcGFyZW50IGlmIHRoaXMgc2hvdWxkbid0IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICBpZiAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5jb25zdHJ1Y3RvciA9PT0gSXRlbSkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHRoaXMubGVmdC5wYXJlbnRcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLmxlZnQucGFyZW50U3ViXG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yaWdodCAmJiB0aGlzLnJpZ2h0LmNvbnN0cnVjdG9yID09PSBJdGVtKSB7XG4gICAgICAgIHRoaXMucGFyZW50ID0gdGhpcy5yaWdodC5wYXJlbnRcbiAgICAgICAgdGhpcy5wYXJlbnRTdWIgPSB0aGlzLnJpZ2h0LnBhcmVudFN1YlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQuY29uc3RydWN0b3IgPT09IElEKSB7XG4gICAgICBjb25zdCBwYXJlbnRJdGVtID0gZ2V0SXRlbShzdG9yZSwgdGhpcy5wYXJlbnQpXG4gICAgICBpZiAocGFyZW50SXRlbS5jb25zdHJ1Y3RvciA9PT0gR0MpIHtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBudWxsXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcmVudCA9IC8qKiBAdHlwZSB7Q29udGVudFR5cGV9ICovIChwYXJlbnRJdGVtLmNvbnRlbnQpLnR5cGVcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICBpbnRlZ3JhdGUgKHRyYW5zYWN0aW9uLCBvZmZzZXQpIHtcbiAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgdGhpcy5pZC5jbG9jayArPSBvZmZzZXRcbiAgICAgIHRoaXMubGVmdCA9IGdldEl0ZW1DbGVhbkVuZCh0cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBjcmVhdGVJRCh0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jayAtIDEpKVxuICAgICAgdGhpcy5vcmlnaW4gPSB0aGlzLmxlZnQubGFzdElkXG4gICAgICB0aGlzLmNvbnRlbnQgPSB0aGlzLmNvbnRlbnQuc3BsaWNlKG9mZnNldClcbiAgICAgIHRoaXMubGVuZ3RoIC09IG9mZnNldFxuICAgIH1cblxuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKCghdGhpcy5sZWZ0ICYmICghdGhpcy5yaWdodCB8fCB0aGlzLnJpZ2h0LmxlZnQgIT09IG51bGwpKSB8fCAodGhpcy5sZWZ0ICYmIHRoaXMubGVmdC5yaWdodCAhPT0gdGhpcy5yaWdodCkpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtJdGVtfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbGVmdCA9IHRoaXMubGVmdFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7SXRlbXxudWxsfVxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG9cbiAgICAgICAgLy8gc2V0IG8gdG8gdGhlIGZpcnN0IGNvbmZsaWN0aW5nIGl0ZW1cbiAgICAgICAgaWYgKGxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICBvID0gbGVmdC5yaWdodFxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50U3ViICE9PSBudWxsKSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX21hcC5nZXQodGhpcy5wYXJlbnRTdWIpIHx8IG51bGxcbiAgICAgICAgICB3aGlsZSAobyAhPT0gbnVsbCAmJiBvLmxlZnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG8gPSBvLmxlZnRcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3N0YXJ0XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogdXNlIHNvbWV0aGluZyBsaWtlIERlbGV0ZVNldCBoZXJlIChhIHRyZWUgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYmVzdClcbiAgICAgICAgLy8gQHRvZG8gdXNlIGdsb2JhbCBzZXQgZGVmaW5pdGlvbnNcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtTZXQ8SXRlbT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25mbGljdGluZ0l0ZW1zID0gbmV3IFNldCgpXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZSB7U2V0PEl0ZW0+fVxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaXRlbXNCZWZvcmVPcmlnaW4gPSBuZXcgU2V0KClcbiAgICAgICAgLy8gTGV0IGMgaW4gY29uZmxpY3RpbmdJdGVtcywgYiBpbiBpdGVtc0JlZm9yZU9yaWdpblxuICAgICAgICAvLyAqKip7b3JpZ2lufWJiYmJ7dGhpc317YyxifXtjLGJ9e299KioqXG4gICAgICAgIC8vIE5vdGUgdGhhdCBjb25mbGljdGluZ0l0ZW1zIGlzIGEgc3Vic2V0IG9mIGl0ZW1zQmVmb3JlT3JpZ2luXG4gICAgICAgIHdoaWxlIChvICE9PSBudWxsICYmIG8gIT09IHRoaXMucmlnaHQpIHtcbiAgICAgICAgICBpdGVtc0JlZm9yZU9yaWdpbi5hZGQobylcbiAgICAgICAgICBjb25mbGljdGluZ0l0ZW1zLmFkZChvKVxuICAgICAgICAgIGlmIChjb21wYXJlSURzKHRoaXMub3JpZ2luLCBvLm9yaWdpbikpIHtcbiAgICAgICAgICAgIC8vIGNhc2UgMVxuICAgICAgICAgICAgaWYgKG8uaWQuY2xpZW50IDwgdGhpcy5pZC5jbGllbnQpIHtcbiAgICAgICAgICAgICAgbGVmdCA9IG9cbiAgICAgICAgICAgICAgY29uZmxpY3RpbmdJdGVtcy5jbGVhcigpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvbXBhcmVJRHModGhpcy5yaWdodE9yaWdpbiwgby5yaWdodE9yaWdpbikpIHtcbiAgICAgICAgICAgICAgLy8gdGhpcyBhbmQgbyBhcmUgY29uZmxpY3RpbmcgYW5kIHBvaW50IHRvIHRoZSBzYW1lIGludGVncmF0aW9uIHBvaW50cy4gVGhlIGlkIGRlY2lkZXMgd2hpY2ggaXRlbSBjb21lcyBmaXJzdC5cbiAgICAgICAgICAgICAgLy8gU2luY2UgdGhpcyBpcyB0byB0aGUgbGVmdCBvZiBvLCB3ZSBjYW4gYnJlYWsgaGVyZVxuICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfSAvLyBlbHNlLCBvIG1pZ2h0IGJlIGludGVncmF0ZWQgYmVmb3JlIGFuIGl0ZW0gdGhhdCB0aGlzIGNvbmZsaWN0cyB3aXRoLiBJZiBzbywgd2Ugd2lsbCBmaW5kIGl0IGluIHRoZSBuZXh0IGl0ZXJhdGlvbnNcbiAgICAgICAgICB9IGVsc2UgaWYgKG8ub3JpZ2luICE9PSBudWxsICYmIGl0ZW1zQmVmb3JlT3JpZ2luLmhhcyhnZXRJdGVtKHRyYW5zYWN0aW9uLmRvYy5zdG9yZSwgby5vcmlnaW4pKSkgeyAvLyB1c2UgZ2V0SXRlbSBpbnN0ZWFkIG9mIGdldEl0ZW1DbGVhbkVuZCBiZWNhdXNlIHdlIGRvbid0IHdhbnQgLyBuZWVkIHRvIHNwbGl0IGl0ZW1zLlxuICAgICAgICAgICAgLy8gY2FzZSAyXG4gICAgICAgICAgICBpZiAoIWNvbmZsaWN0aW5nSXRlbXMuaGFzKGdldEl0ZW0odHJhbnNhY3Rpb24uZG9jLnN0b3JlLCBvLm9yaWdpbikpKSB7XG4gICAgICAgICAgICAgIGxlZnQgPSBvXG4gICAgICAgICAgICAgIGNvbmZsaWN0aW5nSXRlbXMuY2xlYXIoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBicmVha1xuICAgICAgICAgIH1cbiAgICAgICAgICBvID0gby5yaWdodFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnRcbiAgICAgIH1cbiAgICAgIC8vIHJlY29ubmVjdCBsZWZ0L3JpZ2h0ICsgdXBkYXRlIHBhcmVudCBtYXAvc3RhcnQgaWYgbmVjZXNzYXJ5XG4gICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gdGhpcy5sZWZ0LnJpZ2h0XG4gICAgICAgIHRoaXMucmlnaHQgPSByaWdodFxuICAgICAgICB0aGlzLmxlZnQucmlnaHQgPSB0aGlzXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgclxuICAgICAgICBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbWFwLmdldCh0aGlzLnBhcmVudFN1YikgfHwgbnVsbFxuICAgICAgICAgIHdoaWxlIChyICE9PSBudWxsICYmIHIubGVmdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgciA9IHIubGVmdFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnRcbiAgICAgICAgICA7LyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fc3RhcnQgPSB0aGlzXG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yaWdodCA9IHJcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXNcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnRTdWIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gc2V0IGFzIGN1cnJlbnQgcGFyZW50IHZhbHVlIGlmIHJpZ2h0ID09PSBudWxsIGFuZCB0aGlzIGlzIHBhcmVudFN1YlxuICAgICAgICAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9tYXAuc2V0KHRoaXMucGFyZW50U3ViLCB0aGlzKVxuICAgICAgICBpZiAodGhpcy5sZWZ0ICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY3VycmVudCBhdHRyaWJ1dGUgdmFsdWUgb2YgcGFyZW50LiBkZWxldGUgcmlnaHRcbiAgICAgICAgICB0aGlzLmxlZnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBhZGp1c3QgbGVuZ3RoIG9mIHBhcmVudFxuICAgICAgaWYgKHRoaXMucGFyZW50U3ViID09PSBudWxsICYmIHRoaXMuY291bnRhYmxlICYmICF0aGlzLmRlbGV0ZWQpIHtcbiAgICAgICAgLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5fbGVuZ3RoICs9IHRoaXMubGVuZ3RoXG4gICAgICB9XG4gICAgICBhZGRTdHJ1Y3QodHJhbnNhY3Rpb24uZG9jLnN0b3JlLCB0aGlzKVxuICAgICAgdGhpcy5jb250ZW50LmludGVncmF0ZSh0cmFuc2FjdGlvbiwgdGhpcylcbiAgICAgIC8vIGFkZCBwYXJlbnQgdG8gdHJhbnNhY3Rpb24uY2hhbmdlZFxuICAgICAgYWRkQ2hhbmdlZFR5cGVUb1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLCB0aGlzLnBhcmVudFN1YilcbiAgICAgIGlmICgoLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KS5faXRlbSAhPT0gbnVsbCAmJiAvKiogQHR5cGUge0Fic3RyYWN0VHlwZTxhbnk+fSAqLyAodGhpcy5wYXJlbnQpLl9pdGVtLmRlbGV0ZWQpIHx8ICh0aGlzLnBhcmVudFN1YiAhPT0gbnVsbCAmJiB0aGlzLnJpZ2h0ICE9PSBudWxsKSkge1xuICAgICAgICAvLyBkZWxldGUgaWYgcGFyZW50IGlzIGRlbGV0ZWQgb3IgaWYgdGhpcyBpcyBub3QgdGhlIGN1cnJlbnQgYXR0cmlidXRlIHZhbHVlIG9mIHBhcmVudFxuICAgICAgICB0aGlzLmRlbGV0ZSh0cmFuc2FjdGlvbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcGFyZW50IGlzIG5vdCBkZWZpbmVkLiBJbnRlZ3JhdGUgR0Mgc3RydWN0IGluc3RlYWRcbiAgICAgIG5ldyBHQyh0aGlzLmlkLCB0aGlzLmxlbmd0aCkuaW50ZWdyYXRlKHRyYW5zYWN0aW9uLCAwKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuZXh0IG5vbi1kZWxldGVkIGl0ZW1cbiAgICovXG4gIGdldCBuZXh0ICgpIHtcbiAgICBsZXQgbiA9IHRoaXMucmlnaHRcbiAgICB3aGlsZSAobiAhPT0gbnVsbCAmJiBuLmRlbGV0ZWQpIHtcbiAgICAgIG4gPSBuLnJpZ2h0XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJldmlvdXMgbm9uLWRlbGV0ZWQgaXRlbVxuICAgKi9cbiAgZ2V0IHByZXYgKCkge1xuICAgIGxldCBuID0gdGhpcy5sZWZ0XG4gICAgd2hpbGUgKG4gIT09IG51bGwgJiYgbi5kZWxldGVkKSB7XG4gICAgICBuID0gbi5sZWZ0XG4gICAgfVxuICAgIHJldHVybiBuXG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIGxhc3QgY29udGVudCBhZGRyZXNzIG9mIHRoaXMgSXRlbS5cbiAgICovXG4gIGdldCBsYXN0SWQgKCkge1xuICAgIC8vIGFsbG9jYXRpbmcgaWRzIGlzIHByZXR0eSBjb3N0bHkgYmVjYXVzZSBvZiB0aGUgYW1vdW50IG9mIGlkcyBjcmVhdGVkLCBzbyB3ZSB0cnkgdG8gcmV1c2Ugd2hlbmV2ZXIgcG9zc2libGVcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgPyB0aGlzLmlkIDogY3JlYXRlSUQodGhpcy5pZC5jbGllbnQsIHRoaXMuaWQuY2xvY2sgKyB0aGlzLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvKipcbiAgICogVHJ5IHRvIG1lcmdlIHR3byBpdGVtc1xuICAgKlxuICAgKiBAcGFyYW0ge0l0ZW19IHJpZ2h0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBtZXJnZVdpdGggKHJpZ2h0KSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5jb25zdHJ1Y3RvciA9PT0gcmlnaHQuY29uc3RydWN0b3IgJiZcbiAgICAgIGNvbXBhcmVJRHMocmlnaHQub3JpZ2luLCB0aGlzLmxhc3RJZCkgJiZcbiAgICAgIHRoaXMucmlnaHQgPT09IHJpZ2h0ICYmXG4gICAgICBjb21wYXJlSURzKHRoaXMucmlnaHRPcmlnaW4sIHJpZ2h0LnJpZ2h0T3JpZ2luKSAmJlxuICAgICAgdGhpcy5pZC5jbGllbnQgPT09IHJpZ2h0LmlkLmNsaWVudCAmJlxuICAgICAgdGhpcy5pZC5jbG9jayArIHRoaXMubGVuZ3RoID09PSByaWdodC5pZC5jbG9jayAmJlxuICAgICAgdGhpcy5kZWxldGVkID09PSByaWdodC5kZWxldGVkICYmXG4gICAgICB0aGlzLnJlZG9uZSA9PT0gbnVsbCAmJlxuICAgICAgcmlnaHQucmVkb25lID09PSBudWxsICYmXG4gICAgICB0aGlzLmNvbnRlbnQuY29uc3RydWN0b3IgPT09IHJpZ2h0LmNvbnRlbnQuY29uc3RydWN0b3IgJiZcbiAgICAgIHRoaXMuY29udGVudC5tZXJnZVdpdGgocmlnaHQuY29udGVudClcbiAgICApIHtcbiAgICAgIGNvbnN0IHNlYXJjaE1hcmtlciA9IC8qKiBAdHlwZSB7QWJzdHJhY3RUeXBlPGFueT59ICovICh0aGlzLnBhcmVudCkuX3NlYXJjaE1hcmtlclxuICAgICAgaWYgKHNlYXJjaE1hcmtlcikge1xuICAgICAgICBzZWFyY2hNYXJrZXIuZm9yRWFjaChtYXJrZXIgPT4ge1xuICAgICAgICAgIGlmIChtYXJrZXIucCA9PT0gcmlnaHQpIHtcbiAgICAgICAgICAgIC8vIHJpZ2h0IGlzIGdvaW5nIHRvIGJlIFwiZm9yZ290dGVuXCIgc28gd2UgbmVlZCB0byB1cGRhdGUgdGhlIG1hcmtlclxuICAgICAgICAgICAgbWFya2VyLnAgPSB0aGlzXG4gICAgICAgICAgICAvLyBhZGp1c3QgbWFya2VyIGluZGV4XG4gICAgICAgICAgICBpZiAoIXRoaXMuZGVsZXRlZCAmJiB0aGlzLmNvdW50YWJsZSkge1xuICAgICAgICAgICAgICBtYXJrZXIuaW5kZXggLT0gdGhpcy5sZW5ndGhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICBpZiAocmlnaHQua2VlcCkge1xuICAgICAgICB0aGlzLmtlZXAgPSB0cnVlXG4gICAgICB9XG4gICAgICB0aGlzLnJpZ2h0ID0gcmlnaHQucmlnaHRcbiAgICAgIGlmICh0aGlzLnJpZ2h0ICE9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmlnaHQubGVmdCA9IHRoaXNcbiAgICAgIH1cbiAgICAgIHRoaXMubGVuZ3RoICs9IHJpZ2h0Lmxlbmd0aFxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvKipcbiAgICogTWFyayB0aGlzIEl0ZW0gYXMgZGVsZXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICovXG4gIGRlbGV0ZSAodHJhbnNhY3Rpb24pIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KVxuICAgICAgLy8gYWRqdXN0IHRoZSBsZW5ndGggb2YgcGFyZW50XG4gICAgICBpZiAodGhpcy5jb3VudGFibGUgJiYgdGhpcy5wYXJlbnRTdWIgPT09IG51bGwpIHtcbiAgICAgICAgcGFyZW50Ll9sZW5ndGggLT0gdGhpcy5sZW5ndGhcbiAgICAgIH1cbiAgICAgIHRoaXMubWFya0RlbGV0ZWQoKVxuICAgICAgYWRkVG9EZWxldGVTZXQodHJhbnNhY3Rpb24uZGVsZXRlU2V0LCB0aGlzLmlkLmNsaWVudCwgdGhpcy5pZC5jbG9jaywgdGhpcy5sZW5ndGgpXG4gICAgICBhZGRDaGFuZ2VkVHlwZVRvVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIHBhcmVudCwgdGhpcy5wYXJlbnRTdWIpXG4gICAgICB0aGlzLmNvbnRlbnQuZGVsZXRlKHRyYW5zYWN0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cnVjdFN0b3JlfSBzdG9yZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmVudEdDZFxuICAgKi9cbiAgZ2MgKHN0b3JlLCBwYXJlbnRHQ2QpIHtcbiAgICBpZiAoIXRoaXMuZGVsZXRlZCkge1xuICAgICAgdGhyb3cgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgIH1cbiAgICB0aGlzLmNvbnRlbnQuZ2Moc3RvcmUpXG4gICAgaWYgKHBhcmVudEdDZCkge1xuICAgICAgcmVwbGFjZVN0cnVjdChzdG9yZSwgdGhpcywgbmV3IEdDKHRoaXMuaWQsIHRoaXMubGVuZ3RoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENvbnRlbnREZWxldGVkKHRoaXMubGVuZ3RoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFuc2Zvcm0gdGhlIHByb3BlcnRpZXMgb2YgdGhpcyB0eXBlIHRvIGJpbmFyeSBhbmQgd3JpdGUgaXQgdG8gYW5cbiAgICogQmluYXJ5RW5jb2Rlci5cbiAgICpcbiAgICogVGhpcyBpcyBjYWxsZWQgd2hlbiB0aGlzIEl0ZW0gaXMgc2VudCB0byBhIHJlbW90ZSBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlciBUaGUgZW5jb2RlciB0byB3cml0ZSBkYXRhIHRvLlxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgY29uc3Qgb3JpZ2luID0gb2Zmc2V0ID4gMCA/IGNyZWF0ZUlEKHRoaXMuaWQuY2xpZW50LCB0aGlzLmlkLmNsb2NrICsgb2Zmc2V0IC0gMSkgOiB0aGlzLm9yaWdpblxuICAgIGNvbnN0IHJpZ2h0T3JpZ2luID0gdGhpcy5yaWdodE9yaWdpblxuICAgIGNvbnN0IHBhcmVudFN1YiA9IHRoaXMucGFyZW50U3ViXG4gICAgY29uc3QgaW5mbyA9ICh0aGlzLmNvbnRlbnQuZ2V0UmVmKCkgJiBiaW5hcnkuQklUUzUpIHxcbiAgICAgIChvcmlnaW4gPT09IG51bGwgPyAwIDogYmluYXJ5LkJJVDgpIHwgLy8gb3JpZ2luIGlzIGRlZmluZWRcbiAgICAgIChyaWdodE9yaWdpbiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNykgfCAvLyByaWdodCBvcmlnaW4gaXMgZGVmaW5lZFxuICAgICAgKHBhcmVudFN1YiA9PT0gbnVsbCA/IDAgOiBiaW5hcnkuQklUNikgLy8gcGFyZW50U3ViIGlzIG5vbi1udWxsXG4gICAgZW5jb2Rlci53cml0ZUluZm8oaW5mbylcbiAgICBpZiAob3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlTGVmdElEKG9yaWdpbilcbiAgICB9XG4gICAgaWYgKHJpZ2h0T3JpZ2luICE9PSBudWxsKSB7XG4gICAgICBlbmNvZGVyLndyaXRlUmlnaHRJRChyaWdodE9yaWdpbilcbiAgICB9XG4gICAgaWYgKG9yaWdpbiA9PT0gbnVsbCAmJiByaWdodE9yaWdpbiA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gLyoqIEB0eXBlIHtBYnN0cmFjdFR5cGU8YW55Pn0gKi8gKHRoaXMucGFyZW50KVxuICAgICAgaWYgKHBhcmVudC5faXRlbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudEl0ZW0gPSBwYXJlbnQuX2l0ZW1cbiAgICAgICAgaWYgKHBhcmVudEl0ZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBwYXJlbnQgdHlwZSBvbiB5Ll9tYXBcbiAgICAgICAgICAvLyBmaW5kIHRoZSBjb3JyZWN0IGtleVxuICAgICAgICAgIGNvbnN0IHlrZXkgPSBmaW5kUm9vdFR5cGVLZXkocGFyZW50KVxuICAgICAgICAgIGVuY29kZXIud3JpdGVQYXJlbnRJbmZvKHRydWUpIC8vIHdyaXRlIHBhcmVudFlLZXlcbiAgICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHlrZXkpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8oZmFsc2UpIC8vIHdyaXRlIHBhcmVudCBpZFxuICAgICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50SXRlbS5pZClcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJlbnQuY29uc3RydWN0b3IgPT09IFN0cmluZykgeyAvLyB0aGlzIGVkZ2UgY2FzZSB3YXMgYWRkZWQgYnkgZGlmZmVyZW50aWFsIHVwZGF0ZXNcbiAgICAgICAgZW5jb2Rlci53cml0ZVBhcmVudEluZm8odHJ1ZSkgLy8gd3JpdGUgcGFyZW50WUtleVxuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudClcbiAgICAgIH0gZWxzZSBpZiAocGFyZW50LmNvbnN0cnVjdG9yID09PSBJRCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlUGFyZW50SW5mbyhmYWxzZSkgLy8gd3JpdGUgcGFyZW50IGlkXG4gICAgICAgIGVuY29kZXIud3JpdGVMZWZ0SUQocGFyZW50KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IudW5leHBlY3RlZENhc2UoKVxuICAgICAgfVxuICAgICAgaWYgKHBhcmVudFN1YiAhPT0gbnVsbCkge1xuICAgICAgICBlbmNvZGVyLndyaXRlU3RyaW5nKHBhcmVudFN1YilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250ZW50LndyaXRlKGVuY29kZXIsIG9mZnNldClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyfSBkZWNvZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gaW5mb1xuICovXG5leHBvcnQgY29uc3QgcmVhZEl0ZW1Db250ZW50ID0gKGRlY29kZXIsIGluZm8pID0+IGNvbnRlbnRSZWZzW2luZm8gJiBiaW5hcnkuQklUUzVdKGRlY29kZXIpXG5cbi8qKlxuICogQSBsb29rdXAgbWFwIGZvciByZWFkaW5nIEl0ZW0gY29udGVudC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8ZnVuY3Rpb24oVXBkYXRlRGVjb2RlclYxIHwgVXBkYXRlRGVjb2RlclYyKTpBYnN0cmFjdENvbnRlbnQ+fVxuICovXG5leHBvcnQgY29uc3QgY29udGVudFJlZnMgPSBbXG4gICgpID0+IHsgZXJyb3IudW5leHBlY3RlZENhc2UoKSB9LCAvLyBHQyBpcyBub3QgSXRlbUNvbnRlbnRcbiAgcmVhZENvbnRlbnREZWxldGVkLCAvLyAxXG4gIHJlYWRDb250ZW50SlNPTiwgLy8gMlxuICByZWFkQ29udGVudEJpbmFyeSwgLy8gM1xuICByZWFkQ29udGVudFN0cmluZywgLy8gNFxuICByZWFkQ29udGVudEVtYmVkLCAvLyA1XG4gIHJlYWRDb250ZW50Rm9ybWF0LCAvLyA2XG4gIHJlYWRDb250ZW50VHlwZSwgLy8gN1xuICByZWFkQ29udGVudEFueSwgLy8gOFxuICByZWFkQ29udGVudERvYywgLy8gOVxuICAoKSA9PiB7IGVycm9yLnVuZXhwZWN0ZWRDYXNlKCkgfSAvLyAxMCAtIFNraXAgaXMgbm90IEl0ZW1Db250ZW50XG5dXG5cbi8qKlxuICogRG8gbm90IGltcGxlbWVudCB0aGlzIGNsYXNzIVxuICovXG5leHBvcnQgY2xhc3MgQWJzdHJhY3RDb250ZW50IHtcbiAgLyoqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldExlbmd0aCAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QXJyYXk8YW55Pn1cbiAgICovXG4gIGdldENvbnRlbnQgKCkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIFNob3VsZCByZXR1cm4gZmFsc2UgaWYgdGhpcyBJdGVtIGlzIHNvbWUga2luZCBvZiBtZXRhIGluZm9ybWF0aW9uXG4gICAqIChlLmcuIGZvcm1hdCBpbmZvcm1hdGlvbikuXG4gICAqXG4gICAqICogV2hldGhlciB0aGlzIEl0ZW0gc2hvdWxkIGJlIGFkZHJlc3NhYmxlIHZpYSBgeWFycmF5LmdldChpKWBcbiAgICogKiBXaGV0aGVyIHRoaXMgSXRlbSBzaG91bGQgYmUgY291bnRlZCB3aGVuIGNvbXB1dGluZyB5YXJyYXkubGVuZ3RoXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqL1xuICBpc0NvdW50YWJsZSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7QWJzdHJhY3RDb250ZW50fVxuICAgKi9cbiAgY29weSAoKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IF9vZmZzZXRcbiAgICogQHJldHVybiB7QWJzdHJhY3RDb250ZW50fVxuICAgKi9cbiAgc3BsaWNlIChfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBYnN0cmFjdENvbnRlbnR9IF9yaWdodFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgbWVyZ2VXaXRoIChfcmlnaHQpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSBfdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtJdGVtfSBfaXRlbVxuICAgKi9cbiAgaW50ZWdyYXRlIChfdHJhbnNhY3Rpb24sIF9pdGVtKSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtUcmFuc2FjdGlvbn0gX3RyYW5zYWN0aW9uXG4gICAqL1xuICBkZWxldGUgKF90cmFuc2FjdGlvbikge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IF9zdG9yZVxuICAgKi9cbiAgZ2MgKF9zdG9yZSkge1xuICAgIHRocm93IGVycm9yLm1ldGhvZFVuaW1wbGVtZW50ZWQoKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VXBkYXRlRW5jb2RlclYxIHwgVXBkYXRlRW5jb2RlclYyfSBfZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gX29mZnNldFxuICAgKi9cbiAgd3JpdGUgKF9lbmNvZGVyLCBfb2Zmc2V0KSB7XG4gICAgdGhyb3cgZXJyb3IubWV0aG9kVW5pbXBsZW1lbnRlZCgpXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgZ2V0UmVmICgpIHtcbiAgICB0aHJvdyBlcnJvci5tZXRob2RVbmltcGxlbWVudGVkKClcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIEFic3RyYWN0U3RydWN0LFxuICBVcGRhdGVFbmNvZGVyVjEsIFVwZGF0ZUVuY29kZXJWMiwgU3RydWN0U3RvcmUsIFRyYW5zYWN0aW9uLCBJRCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG59IGZyb20gJy4uL2ludGVybmFscy5qcydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJ2xpYjAvZXJyb3InXG5pbXBvcnQgKiBhcyBlbmNvZGluZyBmcm9tICdsaWIwL2VuY29kaW5nJ1xuXG5leHBvcnQgY29uc3Qgc3RydWN0U2tpcFJlZk51bWJlciA9IDEwXG5cbi8qKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFNraXAgZXh0ZW5kcyBBYnN0cmFjdFN0cnVjdCB7XG4gIGdldCBkZWxldGVkICgpIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZGVsZXRlICgpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U2tpcH0gcmlnaHRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIG1lcmdlV2l0aCAocmlnaHQpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciAhPT0gcmlnaHQuY29uc3RydWN0b3IpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCArPSByaWdodC5sZW5ndGhcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRcbiAgICovXG4gIGludGVncmF0ZSAodHJhbnNhY3Rpb24sIG9mZnNldCkge1xuICAgIC8vIHNraXAgc3RydWN0cyBjYW5ub3QgYmUgaW50ZWdyYXRlZFxuICAgIGVycm9yLnVuZXhwZWN0ZWRDYXNlKClcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1VwZGF0ZUVuY29kZXJWMSB8IFVwZGF0ZUVuY29kZXJWMn0gZW5jb2RlclxuICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gICAqL1xuICB3cml0ZSAoZW5jb2Rlciwgb2Zmc2V0KSB7XG4gICAgZW5jb2Rlci53cml0ZUluZm8oc3RydWN0U2tpcFJlZk51bWJlcilcbiAgICAvLyB3cml0ZSBhcyBWYXJVaW50IGJlY2F1c2UgU2tpcHMgY2FuJ3QgbWFrZSB1c2Ugb2YgcHJlZGljdGFibGUgbGVuZ3RoLWVuY29kaW5nXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIucmVzdEVuY29kZXIsIHRoaXMubGVuZ3RoIC0gb2Zmc2V0KVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7VHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7U3RydWN0U3RvcmV9IHN0b3JlXG4gICAqIEByZXR1cm4ge251bGwgfCBudW1iZXJ9XG4gICAqL1xuICBnZXRNaXNzaW5nICh0cmFuc2FjdGlvbiwgc3RvcmUpIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG59XG4iLCAiLyoqIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG5leHBvcnQge1xuICBEb2MsXG4gIFRyYW5zYWN0aW9uLFxuICBZQXJyYXkgYXMgQXJyYXksXG4gIFlNYXAgYXMgTWFwLFxuICBZVGV4dCBhcyBUZXh0LFxuICBZWG1sVGV4dCBhcyBYbWxUZXh0LFxuICBZWG1sSG9vayBhcyBYbWxIb29rLFxuICBZWG1sRWxlbWVudCBhcyBYbWxFbGVtZW50LFxuICBZWG1sRnJhZ21lbnQgYXMgWG1sRnJhZ21lbnQsXG4gIFlYbWxFdmVudCxcbiAgWU1hcEV2ZW50LFxuICBZQXJyYXlFdmVudCxcbiAgWVRleHRFdmVudCxcbiAgWUV2ZW50LFxuICBJdGVtLFxuICBBYnN0cmFjdFN0cnVjdCxcbiAgR0MsXG4gIFNraXAsXG4gIENvbnRlbnRCaW5hcnksXG4gIENvbnRlbnREZWxldGVkLFxuICBDb250ZW50RG9jLFxuICBDb250ZW50RW1iZWQsXG4gIENvbnRlbnRGb3JtYXQsXG4gIENvbnRlbnRKU09OLFxuICBDb250ZW50QW55LFxuICBDb250ZW50U3RyaW5nLFxuICBDb250ZW50VHlwZSxcbiAgQWJzdHJhY3RUeXBlLFxuICBnZXRUeXBlQ2hpbGRyZW4sXG4gIGNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4LFxuICBjcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04sXG4gIGNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbixcbiAgY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zLFxuICBBYnNvbHV0ZVBvc2l0aW9uLFxuICBSZWxhdGl2ZVBvc2l0aW9uLFxuICBJRCxcbiAgY3JlYXRlSUQsXG4gIGNvbXBhcmVJRHMsXG4gIGdldFN0YXRlLFxuICBTbmFwc2hvdCxcbiAgY3JlYXRlU25hcHNob3QsXG4gIGNyZWF0ZURlbGV0ZVNldCxcbiAgY3JlYXRlRGVsZXRlU2V0RnJvbVN0cnVjdFN0b3JlLFxuICBjbGVhbnVwWVRleHRGb3JtYXR0aW5nLFxuICBzbmFwc2hvdCxcbiAgZW1wdHlTbmFwc2hvdCxcbiAgZmluZFJvb3RUeXBlS2V5LFxuICBmaW5kSW5kZXhTUyxcbiAgZ2V0SXRlbSxcbiAgdHlwZUxpc3RUb0FycmF5U25hcHNob3QsXG4gIHR5cGVNYXBHZXRTbmFwc2hvdCxcbiAgdHlwZU1hcEdldEFsbFNuYXBzaG90LFxuICBjcmVhdGVEb2NGcm9tU25hcHNob3QsXG4gIGl0ZXJhdGVEZWxldGVkU3RydWN0cyxcbiAgYXBwbHlVcGRhdGUsXG4gIGFwcGx5VXBkYXRlVjIsXG4gIHJlYWRVcGRhdGUsXG4gIHJlYWRVcGRhdGVWMixcbiAgZW5jb2RlU3RhdGVBc1VwZGF0ZSxcbiAgZW5jb2RlU3RhdGVBc1VwZGF0ZVYyLFxuICBlbmNvZGVTdGF0ZVZlY3RvcixcbiAgVW5kb01hbmFnZXIsXG4gIGRlY29kZVNuYXBzaG90LFxuICBlbmNvZGVTbmFwc2hvdCxcbiAgZGVjb2RlU25hcHNob3RWMixcbiAgZW5jb2RlU25hcHNob3RWMixcbiAgZGVjb2RlU3RhdGVWZWN0b3IsXG4gIGxvZ1VwZGF0ZSxcbiAgbG9nVXBkYXRlVjIsXG4gIGRlY29kZVVwZGF0ZSxcbiAgZGVjb2RlVXBkYXRlVjIsXG4gIHJlbGF0aXZlUG9zaXRpb25Ub0pTT04sXG4gIGlzRGVsZXRlZCxcbiAgaXNQYXJlbnRPZixcbiAgZXF1YWxTbmFwc2hvdHMsXG4gIFBlcm1hbmVudFVzZXJEYXRhLCAvLyBAVE9ETyBleHBlcmltZW50YWxcbiAgdHJ5R2MsXG4gIHRyYW5zYWN0LFxuICBBYnN0cmFjdENvbm5lY3RvcixcbiAgbG9nVHlwZSxcbiAgbWVyZ2VVcGRhdGVzLFxuICBtZXJnZVVwZGF0ZXNWMixcbiAgcGFyc2VVcGRhdGVNZXRhLFxuICBwYXJzZVVwZGF0ZU1ldGFWMixcbiAgZW5jb2RlU3RhdGVWZWN0b3JGcm9tVXBkYXRlLFxuICBlbmNvZGVTdGF0ZVZlY3RvckZyb21VcGRhdGVWMixcbiAgZW5jb2RlUmVsYXRpdmVQb3NpdGlvbixcbiAgZGVjb2RlUmVsYXRpdmVQb3NpdGlvbixcbiAgZGlmZlVwZGF0ZSxcbiAgZGlmZlVwZGF0ZVYyLFxuICBjb252ZXJ0VXBkYXRlRm9ybWF0VjFUb1YyLFxuICBjb252ZXJ0VXBkYXRlRm9ybWF0VjJUb1YxLFxuICBvYmZ1c2NhdGVVcGRhdGUsXG4gIG9iZnVzY2F0ZVVwZGF0ZVYyLFxuICBVcGRhdGVFbmNvZGVyVjEsXG4gIFVwZGF0ZUVuY29kZXJWMixcbiAgVXBkYXRlRGVjb2RlclYxLFxuICBVcGRhdGVEZWNvZGVyVjIsXG4gIGVxdWFsRGVsZXRlU2V0cyxcbiAgbWVyZ2VEZWxldGVTZXRzLFxuICBzbmFwc2hvdENvbnRhaW5zVXBkYXRlXG59IGZyb20gJy4vaW50ZXJuYWxzLmpzJ1xuXG5jb25zdCBnbG8gPSAvKiogQHR5cGUge2FueX0gKi8gKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJ1xuICA/IGdsb2JhbFRoaXNcbiAgOiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJ1xuICAgID8gd2luZG93XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIDogdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwgOiB7fSlcblxuY29uc3QgaW1wb3J0SWRlbnRpZmllciA9ICdfXyAkWUpTJCBfXydcblxuaWYgKGdsb1tpbXBvcnRJZGVudGlmaWVyXSA9PT0gdHJ1ZSkge1xuICAvKipcbiAgICogRGVhciByZWFkZXIgb2YgdGhpcyBtZXNzYWdlLiBQbGVhc2UgdGFrZSB0aGlzIHNlcmlvdXNseS5cbiAgICpcbiAgICogSWYgeW91IHNlZSB0aGlzIG1lc3NhZ2UsIG1ha2Ugc3VyZSB0aGF0IHlvdSBvbmx5IGltcG9ydCBvbmUgdmVyc2lvbiBvZiBZanMuIEluIG1hbnkgY2FzZXMsXG4gICAqIHlvdXIgcGFja2FnZSBtYW5hZ2VyIGluc3RhbGxzIHR3byB2ZXJzaW9ucyBvZiBZanMgdGhhdCBhcmUgdXNlZCBieSBkaWZmZXJlbnQgcGFja2FnZXMgd2l0aGluIHlvdXIgcHJvamVjdC5cbiAgICogQW5vdGhlciByZWFzb24gZm9yIHRoaXMgbWVzc2FnZSBpcyB0aGF0IHNvbWUgcGFydHMgb2YgeW91ciBwcm9qZWN0IHVzZSB0aGUgY29tbW9uanMgdmVyc2lvbiBvZiBZanNcbiAgICogYW5kIG90aGVycyB1c2UgdGhlIEVjbWFTY3JpcHQgdmVyc2lvbiBvZiBZanMuXG4gICAqXG4gICAqIFRoaXMgb2Z0ZW4gbGVhZHMgdG8gaXNzdWVzIHRoYXQgYXJlIGhhcmQgdG8gZGVidWcuIFdlIG9mdGVuIG5lZWQgdG8gcGVyZm9ybSBjb25zdHJ1Y3RvciBjaGVja3MsXG4gICAqIGUuZy4gYHN0cnVjdCBpbnN0YW5jZW9mIEdDYC4gSWYgeW91IGltcG9ydGVkIGRpZmZlcmVudCB2ZXJzaW9ucyBvZiBZanMsIGl0IGlzIGltcG9zc2libGUgZm9yIHVzIHRvXG4gICAqIGRvIHRoZSBjb25zdHJ1Y3RvciBjaGVja3MgYW55bW9yZSAtIHdoaWNoIG1pZ2h0IGJyZWFrIHRoZSBDUkRUIGFsZ29yaXRobS5cbiAgICpcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzQzOFxuICAgKi9cbiAgY29uc29sZS5lcnJvcignWWpzIHdhcyBhbHJlYWR5IGltcG9ydGVkLiBUaGlzIGJyZWFrcyBjb25zdHJ1Y3RvciBjaGVja3MgYW5kIHdpbGwgbGVhZCB0byBpc3N1ZXMhIC0gaHR0cHM6Ly9naXRodWIuY29tL3lqcy95anMvaXNzdWVzLzQzOCcpXG59XG5nbG9baW1wb3J0SWRlbnRpZmllcl0gPSB0cnVlXG4iLCAiaW1wb3J0ICogYXMgWFhIIGZyb20gJ3h4aGFzaGpzJ1xuXG5cbmV4cG9ydCBjb25zdCBjcmVhdGVSYW5kb21JZCA9ICgpOiBzdHJpbmcgPT4ge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5yYW5kb21VVUlEKClcbn1cblxuZXhwb3J0IGNvbnN0IHJhbmRvbVVpbnQzMiA9ICgpOiBudW1iZXIgPT4ge1xuICByZXR1cm4gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcbn1cblxuZXhwb3J0IGNvbnN0IGdlbmVyYXRlUmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygyMCkuc3Vic3RyaW5nKDIsIDgpXG59XG5cbmV4cG9ydCBjb25zdCBjYWxjdWxhdGVIYXNoID0gKHRleHQ6IHN0cmluZykgPT4geyByZXR1cm4gWFhILmgzMih0ZXh0LCAweEFCQ0QpLnRvU3RyaW5nKDE2KSB9XG5cbmV4cG9ydCBjb25zdCBzZXJpYWxpemUgPSAob2JqOiBhbnkpOiBzdHJpbmcgPT4ge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIGBbJHtvYmoubWFwKGVsID0+IHNlcmlhbGl6ZShlbCkpLmpvaW4oJywnKX1dYFxuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xuICAgIGxldCBhY2MgPSAnJ1xuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhvYmopLnNvcnQoKVxuICAgIGFjYyArPSBgeyR7SlNPTi5zdHJpbmdpZnkoa2V5cyl9YFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgYWNjICs9IGAke3NlcmlhbGl6ZShvYmpba2V5c1tpXV0pfSxgXG4gICAgfVxuICAgIHJldHVybiBgJHthY2N9fWBcbiAgfVxuICByZXR1cm4gYCR7SlNPTi5zdHJpbmdpZnkob2JqKX1gXG59IiwgImltcG9ydCB7IEFwcCwgTW9kYWwsIE5vdGljZSwgU2V0dGluZywgVEZpbGUsIFdvcmtzcGFjZSwgV29ya3NwYWNlTGVhZiB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5jbGFzcyBTaG93VGV4dE1vZGFsIGV4dGVuZHMgTW9kYWwge1xuXG5cdG1lc3NhZ2U6IHN0cmluZ1xuICB0aXRsZTogc3RyaW5nXG5cblx0Y29uc3RydWN0b3IoYXBwOiBBcHAsIHRpdGxlOiBzdHJpbmcsIG1lc3NhZ2U6IHN0cmluZykge1xuXHRcdHN1cGVyKGFwcCk7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuICAgIHRoaXMudGl0bGUgPSB0aXRsZVxuXHR9XG5cblx0b25PcGVuKCkge1xuXHRcdHRoaXMudGl0bGVFbC5zZXRUZXh0KHRoaXMudGl0bGUpXG5cdFx0dGhpcy5jb250ZW50RWwuc2V0VGV4dCh0aGlzLm1lc3NhZ2UpXG5cdH1cblxuXHRvbkNsb3NlKCkge1xuXHRcdHRoaXMuY29udGFpbmVyRWwuZW1wdHkoKVxuXHR9XG59XG5cbmV4cG9ydCBjb25zdCBzaG93VGV4dE1vZGFsID0gKGFwcDogQXBwLCB0aXRsZTogc3RyaW5nLCB0ZXh0OiBzdHJpbmcpID0+IHtcbiAgbmV3IFNob3dUZXh0TW9kYWwoYXBwLCB0aXRsZSwgdGV4dCkub3BlbigpXG59XG5cbmV4cG9ydCBjb25zdCBzaG93Tm90aWNlID0gKHRleHQ6IHN0cmluZywgZHVyYXRpb24/OiBudW1iZXIgfCB1bmRlZmluZWQpID0+IHtcblx0cmV0dXJuIG5ldyBOb3RpY2UodGV4dCwgZHVyYXRpb24pXG59XG5cblxuY2xhc3MgRW50ZXJUZXh0TW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cbiAgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmd9PlxuICBjYjogKHJlc3VsdDogQXJyYXk8e25hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZ30+KSA9PiBhbnlcbiAgcmVzdWx0OiBBcnJheTx7bmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nfT5cblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHtuYW1lOiBzdHJpbmcsIGRlc2NyaXB0aW9uOiBzdHJpbmd9PiwgY2I6IChyZXN1bHQ6IEFycmF5PHtuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmd9PikgPT4gYW55KSB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuaW5wdXREZXNjcmlwdGlvbnMgPSBpbnB1dERlc2NyaXB0aW9uc1xuICAgIHRoaXMuY2IgPSBjYlxuICAgIHRoaXMucmVzdWx0ID0gaW5wdXREZXNjcmlwdGlvbnMubWFwKGRlc2NyaXB0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5hbWU6IGRlc2NyaXB0aW9uLm5hbWUsXG4gICAgICAgIHZhbHVlOiBcIlwiXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5pbnB1dERlc2NyaXB0aW9ucy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5pbnB1dERlc2NyaXB0aW9uc1tpbmRleF07XG4gICAgICBjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgICBzZXR0aW5nLnNldE5hbWUoZGVzY3JpcHRpb24ubmFtZSlcbiAgICAgIHNldHRpbmcuc2V0RGVzYyhkZXNjcmlwdGlvbi5kZXNjcmlwdGlvbilcbiAgICAgIHNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgICAgdGV4dC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgICAgdGhpcy5yZXN1bHRbaW5kZXhdLnZhbHVlID0gdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgYnV0dG9ucyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuICAgIGJ1dHRvbnMuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkNhbmNlbFwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIGJ1dHRvbnMuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIkdvXCIpXG4gICAgICBidXR0b24uc2V0Q3RhKClcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIHRoaXMuY2IodGhpcy5yZXN1bHQpXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBvbkNsb3NlKCk6IHZvaWQge1xuICAgIHRoaXMuY2IodGhpcy5yZXN1bHQpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvck11bHRpcGxlVGV4dElucHV0cyA9IGFzeW5jIChhcHA6IEFwcCwgaW5wdXREZXNjcmlwdGlvbnM6IEFycmF5PHsgbmFtZTogc3RyaW5nLCBkZXNjcmlwdGlvbjogc3RyaW5nIH0+KSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxBcnJheTx7IG5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyB9PiB8IHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IEVudGVyVGV4dE1vZGFsKGFwcCwgaW5wdXREZXNjcmlwdGlvbnMsIChyZXN1bHQpID0+IHtcbiAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgIH0pLm9wZW4oKVxuICB9KVxufVxuXG5leHBvcnQgY29uc3Qgb3BlbkZpbGVJbk5ld1RhYiA9IGFzeW5jIChmaWxlOiBURmlsZSwgd29ya3NwYWNlOiBXb3Jrc3BhY2UpID0+IHtcbiAgY29uc3QgbGVhZiA9IHdvcmtzcGFjZS5nZXRMZWFmKCd0YWInKVxuICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpXG4gIHJldHVybiBsZWFmXG59XG5cblxuXG5leHBvcnQgY29uc3QgcGluTGVhZiA9IChsZWFmOiBXb3Jrc3BhY2VMZWFmKSA9PiB7XG4gIGxlYWYuc2V0UGlubmVkKHRydWUpXG4gIHNob3dOb3RpY2UoYGF1dG8tcGlubmVkIFwiJHtsZWFmLmdldERpc3BsYXlUZXh0KCl9XCJgKVxufVxuXG5leHBvcnQgY29uc3QgdXNlcmNvbG9ycyA9IFtcbiAgeyBkYXJrOiAnIzMwYmNlZCcsIGxpZ2h0OiAnIzMwYmNlZDMzJyB9LFxuICB7IGRhcms6ICcjNmVlYjgzJywgbGlnaHQ6ICcjNmVlYjgzMzMnIH0sXG4gIHsgZGFyazogJyNmZmJjNDInLCBsaWdodDogJyNmZmJjNDIzMycgfSxcbiAgeyBkYXJrOiAnI2VjZDQ0NCcsIGxpZ2h0OiAnI2VjZDQ0NDMzJyB9LFxuICB7IGRhcms6ICcjZWU2MzUyJywgbGlnaHQ6ICcjZWU2MzUyMzMnIH0sXG4gIHsgZGFyazogJyM5YWMyYzknLCBsaWdodDogJyM5YWMyYzkzMycgfSxcbiAgeyBkYXJrOiAnIzhhY2I4OCcsIGxpZ2h0OiAnIzhhY2I4ODMzJyB9LFxuICB7IGRhcms6ICcjMWJlN2ZmJywgbGlnaHQ6ICcjMWJlN2ZmMzMnIH1cbl0iLCAiXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcycgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnXG5pbXBvcnQgKiBhcyBjbVN0YXRlIGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmltcG9ydCB7IFlSYW5nZSB9IGZyb20gJy4veS1yYW5nZS5qcydcbmltcG9ydCB7IHlTeW5jLCB5U3luY0ZhY2V0LCBZU3luY0NvbmZpZyB9IGZyb20gJy4veS1zeW5jLmpzJ1xuaW1wb3J0IHsgeVJlbW90ZVNlbGVjdGlvbnMsIHlSZW1vdGVTZWxlY3Rpb25zVGhlbWUgfSBmcm9tICcuL3ktcmVtb3RlLXNlbGVjdGlvbnMuanMnXG5pbXBvcnQgeyB5VW5kb01hbmFnZXIsIHlVbmRvTWFuYWdlckZhY2V0LCBZVW5kb01hbmFnZXJDb25maWcsIHVuZG8sIHJlZG8sIHlVbmRvTWFuYWdlcktleW1hcCB9IGZyb20gJy4veS11bmRvbWFuYWdlci5qcydcblxuZXhwb3J0IHsgWVJhbmdlLCB5UmVtb3RlU2VsZWN0aW9ucywgeVJlbW90ZVNlbGVjdGlvbnNUaGVtZSwgeVN5bmMsIHlTeW5jRmFjZXQsIFlTeW5jQ29uZmlnLCB5VW5kb01hbmFnZXJLZXltYXAgfVxuXG4vKipcbiAqIEBwYXJhbSB7WS5UZXh0fSB5dGV4dFxuICogQHBhcmFtIHthbnl9IGF3YXJlbmVzc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRzXVxuICogQHBhcmFtIHtZLlVuZG9NYW5hZ2VyIHwgZmFsc2V9IFtvcHRzLnVuZG9NYW5hZ2VyXSBTZXQgdW5kb01hbmFnZXIgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGUgdW5kby1yZWRvIHBsdWdpblxuICogQHJldHVybiB7Y21TdGF0ZS5FeHRlbnNpb259XG4gKi9cbmV4cG9ydCBjb25zdCB5Q29sbGFiID0gKHl0ZXh0LCBhd2FyZW5lc3MsIHsgdW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcih5dGV4dCkgfSA9IHt9KSA9PiB7XG4gIGNvbnN0IHlTeW5jQ29uZmlnID0gbmV3IFlTeW5jQ29uZmlnKHl0ZXh0LCBhd2FyZW5lc3MpXG4gIGNvbnN0IHBsdWdpbnMgPSBbXG4gICAgeVN5bmNGYWNldC5vZih5U3luY0NvbmZpZyksXG4gICAgeVN5bmNcbiAgXVxuICBpZiAoYXdhcmVuZXNzKSB7XG4gICAgcGx1Z2lucy5wdXNoKFxuICAgICAgeVJlbW90ZVNlbGVjdGlvbnNUaGVtZSxcbiAgICAgIHlSZW1vdGVTZWxlY3Rpb25zXG4gICAgKVxuICB9XG4gIGlmICh1bmRvTWFuYWdlciAhPT0gZmFsc2UpIHtcbiAgICAvLyBCeSBkZWZhdWx0LCBvbmx5IHRyYWNrIGNoYW5nZXMgdGhhdCBhcmUgcHJvZHVjZWQgYnkgdGhlIHN5bmMgcGx1Z2luIChsb2NhbCBlZGl0cylcbiAgICBwbHVnaW5zLnB1c2goXG4gICAgICB5VW5kb01hbmFnZXJGYWNldC5vZihuZXcgWVVuZG9NYW5hZ2VyQ29uZmlnKHVuZG9NYW5hZ2VyKSksXG4gICAgICB5VW5kb01hbmFnZXIsXG4gICAgICBjbVZpZXcuRWRpdG9yVmlldy5kb21FdmVudEhhbmRsZXJzKHtcbiAgICAgICAgYmVmb3JlaW5wdXQgKGUsIHZpZXcpIHtcbiAgICAgICAgICBpZiAoZS5pbnB1dFR5cGUgPT09ICdoaXN0b3J5VW5kbycpIHJldHVybiB1bmRvKHZpZXcpXG4gICAgICAgICAgaWYgKGUuaW5wdXRUeXBlID09PSAnaGlzdG9yeVJlZG8nKSByZXR1cm4gcmVkbyh2aWV3KVxuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfVxuICByZXR1cm4gcGx1Z2luc1xufVxuIiwgImltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuXG4vKipcbiAqIERlZmluZXMgYSByYW5nZSBvbiB0ZXh0IHVzaW5nIHJlbGF0aXZlIHBvc2l0aW9ucyB0aGF0IGNhbiBiZSB0cmFuc2Zvcm1lZCBiYWNrIHRvXG4gKiBhYnNvbHV0ZSBwb3NpdGlvbnMuIChodHRwczovL2RvY3MueWpzLmRldi9hcGkvcmVsYXRpdmUtcG9zaXRpb25zKVxuICovXG5leHBvcnQgY2xhc3MgWVJhbmdlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5SZWxhdGl2ZVBvc2l0aW9ufSB5YW5jaG9yXG4gICAqIEBwYXJhbSB7WS5SZWxhdGl2ZVBvc2l0aW9ufSB5aGVhZFxuICAgKi9cbiAgY29uc3RydWN0b3IgKHlhbmNob3IsIHloZWFkKSB7XG4gICAgdGhpcy55YW5jaG9yID0geWFuY2hvclxuICAgIHRoaXMueWhlYWQgPSB5aGVhZFxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHthbnl9XG4gICAqL1xuICB0b0pTT04gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB5YW5jaG9yOiBZLnJlbGF0aXZlUG9zaXRpb25Ub0pTT04odGhpcy55YW5jaG9yKSxcbiAgICAgIHloZWFkOiBZLnJlbGF0aXZlUG9zaXRpb25Ub0pTT04odGhpcy55aGVhZClcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGpzb25cbiAgICogQHJldHVybiB7WVJhbmdlfVxuICAgKi9cbiAgc3RhdGljIGZyb21KU09OIChqc29uKSB7XG4gICAgcmV0dXJuIG5ldyBZUmFuZ2UoWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oanNvbi55YW5jaG9yKSwgWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04oanNvbi55aGVhZCkpXG4gIH1cbn1cbiIsICJcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0ICogYXMgY21TdGF0ZSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZScgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuaW1wb3J0ICogYXMgY21WaWV3IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IFlSYW5nZSB9IGZyb20gJy4veS1yYW5nZS5qcydcblxuZXhwb3J0IGNsYXNzIFlTeW5jQ29uZmlnIHtcbiAgY29uc3RydWN0b3IgKHl0ZXh0LCBhd2FyZW5lc3MpIHtcbiAgICB0aGlzLnl0ZXh0ID0geXRleHRcbiAgICB0aGlzLmF3YXJlbmVzcyA9IGF3YXJlbmVzc1xuICAgIHRoaXMudW5kb01hbmFnZXIgPSBuZXcgWS5VbmRvTWFuYWdlcih5dGV4dClcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGFuIGFic29sdXRlIGluZGV4IHBvc2l0aW9uIHRvIGEgWWpzLWJhc2VkIHJlbGF0aXZlIHBvc2l0aW9uXG4gICAqIChodHRwczovL2RvY3MueWpzLmRldi9hcGkvcmVsYXRpdmUtcG9zaXRpb25zKS5cbiAgICpcbiAgICogQSByZWxhdGl2ZSBwb3NpdGlvbiBjYW4gYmUgdHJhbnNmb3JtZWQgYmFjayB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBldmVuIGFmdGVyIHRoZSBkb2N1bWVudCBoYXMgY2hhbmdlZC4gVGhlIHBvc2l0aW9uIGlzXG4gICAqIGF1dG9tYXRpY2FsbHkgYWRhcHRlZC4gVGhpcyBkb2VzIG5vdCByZXF1aXJlIGFueSBwb3NpdGlvbiB0cmFuc2Zvcm1hdGlvbnMuIFJlbGF0aXZlIHBvc2l0aW9ucyBhcmUgY29tcHV0ZWQgYmFzZWQgb25cbiAgICogdGhlIGludGVybmFsIFlqcyBkb2N1bWVudCBtb2RlbC4gUGVlcnMgdGhhdCBzaGFyZSBjb250ZW50IHRocm91Z2ggWWpzIGFyZSBndWFyYW50ZWVkIHRoYXQgdGhlaXIgcG9zaXRpb25zIHdpbGwgYWx3YXlzXG4gICAqIHN5bmNlZCB1cCB3aGVuIHVzaW5nIHJlbGF0dmUgcG9zaXRpb25zLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBpbXBvcnQgeyB5U3luY0ZhY2V0IH0gZnJvbSAneS1jb2RlbWlycm9yJ1xuICAgKlxuICAgKiAuLlxuICAgKiBjb25zdCB5c3luYyA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICogLy8gdHJhbnNmb3JtIGFuIGFic29sdXRlIGluZGV4IHBvc2l0aW9uIHRvIGEgeXBvc1xuICAgKiBjb25zdCB5cG9zID0geXN5bmMuZ2V0WVBvcygzKVxuICAgKiAvLyB0cmFuc2Zvcm0gdGhlIHlwb3MgYmFjayB0byBhbiBhYnNvbHV0ZSBwb3NpdGlvblxuICAgKiB5c3luYy5mcm9tWVBvcyh5cG9zKSAvLyA9PiAzXG4gICAqIGBgYFxuICAgKlxuICAgKiBJdCBjYW5ub3QgYmUgZ3VhcmFudGVlZCB0aGF0IGFic29sdXRlIGluZGV4IHBvc2l0aW9ucyBjYW4gYmUgc3luY2VkIHVwIGJldHdlZW4gcGVlcnMuXG4gICAqIFRoaXMgbWlnaHQgbGVhZCB0byB1bmRlc2lyZWQgYmVoYXZpb3Igd2hlbiBpbXBsZW1lbnRpbmcgZmVhdHVyZXMgdGhhdCByZXF1aXJlIHRoYXQgYWxsIHBlZXJzIHNlZSB0aGVcbiAgICogc2FtZSBtYXJrZWQgcmFuZ2UgKGUuZy4gYSBjb21tZW50IHBsdWdpbikuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwb3NcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthc3NvY11cbiAgICovXG4gIHRvWVBvcyAocG9zLCBhc3NvYyA9IDApIHtcbiAgICByZXR1cm4gWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbVR5cGVJbmRleCh0aGlzLnl0ZXh0LCBwb3MsIGFzc29jKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WS5SZWxhdGl2ZVBvc2l0aW9uIHwgT2JqZWN0fSBycG9zXG4gICAqL1xuICBmcm9tWVBvcyAocnBvcykge1xuICAgIGNvbnN0IHBvcyA9IFkuY3JlYXRlQWJzb2x1dGVQb3NpdGlvbkZyb21SZWxhdGl2ZVBvc2l0aW9uKFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21KU09OKHJwb3MpLCB0aGlzLnl0ZXh0LmRvYylcbiAgICBpZiAocG9zID09IG51bGwgfHwgcG9zLnR5cGUgIT09IHRoaXMueXRleHQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignW3ktY29kZW1pcnJvcl0gVGhlIHBvc2l0aW9uIHlvdSB3YW50IHRvIHJldHJpZXZlIHdhcyBjcmVhdGVkIGJ5IGEgZGlmZmVyZW50IGRvY3VtZW50JylcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvczogcG9zLmluZGV4LFxuICAgICAgYXNzb2M6IHBvcy5hc3NvY1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtU3RhdGUuU2VsZWN0aW9uUmFuZ2V9IHJhbmdlXG4gICAqIEByZXR1cm4ge1lSYW5nZX1cbiAgICovXG4gIHRvWVJhbmdlIChyYW5nZSkge1xuICAgIGNvbnN0IGFzc29jID0gcmFuZ2UuYXNzb2NcbiAgICBjb25zdCB5YW5jaG9yID0gdGhpcy50b1lQb3MocmFuZ2UuYW5jaG9yLCBhc3NvYylcbiAgICBjb25zdCB5aGVhZCA9IHRoaXMudG9ZUG9zKHJhbmdlLmhlYWQsIGFzc29jKVxuICAgIHJldHVybiBuZXcgWVJhbmdlKHlhbmNob3IsIHloZWFkKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7WVJhbmdlfSB5cmFuZ2VcbiAgICovXG4gIGZyb21ZUmFuZ2UgKHlyYW5nZSkge1xuICAgIGNvbnN0IGFuY2hvciA9IHRoaXMuZnJvbVlQb3MoeXJhbmdlLnlhbmNob3IpXG4gICAgY29uc3QgaGVhZCA9IHRoaXMuZnJvbVlQb3MoeXJhbmdlLnloZWFkKVxuICAgIGlmIChhbmNob3IucG9zID09PSBoZWFkLnBvcykge1xuICAgICAgcmV0dXJuIGNtU3RhdGUuRWRpdG9yU2VsZWN0aW9uLmN1cnNvcihoZWFkLnBvcywgaGVhZC5hc3NvYylcbiAgICB9XG4gICAgcmV0dXJuIGNtU3RhdGUuRWRpdG9yU2VsZWN0aW9uLnJhbmdlKGFuY2hvci5wb3MsIGhlYWQucG9zKVxuICB9XG59XG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuRmFjZXQ8WVN5bmNDb25maWcsIFlTeW5jQ29uZmlnPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlTeW5jRmFjZXQgPSBjbVN0YXRlLkZhY2V0LmRlZmluZSh7XG4gIGNvbWJpbmUgKGlucHV0cykge1xuICAgIHJldHVybiBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDFdXG4gIH1cbn0pXG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuQW5ub3RhdGlvblR5cGU8WVN5bmNDb25maWc+fVxuICovXG5leHBvcnQgY29uc3QgeVN5bmNBbm5vdGF0aW9uID0gY21TdGF0ZS5Bbm5vdGF0aW9uLmRlZmluZSgpXG5cbi8qKlxuICogQGV4dGVuZHMge1BsdWdpblZhbHVlfVxuICovXG5jbGFzcyBZU3luY1BsdWdpblZhbHVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LkVkaXRvclZpZXd9IHZpZXdcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2aWV3KSB7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICB0aGlzLl9vYnNlcnZlciA9IChldmVudCwgdHIpID0+IHtcbiAgICAgIGlmICh0ci5vcmlnaW4gIT09IHRoaXMuY29uZikge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGV2ZW50LmRlbHRhXG4gICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXVxuICAgICAgICBsZXQgcG9zID0gMFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbHRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgZCA9IGRlbHRhW2ldXG4gICAgICAgICAgaWYgKGQuaW5zZXJ0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IHBvcywgdG86IHBvcywgaW5zZXJ0OiBkLmluc2VydCB9KVxuICAgICAgICAgIH0gZWxzZSBpZiAoZC5kZWxldGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogcG9zLCB0bzogcG9zICsgZC5kZWxldGUsIGluc2VydDogJycgfSlcbiAgICAgICAgICAgIHBvcyArPSBkLmRlbGV0ZVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gZC5yZXRhaW5cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGNoYW5nZXMsIGFubm90YXRpb25zOiBbeVN5bmNBbm5vdGF0aW9uLm9mKHRoaXMuY29uZildIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX3l0ZXh0ID0gdGhpcy5jb25mLnl0ZXh0XG4gICAgdGhpcy5feXRleHQub2JzZXJ2ZSh0aGlzLl9vYnNlcnZlcilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5WaWV3VXBkYXRlfSB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZSAodXBkYXRlKSB7XG4gICAgaWYgKCF1cGRhdGUuZG9jQ2hhbmdlZCB8fCAodXBkYXRlLnRyYW5zYWN0aW9ucy5sZW5ndGggPiAwICYmIHVwZGF0ZS50cmFuc2FjdGlvbnNbMF0uYW5ub3RhdGlvbih5U3luY0Fubm90YXRpb24pID09PSB0aGlzLmNvbmYpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgY29uc3QgeXRleHQgPSB0aGlzLmNvbmYueXRleHRcbiAgICB5dGV4dC5kb2MudHJhbnNhY3QoKCkgPT4ge1xuICAgICAgLyoqXG4gICAgICAgKiBUaGlzIHZhcmlhYmxlIGFkanVzdHMgdGhlIGZyb21BIHBvc2l0aW9uIHRvIHRoZSBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBZLlRleHQgdHlwZS5cbiAgICAgICAqL1xuICAgICAgbGV0IGFkaiA9IDBcbiAgICAgIHVwZGF0ZS5jaGFuZ2VzLml0ZXJDaGFuZ2VzKChmcm9tQSwgdG9BLCBmcm9tQiwgdG9CLCBpbnNlcnQpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VGV4dCA9IGluc2VydC5zbGljZVN0cmluZygwLCBpbnNlcnQubGVuZ3RoLCAnXFxuJylcbiAgICAgICAgaWYgKGZyb21BICE9PSB0b0EpIHtcbiAgICAgICAgICB5dGV4dC5kZWxldGUoZnJvbUEgKyBhZGosIHRvQSAtIGZyb21BKVxuICAgICAgICB9XG4gICAgICAgIGlmIChpbnNlcnRUZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICB5dGV4dC5pbnNlcnQoZnJvbUEgKyBhZGosIGluc2VydFRleHQpXG4gICAgICAgIH1cbiAgICAgICAgYWRqICs9IGluc2VydFRleHQubGVuZ3RoIC0gKHRvQSAtIGZyb21BKVxuICAgICAgfSlcbiAgICB9LCB0aGlzLmNvbmYpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl95dGV4dC51bm9ic2VydmUodGhpcy5fb2JzZXJ2ZXIpXG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IHlTeW5jID0gY21WaWV3LlZpZXdQbHVnaW4uZnJvbUNsYXNzKFlTeW5jUGx1Z2luVmFsdWUpXG4iLCAiXG5pbXBvcnQgKiBhcyBjbVZpZXcgZnJvbSAnQGNvZGVtaXJyb3IvdmlldydcblxuaW1wb3J0ICogYXMgY21TdGF0ZSBmcm9tICdAY29kZW1pcnJvci9zdGF0ZSdcbmltcG9ydCAqIGFzIGRvbSBmcm9tICdsaWIwL2RvbSdcbmltcG9ydCAqIGFzIHBhaXIgZnJvbSAnbGliMC9wYWlyJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5cbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJ1xuaW1wb3J0IHsgeVN5bmNGYWNldCB9IGZyb20gJy4veS1zeW5jLmpzJ1xuXG5leHBvcnQgY29uc3QgeVJlbW90ZVNlbGVjdGlvbnNUaGVtZSA9IGNtVmlldy5FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICcuY20teVNlbGVjdGlvbic6IHtcbiAgfSxcbiAgJy5jbS15TGluZVNlbGVjdGlvbic6IHtcbiAgICBwYWRkaW5nOiAwLFxuICAgIG1hcmdpbjogJzBweCAycHggMHB4IDRweCdcbiAgfSxcbiAgJy5jbS15U2VsZWN0aW9uQ2FyZXQnOiB7XG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgYm9yZGVyTGVmdDogJzFweCBzb2xpZCBibGFjaycsXG4gICAgYm9yZGVyUmlnaHQ6ICcxcHggc29saWQgYmxhY2snLFxuICAgIG1hcmdpbkxlZnQ6ICctMXB4JyxcbiAgICBtYXJnaW5SaWdodDogJy0xcHgnLFxuICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxuICAgIGRpc3BsYXk6ICdpbmxpbmUnXG4gIH0sXG4gICcuY20teVNlbGVjdGlvbkNhcmV0RG90Jzoge1xuICAgIGJvcmRlclJhZGl1czogJzUwJScsXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgd2lkdGg6ICcuNGVtJyxcbiAgICBoZWlnaHQ6ICcuNGVtJyxcbiAgICB0b3A6ICctLjJlbScsXG4gICAgbGVmdDogJy0uMmVtJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdpbmhlcml0JyxcbiAgICB0cmFuc2l0aW9uOiAndHJhbnNmb3JtIC4zcyBlYXNlLWluLW91dCcsXG4gICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcbiAgfSxcbiAgJy5jbS15U2VsZWN0aW9uQ2FyZXQ6aG92ZXIgPiAuY20teVNlbGVjdGlvbkNhcmV0RG90Jzoge1xuICAgIHRyYW5zZm9ybU9yaWdpbjogJ2JvdHRvbSBjZW50ZXInLFxuICAgIHRyYW5zZm9ybTogJ3NjYWxlKDApJ1xuICB9LFxuICAnLmNtLXlTZWxlY3Rpb25JbmZvJzoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHRvcDogJy0xLjA1ZW0nLFxuICAgIGxlZnQ6ICctMXB4JyxcbiAgICBmb250U2l6ZTogJy43NWVtJyxcbiAgICBmb250RmFtaWx5OiAnc2VyaWYnLFxuICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXG4gICAgZm9udFdlaWdodDogJ25vcm1hbCcsXG4gICAgbGluZUhlaWdodDogJ25vcm1hbCcsXG4gICAgdXNlclNlbGVjdDogJ25vbmUnLFxuICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgIHBhZGRpbmdMZWZ0OiAnMnB4JyxcbiAgICBwYWRkaW5nUmlnaHQ6ICcycHgnLFxuICAgIHpJbmRleDogMTAxLFxuICAgIHRyYW5zaXRpb246ICdvcGFjaXR5IC4zcyBlYXNlLWluLW91dCcsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnaW5oZXJpdCcsXG4gICAgLy8gdGhlc2Ugc2hvdWxkIGJlIHNlcGFyYXRlXG4gICAgb3BhY2l0eTogMCxcbiAgICB0cmFuc2l0aW9uRGVsYXk6ICcwcycsXG4gICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbiAgfSxcbiAgJy5jbS15U2VsZWN0aW9uQ2FyZXQ6aG92ZXIgPiAuY20teVNlbGVjdGlvbkluZm8nOiB7XG4gICAgb3BhY2l0eTogMSxcbiAgICB0cmFuc2l0aW9uRGVsYXk6ICcwcydcbiAgfVxufSlcblxuLyoqXG4gKiBAdG9kbyBzcGVjaWZ5IHRoZSB1c2VycyB0aGF0IGFjdHVhbGx5IGNoYW5nZWQuIEN1cnJlbnRseSwgd2UgcmVjYWxjdWxhdGUgcG9zaXRpb25zIGZvciBldmVyeSB1c2VyLlxuICogQHR5cGUge2NtU3RhdGUuQW5ub3RhdGlvblR5cGU8QXJyYXk8bnVtYmVyPj59XG4gKi9cbmNvbnN0IHlSZW1vdGVTZWxlY3Rpb25zQW5ub3RhdGlvbiA9IGNtU3RhdGUuQW5ub3RhdGlvbi5kZWZpbmUoKVxuXG5jbGFzcyBZUmVtb3RlQ2FyZXRXaWRnZXQgZXh0ZW5kcyBjbVZpZXcuV2lkZ2V0VHlwZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29sb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIGNvbnN0cnVjdG9yIChjb2xvciwgbmFtZSkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmNvbG9yID0gY29sb3JcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gIH1cblxuICB0b0RPTSAoKSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovIChkb20uZWxlbWVudCgnc3BhbicsIFtwYWlyLmNyZWF0ZSgnY2xhc3MnLCAnY20teVNlbGVjdGlvbkNhcmV0JyksIHBhaXIuY3JlYXRlKCdzdHlsZScsIGBiYWNrZ3JvdW5kLWNvbG9yOiAke3RoaXMuY29sb3J9OyBib3JkZXItY29sb3I6ICR7dGhpcy5jb2xvcn1gKV0sIFtcbiAgICAgIGRvbS50ZXh0KCdcXHUyMDYwJyksXG4gICAgICBkb20uZWxlbWVudCgnZGl2JywgW1xuICAgICAgICBwYWlyLmNyZWF0ZSgnY2xhc3MnLCAnY20teVNlbGVjdGlvbkNhcmV0RG90JylcbiAgICAgIF0pLFxuICAgICAgZG9tLnRleHQoJ1xcdTIwNjAnKSxcbiAgICAgIGRvbS5lbGVtZW50KCdkaXYnLCBbXG4gICAgICAgIHBhaXIuY3JlYXRlKCdjbGFzcycsICdjbS15U2VsZWN0aW9uSW5mbycpXG4gICAgICBdLCBbXG4gICAgICAgIGRvbS50ZXh0KHRoaXMubmFtZSlcbiAgICAgIF0pLFxuICAgICAgZG9tLnRleHQoJ1xcdTIwNjAnKVxuICAgIF0pKVxuICB9XG5cbiAgZXEgKHdpZGdldCkge1xuICAgIHJldHVybiB3aWRnZXQuY29sb3IgPT09IHRoaXMuY29sb3JcbiAgfVxuXG4gIGNvbXBhcmUgKHdpZGdldCkge1xuICAgIHJldHVybiB3aWRnZXQuY29sb3IgPT09IHRoaXMuY29sb3JcbiAgfVxuXG4gIHVwZGF0ZURPTSAoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBnZXQgZXN0aW1hdGVkSGVpZ2h0ICgpIHsgcmV0dXJuIC0xIH1cblxuICBpZ25vcmVFdmVudCAoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWVJlbW90ZVNlbGVjdGlvbnNQbHVnaW5WYWx1ZSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5FZGl0b3JWaWV3fSB2aWV3XG4gICAqL1xuICBjb25zdHJ1Y3RvciAodmlldykge1xuICAgIHRoaXMuY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoeVN5bmNGYWNldClcbiAgICB0aGlzLl9saXN0ZW5lciA9ICh7IGFkZGVkLCB1cGRhdGVkLCByZW1vdmVkIH0sIHMsIHQpID0+IHtcbiAgICAgIGNvbnN0IGNsaWVudHMgPSBhZGRlZC5jb25jYXQodXBkYXRlZCkuY29uY2F0KHJlbW92ZWQpXG4gICAgICBpZiAoY2xpZW50cy5maW5kSW5kZXgoaWQgPT4gaWQgIT09IHRoaXMuY29uZi5hd2FyZW5lc3MuZG9jLmNsaWVudElEKSA+PSAwKSB7XG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBhbm5vdGF0aW9uczogW3lSZW1vdGVTZWxlY3Rpb25zQW5ub3RhdGlvbi5vZihbXSldIH0pXG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2F3YXJlbmVzcyA9IHRoaXMuY29uZi5hd2FyZW5lc3NcbiAgICB0aGlzLl9hd2FyZW5lc3Mub24oJ2NoYW5nZScsIHRoaXMuX2xpc3RlbmVyKVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtjbVZpZXcuRGVjb3JhdGlvblNldH1cbiAgICAgKi9cbiAgICB0aGlzLmRlY29yYXRpb25zID0gY21TdGF0ZS5SYW5nZVNldC5vZihbXSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuX2F3YXJlbmVzcy5vZmYoJ2NoYW5nZScsIHRoaXMuX2xpc3RlbmVyKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LlZpZXdVcGRhdGV9IHVwZGF0ZVxuICAgKi9cbiAgdXBkYXRlICh1cGRhdGUpIHtcbiAgICBjb25zdCB5dGV4dCA9IHRoaXMuY29uZi55dGV4dFxuICAgIGNvbnN0IHlkb2MgPSAvKiogQHR5cGUge1kuRG9jfSAqLyAoeXRleHQuZG9jKVxuICAgIGNvbnN0IGF3YXJlbmVzcyA9IHRoaXMuY29uZi5hd2FyZW5lc3NcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7QXJyYXk8Y21TdGF0ZS5SYW5nZTxjbVZpZXcuRGVjb3JhdGlvbj4+fVxuICAgICAqL1xuICAgIGNvbnN0IGRlY29yYXRpb25zID0gW11cbiAgICBjb25zdCBsb2NhbEF3YXJlbmVzc1N0YXRlID0gdGhpcy5jb25mLmF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKClcblxuICAgIC8vIHNldCBsb2NhbCBhd2FyZW5lc3Mgc3RhdGUgKHVwZGF0ZSBjdXJzb3JzKVxuICAgIGlmIChsb2NhbEF3YXJlbmVzc1N0YXRlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGhhc0ZvY3VzID0gdXBkYXRlLnZpZXcuaGFzRm9jdXMgJiYgdXBkYXRlLnZpZXcuZG9tLm93bmVyRG9jdW1lbnQuaGFzRm9jdXMoKVxuICAgICAgY29uc3Qgc2VsID0gaGFzRm9jdXMgPyB1cGRhdGUuc3RhdGUuc2VsZWN0aW9uLm1haW4gOiBudWxsXG4gICAgICBjb25zdCBjdXJyZW50QW5jaG9yID0gbG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IgPT0gbnVsbCA/IG51bGwgOiBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tSlNPTihsb2NhbEF3YXJlbmVzc1N0YXRlLmN1cnNvci5hbmNob3IpXG4gICAgICBjb25zdCBjdXJyZW50SGVhZCA9IGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yID09IG51bGwgPyBudWxsIDogWS5jcmVhdGVSZWxhdGl2ZVBvc2l0aW9uRnJvbUpTT04obG9jYWxBd2FyZW5lc3NTdGF0ZS5jdXJzb3IuaGVhZClcblxuICAgICAgaWYgKHNlbCAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IFkuY3JlYXRlUmVsYXRpdmVQb3NpdGlvbkZyb21UeXBlSW5kZXgoeXRleHQsIHNlbC5hbmNob3IpXG4gICAgICAgIGNvbnN0IGhlYWQgPSBZLmNyZWF0ZVJlbGF0aXZlUG9zaXRpb25Gcm9tVHlwZUluZGV4KHl0ZXh0LCBzZWwuaGVhZClcbiAgICAgICAgaWYgKGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yID09IG51bGwgfHwgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKGN1cnJlbnRBbmNob3IsIGFuY2hvcikgfHwgIVkuY29tcGFyZVJlbGF0aXZlUG9zaXRpb25zKGN1cnJlbnRIZWFkLCBoZWFkKSkge1xuICAgICAgICAgIGF3YXJlbmVzcy5zZXRMb2NhbFN0YXRlRmllbGQoJ2N1cnNvcicsIHtcbiAgICAgICAgICAgIGFuY2hvcixcbiAgICAgICAgICAgIGhlYWRcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGxvY2FsQXdhcmVuZXNzU3RhdGUuY3Vyc29yICE9IG51bGwgJiYgaGFzRm9jdXMpIHtcbiAgICAgICAgYXdhcmVuZXNzLnNldExvY2FsU3RhdGVGaWVsZCgnY3Vyc29yJywgbnVsbClcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgZGVjb3JhdGlvbnMgKHJlbW90ZSBzZWxlY3Rpb25zKVxuICAgIGF3YXJlbmVzcy5nZXRTdGF0ZXMoKS5mb3JFYWNoKChzdGF0ZSwgY2xpZW50aWQpID0+IHtcbiAgICAgIGlmIChjbGllbnRpZCA9PT0gYXdhcmVuZXNzLmRvYy5jbGllbnRJRCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIGNvbnN0IGN1cnNvciA9IHN0YXRlLmN1cnNvclxuICAgICAgaWYgKGN1cnNvciA9PSBudWxsIHx8IGN1cnNvci5hbmNob3IgPT0gbnVsbCB8fCBjdXJzb3IuaGVhZCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgY29uc3QgYW5jaG9yID0gWS5jcmVhdGVBYnNvbHV0ZVBvc2l0aW9uRnJvbVJlbGF0aXZlUG9zaXRpb24oY3Vyc29yLmFuY2hvciwgeWRvYylcbiAgICAgIGNvbnN0IGhlYWQgPSBZLmNyZWF0ZUFic29sdXRlUG9zaXRpb25Gcm9tUmVsYXRpdmVQb3NpdGlvbihjdXJzb3IuaGVhZCwgeWRvYylcbiAgICAgIGlmIChhbmNob3IgPT0gbnVsbCB8fCBoZWFkID09IG51bGwgfHwgYW5jaG9yLnR5cGUgIT09IHl0ZXh0IHx8IGhlYWQudHlwZSAhPT0geXRleHQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICBjb25zdCB7IGNvbG9yID0gJyMzMGJjZWQnLCBuYW1lID0gJ0Fub255bW91cycgfSA9IHN0YXRlLnVzZXIgfHwge31cbiAgICAgIGNvbnN0IGNvbG9yTGlnaHQgPSAoc3RhdGUudXNlciAmJiBzdGF0ZS51c2VyLmNvbG9yTGlnaHQpIHx8IGNvbG9yICsgJzMzJ1xuICAgICAgY29uc3Qgc3RhcnQgPSBtYXRoLm1pbihhbmNob3IuaW5kZXgsIGhlYWQuaW5kZXgpXG4gICAgICBjb25zdCBlbmQgPSBtYXRoLm1heChhbmNob3IuaW5kZXgsIGhlYWQuaW5kZXgpXG4gICAgICBjb25zdCBzdGFydExpbmUgPSB1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZUF0KHN0YXJ0KVxuICAgICAgY29uc3QgZW5kTGluZSA9IHVwZGF0ZS52aWV3LnN0YXRlLmRvYy5saW5lQXQoZW5kKVxuICAgICAgaWYgKHN0YXJ0TGluZS5udW1iZXIgPT09IGVuZExpbmUubnVtYmVyKSB7XG4gICAgICAgIC8vIHNlbGVjdGVkIGNvbnRlbnQgaW4gYSBzaW5nbGUgbGluZS5cbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICAgICAgZnJvbTogc3RhcnQsXG4gICAgICAgICAgdG86IGVuZCxcbiAgICAgICAgICB2YWx1ZTogY21WaWV3LkRlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiBgYmFja2dyb3VuZC1jb2xvcjogJHtjb2xvckxpZ2h0fWAgfSxcbiAgICAgICAgICAgIGNsYXNzOiAnY20teVNlbGVjdGlvbidcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2VsZWN0ZWQgY29udGVudCBpbiBtdWx0aXBsZSBsaW5lc1xuICAgICAgICAvLyBmaXJzdCwgcmVuZGVyIHRleHQtc2VsZWN0aW9uIGluIHRoZSBmaXJzdCBsaW5lXG4gICAgICAgIGRlY29yYXRpb25zLnB1c2goe1xuICAgICAgICAgIGZyb206IHN0YXJ0LFxuICAgICAgICAgIHRvOiBzdGFydExpbmUuZnJvbSArIHN0YXJ0TGluZS5sZW5ndGgsXG4gICAgICAgICAgdmFsdWU6IGNtVmlldy5EZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JMaWdodH1gIH0sXG4gICAgICAgICAgICBjbGFzczogJ2NtLXlTZWxlY3Rpb24nXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgLy8gcmVuZGVyIHRleHQtc2VsZWN0aW9uIGluIHRoZSBsYXN0IGxpbmVcbiAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICAgICAgZnJvbTogZW5kTGluZS5mcm9tLFxuICAgICAgICAgIHRvOiBlbmQsXG4gICAgICAgICAgdmFsdWU6IGNtVmlldy5EZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgYXR0cmlidXRlczogeyBzdHlsZTogYGJhY2tncm91bmQtY29sb3I6ICR7Y29sb3JMaWdodH1gIH0sXG4gICAgICAgICAgICBjbGFzczogJ2NtLXlTZWxlY3Rpb24nXG4gICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0TGluZS5udW1iZXIgKyAxOyBpIDwgZW5kTGluZS5udW1iZXI7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxpbmVQb3MgPSB1cGRhdGUudmlldy5zdGF0ZS5kb2MubGluZShpKS5mcm9tXG4gICAgICAgICAgZGVjb3JhdGlvbnMucHVzaCh7XG4gICAgICAgICAgICBmcm9tOiBsaW5lUG9zLFxuICAgICAgICAgICAgdG86IGxpbmVQb3MsXG4gICAgICAgICAgICB2YWx1ZTogY21WaWV3LkRlY29yYXRpb24ubGluZSh7XG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHsgc3R5bGU6IGBiYWNrZ3JvdW5kLWNvbG9yOiAke2NvbG9yTGlnaHR9YCwgY2xhc3M6ICdjbS15TGluZVNlbGVjdGlvbicgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkZWNvcmF0aW9ucy5wdXNoKHtcbiAgICAgICAgZnJvbTogaGVhZC5pbmRleCxcbiAgICAgICAgdG86IGhlYWQuaW5kZXgsXG4gICAgICAgIHZhbHVlOiBjbVZpZXcuRGVjb3JhdGlvbi53aWRnZXQoe1xuICAgICAgICAgIHNpZGU6IGhlYWQuaW5kZXggLSBhbmNob3IuaW5kZXggPiAwID8gLTEgOiAxLCAvLyB0aGUgbG9jYWwgY3Vyc29yIHNob3VsZCBiZSByZW5kZXJlZCBvdXRzaWRlIHRoZSByZW1vdGUgc2VsZWN0aW9uXG4gICAgICAgICAgYmxvY2s6IGZhbHNlLFxuICAgICAgICAgIHdpZGdldDogbmV3IFlSZW1vdGVDYXJldFdpZGdldChjb2xvciwgbmFtZSlcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSlcbiAgICB0aGlzLmRlY29yYXRpb25zID0gY21WaWV3LkRlY29yYXRpb24uc2V0KGRlY29yYXRpb25zLCB0cnVlKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB5UmVtb3RlU2VsZWN0aW9ucyA9IGNtVmlldy5WaWV3UGx1Z2luLmZyb21DbGFzcyhZUmVtb3RlU2VsZWN0aW9uc1BsdWdpblZhbHVlLCB7XG4gIGRlY29yYXRpb25zOiB2ID0+IHYuZGVjb3JhdGlvbnNcbn0pXG4iLCAiaW1wb3J0ICogYXMgWSBmcm9tICd5anMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCAqIGFzIGNtU3RhdGUgZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnXG5cbmltcG9ydCAqIGFzIGNtVmlldyBmcm9tICdAY29kZW1pcnJvci92aWV3J1xuaW1wb3J0IHsgeVN5bmNGYWNldCwgeVN5bmNBbm5vdGF0aW9uIH0gZnJvbSAnLi95LXN5bmMuanMnXG5pbXBvcnQgeyBZUmFuZ2UgfSBmcm9tICcuL3ktcmFuZ2UuanMnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbmltcG9ydCB7IGNyZWF0ZU11dGV4IH0gZnJvbSAnbGliMC9tdXRleCdcblxuZXhwb3J0IGNsYXNzIFlVbmRvTWFuYWdlckNvbmZpZyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1kuVW5kb01hbmFnZXJ9IHVuZG9NYW5hZ2VyXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodW5kb01hbmFnZXIpIHtcbiAgICB0aGlzLnVuZG9NYW5hZ2VyID0gdW5kb01hbmFnZXJcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gb3JpZ2luXG4gICAqL1xuICBhZGRUcmFja2VkT3JpZ2luIChvcmlnaW4pIHtcbiAgICB0aGlzLnVuZG9NYW5hZ2VyLmFkZFRyYWNrZWRPcmlnaW4ob3JpZ2luKVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICovXG4gIHJlbW92ZVRyYWNrZWRPcmlnaW4gKG9yaWdpbikge1xuICAgIHRoaXMudW5kb01hbmFnZXIucmVtb3ZlVHJhY2tlZE9yaWdpbihvcmlnaW4pXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBhIGNoYW5nZSB3YXMgdW5kb25lLlxuICAgKi9cbiAgdW5kbyAoKSB7XG4gICAgcmV0dXJuIHRoaXMudW5kb01hbmFnZXIudW5kbygpICE9IG51bGxcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIGEgY2hhbmdlIHdhcyByZWRvbmUuXG4gICAqL1xuICByZWRvICgpIHtcbiAgICByZXR1cm4gdGhpcy51bmRvTWFuYWdlci5yZWRvKCkgIT0gbnVsbFxuICB9XG59XG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuRmFjZXQ8WVVuZG9NYW5hZ2VyQ29uZmlnLCBZVW5kb01hbmFnZXJDb25maWc+fVxuICovXG5leHBvcnQgY29uc3QgeVVuZG9NYW5hZ2VyRmFjZXQgPSBjbVN0YXRlLkZhY2V0LmRlZmluZSh7XG4gIGNvbWJpbmUgKGlucHV0cykge1xuICAgIHJldHVybiBpbnB1dHNbaW5wdXRzLmxlbmd0aCAtIDFdXG4gIH1cbn0pXG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuQW5ub3RhdGlvblR5cGU8WVVuZG9NYW5hZ2VyQ29uZmlnPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlVbmRvTWFuYWdlckFubm90YXRpb24gPSBjbVN0YXRlLkFubm90YXRpb24uZGVmaW5lKClcblxuLyoqXG4gKiBAZXh0ZW5kcyB7UGx1Z2luVmFsdWV9XG4gKi9cbmNsYXNzIFlVbmRvTWFuYWdlclBsdWdpblZhbHVlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Y21WaWV3LkVkaXRvclZpZXd9IHZpZXdcbiAgICovXG4gIGNvbnN0cnVjdG9yICh2aWV3KSB7XG4gICAgdGhpcy52aWV3ID0gdmlld1xuICAgIHRoaXMuY29uZiA9IHZpZXcuc3RhdGUuZmFjZXQoeVVuZG9NYW5hZ2VyRmFjZXQpXG4gICAgdGhpcy5fdW5kb01hbmFnZXIgPSB0aGlzLmNvbmYudW5kb01hbmFnZXJcbiAgICB0aGlzLnN5bmNDb25mID0gdmlldy5zdGF0ZS5mYWNldCh5U3luY0ZhY2V0KVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtudWxsIHwgWVJhbmdlfVxuICAgICAqL1xuICAgIHRoaXMuX2JlZm9yZUNoYW5nZVNlbGVjdGlvbiA9IG51bGxcbiAgICB0aGlzLl9tdXggPSBjcmVhdGVNdXRleCgpXG5cbiAgICB0aGlzLl9vblN0YWNrSXRlbUFkZGVkID0gKHsgc3RhY2tJdGVtLCBjaGFuZ2VkUGFyZW50VHlwZXMgfSkgPT4ge1xuICAgICAgLy8gb25seSBzdG9yZSBtZXRhZGF0YSBpZiB0aGlzIHR5cGUgd2FzIGFmZmVjdGVkXG4gICAgICBpZiAoY2hhbmdlZFBhcmVudFR5cGVzLmhhcyh0aGlzLnN5bmNDb25mLnl0ZXh0KSAmJiB0aGlzLl9iZWZvcmVDaGFuZ2VTZWxlY3Rpb24gJiYgIXN0YWNrSXRlbS5tZXRhLmhhcyh0aGlzKSkgeyAvLyBkbyBub3Qgb3ZlcndyaXRlIHByZXZpb3VzIHN0b3JlZCBzZWxlY3Rpb25cbiAgICAgICAgc3RhY2tJdGVtLm1ldGEuc2V0KHRoaXMsIHRoaXMuX2JlZm9yZUNoYW5nZVNlbGVjdGlvbilcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fb25TdGFja0l0ZW1Qb3BwZWQgPSAoeyBzdGFja0l0ZW0gfSkgPT4ge1xuICAgICAgY29uc3Qgc2VsID0gc3RhY2tJdGVtLm1ldGEuZ2V0KHRoaXMpXG4gICAgICBpZiAoc2VsKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHRoaXMuc3luY0NvbmYuZnJvbVlSYW5nZShzZWwpXG4gICAgICAgIHZpZXcuZGlzcGF0Y2godmlldy5zdGF0ZS51cGRhdGUoe1xuICAgICAgICAgIHNlbGVjdGlvbixcbiAgICAgICAgICBlZmZlY3RzOiBbY21WaWV3LkVkaXRvclZpZXcuc2Nyb2xsSW50b1ZpZXcoc2VsZWN0aW9uKV1cbiAgICAgICAgfSkpXG4gICAgICAgIHRoaXMuX3N0b3JlU2VsZWN0aW9uKClcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRG8gdGhpcyB3aXRob3V0IG11dGV4LCBzaW1wbHkgdXNlIHRoZSBzeW5jIGFubm90YXRpb25cbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVNlbGVjdGlvbiA9ICgpID0+IHtcbiAgICAgIC8vIHN0b3JlIHRoZSBzZWxlY3Rpb24gYmVmb3JlIHRoZSBjaGFuZ2UgaXMgYXBwbGllZCBzbyB3ZSBjYW4gcmVzdG9yZSBpdCB3aXRoIHRoZSB1bmRvIG1hbmFnZXIuXG4gICAgICB0aGlzLl9iZWZvcmVDaGFuZ2VTZWxlY3Rpb24gPSB0aGlzLnN5bmNDb25mLnRvWVJhbmdlKHRoaXMudmlldy5zdGF0ZS5zZWxlY3Rpb24ubWFpbilcbiAgICB9XG4gICAgdGhpcy5fdW5kb01hbmFnZXIub24oJ3N0YWNrLWl0ZW0tYWRkZWQnLCB0aGlzLl9vblN0YWNrSXRlbUFkZGVkKVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLm9uKCdzdGFjay1pdGVtLXBvcHBlZCcsIHRoaXMuX29uU3RhY2tJdGVtUG9wcGVkKVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLmFkZFRyYWNrZWRPcmlnaW4odGhpcy5zeW5jQ29uZilcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge2NtVmlldy5WaWV3VXBkYXRlfSB1cGRhdGVcbiAgICovXG4gIHVwZGF0ZSAodXBkYXRlKSB7XG4gICAgaWYgKHVwZGF0ZS5zZWxlY3Rpb25TZXQgJiYgKHVwZGF0ZS50cmFuc2FjdGlvbnMubGVuZ3RoID09PSAwIHx8IHVwZGF0ZS50cmFuc2FjdGlvbnNbMF0uYW5ub3RhdGlvbih5U3luY0Fubm90YXRpb24pICE9PSB0aGlzLnN5bmNDb25mKSkge1xuICAgICAgLy8gVGhpcyBvbmx5IHdvcmtzIHdoZW4gWVVuZG9NYW5hZ2VyUGx1Z2luIGlzIGluY2x1ZGVkIGJlZm9yZSB0aGUgc3luYyBwbHVnaW5cbiAgICAgIHRoaXMuX3N0b3JlU2VsZWN0aW9uKClcbiAgICB9XG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLl91bmRvTWFuYWdlci5vZmYoJ3N0YWNrLWl0ZW0tYWRkZWQnLCB0aGlzLl9vblN0YWNrSXRlbUFkZGVkKVxuICAgIHRoaXMuX3VuZG9NYW5hZ2VyLm9mZignc3RhY2staXRlbS1wb3BwZWQnLCB0aGlzLl9vblN0YWNrSXRlbVBvcHBlZClcbiAgICB0aGlzLl91bmRvTWFuYWdlci5yZW1vdmVUcmFja2VkT3JpZ2luKHRoaXMuc3luY0NvbmYpXG4gIH1cbn1cbmV4cG9ydCBjb25zdCB5VW5kb01hbmFnZXIgPSBjbVZpZXcuVmlld1BsdWdpbi5mcm9tQ2xhc3MoWVVuZG9NYW5hZ2VyUGx1Z2luVmFsdWUpXG5cbi8qKlxuICogQHR5cGUge2NtU3RhdGUuU3RhdGVDb21tYW5kfVxuICovXG5leHBvcnQgY29uc3QgdW5kbyA9ICh7IHN0YXRlLCBkaXNwYXRjaCB9KSA9PlxuICBzdGF0ZS5mYWNldCh5VW5kb01hbmFnZXJGYWNldCkudW5kbygpIHx8IHRydWVcblxuLyoqXG4gKiBAdHlwZSB7Y21TdGF0ZS5TdGF0ZUNvbW1hbmR9XG4gKi9cbmV4cG9ydCBjb25zdCByZWRvID0gKHsgc3RhdGUsIGRpc3BhdGNoIH0pID0+XG4gIHN0YXRlLmZhY2V0KHlVbmRvTWFuYWdlckZhY2V0KS5yZWRvKCkgfHwgdHJ1ZVxuXG4vKipcbiAqIEBwYXJhbSB7Y21TdGF0ZS5FZGl0b3JTdGF0ZX0gc3RhdGVcbiAqIEByZXR1cm4ge251bWJlcn1cbiAqL1xuZXhwb3J0IGNvbnN0IHVuZG9EZXB0aCA9IHN0YXRlID0+IHN0YXRlLmZhY2V0KHlVbmRvTWFuYWdlckZhY2V0KS51bmRvTWFuYWdlci51bmRvU3RhY2subGVuZ3RoXG5cbi8qKlxuICogQHBhcmFtIHtjbVN0YXRlLkVkaXRvclN0YXRlfSBzdGF0ZVxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5leHBvcnQgY29uc3QgcmVkb0RlcHRoID0gc3RhdGUgPT4gc3RhdGUuZmFjZXQoeVVuZG9NYW5hZ2VyRmFjZXQpLnVuZG9NYW5hZ2VyLnJlZG9TdGFjay5sZW5ndGhcblxuLyoqXG4gKiBEZWZhdWx0IGtleSBiaW5kaWdzIGZvciB0aGUgdW5kbyBtYW5hZ2VyLlxuICogQHR5cGUge0FycmF5PGNtVmlldy5LZXlCaW5kaW5nPn1cbiAqL1xuZXhwb3J0IGNvbnN0IHlVbmRvTWFuYWdlcktleW1hcCA9IFtcbiAgeyBrZXk6ICdNb2QteicsIHJ1bjogdW5kbywgcHJldmVudERlZmF1bHQ6IHRydWUgfSxcbiAgeyBrZXk6ICdNb2QteScsIG1hYzogJ01vZC1TaGlmdC16JywgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9LFxuICB7IGtleTogJ01vZC1TaGlmdC16JywgcnVuOiByZWRvLCBwcmV2ZW50RGVmYXVsdDogdHJ1ZSB9XG5dXG4iLCAiLyoqXG4gKiBNdXR1YWwgZXhjbHVkZSBmb3IgSmF2YVNjcmlwdC5cbiAqXG4gKiBAbW9kdWxlIG11dGV4XG4gKi9cblxuLyoqXG4gKiBAY2FsbGJhY2sgbXV0ZXhcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBjYiBPbmx5IGV4ZWN1dGVkIHdoZW4gdGhpcyBtdXRleCBpcyBub3QgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTp2b2lkfSBbZWxzZUNiXSBFeGVjdXRlZCB3aGVuIHRoaXMgbXV0ZXggaXMgaW4gdGhlIGN1cnJlbnQgc3RhY2tcbiAqL1xuXG4vKipcbiAqIENyZWF0ZXMgYSBtdXR1YWwgZXhjbHVkZSBmdW5jdGlvbiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydHk6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG11dGV4ID0gY3JlYXRlTXV0ZXgoKVxuICogbXV0ZXgoKCkgPT4ge1xuICogICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGltbWVkaWF0ZWx5IGV4ZWN1dGVkXG4gKiAgIG11dGV4KCgpID0+IHtcbiAqICAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG5vdCBleGVjdXRlZCwgYXMgdGhlIG11dGV4IGlzIGFscmVhZHkgYWN0aXZlLlxuICogICB9KVxuICogfSlcbiAqIGBgYFxuICpcbiAqIEByZXR1cm4ge211dGV4fSBBIG11dHVhbCBleGNsdWRlIGZ1bmN0aW9uXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVNdXRleCA9ICgpID0+IHtcbiAgbGV0IHRva2VuID0gdHJ1ZVxuICByZXR1cm4gKGYsIGcpID0+IHtcbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIHRva2VuID0gZmFsc2VcbiAgICAgIHRyeSB7XG4gICAgICAgIGYoKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdG9rZW4gPSB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChnICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGcoKVxuICAgIH1cbiAgfVxufVxuIiwgImltcG9ydCAqIGFzIG9ic2VydmFibGUgZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuXG50eXBlIEV2ZW50czxWYWx1ZT4gPSB7XG4gIGFkZDogKGtleTogc3RyaW5nLCB2YWx1ZTogVmFsdWUpID0+IHZvaWQsXG4gIHVwZGF0ZTogKGtleTogc3RyaW5nLCBvbGRWYWx1ZTogVmFsdWUsIG5ld1ZhbHVlOiBWYWx1ZSkgPT4gdm9pZCxcbiAgZGVsZXRlOiAoa2V5OiBzdHJpbmcsIG9sZFZhbHVlOiBWYWx1ZSkgPT4gdm9pZFxufVxuXG5leHBvcnQgY2xhc3MgUGVlcmRyYWZ0UmVjb3JkPFZhbHVlPiBleHRlbmRzIG9ic2VydmFibGUuT2JzZXJ2YWJsZVYyPEV2ZW50czxWYWx1ZT4+IHtcbiAgcHJpdmF0ZSByZWNvcmQ6IFJlY29yZDxzdHJpbmcsIFZhbHVlPiA9IHt9XG5cbiAgcHVibGljIHNldChrZXk6IHN0cmluZywgdmFsdWU6IFZhbHVlKSB7XG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnJlY29yZFtrZXldXG4gICAgdGhpcy5yZWNvcmRba2V5XSA9IHZhbHVlXG4gICAgaWYgKG9sZFZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuZW1pdCgnYWRkJywgW2tleSwgdmFsdWVdKVxuICAgIH0gZWxzZSBpZiAob2xkVmFsdWUgIT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW2tleSwgb2xkVmFsdWUsIHZhbHVlXSlcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgZ2V0KGtleTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb3JkW2tleV1cbiAgfVxuXG4gIHB1YmxpYyBkZWxldGUoa2V5OiBzdHJpbmcpIHtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IHRoaXMucmVjb3JkW2tleV1cbiAgICBkZWxldGUgdGhpcy5yZWNvcmRba2V5XVxuICAgIHRoaXMuZW1pdCgnZGVsZXRlJywgW2tleSwgb2xkVmFsdWVdKVxuICB9XG5cbiAgcHVibGljIGdldCBzaXplKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnJlY29yZCkubGVuZ3RoXG4gIH1cblxuICBwdWJsaWMgZ2V0IGtleXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMucmVjb3JkKVxuICB9XG59IiwgImltcG9ydCAqIGFzIG9ic2VydmFibGUgZnJvbSAnbGliMC9vYnNlcnZhYmxlJ1xuXG50eXBlIEV2ZW50cyA9IHtcbiAgY2hhbmdlSXNQcmV2aWV3OiAob2xkTW9kZTogYm9vbGVhbiwgbmV3TW9kZTogYm9vbGVhbikgPT4gdm9pZCxcbiAgY2hhbmdlUGF0aDogKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjbGFzcyBQZWVyZHJhZnRMZWFmIGV4dGVuZHMgb2JzZXJ2YWJsZS5PYnNlcnZhYmxlVjI8RXZlbnRzPiB7XG4gIHByaXZhdGUgX2lzUHJldmlldzogYm9vbGVhblxuICBwcml2YXRlIF9wYXRoOiBzdHJpbmdcblxuICBjb25zdHJ1Y3RvcihwYXRoOiBzdHJpbmcsIGlzUHJldmlldzogYm9vbGVhbikge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLl9pc1ByZXZpZXcgPSBpc1ByZXZpZXcsXG4gICAgdGhpcy5fcGF0aCA9IHBhdGhcbiAgfVxuXG4gIGdldCBpc1ByZXZpZXcgKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1ByZXZpZXdcbiAgfVxuXG4gIHNldCBpc1ByZXZpZXcgKHZhbHVlOiBib29sZWFuKSB7XG4gICAgY29uc3Qgb2xkID0gdGhpcy5faXNQcmV2aWV3XG4gICAgdGhpcy5faXNQcmV2aWV3ID0gdmFsdWVcbiAgICBpZiAodmFsdWUgIT0gb2xkKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZUlzUHJldmlldycsIFtvbGQsIHZhbHVlXSlcbiAgICB9XG4gIH1cblxuICBnZXQgcGF0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF0aFxuICB9XG5cbiAgc2V0IHBhdGggKHZhbHVlOiBzdHJpbmcpIHtcbiAgICBjb25zdCBvbGQgPSB0aGlzLl9wYXRoXG4gICAgdGhpcy5fcGF0aCA9IHZhbHVlXG4gICAgaWYgKHZhbHVlICE9IG9sZCkge1xuICAgICAgdGhpcy5lbWl0KCdjaGFuZ2VQYXRoJywgW29sZCwgdmFsdWVdKVxuICAgIH1cbiAgfVxuXG59IiwgImltcG9ydCB7IFBlZXJkcmFmdFJlY29yZCB9IGZyb20gXCJzcmMvdXRpbHMvcGVlcmRyYWZ0UmVjb3JkXCI7XG5pbXBvcnQgeyBQZWVyZHJhZnRMZWFmIH0gZnJvbSBcIi4vcGVlcmRyYWZ0TGVhZlwiO1xuaW1wb3J0IHsgTWFya2Rvd25WaWV3LCBXb3Jrc3BhY2UsIG5vcm1hbGl6ZVBhdGggfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGNvbnN0IHVwZGF0ZVBlZXJkcmFmdFdvcmtzcGFjZSA9ICh3czogV29ya3NwYWNlLCBwd3M6IFBlZXJkcmFmdFJlY29yZDxQZWVyZHJhZnRMZWFmPikgPT4ge1xuICBjb25zdCBsZWFmcyA9IHdzLmdldExlYXZlc09mVHlwZShcIm1hcmtkb3duXCIpXG4gIFxuICBjb25zdCBvbGRMZWFmSWRzID0gcHdzLmtleXNcbiAgY29uc3QgZXhpc3RpbmdMZWFmSWRzID0gbGVhZnMubWFwKGxlYWYgPT4ge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICByZXR1cm4gbGVhZi5pZCBhcyBzdHJpbmdcbiAgfSlcblxuICBmb3IgKGNvbnN0IGxlYWYgb2YgbGVhZnMpIHtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgbGVhZklkID0gbGVhZi5pZCBhcyBzdHJpbmdcblxuICAgIGNvbnN0IGlzUHJldmlldyA9IGxlYWYudmlldy5jb250YWluZXJFbC5nZXRBdHRyaWJ1dGUoXCJkYXRhLW1vZGVcIikgPT09IFwicHJldmlld1wiXG4gICAgY29uc3QgcGF0aCA9IChsZWFmLnZpZXcgYXMgKE1hcmtkb3duVmlldykpLmZpbGU/LnBhdGggPz8gJydcblxuICAgIGxldCBwbGVhZiA9IHB3cy5nZXQobGVhZklkKVxuICAgIGlmIChwbGVhZikge1xuICAgICAgcGxlYWYuaXNQcmV2aWV3ID0gaXNQcmV2aWV3XG4gICAgICBwbGVhZi5wYXRoID0gcGF0aFxuICAgIH0gZWxzZSB7XG4gICAgICBwbGVhZiA9IG5ldyBQZWVyZHJhZnRMZWFmKHBhdGgsIGlzUHJldmlldylcbiAgICAgIHB3cy5zZXQobGVhZklkLCBwbGVhZilcbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IG9sZExlYWZJZCBvZiBvbGRMZWFmSWRzKSB7IFxuICAgIGlmKCFleGlzdGluZ0xlYWZJZHMuY29udGFpbnMob2xkTGVhZklkKSkge1xuICAgICAgcHdzLmRlbGV0ZShvbGRMZWFmSWQpXG4gICAgfVxuICB9XG5cbn1cblxuZXhwb3J0IGNvbnN0IGdldExlYWZzQnlQYXRoID0gKHBhdGg6IHN0cmluZywgcHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4pID0+IHtcbiAgcmV0dXJuIHB3cy5rZXlzLm1hcCgoa2V5KSA9PiB7XG4gICAgcmV0dXJuIHB3cy5nZXQoa2V5KVxuICB9KS5maWx0ZXIoKGxlYWYpID0+IHtcbiAgICByZXR1cm4gbGVhZi5wYXRoID09PSBwYXRoXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCBnZXRMZWFmSWRzQnlQYXRoID0gKHBhdGg6IHN0cmluZywgcHdzOiBQZWVyZHJhZnRSZWNvcmQ8UGVlcmRyYWZ0TGVhZj4pID0+IHtcbiAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKHBhdGgpXG4gIHJldHVybiBwd3Mua2V5cy5maWx0ZXIoKGtleSkgPT4ge1xuICAgIHJldHVybiBub3JtYWxpemVQYXRoKHB3cy5nZXQoa2V5KS5wYXRoKSA9PT0gbm9ybWFsaXplZFBhdGhcbiAgfSlcbn0iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGlueSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBoYW5kbGVyLlxuICpcbiAqIEltcGxlbWVudHMgZXhwb25lbnRpYWwgYmFja29mZiByZWNvbm5lY3RzLCBwaW5nL3BvbmcsIGFuZCBhIG5pY2UgZXZlbnQgc3lzdGVtIHVzaW5nIFtsaWIwL29ic2VydmFibGVdLlxuICpcbiAqIEBtb2R1bGUgd2Vic29ja2V0XG4gKi9cblxuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJy4vb2JzZXJ2YWJsZS5qcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnLi90aW1lLmpzJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICcuL21hdGguanMnXG5cbmNvbnN0IHJlY29ubmVjdFRpbWVvdXRCYXNlID0gMTIwMFxuY29uc3QgbWF4UmVjb25uZWN0VGltZW91dCA9IDI1MDBcbi8vIEB0b2RvIC0gdGhpcyBzaG91bGQgZGVwZW5kIG9uIGF3YXJlbmVzcy5vdXRkYXRlZFRpbWVcbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuLyoqXG4gKiBAcGFyYW0ge1dlYnNvY2tldENsaWVudH0gd3NjbGllbnRcbiAqL1xuY29uc3Qgc2V0dXBXUyA9ICh3c2NsaWVudCkgPT4ge1xuICBpZiAod3NjbGllbnQuc2hvdWxkQ29ubmVjdCAmJiB3c2NsaWVudC53cyA9PT0gbnVsbCkge1xuICAgIGNvbnN0IHdlYnNvY2tldCA9IG5ldyBXZWJTb2NrZXQod3NjbGllbnQudXJsKVxuICAgIGNvbnN0IGJpbmFyeVR5cGUgPSB3c2NsaWVudC5iaW5hcnlUeXBlXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICBsZXQgcGluZ1RpbWVvdXQgPSBudWxsXG4gICAgaWYgKGJpbmFyeVR5cGUpIHtcbiAgICAgIHdlYnNvY2tldC5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZVxuICAgIH1cbiAgICB3c2NsaWVudC53cyA9IHdlYnNvY2tldFxuICAgIHdzY2xpZW50LmNvbm5lY3RpbmcgPSB0cnVlXG4gICAgd3NjbGllbnQuY29ubmVjdGVkID0gZmFsc2VcbiAgICB3ZWJzb2NrZXQub25tZXNzYWdlID0gZXZlbnQgPT4ge1xuICAgICAgd3NjbGllbnQubGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgY29uc3QgZGF0YSA9IGV2ZW50LmRhdGFcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGRhdGEpIDogZGF0YVxuICAgICAgaWYgKG1lc3NhZ2UgJiYgbWVzc2FnZS50eXBlID09PSAncG9uZycpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHBpbmdUaW1lb3V0KVxuICAgICAgICBwaW5nVGltZW91dCA9IHNldFRpbWVvdXQoc2VuZFBpbmcsIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMilcbiAgICAgIH1cbiAgICAgIHdzY2xpZW50LmVtaXQoJ21lc3NhZ2UnLCBbbWVzc2FnZSwgd3NjbGllbnRdKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FueX0gZXJyb3JcbiAgICAgKi9cbiAgICBjb25zdCBvbmNsb3NlID0gZXJyb3IgPT4ge1xuICAgICAgaWYgKHdzY2xpZW50LndzICE9PSBudWxsKSB7XG4gICAgICAgIHdzY2xpZW50LndzID0gbnVsbFxuICAgICAgICB3c2NsaWVudC5jb25uZWN0aW5nID0gZmFsc2VcbiAgICAgICAgaWYgKHdzY2xpZW50LmNvbm5lY3RlZCkge1xuICAgICAgICAgIHdzY2xpZW50LmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgICAgd3NjbGllbnQuZW1pdCgnZGlzY29ubmVjdCcsIFt7IHR5cGU6ICdkaXNjb25uZWN0JywgZXJyb3IgfSwgd3NjbGllbnRdKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdzY2xpZW50LnVuc3VjY2Vzc2Z1bFJlY29ubmVjdHMrK1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0YXJ0IHdpdGggbm8gcmVjb25uZWN0IHRpbWVvdXQgYW5kIGluY3JlYXNlIHRpbWVvdXQgYnlcbiAgICAgICAgLy8gbG9nMTAod3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKS5cbiAgICAgICAgLy8gVGhlIGlkZWEgaXMgdG8gaW5jcmVhc2UgcmVjb25uZWN0IHRpbWVvdXQgc2xvd2x5IGFuZCBoYXZlIG5vIHJlY29ubmVjdFxuICAgICAgICAvLyB0aW1lb3V0IGF0IHRoZSBiZWdpbm5pbmcgKGxvZygxKSA9IDApXG4gICAgICAgIHNldFRpbWVvdXQoc2V0dXBXUywgbWF0aC5taW4obWF0aC5sb2cxMCh3c2NsaWVudC51bnN1Y2Nlc3NmdWxSZWNvbm5lY3RzICsgMSkgKiByZWNvbm5lY3RUaW1lb3V0QmFzZSwgbWF4UmVjb25uZWN0VGltZW91dCksIHdzY2xpZW50KVxuICAgICAgfVxuICAgICAgY2xlYXJUaW1lb3V0KHBpbmdUaW1lb3V0KVxuICAgIH1cbiAgICBjb25zdCBzZW5kUGluZyA9ICgpID0+IHtcbiAgICAgIGlmICh3c2NsaWVudC53cyA9PT0gd2Vic29ja2V0KSB7XG4gICAgICAgIHdzY2xpZW50LnNlbmQoe1xuICAgICAgICAgIHR5cGU6ICdwaW5nJ1xuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9ICgpID0+IG9uY2xvc2UobnVsbClcbiAgICB3ZWJzb2NrZXQub25lcnJvciA9IGVycm9yID0+IG9uY2xvc2UoZXJyb3IpXG4gICAgd2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgIHdzY2xpZW50Lmxhc3RNZXNzYWdlUmVjZWl2ZWQgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIHdzY2xpZW50LmNvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgd3NjbGllbnQuY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgd3NjbGllbnQudW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICAgIHdzY2xpZW50LmVtaXQoJ2Nvbm5lY3QnLCBbeyB0eXBlOiAnY29ubmVjdCcgfSwgd3NjbGllbnRdKVxuICAgICAgLy8gc2V0IHBpbmdcbiAgICAgIHBpbmdUaW1lb3V0ID0gc2V0VGltZW91dChzZW5kUGluZywgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAyKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkXG4gKiBAZXh0ZW5kcyBPYnNlcnZhYmxlPHN0cmluZz5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYnNvY2tldENsaWVudCBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge29iamVjdH0gb3B0c1xuICAgKiBAcGFyYW0geydhcnJheWJ1ZmZlcicgfCAnYmxvYicgfCBudWxsfSBbb3B0cy5iaW5hcnlUeXBlXSBTZXQgYHdzLmJpbmFyeVR5cGVgXG4gICAqL1xuICBjb25zdHJ1Y3RvciAodXJsLCB7IGJpbmFyeVR5cGUgfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudXJsID0gdXJsXG4gICAgLyoqXG4gICAgICogQHR5cGUge1dlYlNvY2tldD99XG4gICAgICovXG4gICAgdGhpcy53cyA9IG51bGxcbiAgICB0aGlzLmJpbmFyeVR5cGUgPSBiaW5hcnlUeXBlIHx8IG51bGxcbiAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy5jb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLnVuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgdGhpcy5sYXN0TWVzc2FnZVJlY2VpdmVkID0gMFxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gY29ubmVjdCB0byBvdGhlciBwZWVycyBvciBub3RcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSB0cnVlXG4gICAgdGhpcy5fY2hlY2tJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCAmJiBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA8IHRpbWUuZ2V0VW5peFRpbWUoKSAtIHRoaXMubGFzdE1lc3NhZ2VSZWNlaXZlZCkge1xuICAgICAgICAvLyBubyBtZXNzYWdlIHJlY2VpdmVkIGluIGEgbG9uZyB0aW1lIC0gbm90IGV2ZW4geW91ciBvd24gYXdhcmVuZXNzXG4gICAgICAgIC8vIHVwZGF0ZXMgKHdoaWNoIGFyZSB1cGRhdGVkIGV2ZXJ5IDE1IHNlY29uZHMpXG4gICAgICAgIC8qKiBAdHlwZSB7V2ViU29ja2V0fSAqLyAodGhpcy53cykuY2xvc2UoKVxuICAgICAgfVxuICAgIH0sIG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0IC8gMilcbiAgICBzZXR1cFdTKHRoaXMpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IG1lc3NhZ2VcbiAgICovXG4gIHNlbmQgKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy53cykge1xuICAgICAgdGhpcy53cy5zZW5kKEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgZGlzY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICBpZiAodGhpcy53cyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy53cy5jbG9zZSgpXG4gICAgfVxuICB9XG5cbiAgY29ubmVjdCAoKSB7XG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gdHJ1ZVxuICAgIGlmICghdGhpcy5jb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgIH1cbiAgfVxufVxuIiwgIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIEhlbHBlcnMgZm9yIGNyb3NzLXRhYiBjb21tdW5pY2F0aW9uIHVzaW5nIGJyb2FkY2FzdGNoYW5uZWwgd2l0aCBMb2NhbFN0b3JhZ2UgZmFsbGJhY2suXG4gKlxuICogYGBganNcbiAqIC8vIEluIGJyb3dzZXIgd2luZG93IEE6XG4gKiBicm9hZGNhc3RjaGFubmVsLnN1YnNjcmliZSgnbXkgZXZlbnRzJywgZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSlcbiAqIGJyb2FkY2FzdGNoYW5uZWwucHVibGlzaCgnbXkgZXZlbnRzJywgJ0hlbGxvIHdvcmxkIScpIC8vID0+IEE6ICdIZWxsbyB3b3JsZCEnIGZpcmVzIHN5bmNocm9ub3VzbHkgaW4gc2FtZSB0YWJcbiAqXG4gKiAvLyBJbiBicm93c2VyIHdpbmRvdyBCOlxuICogYnJvYWRjYXN0Y2hhbm5lbC5wdWJsaXNoKCdteSBldmVudHMnLCAnaGVsbG8gZnJvbSB0YWIgQicpIC8vID0+IEE6ICdoZWxsbyBmcm9tIHRhYiBCJ1xuICogYGBgXG4gKlxuICogQG1vZHVsZSBicm9hZGNhc3RjaGFubmVsXG4gKi9cblxuLy8gQHRvZG8gYmVmb3JlIG5leHQgbWFqb3I6IHVzZSBVaW50OEFycmF5IGluc3RlYWQgYXMgYnVmZmVyIG9iamVjdFxuXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnLi9tYXAuanMnXG5pbXBvcnQgKiBhcyBzZXQgZnJvbSAnLi9zZXQuanMnXG5pbXBvcnQgKiBhcyBidWZmZXIgZnJvbSAnLi9idWZmZXIuanMnXG5pbXBvcnQgKiBhcyBzdG9yYWdlIGZyb20gJy4vc3RvcmFnZS5qcydcblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDaGFubmVsXG4gKiBAcHJvcGVydHkge1NldDxmdW5jdGlvbihhbnksIGFueSk6YW55Pn0gQ2hhbm5lbC5zdWJzXG4gKiBAcHJvcGVydHkge2FueX0gQ2hhbm5lbC5iY1xuICovXG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsIENoYW5uZWw+fVxuICovXG5jb25zdCBjaGFubmVscyA9IG5ldyBNYXAoKVxuXG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNsYXNzIExvY2FsU3RvcmFnZVBvbHlmaWxsIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gICAqL1xuICBjb25zdHJ1Y3RvciAocm9vbSkge1xuICAgIHRoaXMucm9vbSA9IHJvb21cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7bnVsbHxmdW5jdGlvbih7ZGF0YTpBcnJheUJ1ZmZlcn0pOnZvaWR9XG4gICAgICovXG4gICAgdGhpcy5vbm1lc3NhZ2UgPSBudWxsXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHthbnl9IGVcbiAgICAgKi9cbiAgICB0aGlzLl9vbkNoYW5nZSA9IGUgPT4gZS5rZXkgPT09IHJvb20gJiYgdGhpcy5vbm1lc3NhZ2UgIT09IG51bGwgJiYgdGhpcy5vbm1lc3NhZ2UoeyBkYXRhOiBidWZmZXIuZnJvbUJhc2U2NChlLm5ld1ZhbHVlIHx8ICcnKSB9KVxuICAgIHN0b3JhZ2Uub25DaGFuZ2UodGhpcy5fb25DaGFuZ2UpXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYnVmXG4gICAqL1xuICBwb3N0TWVzc2FnZSAoYnVmKSB7XG4gICAgc3RvcmFnZS52YXJTdG9yYWdlLnNldEl0ZW0odGhpcy5yb29tLCBidWZmZXIudG9CYXNlNjQoYnVmZmVyLmNyZWF0ZVVpbnQ4QXJyYXlGcm9tQXJyYXlCdWZmZXIoYnVmKSkpXG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgc3RvcmFnZS5vZmZDaGFuZ2UodGhpcy5fb25DaGFuZ2UpXG4gIH1cbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5cbi8vIFVzZSBCcm9hZGNhc3RDaGFubmVsIG9yIFBvbHlmaWxsXG4vKiBjOCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgQkMgPSB0eXBlb2YgQnJvYWRjYXN0Q2hhbm5lbCA9PT0gJ3VuZGVmaW5lZCcgPyBMb2NhbFN0b3JhZ2VQb2x5ZmlsbCA6IEJyb2FkY2FzdENoYW5uZWxcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHJldHVybiB7Q2hhbm5lbH1cbiAqL1xuY29uc3QgZ2V0Q2hhbm5lbCA9IHJvb20gPT5cbiAgbWFwLnNldElmVW5kZWZpbmVkKGNoYW5uZWxzLCByb29tLCAoKSA9PiB7XG4gICAgY29uc3Qgc3VicyA9IHNldC5jcmVhdGUoKVxuICAgIGNvbnN0IGJjID0gbmV3IEJDKHJvb20pXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHt7ZGF0YTpBcnJheUJ1ZmZlcn19IGVcbiAgICAgKi9cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIGJjLm9ubWVzc2FnZSA9IGUgPT4gc3Vicy5mb3JFYWNoKHN1YiA9PiBzdWIoZS5kYXRhLCAnYnJvYWRjYXN0Y2hhbm5lbCcpKVxuICAgIHJldHVybiB7XG4gICAgICBiYywgc3Vic1xuICAgIH1cbiAgfSlcblxuLyoqXG4gKiBTdWJzY3JpYmUgdG8gZ2xvYmFsIGBwdWJsaXNoYCBldmVudHMuXG4gKlxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9vbVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnksIGFueSk6YW55fSBmXG4gKi9cbmV4cG9ydCBjb25zdCBzdWJzY3JpYmUgPSAocm9vbSwgZikgPT4ge1xuICBnZXRDaGFubmVsKHJvb20pLnN1YnMuYWRkKGYpXG4gIHJldHVybiBmXG59XG5cbi8qKlxuICogVW5zdWJzY3JpYmUgZnJvbSBgcHVibGlzaGAgZ2xvYmFsIGV2ZW50cy5cbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKGFueSwgYW55KTphbnl9IGZcbiAqL1xuZXhwb3J0IGNvbnN0IHVuc3Vic2NyaWJlID0gKHJvb20sIGYpID0+IHtcbiAgY29uc3QgY2hhbm5lbCA9IGdldENoYW5uZWwocm9vbSlcbiAgY29uc3QgdW5zdWJzY3JpYmVkID0gY2hhbm5lbC5zdWJzLmRlbGV0ZShmKVxuICBpZiAodW5zdWJzY3JpYmVkICYmIGNoYW5uZWwuc3Vicy5zaXplID09PSAwKSB7XG4gICAgY2hhbm5lbC5iYy5jbG9zZSgpXG4gICAgY2hhbm5lbHMuZGVsZXRlKHJvb20pXG4gIH1cbiAgcmV0dXJuIHVuc3Vic2NyaWJlZFxufVxuXG4vKipcbiAqIFB1Ymxpc2ggZGF0YSB0byBhbGwgc3Vic2NyaWJlcnMgKGluY2x1ZGluZyBzdWJzY3JpYmVycyBvbiB0aGlzIHRhYilcbiAqXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tXG4gKiBAcGFyYW0ge2FueX0gZGF0YVxuICogQHBhcmFtIHthbnl9IFtvcmlnaW5dXG4gKi9cbmV4cG9ydCBjb25zdCBwdWJsaXNoID0gKHJvb20sIGRhdGEsIG9yaWdpbiA9IG51bGwpID0+IHtcbiAgY29uc3QgYyA9IGdldENoYW5uZWwocm9vbSlcbiAgYy5iYy5wb3N0TWVzc2FnZShkYXRhKVxuICBjLnN1YnMuZm9yRWFjaChzdWIgPT4gc3ViKGRhdGEsIG9yaWdpbikpXG59XG4iLCAiaW1wb3J0ICogYXMgd3MgZnJvbSAnbGliMC93ZWJzb2NrZXQnXG5pbXBvcnQgKiBhcyBtYXAgZnJvbSAnbGliMC9tYXAnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgcmFuZG9tIGZyb20gJ2xpYjAvcmFuZG9tJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gJ2xpYjAvbG9nZ2luZydcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJ1xuaW1wb3J0ICogYXMgYmMgZnJvbSAnbGliMC9icm9hZGNhc3RjaGFubmVsJ1xuaW1wb3J0ICogYXMgYnVmZmVyIGZyb20gJ2xpYjAvYnVmZmVyJ1xuaW1wb3J0ICogYXMgbWF0aCBmcm9tICdsaWIwL21hdGgnXG5pbXBvcnQgeyBjcmVhdGVNdXRleCB9IGZyb20gJ2xpYjAvbXV0ZXgnXG5cbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5pbXBvcnQgUGVlciBmcm9tICdzaW1wbGUtcGVlci9zaW1wbGVwZWVyLm1pbi5qcydcblxuaW1wb3J0ICogYXMgc3luY1Byb3RvY29sIGZyb20gJ3ktcHJvdG9jb2xzL3N5bmMnXG5pbXBvcnQgKiBhcyBhd2FyZW5lc3NQcm90b2NvbCBmcm9tICd5LXByb3RvY29scy9hd2FyZW5lc3MnXG5cbmltcG9ydCAqIGFzIGNyeXB0b3V0aWxzIGZyb20gJy4vY3J5cHRvLmpzJ1xuXG5jb25zdCBsb2cgPSBsb2dnaW5nLmNyZWF0ZU1vZHVsZUxvZ2dlcigneS13ZWJydGMnKVxuXG5jb25zdCBtZXNzYWdlU3luYyA9IDBcbmNvbnN0IG1lc3NhZ2VRdWVyeUF3YXJlbmVzcyA9IDNcbmNvbnN0IG1lc3NhZ2VBd2FyZW5lc3MgPSAxXG5jb25zdCBtZXNzYWdlQmNQZWVySWQgPSA0XG5cbi8qKlxuICogQHR5cGUge01hcDxzdHJpbmcsIFNpZ25hbGluZ0Nvbm4+fVxuICovXG5jb25zdCBzaWduYWxpbmdDb25ucyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIEB0eXBlIHtNYXA8c3RyaW5nLFJvb20+fVxuICovXG5jb25zdCByb29tcyA9IG5ldyBNYXAoKVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICovXG5jb25zdCBjaGVja0lzU3luY2VkID0gcm9vbSA9PiB7XG4gIGxldCBzeW5jZWQgPSB0cnVlXG4gIHJvb20ud2VicnRjQ29ubnMuZm9yRWFjaChwZWVyID0+IHtcbiAgICBpZiAoIXBlZXIuc3luY2VkKSB7XG4gICAgICBzeW5jZWQgPSBmYWxzZVxuICAgIH1cbiAgfSlcbiAgaWYgKCghc3luY2VkICYmIHJvb20uc3luY2VkKSB8fCAoc3luY2VkICYmICFyb29tLnN5bmNlZCkpIHtcbiAgICByb29tLnN5bmNlZCA9IHN5bmNlZFxuICAgIHJvb20ucHJvdmlkZXIuZW1pdCgnc3luY2VkJywgW3sgc3luY2VkIH1dKVxuICAgIGxvZygnc3luY2VkICcsIGxvZ2dpbmcuQk9MRCwgcm9vbS5uYW1lLCBsb2dnaW5nLlVOQk9MRCwgJyB3aXRoIGFsbCBwZWVycycpXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Jvb219IHJvb21cbiAqIEBwYXJhbSB7VWludDhBcnJheX0gYnVmXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzeW5jZWRDYWxsYmFja1xuICogQHJldHVybiB7ZW5jb2RpbmcuRW5jb2Rlcj99XG4gKi9cbmNvbnN0IHJlYWRNZXNzYWdlID0gKHJvb20sIGJ1Ziwgc3luY2VkQ2FsbGJhY2spID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIoYnVmKVxuICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgaWYgKHJvb20gPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsXG4gIH1cbiAgY29uc3QgYXdhcmVuZXNzID0gcm9vbS5hd2FyZW5lc3NcbiAgY29uc3QgZG9jID0gcm9vbS5kb2NcbiAgbGV0IHNlbmRSZXBseSA9IGZhbHNlXG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlIG1lc3NhZ2VTeW5jOiB7XG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICBjb25zdCBzeW5jTWVzc2FnZVR5cGUgPSBzeW5jUHJvdG9jb2wucmVhZFN5bmNNZXNzYWdlKGRlY29kZXIsIGVuY29kZXIsIGRvYywgcm9vbSlcbiAgICAgIGlmIChzeW5jTWVzc2FnZVR5cGUgPT09IHN5bmNQcm90b2NvbC5tZXNzYWdlWWpzU3luY1N0ZXAyICYmICFyb29tLnN5bmNlZCkge1xuICAgICAgICBzeW5jZWRDYWxsYmFjaygpXG4gICAgICB9XG4gICAgICBpZiAoc3luY01lc3NhZ2VUeXBlID09PSBzeW5jUHJvdG9jb2wubWVzc2FnZVlqc1N5bmNTdGVwMSkge1xuICAgICAgICBzZW5kUmVwbHkgPSB0cnVlXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIH1cbiAgICBjYXNlIG1lc3NhZ2VRdWVyeUF3YXJlbmVzczpcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIEFycmF5LmZyb20oYXdhcmVuZXNzLmdldFN0YXRlcygpLmtleXMoKSkpKVxuICAgICAgc2VuZFJlcGx5ID0gdHJ1ZVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VBd2FyZW5lc3M6XG4gICAgICBhd2FyZW5lc3NQcm90b2NvbC5hcHBseUF3YXJlbmVzc1VwZGF0ZShhd2FyZW5lc3MsIGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpLCByb29tKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VCY1BlZXJJZDoge1xuICAgICAgY29uc3QgYWRkID0gZGVjb2RpbmcucmVhZFVpbnQ4KGRlY29kZXIpID09PSAxXG4gICAgICBjb25zdCBwZWVyTmFtZSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgIGlmIChwZWVyTmFtZSAhPT0gcm9vbS5wZWVySWQgJiYgKChyb29tLmJjQ29ubnMuaGFzKHBlZXJOYW1lKSAmJiAhYWRkKSB8fCAoIXJvb20uYmNDb25ucy5oYXMocGVlck5hbWUpICYmIGFkZCkpKSB7XG4gICAgICAgIGNvbnN0IHJlbW92ZWQgPSBbXVxuICAgICAgICBjb25zdCBhZGRlZCA9IFtdXG4gICAgICAgIGlmIChhZGQpIHtcbiAgICAgICAgICByb29tLmJjQ29ubnMuYWRkKHBlZXJOYW1lKVxuICAgICAgICAgIGFkZGVkLnB1c2gocGVlck5hbWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcm9vbS5iY0Nvbm5zLmRlbGV0ZShwZWVyTmFtZSlcbiAgICAgICAgICByZW1vdmVkLnB1c2gocGVlck5hbWUpXG4gICAgICAgIH1cbiAgICAgICAgcm9vbS5wcm92aWRlci5lbWl0KCdwZWVycycsIFt7XG4gICAgICAgICAgYWRkZWQsXG4gICAgICAgICAgcmVtb3ZlZCxcbiAgICAgICAgICB3ZWJydGNQZWVyczogQXJyYXkuZnJvbShyb29tLndlYnJ0Y0Nvbm5zLmtleXMoKSksXG4gICAgICAgICAgYmNQZWVyczogQXJyYXkuZnJvbShyb29tLmJjQ29ubnMpXG4gICAgICAgIH1dKVxuICAgICAgICBicm9hZGNhc3RCY1BlZXJJZChyb29tKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1VuYWJsZSB0byBjb21wdXRlIG1lc3NhZ2UnKVxuICAgICAgcmV0dXJuIGVuY29kZXJcbiAgfVxuICBpZiAoIXNlbmRSZXBseSkge1xuICAgIC8vIG5vdGhpbmcgaGFzIGJlZW4gd3JpdHRlbiwgbm8gYW5zd2VyIGNyZWF0ZWRcbiAgICByZXR1cm4gbnVsbFxuICB9XG4gIHJldHVybiBlbmNvZGVyXG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJydGNDb25ufSBwZWVyQ29ublxuICogQHBhcmFtIHtVaW50OEFycmF5fSBidWZcbiAqIEByZXR1cm4ge2VuY29kaW5nLkVuY29kZXI/fVxuICovXG5jb25zdCByZWFkUGVlck1lc3NhZ2UgPSAocGVlckNvbm4sIGJ1ZikgPT4ge1xuICBjb25zdCByb29tID0gcGVlckNvbm4ucm9vbVxuICBsb2coJ3JlY2VpdmVkIG1lc3NhZ2UgZnJvbSAnLCBsb2dnaW5nLkJPTEQsIHBlZXJDb25uLnJlbW90ZVBlZXJJZCwgbG9nZ2luZy5HUkVZLCAnICgnLCByb29tLm5hbWUsICcpJywgbG9nZ2luZy5VTkJPTEQsIGxvZ2dpbmcuVU5DT0xPUilcbiAgcmV0dXJuIHJlYWRNZXNzYWdlKHJvb20sIGJ1ZiwgKCkgPT4ge1xuICAgIHBlZXJDb25uLnN5bmNlZCA9IHRydWVcbiAgICBsb2coJ3N5bmNlZCAnLCBsb2dnaW5nLkJPTEQsIHJvb20ubmFtZSwgbG9nZ2luZy5VTkJPTEQsICcgd2l0aCAnLCBsb2dnaW5nLkJPTEQsIHBlZXJDb25uLnJlbW90ZVBlZXJJZClcbiAgICBjaGVja0lzU3luY2VkKHJvb20pXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtXZWJydGNDb25ufSB3ZWJydGNDb25uXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqL1xuY29uc3Qgc2VuZFdlYnJ0Y0Nvbm4gPSAod2VicnRjQ29ubiwgZW5jb2RlcikgPT4ge1xuICBsb2coJ3NlbmQgbWVzc2FnZSB0byAnLCBsb2dnaW5nLkJPTEQsIHdlYnJ0Y0Nvbm4ucmVtb3RlUGVlcklkLCBsb2dnaW5nLlVOQk9MRCwgbG9nZ2luZy5HUkVZLCAnICgnLCB3ZWJydGNDb25uLnJvb20ubmFtZSwgJyknLCBsb2dnaW5nLlVOQ09MT1IpXG4gIHRyeSB7XG4gICAgd2VicnRjQ29ubi5wZWVyLnNlbmQoZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtXG4gKi9cbmNvbnN0IGJyb2FkY2FzdFdlYnJ0Y0Nvbm4gPSAocm9vbSwgbSkgPT4ge1xuICBsb2coJ2Jyb2FkY2FzdCBtZXNzYWdlIGluICcsIGxvZ2dpbmcuQk9MRCwgcm9vbS5uYW1lLCBsb2dnaW5nLlVOQk9MRClcbiAgcm9vbS53ZWJydGNDb25ucy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25uLnBlZXIuc2VuZChtKVxuICAgIH0gY2F0Y2ggKGUpIHt9XG4gIH0pXG59XG5cbmV4cG9ydCBjbGFzcyBXZWJydGNDb25uIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U2lnbmFsaW5nQ29ubn0gc2lnbmFsaW5nQ29ublxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluaXRpYXRvclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGVlcklkXG4gICAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICAgKi9cbiAgY29uc3RydWN0b3IgKHNpZ25hbGluZ0Nvbm4sIGluaXRpYXRvciwgcmVtb3RlUGVlcklkLCByb29tKSB7XG4gICAgbG9nKCdlc3RhYmxpc2hpbmcgY29ubmVjdGlvbiB0byAnLCBsb2dnaW5nLkJPTEQsIHJlbW90ZVBlZXJJZClcbiAgICB0aGlzLnJvb20gPSByb29tXG4gICAgdGhpcy5yZW1vdGVQZWVySWQgPSByZW1vdGVQZWVySWRcbiAgICB0aGlzLmdsYXJlVG9rZW4gPSB1bmRlZmluZWRcbiAgICB0aGlzLmNsb3NlZCA9IGZhbHNlXG4gICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuc3luY2VkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YW55fVxuICAgICAqL1xuICAgIHRoaXMucGVlciA9IG5ldyBQZWVyKHsgaW5pdGlhdG9yLCAuLi5yb29tLnByb3ZpZGVyLnBlZXJPcHRzIH0pXG4gICAgdGhpcy5wZWVyLm9uKCdzaWduYWwnLCBzaWduYWwgPT4ge1xuICAgICAgaWYgKHRoaXMuZ2xhcmVUb2tlbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIGFkZCBzb21lIHJhbmRvbW5lc3MgdG8gdGhlIHRpbWVzdGFtcCBvZiB0aGUgb2ZmZXJcbiAgICAgICAgdGhpcy5nbGFyZVRva2VuID0gRGF0ZS5ub3coKSArIE1hdGgucmFuZG9tKClcbiAgICAgIH1cbiAgICAgIHB1Ymxpc2hTaWduYWxpbmdNZXNzYWdlKHNpZ25hbGluZ0Nvbm4sIHJvb20sIHsgdG86IHJlbW90ZVBlZXJJZCwgZnJvbTogcm9vbS5wZWVySWQsIHR5cGU6ICdzaWduYWwnLCB0b2tlbjogdGhpcy5nbGFyZVRva2VuLCBzaWduYWwgfSlcbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignY29ubmVjdCcsICgpID0+IHtcbiAgICAgIGxvZygnY29ubmVjdGVkIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkKVxuICAgICAgdGhpcy5jb25uZWN0ZWQgPSB0cnVlXG4gICAgICAvLyBzZW5kIHN5bmMgc3RlcCAxXG4gICAgICBjb25zdCBwcm92aWRlciA9IHJvb20ucHJvdmlkZXJcbiAgICAgIGNvbnN0IGRvYyA9IHByb3ZpZGVyLmRvY1xuICAgICAgY29uc3QgYXdhcmVuZXNzID0gcm9vbS5hd2FyZW5lc3NcbiAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlU3luYylcbiAgICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMShlbmNvZGVyLCBkb2MpXG4gICAgICBzZW5kV2VicnRjQ29ubih0aGlzLCBlbmNvZGVyKVxuICAgICAgY29uc3QgYXdhcmVuZXNzU3RhdGVzID0gYXdhcmVuZXNzLmdldFN0YXRlcygpXG4gICAgICBpZiAoYXdhcmVuZXNzU3RhdGVzLnNpemUgPiAwKSB7XG4gICAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBhd2FyZW5lc3NQcm90b2NvbC5lbmNvZGVBd2FyZW5lc3NVcGRhdGUoYXdhcmVuZXNzLCBBcnJheS5mcm9tKGF3YXJlbmVzc1N0YXRlcy5rZXlzKCkpKSlcbiAgICAgICAgc2VuZFdlYnJ0Y0Nvbm4odGhpcywgZW5jb2RlcilcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMucGVlci5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlXG4gICAgICB0aGlzLmNsb3NlZCA9IHRydWVcbiAgICAgIGlmIChyb29tLndlYnJ0Y0Nvbm5zLmhhcyh0aGlzLnJlbW90ZVBlZXJJZCkpIHtcbiAgICAgICAgcm9vbS53ZWJydGNDb25ucy5kZWxldGUodGhpcy5yZW1vdGVQZWVySWQpXG4gICAgICAgIHJvb20ucHJvdmlkZXIuZW1pdCgncGVlcnMnLCBbe1xuICAgICAgICAgIHJlbW92ZWQ6IFt0aGlzLnJlbW90ZVBlZXJJZF0sXG4gICAgICAgICAgYWRkZWQ6IFtdLFxuICAgICAgICAgIHdlYnJ0Y1BlZXJzOiBBcnJheS5mcm9tKHJvb20ud2VicnRjQ29ubnMua2V5cygpKSxcbiAgICAgICAgICBiY1BlZXJzOiBBcnJheS5mcm9tKHJvb20uYmNDb25ucylcbiAgICAgICAgfV0pXG4gICAgICB9XG4gICAgICBjaGVja0lzU3luY2VkKHJvb20pXG4gICAgICB0aGlzLnBlZXIuZGVzdHJveSgpXG4gICAgICBsb2coJ2Nsb3NlZCBjb25uZWN0aW9uIHRvICcsIGxvZ2dpbmcuQk9MRCwgcmVtb3RlUGVlcklkKVxuICAgICAgYW5ub3VuY2VTaWduYWxpbmdJbmZvKHJvb20pXG4gICAgfSlcbiAgICB0aGlzLnBlZXIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgIGxvZygnRXJyb3IgaW4gY29ubmVjdGlvbiB0byAnLCBsb2dnaW5nLkJPTEQsIHJlbW90ZVBlZXJJZCwgJzogJywgZXJyKVxuICAgICAgYW5ub3VuY2VTaWduYWxpbmdJbmZvKHJvb20pXG4gICAgfSlcbiAgICB0aGlzLnBlZXIub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGFuc3dlciA9IHJlYWRQZWVyTWVzc2FnZSh0aGlzLCBkYXRhKVxuICAgICAgaWYgKGFuc3dlciAhPT0gbnVsbCkge1xuICAgICAgICBzZW5kV2VicnRjQ29ubih0aGlzLCBhbnN3ZXIpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMucGVlci5kZXN0cm95KClcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtXG4gKi9cbmNvbnN0IGJyb2FkY2FzdEJjTWVzc2FnZSA9IChyb29tLCBtKSA9PiBjcnlwdG91dGlscy5lbmNyeXB0KG0sIHJvb20ua2V5KS50aGVuKGRhdGEgPT5cbiAgcm9vbS5tdXgoKCkgPT5cbiAgICBiYy5wdWJsaXNoKHJvb20ubmFtZSwgZGF0YSlcbiAgKVxuKVxuXG4vKipcbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHtVaW50OEFycmF5fSBtXG4gKi9cbmNvbnN0IGJyb2FkY2FzdFJvb21NZXNzYWdlID0gKHJvb20sIG0pID0+IHtcbiAgaWYgKHJvb20uYmNjb25uZWN0ZWQpIHtcbiAgICBicm9hZGNhc3RCY01lc3NhZ2Uocm9vbSwgbSlcbiAgfVxuICBicm9hZGNhc3RXZWJydGNDb25uKHJvb20sIG0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtSb29tfSByb29tXG4gKi9cbmNvbnN0IGFubm91bmNlU2lnbmFsaW5nSW5mbyA9IHJvb20gPT4ge1xuICBzaWduYWxpbmdDb25ucy5mb3JFYWNoKGNvbm4gPT4ge1xuICAgIC8vIG9ubHkgc3Vic2NyaWJlIGlmIGNvbm5lY3Rpb24gaXMgZXN0YWJsaXNoZWQsIG90aGVyd2lzZSB0aGUgY29ubiBhdXRvbWF0aWNhbGx5IHN1YnNjcmliZXMgdG8gYWxsIHJvb21zXG4gICAgaWYgKGNvbm4uY29ubmVjdGVkKSB7XG4gICAgICBjb25uLnNlbmQoeyB0eXBlOiAnc3Vic2NyaWJlJywgdG9waWNzOiBbcm9vbS5uYW1lXSB9KVxuICAgICAgaWYgKHJvb20ud2VicnRjQ29ubnMuc2l6ZSA8IHJvb20ucHJvdmlkZXIubWF4Q29ubnMpIHtcbiAgICAgICAgcHVibGlzaFNpZ25hbGluZ01lc3NhZ2UoY29ubiwgcm9vbSwgeyB0eXBlOiAnYW5ub3VuY2UnLCBmcm9tOiByb29tLnBlZXJJZCB9KVxuICAgICAgfVxuICAgIH1cbiAgfSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1Jvb219IHJvb21cbiAqL1xuY29uc3QgYnJvYWRjYXN0QmNQZWVySWQgPSByb29tID0+IHtcbiAgaWYgKHJvb20ucHJvdmlkZXIuZmlsdGVyQmNDb25ucykge1xuICAgIC8vIGJyb2FkY2FzdCBwZWVySWQgdmlhIGJyb2FkY2FzdGNoYW5uZWxcbiAgICBjb25zdCBlbmNvZGVyUGVlcklkQmMgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlclBlZXJJZEJjLCBtZXNzYWdlQmNQZWVySWQpXG4gICAgZW5jb2Rpbmcud3JpdGVVaW50OChlbmNvZGVyUGVlcklkQmMsIDEpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlclBlZXJJZEJjLCByb29tLnBlZXJJZClcbiAgICBicm9hZGNhc3RCY01lc3NhZ2Uocm9vbSwgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJQZWVySWRCYykpXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIFJvb20ge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqIEBwYXJhbSB7V2VicnRjUHJvdmlkZXJ9IHByb3ZpZGVyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Q3J5cHRvS2V5fG51bGx9IGtleVxuICAgKi9cbiAgY29uc3RydWN0b3IgKGRvYywgcHJvdmlkZXIsIG5hbWUsIGtleSkge1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBhc3N1bWUgdGhhdCBwZWVySWQgaXMgdW5pcXVlLiBUaGlzIGlzIG9ubHkgbWVhbnQgZm9yIHNlbmRpbmcgc2lnbmFsaW5nIG1lc3NhZ2VzLlxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB0aGlzLnBlZXJJZCA9IHJhbmRvbS51dWlkdjQoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge2F3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzc31cbiAgICAgKi9cbiAgICB0aGlzLmF3YXJlbmVzcyA9IHByb3ZpZGVyLmF3YXJlbmVzc1xuICAgIHRoaXMucHJvdmlkZXIgPSBwcm92aWRlclxuICAgIHRoaXMuc3luY2VkID0gZmFsc2VcbiAgICB0aGlzLm5hbWUgPSBuYW1lXG4gICAgLy8gQHRvZG8gbWFrZSBrZXkgc2VjcmV0IGJ5IHNjb3BpbmdcbiAgICB0aGlzLmtleSA9IGtleVxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBXZWJydGNDb25uPn1cbiAgICAgKi9cbiAgICB0aGlzLndlYnJ0Y0Nvbm5zID0gbmV3IE1hcCgpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxzdHJpbmc+fVxuICAgICAqL1xuICAgIHRoaXMuYmNDb25ucyA9IG5ldyBTZXQoKVxuICAgIHRoaXMubXV4ID0gY3JlYXRlTXV0ZXgoKVxuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7QXJyYXlCdWZmZXJ9IGRhdGFcbiAgICAgKi9cbiAgICB0aGlzLl9iY1N1YnNjcmliZXIgPSBkYXRhID0+XG4gICAgICBjcnlwdG91dGlscy5kZWNyeXB0KG5ldyBVaW50OEFycmF5KGRhdGEpLCBrZXkpLnRoZW4obSA9PlxuICAgICAgICB0aGlzLm11eCgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVwbHkgPSByZWFkTWVzc2FnZSh0aGlzLCBtLCAoKSA9PiB7fSlcbiAgICAgICAgICBpZiAocmVwbHkpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkocmVwbHkpKVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgIClcbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIHRvIFlqcyB1cGRhdGVzIGFuZCBzZW5kcyB0aGVtIHRvIHJlbW90ZSBwZWVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtVaW50OEFycmF5fSB1cGRhdGVcbiAgICAgKiBAcGFyYW0ge2FueX0gX29yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX2RvY1VwZGF0ZUhhbmRsZXIgPSAodXBkYXRlLCBfb3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbWVzc2FnZVN5bmMpXG4gICAgICBzeW5jUHJvdG9jb2wud3JpdGVVcGRhdGUoZW5jb2RlciwgdXBkYXRlKVxuICAgICAgYnJvYWRjYXN0Um9vbU1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXIpKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0ZW5zIHRvIEF3YXJlbmVzcyB1cGRhdGVzIGFuZCBzZW5kcyB0aGVtIHRvIHJlbW90ZSBwZWVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGNoYW5nZWRcbiAgICAgKiBAcGFyYW0ge2FueX0gX29yaWdpblxuICAgICAqL1xuICAgIHRoaXMuX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXIgPSAoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9LCBfb3JpZ2luKSA9PiB7XG4gICAgICBjb25zdCBjaGFuZ2VkQ2xpZW50cyA9IGFkZGVkLmNvbmNhdCh1cGRhdGVkKS5jb25jYXQocmVtb3ZlZClcbiAgICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3MgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzLCBtZXNzYWdlQXdhcmVuZXNzKVxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3MsIGF3YXJlbmVzc1Byb3RvY29sLmVuY29kZUF3YXJlbmVzc1VwZGF0ZSh0aGlzLmF3YXJlbmVzcywgY2hhbmdlZENsaWVudHMpKVxuICAgICAgYnJvYWRjYXN0Um9vbU1lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3MpKVxuICAgIH1cblxuICAgIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICBhd2FyZW5lc3NQcm90b2NvbC5yZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcy5hd2FyZW5lc3MsIFtkb2MuY2xpZW50SURdLCAnd2luZG93IHVubG9hZCcpXG4gICAgICByb29tcy5mb3JFYWNoKHJvb20gPT4ge1xuICAgICAgICByb29tLmRpc2Nvbm5lY3QoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLl9iZWZvcmVVbmxvYWRIYW5kbGVyKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBwcm9jZXNzLm9uKCdleGl0JywgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9XG4gIH1cblxuICBjb25uZWN0ICgpIHtcbiAgICB0aGlzLmRvYy5vbigndXBkYXRlJywgdGhpcy5fZG9jVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLmF3YXJlbmVzcy5vbigndXBkYXRlJywgdGhpcy5fYXdhcmVuZXNzVXBkYXRlSGFuZGxlcilcbiAgICAvLyBzaWduYWwgdGhyb3VnaCBhbGwgYXZhaWxhYmxlIHNpZ25hbGluZyBjb25uZWN0aW9uc1xuICAgIGFubm91bmNlU2lnbmFsaW5nSW5mbyh0aGlzKVxuICAgIGNvbnN0IHJvb21OYW1lID0gdGhpcy5uYW1lXG4gICAgYmMuc3Vic2NyaWJlKHJvb21OYW1lLCB0aGlzLl9iY1N1YnNjcmliZXIpXG4gICAgdGhpcy5iY2Nvbm5lY3RlZCA9IHRydWVcbiAgICAvLyBicm9hZGNhc3QgcGVlcklkIHZpYSBicm9hZGNhc3RjaGFubmVsXG4gICAgYnJvYWRjYXN0QmNQZWVySWQodGhpcylcbiAgICAvLyB3cml0ZSBzeW5jIHN0ZXAgMVxuICAgIGNvbnN0IGVuY29kZXJTeW5jID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJTeW5jLCBtZXNzYWdlU3luYylcbiAgICBzeW5jUHJvdG9jb2wud3JpdGVTeW5jU3RlcDEoZW5jb2RlclN5bmMsIHRoaXMuZG9jKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN5bmMpKVxuICAgIC8vIGJyb2FkY2FzdCBsb2NhbCBzdGF0ZVxuICAgIGNvbnN0IGVuY29kZXJTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyU3RhdGUsIG1lc3NhZ2VTeW5jKVxuICAgIHN5bmNQcm90b2NvbC53cml0ZVN5bmNTdGVwMihlbmNvZGVyU3RhdGUsIHRoaXMuZG9jKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclN0YXRlKSlcbiAgICAvLyB3cml0ZSBxdWVyeUF3YXJlbmVzc1xuICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NRdWVyeSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzUXVlcnksIG1lc3NhZ2VRdWVyeUF3YXJlbmVzcylcbiAgICBicm9hZGNhc3RCY01lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NRdWVyeSkpXG4gICAgLy8gYnJvYWRjYXN0IGxvY2FsIGF3YXJlbmVzcyBzdGF0ZVxuICAgIGNvbnN0IGVuY29kZXJBd2FyZW5lc3NTdGF0ZSA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyQXdhcmVuZXNzU3RhdGUsIG1lc3NhZ2VBd2FyZW5lc3MpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSwgYXdhcmVuZXNzUHJvdG9jb2wuZW5jb2RlQXdhcmVuZXNzVXBkYXRlKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdKSlcbiAgICBicm9hZGNhc3RCY01lc3NhZ2UodGhpcywgZW5jb2RpbmcudG9VaW50OEFycmF5KGVuY29kZXJBd2FyZW5lc3NTdGF0ZSkpXG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICAvLyBzaWduYWwgdGhyb3VnaCBhbGwgYXZhaWxhYmxlIHNpZ25hbGluZyBjb25uZWN0aW9uc1xuICAgIHNpZ25hbGluZ0Nvbm5zLmZvckVhY2goY29ubiA9PiB7XG4gICAgICBpZiAoY29ubi5jb25uZWN0ZWQpIHtcbiAgICAgICAgY29ubi5zZW5kKHsgdHlwZTogJ3Vuc3Vic2NyaWJlJywgdG9waWNzOiBbdGhpcy5uYW1lXSB9KVxuICAgICAgfVxuICAgIH0pXG4gICAgYXdhcmVuZXNzUHJvdG9jb2wucmVtb3ZlQXdhcmVuZXNzU3RhdGVzKHRoaXMuYXdhcmVuZXNzLCBbdGhpcy5kb2MuY2xpZW50SURdLCAnZGlzY29ubmVjdCcpXG4gICAgLy8gYnJvYWRjYXN0IHBlZXJJZCByZW1vdmFsIHZpYSBicm9hZGNhc3RjaGFubmVsXG4gICAgY29uc3QgZW5jb2RlclBlZXJJZEJjID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXJQZWVySWRCYywgbWVzc2FnZUJjUGVlcklkKVxuICAgIGVuY29kaW5nLndyaXRlVWludDgoZW5jb2RlclBlZXJJZEJjLCAwKSAvLyByZW1vdmUgcGVlcklkIGZyb20gb3RoZXIgYmMgcGVlcnNcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyUGVlcklkQmMsIHRoaXMucGVlcklkKVxuICAgIGJyb2FkY2FzdEJjTWVzc2FnZSh0aGlzLCBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlclBlZXJJZEJjKSlcblxuICAgIGJjLnVuc3Vic2NyaWJlKHRoaXMubmFtZSwgdGhpcy5fYmNTdWJzY3JpYmVyKVxuICAgIHRoaXMuYmNjb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMuZG9jLm9mZigndXBkYXRlJywgdGhpcy5fZG9jVXBkYXRlSGFuZGxlcilcbiAgICB0aGlzLmF3YXJlbmVzcy5vZmYoJ3VwZGF0ZScsIHRoaXMuX2F3YXJlbmVzc1VwZGF0ZUhhbmRsZXIpXG4gICAgdGhpcy53ZWJydGNDb25ucy5mb3JFYWNoKGNvbm4gPT4gY29ubi5kZXN0cm95KCkpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMuX2JlZm9yZVVubG9hZEhhbmRsZXIpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHByb2Nlc3Mub2ZmKCdleGl0JywgdGhpcy5fYmVmb3JlVW5sb2FkSGFuZGxlcilcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAqIEBwYXJhbSB7V2VicnRjUHJvdmlkZXJ9IHByb3ZpZGVyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtDcnlwdG9LZXl8bnVsbH0ga2V5XG4gKiBAcmV0dXJuIHtSb29tfVxuICovXG5jb25zdCBvcGVuUm9vbSA9IChkb2MsIHByb3ZpZGVyLCBuYW1lLCBrZXkpID0+IHtcbiAgLy8gdGhlcmUgbXVzdCBvbmx5IGJlIG9uZSByb29tXG4gIGlmIChyb29tcy5oYXMobmFtZSkpIHtcbiAgICB0aHJvdyBlcnJvci5jcmVhdGUoYEEgWWpzIERvYyBjb25uZWN0ZWQgdG8gcm9vbSBcIiR7bmFtZX1cIiBhbHJlYWR5IGV4aXN0cyFgKVxuICB9XG4gIGNvbnN0IHJvb20gPSBuZXcgUm9vbShkb2MsIHByb3ZpZGVyLCBuYW1lLCBrZXkpXG4gIHJvb21zLnNldChuYW1lLCAvKiogQHR5cGUge1Jvb219ICovIChyb29tKSlcbiAgcmV0dXJuIHJvb21cbn1cblxuLyoqXG4gKiBAcGFyYW0ge1NpZ25hbGluZ0Nvbm59IGNvbm5cbiAqIEBwYXJhbSB7Um9vbX0gcm9vbVxuICogQHBhcmFtIHthbnl9IGRhdGFcbiAqL1xuY29uc3QgcHVibGlzaFNpZ25hbGluZ01lc3NhZ2UgPSAoY29ubiwgcm9vbSwgZGF0YSkgPT4ge1xuICBpZiAocm9vbS5rZXkpIHtcbiAgICBjcnlwdG91dGlscy5lbmNyeXB0SnNvbihkYXRhLCByb29tLmtleSkudGhlbihkYXRhID0+IHtcbiAgICAgIGNvbm4uc2VuZCh7IHR5cGU6ICdwdWJsaXNoJywgdG9waWM6IHJvb20ubmFtZSwgZGF0YTogYnVmZmVyLnRvQmFzZTY0KGRhdGEpIH0pXG4gICAgfSlcbiAgfSBlbHNlIHtcbiAgICBjb25uLnNlbmQoeyB0eXBlOiAncHVibGlzaCcsIHRvcGljOiByb29tLm5hbWUsIGRhdGEgfSlcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2lnbmFsaW5nQ29ubiBleHRlbmRzIHdzLldlYnNvY2tldENsaWVudCB7XG4gIGNvbnN0cnVjdG9yICh1cmwpIHtcbiAgICBzdXBlcih1cmwpXG4gICAgLyoqXG4gICAgICogQHR5cGUge1NldDxXZWJydGNQcm92aWRlcj59XG4gICAgICovXG4gICAgdGhpcy5wcm92aWRlcnMgPSBuZXcgU2V0KClcbiAgICB0aGlzLm9uKCdjb25uZWN0JywgKCkgPT4ge1xuICAgICAgbG9nKGBjb25uZWN0ZWQgKCR7dXJsfSlgKVxuICAgICAgY29uc3QgdG9waWNzID0gQXJyYXkuZnJvbShyb29tcy5rZXlzKCkpXG4gICAgICB0aGlzLnNlbmQoeyB0eXBlOiAnc3Vic2NyaWJlJywgdG9waWNzIH0pXG4gICAgICByb29tcy5mb3JFYWNoKHJvb20gPT5cbiAgICAgICAgcHVibGlzaFNpZ25hbGluZ01lc3NhZ2UodGhpcywgcm9vbSwgeyB0eXBlOiAnYW5ub3VuY2UnLCBmcm9tOiByb29tLnBlZXJJZCB9KVxuICAgICAgKVxuICAgIH0pXG4gICAgdGhpcy5vbignbWVzc2FnZScsIG0gPT4ge1xuICAgICAgc3dpdGNoIChtLnR5cGUpIHtcbiAgICAgICAgY2FzZSAncHVibGlzaCc6IHtcbiAgICAgICAgICBjb25zdCByb29tTmFtZSA9IG0udG9waWNcbiAgICAgICAgICBjb25zdCByb29tID0gcm9vbXMuZ2V0KHJvb21OYW1lKVxuICAgICAgICAgIGlmIChyb29tID09IG51bGwgfHwgdHlwZW9mIHJvb21OYW1lICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4ZWNNZXNzYWdlID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3ZWJydGNDb25ucyA9IHJvb20ud2VicnRjQ29ubnNcbiAgICAgICAgICAgIGNvbnN0IHBlZXJJZCA9IHJvb20ucGVlcklkXG4gICAgICAgICAgICBpZiAoZGF0YSA9PSBudWxsIHx8IGRhdGEuZnJvbSA9PT0gcGVlcklkIHx8IChkYXRhLnRvICE9PSB1bmRlZmluZWQgJiYgZGF0YS50byAhPT0gcGVlcklkKSB8fCByb29tLmJjQ29ubnMuaGFzKGRhdGEuZnJvbSkpIHtcbiAgICAgICAgICAgICAgLy8gaWdub3JlIG1lc3NhZ2VzIHRoYXQgYXJlIG5vdCBhZGRyZXNzZWQgdG8gdGhpcyBjb25uLCBvciBmcm9tIGNsaWVudHMgdGhhdCBhcmUgY29ubmVjdGVkIHZpYSBicm9hZGNhc3RjaGFubmVsXG4gICAgICAgICAgICAgIHJldHVyblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZW1pdFBlZXJDaGFuZ2UgPSB3ZWJydGNDb25ucy5oYXMoZGF0YS5mcm9tKVxuICAgICAgICAgICAgICA/ICgpID0+IHt9XG4gICAgICAgICAgICAgIDogKCkgPT5cbiAgICAgICAgICAgICAgICByb29tLnByb3ZpZGVyLmVtaXQoJ3BlZXJzJywgW3tcbiAgICAgICAgICAgICAgICAgIHJlbW92ZWQ6IFtdLFxuICAgICAgICAgICAgICAgICAgYWRkZWQ6IFtkYXRhLmZyb21dLFxuICAgICAgICAgICAgICAgICAgd2VicnRjUGVlcnM6IEFycmF5LmZyb20ocm9vbS53ZWJydGNDb25ucy5rZXlzKCkpLFxuICAgICAgICAgICAgICAgICAgYmNQZWVyczogQXJyYXkuZnJvbShyb29tLmJjQ29ubnMpXG4gICAgICAgICAgICAgICAgfV0pXG4gICAgICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgICAgICBjYXNlICdhbm5vdW5jZSc6XG4gICAgICAgICAgICAgICAgaWYgKHdlYnJ0Y0Nvbm5zLnNpemUgPCByb29tLnByb3ZpZGVyLm1heENvbm5zKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuc2V0SWZVbmRlZmluZWQod2VicnRjQ29ubnMsIGRhdGEuZnJvbSwgKCkgPT4gbmV3IFdlYnJ0Y0Nvbm4odGhpcywgdHJ1ZSwgZGF0YS5mcm9tLCByb29tKSlcbiAgICAgICAgICAgICAgICAgIGVtaXRQZWVyQ2hhbmdlKClcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICAgICAgY2FzZSAnc2lnbmFsJzpcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaWduYWwudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdDb25uID0gd2VicnRjQ29ubnMuZ2V0KGRhdGEuZnJvbSlcbiAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Nvbm4pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3RlVG9rZW4gPSBkYXRhLnRva2VuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsVG9rZW4gPSBleGlzdGluZ0Nvbm4uZ2xhcmVUb2tlblxuICAgICAgICAgICAgICAgICAgICBpZiAobG9jYWxUb2tlbiAmJiBsb2NhbFRva2VuID4gcmVtb3RlVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICBsb2coJ29mZmVyIHJlamVjdGVkOiAnLCBkYXRhLmZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgd2UgZG9uJ3QgcmVqZWN0IHRoZSBvZmZlciwgd2Ugd2lsbCBiZSBhY2NlcHRpbmcgaXQgYW5kIGFuc3dlcmluZyBpdFxuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0Nvbm4uZ2xhcmVUb2tlbiA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5zaWduYWwudHlwZSA9PT0gJ2Fuc3dlcicpIHtcbiAgICAgICAgICAgICAgICAgIGxvZygnb2ZmZXIgYW5zd2VyZWQgYnk6ICcsIGRhdGEuZnJvbSlcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nQ29ubiA9IHdlYnJ0Y0Nvbm5zLmdldChkYXRhLmZyb20pXG4gICAgICAgICAgICAgICAgICBleGlzdGluZ0Nvbm4uZ2xhcmVUb2tlbiA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZGF0YS50byA9PT0gcGVlcklkKSB7XG4gICAgICAgICAgICAgICAgICBtYXAuc2V0SWZVbmRlZmluZWQod2VicnRjQ29ubnMsIGRhdGEuZnJvbSwgKCkgPT4gbmV3IFdlYnJ0Y0Nvbm4odGhpcywgZmFsc2UsIGRhdGEuZnJvbSwgcm9vbSkpLnBlZXIuc2lnbmFsKGRhdGEuc2lnbmFsKVxuICAgICAgICAgICAgICAgICAgZW1pdFBlZXJDaGFuZ2UoKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vbS5rZXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbS5kYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjcnlwdG91dGlscy5kZWNyeXB0SnNvbihidWZmZXIuZnJvbUJhc2U2NChtLmRhdGEpLCByb29tLmtleSkudGhlbihleGVjTWVzc2FnZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXhlY01lc3NhZ2UobS5kYXRhKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5vbignZGlzY29ubmVjdCcsICgpID0+IGxvZyhgZGlzY29ubmVjdCAoJHt1cmx9KWApKVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gUHJvdmlkZXJPcHRpb25zXG4gKiBAcHJvcGVydHkge0FycmF5PHN0cmluZz59IFtzaWduYWxpbmddXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW3Bhc3N3b3JkXVxuICogQHByb3BlcnR5IHthd2FyZW5lc3NQcm90b2NvbC5Bd2FyZW5lc3N9IFthd2FyZW5lc3NdXG4gKiBAcHJvcGVydHkge251bWJlcn0gW21heENvbm5zXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbZmlsdGVyQmNDb25uc11cbiAqIEBwcm9wZXJ0eSB7YW55fSBbcGVlck9wdHNdXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge1dlYnJ0Y1Byb3ZpZGVyfSBwcm92aWRlclxuICovXG5jb25zdCBlbWl0U3RhdHVzID0gcHJvdmlkZXIgPT4ge1xuICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgIGNvbm5lY3RlZDogcHJvdmlkZXIuY29ubmVjdGVkXG4gIH1dKVxufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IFdlYnJ0Y1Byb3ZpZGVyRXZlbnRzXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHtjb25uZWN0ZWQ6Ym9vbGVhbn0pOnZvaWR9IFdlYnJ0Y1Byb3ZpZGVyRXZlbnQuc3RhdHVzXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHtzeW5jZWQ6Ym9vbGVhbn0pOnZvaWR9IFdlYnJ0Y1Byb3ZpZGVyRXZlbnQuc3luY2VkXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKHthZGRlZDpBcnJheTxzdHJpbmc+LHJlbW92ZWQ6QXJyYXk8c3RyaW5nPix3ZWJydGNQZWVyczpBcnJheTxzdHJpbmc+LGJjUGVlcnM6QXJyYXk8c3RyaW5nPn0pOnZvaWR9IFdlYnJ0Y1Byb3ZpZGVyRXZlbnQucGVlcnNcbiAqL1xuXG4vKipcbiAqIEBleHRlbmRzIE9ic2VydmFibGVWMjxXZWJydGNQcm92aWRlckV2ZW50cz5cbiAqL1xuZXhwb3J0IGNsYXNzIFdlYnJ0Y1Byb3ZpZGVyIGV4dGVuZHMgT2JzZXJ2YWJsZVYyIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb29tTmFtZVxuICAgKiBAcGFyYW0ge1kuRG9jfSBkb2NcbiAgICogQHBhcmFtIHtQcm92aWRlck9wdGlvbnM/fSBvcHRzXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoXG4gICAgcm9vbU5hbWUsXG4gICAgZG9jLFxuICAgIHtcbiAgICAgIHNpZ25hbGluZyA9IFsnd3NzOi8veS13ZWJydGMtZXUuZmx5LmRldiddLFxuICAgICAgcGFzc3dvcmQgPSBudWxsLFxuICAgICAgYXdhcmVuZXNzID0gbmV3IGF3YXJlbmVzc1Byb3RvY29sLkF3YXJlbmVzcyhkb2MpLFxuICAgICAgbWF4Q29ubnMgPSAyMCArIG1hdGguZmxvb3IocmFuZG9tLnJhbmQoKSAqIDE1KSwgLy8gdGhlIHJhbmRvbSBmYWN0b3IgcmVkdWNlcyB0aGUgY2hhbmNlIHRoYXQgbiBjbGllbnRzIGZvcm0gYSBjbHVzdGVyXG4gICAgICBmaWx0ZXJCY0Nvbm5zID0gdHJ1ZSxcbiAgICAgIHBlZXJPcHRzID0ge30gLy8gc2ltcGxlLXBlZXIgb3B0aW9ucy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3Mvc2ltcGxlLXBlZXIjcGVlci0tbmV3LXBlZXJvcHRzXG4gICAgfSA9IHt9XG4gICkge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnJvb21OYW1lID0gcm9vbU5hbWVcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMuZmlsdGVyQmNDb25ucyA9IGZpbHRlckJjQ29ubnNcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7YXdhcmVuZXNzUHJvdG9jb2wuQXdhcmVuZXNzfVxuICAgICAqL1xuICAgIHRoaXMuYXdhcmVuZXNzID0gYXdhcmVuZXNzXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gZmFsc2VcbiAgICB0aGlzLnNpZ25hbGluZ1VybHMgPSBzaWduYWxpbmdcbiAgICB0aGlzLnNpZ25hbGluZ0Nvbm5zID0gW11cbiAgICB0aGlzLm1heENvbm5zID0gbWF4Q29ubnNcbiAgICB0aGlzLnBlZXJPcHRzID0gcGVlck9wdHNcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZUxpa2U8Q3J5cHRvS2V5IHwgbnVsbD59XG4gICAgICovXG4gICAgdGhpcy5rZXkgPSBwYXNzd29yZCA/IGNyeXB0b3V0aWxzLmRlcml2ZUtleShwYXNzd29yZCwgcm9vbU5hbWUpIDogLyoqIEB0eXBlIHtQcm9taXNlTGlrZTxudWxsPn0gKi8gKHByb21pc2UucmVzb2x2ZShudWxsKSlcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7Um9vbXxudWxsfVxuICAgICAqL1xuICAgIHRoaXMucm9vbSA9IG51bGxcbiAgICB0aGlzLmtleS50aGVuKGtleSA9PiB7XG4gICAgICB0aGlzLnJvb20gPSBvcGVuUm9vbShkb2MsIHRoaXMsIHJvb21OYW1lLCBrZXkpXG4gICAgICBpZiAodGhpcy5zaG91bGRDb25uZWN0KSB7XG4gICAgICAgIHRoaXMucm9vbS5jb25uZWN0KClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucm9vbS5kaXNjb25uZWN0KClcbiAgICAgIH1cbiAgICAgIGVtaXRTdGF0dXModGhpcylcbiAgICB9KVxuICAgIHRoaXMuY29ubmVjdCgpXG4gICAgdGhpcy5kZXN0cm95ID0gdGhpcy5kZXN0cm95LmJpbmQodGhpcylcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCB0aGlzLmRlc3Ryb3kpXG4gIH1cblxuICAvKipcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHByb3ZpZGVyIGlzIGxvb2tpbmcgZm9yIG90aGVyIHBlZXJzLlxuICAgKlxuICAgKiBPdGhlciBwZWVycyBjYW4gYmUgZm91bmQgdmlhIHNpZ25hbGluZyBzZXJ2ZXJzIG9yIHZpYSBicm9hZGNhc3RjaGFubmVsIChjcm9zcyBicm93c2VyLXRhYlxuICAgKiBjb21tdW5pY2F0aW9uKS4gWW91IG5ldmVyIGtub3cgd2hlbiB5b3UgYXJlIGNvbm5lY3RlZCB0byBhbGwgcGVlcnMuIFlvdSBhbHNvIGRvbid0IGtub3cgaWZcbiAgICogdGhlcmUgYXJlIG90aGVyIHBlZXJzLiBjb25uZWN0ZWQgZG9lc24ndCBtZWFuIHRoYXQgeW91IGFyZSBjb25uZWN0ZWQgdG8gYW55IHBoeXNpY2FsIHBlZXJzXG4gICAqIHdvcmtpbmcgb24gdGhlIHNhbWUgcmVzb3VyY2UgYXMgeW91LiBJdCBkb2VzIG5vdCBjaGFuZ2UgdW5sZXNzIHlvdSBjYWxsIHByb3ZpZGVyLmRpc2Nvbm5lY3QoKVxuICAgKlxuICAgKiBgdGhpcy5vbignc3RhdHVzJywgKGV2ZW50KSA9PiB7IGNvbnNvbGUubG9nKGV2ZW50LmNvbm5lY3RlZCkgfSlgXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKi9cbiAgZ2V0IGNvbm5lY3RlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vbSAhPT0gbnVsbCAmJiB0aGlzLnNob3VsZENvbm5lY3RcbiAgfVxuXG4gIGNvbm5lY3QgKCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICB0aGlzLnNpZ25hbGluZ1VybHMuZm9yRWFjaCh1cmwgPT4ge1xuICAgICAgY29uc3Qgc2lnbmFsaW5nQ29ubiA9IG1hcC5zZXRJZlVuZGVmaW5lZChzaWduYWxpbmdDb25ucywgdXJsLCAoKSA9PiBuZXcgU2lnbmFsaW5nQ29ubih1cmwpKVxuICAgICAgdGhpcy5zaWduYWxpbmdDb25ucy5wdXNoKHNpZ25hbGluZ0Nvbm4pXG4gICAgICBzaWduYWxpbmdDb25uLnByb3ZpZGVycy5hZGQodGhpcylcbiAgICB9KVxuICAgIGlmICh0aGlzLnJvb20pIHtcbiAgICAgIHRoaXMucm9vbS5jb25uZWN0KClcbiAgICAgIGVtaXRTdGF0dXModGhpcylcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0ICgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIHRoaXMuc2lnbmFsaW5nQ29ubnMuZm9yRWFjaChjb25uID0+IHtcbiAgICAgIGNvbm4ucHJvdmlkZXJzLmRlbGV0ZSh0aGlzKVxuICAgICAgaWYgKGNvbm4ucHJvdmlkZXJzLnNpemUgPT09IDApIHtcbiAgICAgICAgY29ubi5kZXN0cm95KClcbiAgICAgICAgc2lnbmFsaW5nQ29ubnMuZGVsZXRlKGNvbm4udXJsKVxuICAgICAgfVxuICAgIH0pXG4gICAgaWYgKHRoaXMucm9vbSkge1xuICAgICAgdGhpcy5yb29tLmRpc2Nvbm5lY3QoKVxuICAgICAgZW1pdFN0YXR1cyh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGRlc3Ryb3kgKCkge1xuICAgIHRoaXMuZG9jLm9mZignZGVzdHJveScsIHRoaXMuZGVzdHJveSlcbiAgICAvLyBuZWVkIHRvIHdhaXQgZm9yIGtleSBiZWZvcmUgZGVsZXRpbmcgcm9vbVxuICAgIHRoaXMua2V5LnRoZW4oKCkgPT4ge1xuICAgICAgLyoqIEB0eXBlIHtSb29tfSAqLyAodGhpcy5yb29tKS5kZXN0cm95KClcbiAgICAgIHJvb21zLmRlbGV0ZSh0aGlzLnJvb21OYW1lKVxuICAgIH0pXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gIH1cbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgc3luYy1wcm90b2NvbFxuICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5cbi8qKlxuICogQHR5cGVkZWYge01hcDxudW1iZXIsIG51bWJlcj59IFN0YXRlTWFwXG4gKi9cblxuLyoqXG4gKiBDb3JlIFlqcyBkZWZpbmVzIHR3byBtZXNzYWdlIHR5cGVzOlxuICogXHUyMDIyIFlqc1N5bmNTdGVwMTogSW5jbHVkZXMgdGhlIFN0YXRlIFNldCBvZiB0aGUgc2VuZGluZyBjbGllbnQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgc2hvdWxkIHJlcGx5IHdpdGggWWpzU3luY1N0ZXAyLlxuICogXHUyMDIyIFlqc1N5bmNTdGVwMjogSW5jbHVkZXMgYWxsIG1pc3Npbmcgc3RydWN0cyBhbmQgdGhlIGNvbXBsZXRlIGRlbGV0ZSBzZXQuIFdoZW4gcmVjZWl2ZWQsIHRoZSBjbGllbnQgaXMgYXNzdXJlZCB0aGF0IGl0XG4gKiAgIHJlY2VpdmVkIGFsbCBpbmZvcm1hdGlvbiBmcm9tIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgcGVlci10by1wZWVyIG5ldHdvcmssIHlvdSBtYXkgd2FudCB0byBpbnRyb2R1Y2UgYSBTeW5jRG9uZSBtZXNzYWdlIHR5cGUuIEJvdGggcGFydGllcyBzaG91bGQgaW5pdGlhdGUgdGhlIGNvbm5lY3Rpb25cbiAqIHdpdGggU3luY1N0ZXAxLiBXaGVuIGEgY2xpZW50IHJlY2VpdmVkIFN5bmNTdGVwMiwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY0RvbmUuIFdoZW4gdGhlIGxvY2FsIGNsaWVudCByZWNlaXZlZCBib3RoXG4gKiBTeW5jU3RlcDIgYW5kIFN5bmNEb25lLCBpdCBpcyBhc3N1cmVkIHRoYXQgaXQgaXMgc3luY2VkIHRvIHRoZSByZW1vdGUgY2xpZW50LlxuICpcbiAqIEluIGEgY2xpZW50LXNlcnZlciBtb2RlbCwgeW91IHdhbnQgdG8gaGFuZGxlIHRoaXMgZGlmZmVyZW50bHk6IFRoZSBjbGllbnQgc2hvdWxkIGluaXRpYXRlIHRoZSBjb25uZWN0aW9uIHdpdGggU3luY1N0ZXAxLlxuICogV2hlbiB0aGUgc2VydmVyIHJlY2VpdmVzIFN5bmNTdGVwMSwgaXQgc2hvdWxkIHJlcGx5IHdpdGggU3luY1N0ZXAyIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IFN5bmNTdGVwMS4gVGhlIGNsaWVudCByZXBsaWVzXG4gKiB3aXRoIFN5bmNTdGVwMiB3aGVuIGl0IHJlY2VpdmVzIFN5bmNTdGVwMS4gT3B0aW9uYWxseSB0aGUgc2VydmVyIG1heSBzZW5kIGEgU3luY0RvbmUgYWZ0ZXIgaXQgcmVjZWl2ZWQgU3luY1N0ZXAyLCBzbyB0aGVcbiAqIGNsaWVudCBrbm93cyB0aGF0IHRoZSBzeW5jIGlzIGZpbmlzaGVkLiAgVGhlcmUgYXJlIHR3byByZWFzb25zIGZvciB0aGlzIG1vcmUgZWxhYm9yYXRlZCBzeW5jIG1vZGVsOiAxLiBUaGlzIHByb3RvY29sIGNhblxuICogZWFzaWx5IGJlIGltcGxlbWVudGVkIG9uIHRvcCBvZiBodHRwIGFuZCB3ZWJzb2NrZXRzLiAyLiBUaGUgc2VydmVyIHNob3VsZCBvbmx5IHJlcGx5IHRvIHJlcXVlc3RzLCBhbmQgbm90IGluaXRpYXRlIHRoZW0uXG4gKiBUaGVyZWZvcmUgaXQgaXMgbmVjZXNzYXJ5IHRoYXQgdGhlIGNsaWVudCBpbml0aWF0ZXMgdGhlIHN5bmMuXG4gKlxuICogQ29uc3RydWN0aW9uIG9mIGEgbWVzc2FnZTpcbiAqIFttZXNzYWdlVHlwZSA6IHZhclVpbnQsIG1lc3NhZ2UgZGVmaW5pdGlvbi4uXVxuICpcbiAqIE5vdGU6IEEgbWVzc2FnZSBkb2VzIG5vdCBpbmNsdWRlIGluZm9ybWF0aW9uIGFib3V0IHRoZSByb29tIG5hbWUuIFRoaXMgbXVzdCB0byBiZSBoYW5kbGVkIGJ5IHRoZSB1cHBlciBsYXllciBwcm90b2NvbCFcbiAqXG4gKiBzdHJpbmdpZnlbbWVzc2FnZVR5cGVdIHN0cmluZ2lmaWVzIGEgbWVzc2FnZSBkZWZpbml0aW9uIChtZXNzYWdlVHlwZSBpcyBhbHJlYWR5IHJlYWQgZnJvbSB0aGUgYnVmZmZlcilcbiAqL1xuXG5leHBvcnQgY29uc3QgbWVzc2FnZVlqc1N5bmNTdGVwMSA9IDBcbmV4cG9ydCBjb25zdCBtZXNzYWdlWWpzU3luY1N0ZXAyID0gMVxuZXhwb3J0IGNvbnN0IG1lc3NhZ2VZanNVcGRhdGUgPSAyXG5cbi8qKlxuICogQ3JlYXRlIGEgc3luYyBzdGVwIDEgbWVzc2FnZSBiYXNlZCBvbiB0aGUgc3RhdGUgb2YgdGhlIGN1cnJlbnQgc2hhcmVkIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKi9cbmV4cG9ydCBjb25zdCB3cml0ZVN5bmNTdGVwMSA9IChlbmNvZGVyLCBkb2MpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNTeW5jU3RlcDEpXG4gIGNvbnN0IHN2ID0gWS5lbmNvZGVTdGF0ZVZlY3Rvcihkb2MpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBzdilcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHtVaW50OEFycmF5fSBbZW5jb2RlZFN0YXRlVmVjdG9yXVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVTeW5jU3RlcDIgPSAoZW5jb2RlciwgZG9jLCBlbmNvZGVkU3RhdGVWZWN0b3IpID0+IHtcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIG1lc3NhZ2VZanNTeW5jU3RlcDIpXG4gIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNvZGVyLCBZLmVuY29kZVN0YXRlQXNVcGRhdGUoZG9jLCBlbmNvZGVkU3RhdGVWZWN0b3IpKVxufVxuXG4vKipcbiAqIFJlYWQgU3luY1N0ZXAxIG1lc3NhZ2UgYW5kIHJlcGx5IHdpdGggU3luY1N0ZXAyLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlciBUaGUgcmVwbHkgdG8gdGhlIHJlY2VpdmVkIG1lc3NhZ2VcbiAqIEBwYXJhbSB7ZW5jb2RpbmcuRW5jb2Rlcn0gZW5jb2RlciBUaGUgcmVjZWl2ZWQgbWVzc2FnZVxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY1N0ZXAxID0gKGRlY29kZXIsIGVuY29kZXIsIGRvYykgPT5cbiAgd3JpdGVTeW5jU3RlcDIoZW5jb2RlciwgZG9jLCBkZWNvZGluZy5yZWFkVmFyVWludDhBcnJheShkZWNvZGVyKSlcblxuLyoqXG4gKiBSZWFkIGFuZCBhcHBseSBTdHJ1Y3RzIGFuZCB0aGVuIERlbGV0ZVN0b3JlIHRvIGEgeSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2RlY29kaW5nLkRlY29kZXJ9IGRlY29kZXJcbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY1N0ZXAyID0gKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pID0+IHtcbiAgdHJ5IHtcbiAgICBZLmFwcGx5VXBkYXRlKGRvYywgZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGVjb2RlciksIHRyYW5zYWN0aW9uT3JpZ2luKVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIC8vIFRoaXMgY2F0Y2hlcyBlcnJvcnMgdGhhdCBhcmUgdGhyb3duIGJ5IGV2ZW50IGhhbmRsZXJzXG4gICAgY29uc29sZS5lcnJvcignQ2F1Z2h0IGVycm9yIHdoaWxlIGhhbmRsaW5nIGEgWWpzIHVwZGF0ZScsIGVycm9yKVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtlbmNvZGluZy5FbmNvZGVyfSBlbmNvZGVyXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICovXG5leHBvcnQgY29uc3Qgd3JpdGVVcGRhdGUgPSAoZW5jb2RlciwgdXBkYXRlKSA9PiB7XG4gIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBtZXNzYWdlWWpzVXBkYXRlKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxufVxuXG4vKipcbiAqIFJlYWQgYW5kIGFwcGx5IFN0cnVjdHMgYW5kIHRoZW4gRGVsZXRlU3RvcmUgdG8gYSB5IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7ZGVjb2RpbmcuRGVjb2Rlcn0gZGVjb2RlclxuICogQHBhcmFtIHtZLkRvY30gZG9jXG4gKiBAcGFyYW0ge2FueX0gdHJhbnNhY3Rpb25PcmlnaW5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRVcGRhdGUgPSByZWFkU3luY1N0ZXAyXG5cbi8qKlxuICogQHBhcmFtIHtkZWNvZGluZy5EZWNvZGVyfSBkZWNvZGVyIEEgbWVzc2FnZSByZWNlaXZlZCBmcm9tIGFub3RoZXIgY2xpZW50XG4gKiBAcGFyYW0ge2VuY29kaW5nLkVuY29kZXJ9IGVuY29kZXIgVGhlIHJlcGx5IG1lc3NhZ2UuIERvZXMgbm90IG5lZWQgdG8gYmUgc2VudCBpZiBlbXB0eS5cbiAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICogQHBhcmFtIHthbnl9IHRyYW5zYWN0aW9uT3JpZ2luXG4gKi9cbmV4cG9ydCBjb25zdCByZWFkU3luY01lc3NhZ2UgPSAoZGVjb2RlciwgZW5jb2RlciwgZG9jLCB0cmFuc2FjdGlvbk9yaWdpbikgPT4ge1xuICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIHN3aXRjaCAobWVzc2FnZVR5cGUpIHtcbiAgICBjYXNlIG1lc3NhZ2VZanNTeW5jU3RlcDE6XG4gICAgICByZWFkU3luY1N0ZXAxKGRlY29kZXIsIGVuY29kZXIsIGRvYylcbiAgICAgIGJyZWFrXG4gICAgY2FzZSBtZXNzYWdlWWpzU3luY1N0ZXAyOlxuICAgICAgcmVhZFN5bmNTdGVwMihkZWNvZGVyLCBkb2MsIHRyYW5zYWN0aW9uT3JpZ2luKVxuICAgICAgYnJlYWtcbiAgICBjYXNlIG1lc3NhZ2VZanNVcGRhdGU6XG4gICAgICByZWFkVXBkYXRlKGRlY29kZXIsIGRvYywgdHJhbnNhY3Rpb25PcmlnaW4pXG4gICAgICBicmVha1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbWVzc2FnZSB0eXBlJylcbiAgfVxuICByZXR1cm4gbWVzc2FnZVR5cGVcbn1cbiIsICIvKipcbiAqIEBtb2R1bGUgYXdhcmVuZXNzLXByb3RvY29sXG4gKi9cblxuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgKiBhcyB0aW1lIGZyb20gJ2xpYjAvdGltZSdcbmltcG9ydCAqIGFzIG1hdGggZnJvbSAnbGliMC9tYXRoJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcbmltcG9ydCAqIGFzIGYgZnJvbSAnbGliMC9mdW5jdGlvbidcbmltcG9ydCAqIGFzIFkgZnJvbSAneWpzJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbmV4cG9ydCBjb25zdCBvdXRkYXRlZFRpbWVvdXQgPSAzMDAwMFxuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IE1ldGFDbGllbnRTdGF0ZVxuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5jbG9ja1xuICogQHByb3BlcnR5IHtudW1iZXJ9IE1ldGFDbGllbnRTdGF0ZS5sYXN0VXBkYXRlZCB1bml4IHRpbWVzdGFtcFxuICovXG5cbi8qKlxuICogVGhlIEF3YXJlbmVzcyBjbGFzcyBpbXBsZW1lbnRzIGEgc2ltcGxlIHNoYXJlZCBzdGF0ZSBwcm90b2NvbCB0aGF0IGNhbiBiZSB1c2VkIGZvciBub24tcGVyc2lzdGVudCBkYXRhIGxpa2UgYXdhcmVuZXNzIGluZm9ybWF0aW9uXG4gKiAoY3Vyc29yLCB1c2VybmFtZSwgc3RhdHVzLCAuLikuIEVhY2ggY2xpZW50IGNhbiB1cGRhdGUgaXRzIG93biBsb2NhbCBzdGF0ZSBhbmQgbGlzdGVuIHRvIHN0YXRlIGNoYW5nZXMgb2ZcbiAqIHJlbW90ZSBjbGllbnRzLiBFdmVyeSBjbGllbnQgbWF5IHNldCBhIHN0YXRlIG9mIGEgcmVtb3RlIHBlZXIgdG8gYG51bGxgIHRvIG1hcmsgdGhlIGNsaWVudCBhcyBvZmZsaW5lLlxuICpcbiAqIEVhY2ggY2xpZW50IGlzIGlkZW50aWZpZWQgYnkgYSB1bmlxdWUgY2xpZW50IGlkIChzb21ldGhpbmcgd2UgYm9ycm93IGZyb20gYGRvYy5jbGllbnRJRGApLiBBIGNsaWVudCBjYW4gb3ZlcnJpZGVcbiAqIGl0cyBvd24gc3RhdGUgYnkgcHJvcGFnYXRpbmcgYSBtZXNzYWdlIHdpdGggYW4gaW5jcmVhc2luZyB0aW1lc3RhbXAgKGBjbG9ja2ApLiBJZiBzdWNoIGEgbWVzc2FnZSBpcyByZWNlaXZlZCwgaXQgaXNcbiAqIGFwcGxpZWQgaWYgdGhlIGtub3duIHN0YXRlIG9mIHRoYXQgY2xpZW50IGlzIG9sZGVyIHRoYW4gdGhlIG5ldyBzdGF0ZSAoYGNsb2NrIDwgbmV3Q2xvY2tgKS4gSWYgYSBjbGllbnQgdGhpbmtzIHRoYXRcbiAqIGEgcmVtb3RlIGNsaWVudCBpcyBvZmZsaW5lLCBpdCBtYXkgcHJvcGFnYXRlIGEgbWVzc2FnZSB3aXRoXG4gKiBgeyBjbG9jazogY3VycmVudENsaWVudENsb2NrLCBzdGF0ZTogbnVsbCwgY2xpZW50OiByZW1vdGVDbGllbnQgfWAuIElmIHN1Y2ggYVxuICogbWVzc2FnZSBpcyByZWNlaXZlZCwgYW5kIHRoZSBrbm93biBjbG9jayBvZiB0aGF0IGNsaWVudCBlcXVhbHMgdGhlIHJlY2VpdmVkIGNsb2NrLCBpdCB3aWxsIG92ZXJyaWRlIHRoZSBzdGF0ZSB3aXRoIGBudWxsYC5cbiAqXG4gKiBCZWZvcmUgYSBjbGllbnQgZGlzY29ubmVjdHMsIGl0IHNob3VsZCBwcm9wYWdhdGUgYSBgbnVsbGAgc3RhdGUgd2l0aCBhbiB1cGRhdGVkIGNsb2NrLlxuICpcbiAqIEF3YXJlbmVzcyBzdGF0ZXMgbXVzdCBiZSB1cGRhdGVkIGV2ZXJ5IDMwIHNlY29uZHMuIE90aGVyd2lzZSB0aGUgQXdhcmVuZXNzIGluc3RhbmNlIHdpbGwgZGVsZXRlIHRoZSBjbGllbnQgc3RhdGUuXG4gKlxuICogQGV4dGVuZHMge09ic2VydmFibGU8c3RyaW5nPn1cbiAqL1xuZXhwb3J0IGNsYXNzIEF3YXJlbmVzcyBleHRlbmRzIE9ic2VydmFibGUge1xuICAvKipcbiAgICogQHBhcmFtIHtZLkRvY30gZG9jXG4gICAqL1xuICBjb25zdHJ1Y3RvciAoZG9jKSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMuZG9jID0gZG9jXG4gICAgLyoqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB0aGlzLmNsaWVudElEID0gZG9jLmNsaWVudElEXG4gICAgLyoqXG4gICAgICogTWFwcyBmcm9tIGNsaWVudCBpZCB0byBjbGllbnQgc3RhdGVcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgT2JqZWN0PHN0cmluZywgYW55Pj59XG4gICAgICovXG4gICAgdGhpcy5zdGF0ZXMgPSBuZXcgTWFwKClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPG51bWJlciwgTWV0YUNsaWVudFN0YXRlPn1cbiAgICAgKi9cbiAgICB0aGlzLm1ldGEgPSBuZXcgTWFwKClcbiAgICB0aGlzLl9jaGVja0ludGVydmFsID0gLyoqIEB0eXBlIHthbnl9ICovIChzZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBjb25zdCBub3cgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgICAgIGlmICh0aGlzLmdldExvY2FsU3RhdGUoKSAhPT0gbnVsbCAmJiAob3V0ZGF0ZWRUaW1lb3V0IC8gMiA8PSBub3cgLSAvKiogQHR5cGUge3tsYXN0VXBkYXRlZDpudW1iZXJ9fSAqLyAodGhpcy5tZXRhLmdldCh0aGlzLmNsaWVudElEKSkubGFzdFVwZGF0ZWQpKSB7XG4gICAgICAgIC8vIHJlbmV3IGxvY2FsIGNsb2NrXG4gICAgICAgIHRoaXMuc2V0TG9jYWxTdGF0ZSh0aGlzLmdldExvY2FsU3RhdGUoKSlcbiAgICAgIH1cbiAgICAgIC8qKlxuICAgICAgICogQHR5cGUge0FycmF5PG51bWJlcj59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHJlbW92ZSA9IFtdXG4gICAgICB0aGlzLm1ldGEuZm9yRWFjaCgobWV0YSwgY2xpZW50aWQpID0+IHtcbiAgICAgICAgaWYgKGNsaWVudGlkICE9PSB0aGlzLmNsaWVudElEICYmIG91dGRhdGVkVGltZW91dCA8PSBub3cgLSBtZXRhLmxhc3RVcGRhdGVkICYmIHRoaXMuc3RhdGVzLmhhcyhjbGllbnRpZCkpIHtcbiAgICAgICAgICByZW1vdmUucHVzaChjbGllbnRpZClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChyZW1vdmUubGVuZ3RoID4gMCkge1xuICAgICAgICByZW1vdmVBd2FyZW5lc3NTdGF0ZXModGhpcywgcmVtb3ZlLCAndGltZW91dCcpXG4gICAgICB9XG4gICAgfSwgbWF0aC5mbG9vcihvdXRkYXRlZFRpbWVvdXQgLyAxMCkpKVxuICAgIGRvYy5vbignZGVzdHJveScsICgpID0+IHtcbiAgICAgIHRoaXMuZGVzdHJveSgpXG4gICAgfSlcbiAgICB0aGlzLnNldExvY2FsU3RhdGUoe30pXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICB0aGlzLmVtaXQoJ2Rlc3Ryb3knLCBbdGhpc10pXG4gICAgdGhpcy5zZXRMb2NhbFN0YXRlKG51bGwpXG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9jaGVja0ludGVydmFsKVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdDxzdHJpbmcsYW55PnxudWxsfVxuICAgKi9cbiAgZ2V0TG9jYWxTdGF0ZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzLmdldCh0aGlzLmNsaWVudElEKSB8fCBudWxsXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q8c3RyaW5nLGFueT58bnVsbH0gc3RhdGVcbiAgICovXG4gIHNldExvY2FsU3RhdGUgKHN0YXRlKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSB0aGlzLmNsaWVudElEXG4gICAgY29uc3QgY3VyckxvY2FsTWV0YSA9IHRoaXMubWV0YS5nZXQoY2xpZW50SUQpXG4gICAgY29uc3QgY2xvY2sgPSBjdXJyTG9jYWxNZXRhID09PSB1bmRlZmluZWQgPyAwIDogY3VyckxvY2FsTWV0YS5jbG9jayArIDFcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLnN0YXRlcy5nZXQoY2xpZW50SUQpXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICB0aGlzLnN0YXRlcy5kZWxldGUoY2xpZW50SUQpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgfVxuICAgIHRoaXMubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgIGNsb2NrLFxuICAgICAgbGFzdFVwZGF0ZWQ6IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgIH0pXG4gICAgY29uc3QgYWRkZWQgPSBbXVxuICAgIGNvbnN0IHVwZGF0ZWQgPSBbXVxuICAgIGNvbnN0IGZpbHRlcmVkVXBkYXRlZCA9IFtdXG4gICAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gICAgaWYgKHN0YXRlID09PSBudWxsKSB7XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfSBlbHNlIGlmIChwcmV2U3RhdGUgPT0gbnVsbCkge1xuICAgICAgaWYgKHN0YXRlICE9IG51bGwpIHtcbiAgICAgICAgYWRkZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlZC5wdXNoKGNsaWVudElEKVxuICAgICAgaWYgKCFmLmVxdWFsaXR5RGVlcChwcmV2U3RhdGUsIHN0YXRlKSkge1xuICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgZmlsdGVyZWRVcGRhdGVkLmxlbmd0aCA+IDAgfHwgcmVtb3ZlZC5sZW5ndGggPiAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ2NoYW5nZScsIFt7IGFkZGVkLCB1cGRhdGVkOiBmaWx0ZXJlZFVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gICAgfVxuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgW3sgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWQgfSwgJ2xvY2FsJ10pXG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkXG4gICAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICAgKi9cbiAgc2V0TG9jYWxTdGF0ZUZpZWxkIChmaWVsZCwgdmFsdWUpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0TG9jYWxTdGF0ZSgpXG4gICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICB0aGlzLnNldExvY2FsU3RhdGUoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgW2ZpZWxkXTogdmFsdWVcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge01hcDxudW1iZXIsT2JqZWN0PHN0cmluZyxhbnk+Pn1cbiAgICovXG4gIGdldFN0YXRlcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGVzXG4gIH1cbn1cblxuLyoqXG4gKiBNYXJrIChyZW1vdGUpIGNsaWVudHMgYXMgaW5hY3RpdmUgYW5kIHJlbW92ZSB0aGVtIGZyb20gdGhlIGxpc3Qgb2YgYWN0aXZlIHBlZXJzLlxuICogVGhpcyBjaGFuZ2Ugd2lsbCBiZSBwcm9wYWdhdGVkIHRvIHJlbW90ZSBjbGllbnRzLlxuICpcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY2xpZW50c1xuICogQHBhcmFtIHthbnl9IG9yaWdpblxuICovXG5leHBvcnQgY29uc3QgcmVtb3ZlQXdhcmVuZXNzU3RhdGVzID0gKGF3YXJlbmVzcywgY2xpZW50cywgb3JpZ2luKSA9PiB7XG4gIGNvbnN0IHJlbW92ZWQgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGNsaWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGNsaWVudHNbaV1cbiAgICBpZiAoYXdhcmVuZXNzLnN0YXRlcy5oYXMoY2xpZW50SUQpKSB7XG4gICAgICBhd2FyZW5lc3Muc3RhdGVzLmRlbGV0ZShjbGllbnRJRClcbiAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEKSB7XG4gICAgICAgIGNvbnN0IGN1ck1ldGEgPSAvKiogQHR5cGUge01ldGFDbGllbnRTdGF0ZX0gKi8gKGF3YXJlbmVzcy5tZXRhLmdldChjbGllbnRJRCkpXG4gICAgICAgIGF3YXJlbmVzcy5tZXRhLnNldChjbGllbnRJRCwge1xuICAgICAgICAgIGNsb2NrOiBjdXJNZXRhLmNsb2NrICsgMSxcbiAgICAgICAgICBsYXN0VXBkYXRlZDogdGltZS5nZXRVbml4VGltZSgpXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgfVxuICB9XG4gIGlmIChyZW1vdmVkLmxlbmd0aCA+IDApIHtcbiAgICBhd2FyZW5lc3MuZW1pdCgnY2hhbmdlJywgW3sgYWRkZWQ6IFtdLCB1cGRhdGVkOiBbXSwgcmVtb3ZlZCB9LCBvcmlnaW5dKVxuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbeyBhZGRlZDogW10sIHVwZGF0ZWQ6IFtdLCByZW1vdmVkIH0sIG9yaWdpbl0pXG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0F3YXJlbmVzc30gYXdhcmVuZXNzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGNsaWVudHNcbiAqIEByZXR1cm4ge1VpbnQ4QXJyYXl9XG4gKi9cbmV4cG9ydCBjb25zdCBlbmNvZGVBd2FyZW5lc3NVcGRhdGUgPSAoYXdhcmVuZXNzLCBjbGllbnRzLCBzdGF0ZXMgPSBhd2FyZW5lc3Muc3RhdGVzKSA9PiB7XG4gIGNvbnN0IGxlbiA9IGNsaWVudHMubGVuZ3RoXG4gIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIGxlbilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGNsaWVudElEID0gY2xpZW50c1tpXVxuICAgIGNvbnN0IHN0YXRlID0gc3RhdGVzLmdldChjbGllbnRJRCkgfHwgbnVsbFxuICAgIGNvbnN0IGNsb2NrID0gLyoqIEB0eXBlIHtNZXRhQ2xpZW50U3RhdGV9ICovIChhd2FyZW5lc3MubWV0YS5nZXQoY2xpZW50SUQpKS5jbG9ja1xuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKVxuICB9XG4gIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2Rlcilcbn1cblxuLyoqXG4gKiBNb2RpZnkgdGhlIGNvbnRlbnQgb2YgYW4gYXdhcmVuZXNzIHVwZGF0ZSBiZWZvcmUgcmUtZW5jb2RpbmcgaXQgdG8gYW4gYXdhcmVuZXNzIHVwZGF0ZS5cbiAqXG4gKiBUaGlzIG1pZ2h0IGJlIHVzZWZ1bCB3aGVuIHlvdSBoYXZlIGEgY2VudHJhbCBzZXJ2ZXIgdGhhdCB3YW50cyB0byBlbnN1cmUgdGhhdCBjbGllbnRzXG4gKiBjYW50IGhpamFjayBzb21lYm9keSBlbHNlcyBpZGVudGl0eS5cbiAqXG4gKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOmFueX0gbW9kaWZ5XG4gKiBAcmV0dXJuIHtVaW50OEFycmF5fVxuICovXG5leHBvcnQgY29uc3QgbW9kaWZ5QXdhcmVuZXNzVXBkYXRlID0gKHVwZGF0ZSwgbW9kaWZ5KSA9PiB7XG4gIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKHVwZGF0ZSlcbiAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICBjb25zdCBsZW4gPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgbGVuKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY2xpZW50SUQgPSBkZWNvZGluZy5yZWFkVmFyVWludChkZWNvZGVyKVxuICAgIGNvbnN0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBtb2RpZmllZFN0YXRlID0gbW9kaWZ5KHN0YXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBjbGllbnRJRClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgY2xvY2spXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgSlNPTi5zdHJpbmdpZnkobW9kaWZpZWRTdGF0ZSkpXG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7QXdhcmVuZXNzfSBhd2FyZW5lc3NcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gdXBkYXRlXG4gKiBAcGFyYW0ge2FueX0gb3JpZ2luIFRoaXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgZW1pdHRlZCBjaGFuZ2UgZXZlbnRcbiAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5QXdhcmVuZXNzVXBkYXRlID0gKGF3YXJlbmVzcywgdXBkYXRlLCBvcmlnaW4pID0+IHtcbiAgY29uc3QgZGVjb2RlciA9IGRlY29kaW5nLmNyZWF0ZURlY29kZXIodXBkYXRlKVxuICBjb25zdCB0aW1lc3RhbXAgPSB0aW1lLmdldFVuaXhUaW1lKClcbiAgY29uc3QgYWRkZWQgPSBbXVxuICBjb25zdCB1cGRhdGVkID0gW11cbiAgY29uc3QgZmlsdGVyZWRVcGRhdGVkID0gW11cbiAgY29uc3QgcmVtb3ZlZCA9IFtdXG4gIGNvbnN0IGxlbiA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBjbGllbnRJRCA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgbGV0IGNsb2NrID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICBjb25zdCBzdGF0ZSA9IEpTT04ucGFyc2UoZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKSlcbiAgICBjb25zdCBjbGllbnRNZXRhID0gYXdhcmVuZXNzLm1ldGEuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IHByZXZTdGF0ZSA9IGF3YXJlbmVzcy5zdGF0ZXMuZ2V0KGNsaWVudElEKVxuICAgIGNvbnN0IGN1cnJDbG9jayA9IGNsaWVudE1ldGEgPT09IHVuZGVmaW5lZCA/IDAgOiBjbGllbnRNZXRhLmNsb2NrXG4gICAgaWYgKGN1cnJDbG9jayA8IGNsb2NrIHx8IChjdXJyQ2xvY2sgPT09IGNsb2NrICYmIHN0YXRlID09PSBudWxsICYmIGF3YXJlbmVzcy5zdGF0ZXMuaGFzKGNsaWVudElEKSkpIHtcbiAgICAgIGlmIChzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAvLyBuZXZlciBsZXQgYSByZW1vdGUgY2xpZW50IHJlbW92ZSB0aGlzIGxvY2FsIHN0YXRlXG4gICAgICAgIGlmIChjbGllbnRJRCA9PT0gYXdhcmVuZXNzLmNsaWVudElEICYmIGF3YXJlbmVzcy5nZXRMb2NhbFN0YXRlKCkgIT0gbnVsbCkge1xuICAgICAgICAgIC8vIHJlbW90ZSBjbGllbnQgcmVtb3ZlZCB0aGUgbG9jYWwgc3RhdGUuIERvIG5vdCByZW1vdGUgc3RhdGUuIEJyb2FkY2FzdCBhIG1lc3NhZ2UgaW5kaWNhdGluZ1xuICAgICAgICAgIC8vIHRoYXQgdGhpcyBjbGllbnQgc3RpbGwgZXhpc3RzIGJ5IGluY3JlYXNpbmcgdGhlIGNsb2NrXG4gICAgICAgICAgY2xvY2srK1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YXJlbmVzcy5zdGF0ZXMuZGVsZXRlKGNsaWVudElEKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FyZW5lc3Muc3RhdGVzLnNldChjbGllbnRJRCwgc3RhdGUpXG4gICAgICB9XG4gICAgICBhd2FyZW5lc3MubWV0YS5zZXQoY2xpZW50SUQsIHtcbiAgICAgICAgY2xvY2ssXG4gICAgICAgIGxhc3RVcGRhdGVkOiB0aW1lc3RhbXBcbiAgICAgIH0pXG4gICAgICBpZiAoY2xpZW50TWV0YSA9PT0gdW5kZWZpbmVkICYmIHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFkZGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKGNsaWVudE1ldGEgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZW1vdmVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIGlmICghZi5lcXVhbGl0eURlZXAoc3RhdGUsIHByZXZTdGF0ZSkpIHtcbiAgICAgICAgICBmaWx0ZXJlZFVwZGF0ZWQucHVzaChjbGllbnRJRClcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVkLnB1c2goY2xpZW50SUQpXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmIChhZGRlZC5sZW5ndGggPiAwIHx8IGZpbHRlcmVkVXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCdjaGFuZ2UnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQ6IGZpbHRlcmVkVXBkYXRlZCwgcmVtb3ZlZFxuICAgIH0sIG9yaWdpbl0pXG4gIH1cbiAgaWYgKGFkZGVkLmxlbmd0aCA+IDAgfHwgdXBkYXRlZC5sZW5ndGggPiAwIHx8IHJlbW92ZWQubGVuZ3RoID4gMCkge1xuICAgIGF3YXJlbmVzcy5lbWl0KCd1cGRhdGUnLCBbe1xuICAgICAgYWRkZWQsIHVwZGF0ZWQsIHJlbW92ZWRcbiAgICB9LCBvcmlnaW5dKVxuICB9XG59XG4iLCAiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbmltcG9ydCAqIGFzIGVuY29kaW5nIGZyb20gJ2xpYjAvZW5jb2RpbmcnXG5pbXBvcnQgKiBhcyBkZWNvZGluZyBmcm9tICdsaWIwL2RlY29kaW5nJ1xuaW1wb3J0ICogYXMgcHJvbWlzZSBmcm9tICdsaWIwL3Byb21pc2UnXG5pbXBvcnQgKiBhcyBlcnJvciBmcm9tICdsaWIwL2Vycm9yJ1xuaW1wb3J0ICogYXMgc3RyaW5nIGZyb20gJ2xpYjAvc3RyaW5nJ1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzZWNyZXRcbiAqIEBwYXJhbSB7c3RyaW5nfSByb29tTmFtZVxuICogQHJldHVybiB7UHJvbWlzZUxpa2U8Q3J5cHRvS2V5Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGRlcml2ZUtleSA9IChzZWNyZXQsIHJvb21OYW1lKSA9PiB7XG4gIGNvbnN0IHNlY3JldEJ1ZmZlciA9IHN0cmluZy5lbmNvZGVVdGY4KHNlY3JldCkuYnVmZmVyXG4gIGNvbnN0IHNhbHQgPSBzdHJpbmcuZW5jb2RlVXRmOChyb29tTmFtZSkuYnVmZmVyXG4gIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleShcbiAgICAncmF3JyxcbiAgICBzZWNyZXRCdWZmZXIsXG4gICAgJ1BCS0RGMicsXG4gICAgZmFsc2UsXG4gICAgWydkZXJpdmVLZXknXVxuICApLnRoZW4oa2V5TWF0ZXJpYWwgPT5cbiAgICBjcnlwdG8uc3VidGxlLmRlcml2ZUtleShcbiAgICAgIHtcbiAgICAgICAgbmFtZTogJ1BCS0RGMicsXG4gICAgICAgIHNhbHQsXG4gICAgICAgIGl0ZXJhdGlvbnM6IDEwMDAwMCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnXG4gICAgICB9LFxuICAgICAga2V5TWF0ZXJpYWwsXG4gICAgICB7XG4gICAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgICAgbGVuZ3RoOiAyNTZcbiAgICAgIH0sXG4gICAgICB0cnVlLFxuICAgICAgWydlbmNyeXB0JywgJ2RlY3J5cHQnXVxuICAgIClcbiAgKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YSBkYXRhIHRvIGJlIGVuY3J5cHRlZFxuICogQHBhcmFtIHtDcnlwdG9LZXk/fSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2VMaWtlPFVpbnQ4QXJyYXk+fSBlbmNyeXB0ZWQsIGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuZXhwb3J0IGNvbnN0IGVuY3J5cHQgPSAoZGF0YSwga2V5KSA9PiB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7UHJvbWlzZUxpa2U8VWludDhBcnJheT59ICovIChwcm9taXNlLnJlc29sdmUoZGF0YSkpXG4gIH1cbiAgY29uc3QgaXYgPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDEyKSlcbiAgcmV0dXJuIGNyeXB0by5zdWJ0bGUuZW5jcnlwdChcbiAgICB7XG4gICAgICBuYW1lOiAnQUVTLUdDTScsXG4gICAgICBpdlxuICAgIH0sXG4gICAga2V5LFxuICAgIGRhdGFcbiAgKS50aGVuKGNpcGhlciA9PiB7XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YUVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNyeXB0ZWREYXRhRW5jb2RlciwgJ0FFUy1HQ00nKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludDhBcnJheShlbmNyeXB0ZWREYXRhRW5jb2RlciwgaXYpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY3J5cHRlZERhdGFFbmNvZGVyLCBuZXcgVWludDhBcnJheShjaXBoZXIpKVxuICAgIHJldHVybiBlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jcnlwdGVkRGF0YUVuY29kZXIpXG4gIH0pXG59XG5cbi8qKlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgZGF0YSB0byBiZSBlbmNyeXB0ZWRcbiAqIEBwYXJhbSB7Q3J5cHRvS2V5P30ga2V5XG4gKiBAcmV0dXJuIHtQcm9taXNlTGlrZTxVaW50OEFycmF5Pn0gZW5jcnlwdGVkIGRhdGEsIGlmIGtleSBpcyBwcm92aWRlZFxuICovXG5leHBvcnQgY29uc3QgZW5jcnlwdEpzb24gPSAoZGF0YSwga2V5KSA9PiB7XG4gIGNvbnN0IGRhdGFFbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gIGVuY29kaW5nLndyaXRlQW55KGRhdGFFbmNvZGVyLCBkYXRhKVxuICByZXR1cm4gZW5jcnlwdChlbmNvZGluZy50b1VpbnQ4QXJyYXkoZGF0YUVuY29kZXIpLCBrZXkpXG59XG5cbi8qKlxuICogQHBhcmFtIHtVaW50OEFycmF5fSBkYXRhXG4gKiBAcGFyYW0ge0NyeXB0b0tleT99IGtleVxuICogQHJldHVybiB7UHJvbWlzZUxpa2U8VWludDhBcnJheT59IGRlY3J5cHRlZCBidWZmZXJcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY3J5cHQgPSAoZGF0YSwga2V5KSA9PiB7XG4gIGlmICgha2V5KSB7XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7UHJvbWlzZUxpa2U8VWludDhBcnJheT59ICovIChwcm9taXNlLnJlc29sdmUoZGF0YSkpXG4gIH1cbiAgY29uc3QgZGF0YURlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRhdGEpXG4gIGNvbnN0IGFsZ29yaXRobSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGF0YURlY29kZXIpXG4gIGlmIChhbGdvcml0aG0gIT09ICdBRVMtR0NNJykge1xuICAgIHByb21pc2UucmVqZWN0KGVycm9yLmNyZWF0ZSgnVW5rbm93biBlbmNyeXB0aW9uIGFsZ29yaXRobScpKVxuICB9XG4gIGNvbnN0IGl2ID0gZGVjb2RpbmcucmVhZFZhclVpbnQ4QXJyYXkoZGF0YURlY29kZXIpXG4gIGNvbnN0IGNpcGhlciA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRhdGFEZWNvZGVyKVxuICByZXR1cm4gY3J5cHRvLnN1YnRsZS5kZWNyeXB0KFxuICAgIHtcbiAgICAgIG5hbWU6ICdBRVMtR0NNJyxcbiAgICAgIGl2XG4gICAgfSxcbiAgICBrZXksXG4gICAgY2lwaGVyXG4gICkudGhlbihkYXRhID0+IG5ldyBVaW50OEFycmF5KGRhdGEpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7VWludDhBcnJheX0gZGF0YVxuICogQHBhcmFtIHtDcnlwdG9LZXk/fSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2VMaWtlPE9iamVjdD59IGRlY3J5cHRlZCBvYmplY3RcbiAqL1xuZXhwb3J0IGNvbnN0IGRlY3J5cHRKc29uID0gKGRhdGEsIGtleSkgPT5cbiAgZGVjcnlwdChkYXRhLCBrZXkpLnRoZW4oZGVjcnlwdGVkVmFsdWUgPT5cbiAgICBkZWNvZGluZy5yZWFkQW55KGRlY29kaW5nLmNyZWF0ZURlY29kZXIobmV3IFVpbnQ4QXJyYXkoZGVjcnlwdGVkVmFsdWUpKSlcbiAgKVxuIiwgImltcG9ydCBQZWVyRHJhZnRQbHVnaW4gZnJvbSAnc3JjL21haW4nXG5pbXBvcnQgeyBXZWJydGNQcm92aWRlciB9IGZyb20gJ3ktd2VicnRjJ1xuaW1wb3J0IHsgSW5kZXhlZGRiUGVyc2lzdGVuY2UgfSBmcm9tIFwieS1pbmRleGVkZGJcIlxuaW1wb3J0ICogYXMgWSBmcm9tICd5anMnXG5pbXBvcnQgeyBjcmVhdGVSYW5kb21JZCB9IGZyb20gJ3NyYy90b29scydcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGggfSBmcm9tICdvYnNpZGlhbidcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTaGFyZWRFbnRpdHkge1xuXG4gIHN0YXRpYyBEQl9QRVJTSVNURU5DRV9QUkVGSVggPSBcInBlZXJkcmFmdF9wZXJzaXN0ZW5jZV9cIlxuXG4gIHlEb2M6IFkuRG9jXG4gIHByb3RlY3RlZCBfc2hhcmVJZDogc3RyaW5nXG5cbiAgcHJvdGVjdGVkIF93ZWJSVENQcm92aWRlcj86IFdlYnJ0Y1Byb3ZpZGVyXG4gIHByb3RlY3RlZCBfd2ViUlRDVGltZW91dDogbnVtYmVyIHwgbnVsbCA9IG51bGxcblxuICBwcm90ZWN0ZWQgX2luZGV4ZWREQlByb3ZpZGVyPzogSW5kZXhlZGRiUGVyc2lzdGVuY2VcblxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWRFbnRpdHk+O1xuXG4gIHByb3RlY3RlZCBfcGF0aDogc3RyaW5nXG5cbiAgZ2V0IHNoYXJlSWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NoYXJlSWRcbiAgfVxuXG4gIGdldCBwYXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXRoXG4gIH1cblxuICBnZXQgaW5kZXhlZERCUHJvdmlkZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyXG4gIH1cblxuICBnZXQgd2ViUlRDUHJvdmlkZXIoKXtcbiAgICByZXR1cm4gdGhpcy5fd2ViUlRDUHJvdmlkZXJcbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoKVxuICAgIGNvbnN0IGRvY3MgPSB0aGlzLl9zaGFyZWRFbnRpdGVzLmZpbHRlcihkb2MgPT4ge1xuICAgICAgcmV0dXJuIGRvYy5wYXRoID09PSBub3JtYWxpemVkUGF0aFxuICAgIH0pXG4gICAgaWYgKGRvY3MubGVuZ3RoID49IDEpIHtcbiAgICAgIHJldHVybiBkb2NzWzBdXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlJZChpZDogc3RyaW5nKSB7XG4gICAgY29uc3QgZG9jcyA9IHRoaXMuX3NoYXJlZEVudGl0ZXMuZmlsdGVyKGRvYyA9PiB7XG4gICAgICByZXR1cm4gZG9jLnNoYXJlSWQgPT09IGlkXG4gICAgfSlcbiAgICBpZiAoZG9jcy5sZW5ndGggPj0gMSkge1xuICAgICAgcmV0dXJuIGRvY3NbMF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgc3RhdGljIGdldEFsbCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihbXSwgdGhpcy5fc2hhcmVkRW50aXRlcykgYXMgQXJyYXk8U2hhcmVkRW50aXR5PlxuICB9XG5cbiAgY29uc3RydWN0b3IocHJvdGVjdGVkIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7fVxuXG4gIGFic3RyYWN0IGNhbGN1bGF0ZUhhc2ggKCk6IHN0cmluZ1xuXG4gIGluaXRTZXJ2ZXJZRG9jKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgdGVtcElkID0gY3JlYXRlUmFuZG9tSWQoKVxuICAgICAgY29uc3QgaGFuZGxlciA9IChzZXJ2ZXJUZW1wSWQ6IHN0cmluZywgaWQ6IHN0cmluZywgY2hlY2tzdW06IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoc2VydmVyVGVtcElkID09PSB0ZW1wSWQpIHtcbiAgICAgICAgICB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLm9mZignbmV3LWRvYy1jb25maXJtZWQnLCBoYW5kbGVyKVxuICAgICAgICAgIHRoaXMuX3NoYXJlSWQgPSBpZFxuICAgICAgICAgIHJlc29sdmUoY2hlY2tzdW0pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMub24oJ25ldy1kb2MtY29uZmlybWVkJywgaGFuZGxlcilcbiAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMuc2VuZE5ld0RvY3VtZW50KHRoaXMsIHRlbXBJZClcbiAgICB9KVxuICB9XG5cbiAgc3luY1dpdGhTZXJ2ZXIoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPHN0cmluZz4ocmVzb2x2ZSA9PiB7XG4gICAgICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKGlkOiBzdHJpbmcsIGhhc2g6IHN0cmluZykgPT4ge1xuICAgICAgICBpZiAoaWQgPT09IHRoaXMuc2hhcmVJZCkge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMub2ZmKCdzeW5jZWQnLCBoYW5kbGVyKVxuICAgICAgICAgIHRoaXMucGx1Z2luLmxvZyhcInN5bmNlZCBcIiArIHRoaXMucGF0aClcbiAgICAgICAgICByZXNvbHZlKGhhc2gpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMub24oJ3N5bmNlZCcsIGhhbmRsZXIpXG4gICAgICBcbiAgICAgIHRoaXMucGx1Z2luLnNlcnZlclN5bmMuc2VuZFN5bmNTdGVwMSh0aGlzKVxuICAgICAgdGhpcy5wbHVnaW4ubG9nKFwic3luY2luZyBcIiArIHRoaXMucGF0aClcbiAgICB9KVxuICB9XG5cblxuICBzdGFydFdlYlJUQ1N5bmMoaW5pdD86IChwcm92aWRlcjogV2VicnRjUHJvdmlkZXIpID0+IGFueSkge1xuICAgIHRoaXMucGx1Z2luLmxvZyhgV2ViUlRDIGZvciAke3RoaXMucGF0aH06IHN0YXJ0YClcbiAgICBpZiAoIXRoaXMuc2hhcmVJZCkgcmV0dXJuXG4gICAgaWYgKHRoaXMuX3dlYlJUQ1Byb3ZpZGVyKSB7XG4gICAgICB0aGlzLl93ZWJSVENQcm92aWRlci5jb25uZWN0KClcbiAgICAgIHJldHVybiB0aGlzLl93ZWJSVENQcm92aWRlclxuICAgIH1cbiAgICBjb25zdCB3ZWJSVENQcm92aWRlciA9IG5ldyBXZWJydGNQcm92aWRlcih0aGlzLl9zaGFyZUlkLCB0aGlzLnlEb2MsIHsgc2lnbmFsaW5nOiBbdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2lnbmFsaW5nXSwgcGVlck9wdHM6IHsgaWNlU2VydmVyczogW3sgdXJsczogJ3N0dW46ZnJlZXR1cm4ubmV0OjUzNDknIH0sIHsgdXJsczogJ3R1cm5zOmZyZWV0dXJuLm5ldDo1MzQ5JywgdXNlcm5hbWU6ICdmcmVlJywgY3JlZGVudGlhbDogJ2ZyZWUnIH0sIHsgdXJsczogJ3N0dW46c3R1bi5sLmdvb2dsZS5jb206MTkzMDInIH0sIHsgdXJsczogJ3N0dW46Z2xvYmFsLnN0dW4udHdpbGlvLmNvbTozNDc4P3RyYW5zcG9ydD11ZHAnIH1dIH0gfSlcbiAgICB0aGlzLl93ZWJSVENQcm92aWRlciA9IHdlYlJUQ1Byb3ZpZGVyXG4gICAgaWYgKGluaXQpIHtcbiAgICAgIGluaXQod2ViUlRDUHJvdmlkZXIpXG4gICAgfVxuICAgIHJldHVybiB3ZWJSVENQcm92aWRlclxuICB9XG5cbiAgc3RvcFdlYlJUQ1N5bmMoKSB7XG4gICAgaWYgKCF0aGlzLl93ZWJSVENQcm92aWRlcikgcmV0dXJuXG4gICAgdGhpcy5wbHVnaW4ubG9nKGBXZWJSVEMgZm9yICR7dGhpcy5wYXRofTogc3RvcGApXG4gICAgdGhpcy5fd2ViUlRDUHJvdmlkZXI/LmF3YXJlbmVzcy5kZXN0cm95KClcbiAgICB0aGlzLl93ZWJSVENQcm92aWRlcj8uZGlzY29ubmVjdCgpXG4gICAgdGhpcy5fd2ViUlRDUHJvdmlkZXI/LmRlc3Ryb3koKVxuICAgIHRoaXMuX3dlYlJUQ1Byb3ZpZGVyID0gdW5kZWZpbmVkXG4gIH1cblxuICBhc3luYyBzdG9wSW5kZXhlZERCU3luYygpIHtcbiAgICBpZiAoIXRoaXMuX2luZGV4ZWREQlByb3ZpZGVyKSByZXR1cm5cbiAgICBhd2FpdCB0aGlzLl9pbmRleGVkREJQcm92aWRlci5kZXN0cm95KClcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdG9wV2ViUlRDU3luYygpXG4gIH1cblxufSIsICIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBIZWxwZXJzIHRvIHdvcmsgd2l0aCBJbmRleGVkREIuXG4gKlxuICogQG1vZHVsZSBpbmRleGVkZGJcbiAqL1xuXG5pbXBvcnQgKiBhcyBwcm9taXNlIGZyb20gJy4vcHJvbWlzZS5qcydcbmltcG9ydCAqIGFzIGVycm9yIGZyb20gJy4vZXJyb3IuanMnXG5cbi8qIGM4IGlnbm9yZSBzdGFydCAqL1xuXG4vKipcbiAqIElEQiBSZXF1ZXN0IHRvIFByb21pc2UgdHJhbnNmb3JtZXJcbiAqXG4gKiBAcGFyYW0ge0lEQlJlcXVlc3R9IHJlcXVlc3RcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IHJ0b3AgPSByZXF1ZXN0ID0+IHByb21pc2UuY3JlYXRlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgLy8gQHRzLWlnbm9yZVxuICByZXF1ZXN0Lm9uZXJyb3IgPSBldmVudCA9PiByZWplY3QobmV3IEVycm9yKGV2ZW50LnRhcmdldC5lcnJvcikpXG4gIC8vIEB0cy1pZ25vcmVcbiAgcmVxdWVzdC5vbnN1Y2Nlc3MgPSBldmVudCA9PiByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpXG59KVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkRhdGFiYXNlKTphbnl9IGluaXREQiBDYWxsZWQgd2hlbiB0aGUgZGF0YWJhc2UgaXMgZmlyc3QgY3JlYXRlZFxuICogQHJldHVybiB7UHJvbWlzZTxJREJEYXRhYmFzZT59XG4gKi9cbmV4cG9ydCBjb25zdCBvcGVuREIgPSAobmFtZSwgaW5pdERCKSA9PiBwcm9taXNlLmNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIGNvbnN0IHJlcXVlc3QgPSBpbmRleGVkREIub3BlbihuYW1lKVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9udXBncmFkZW5lZWRlZCA9IGV2ZW50ID0+IGluaXREQihldmVudC50YXJnZXQucmVzdWx0KVxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uZXJyb3IgPSBldmVudCA9PiByZWplY3QoZXJyb3IuY3JlYXRlKGV2ZW50LnRhcmdldC5lcnJvcikpXG4gIC8qKlxuICAgKiBAcGFyYW0ge2FueX0gZXZlbnRcbiAgICovXG4gIHJlcXVlc3Qub25zdWNjZXNzID0gZXZlbnQgPT4ge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtJREJEYXRhYmFzZX1cbiAgICAgKi9cbiAgICBjb25zdCBkYiA9IGV2ZW50LnRhcmdldC5yZXN1bHRcbiAgICBkYi5vbnZlcnNpb25jaGFuZ2UgPSAoKSA9PiB7IGRiLmNsb3NlKCkgfVxuICAgIHJlc29sdmUoZGIpXG4gIH1cbn0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbGV0ZURCID0gbmFtZSA9PiBydG9wKGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShuYW1lKSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQkRhdGFiYXNlfSBkYlxuICogQHBhcmFtIHtBcnJheTxBcnJheTxzdHJpbmc+fEFycmF5PHN0cmluZ3xJREJPYmplY3RTdG9yZVBhcmFtZXRlcnN8dW5kZWZpbmVkPj59IGRlZmluaXRpb25zXG4gKi9cbmV4cG9ydCBjb25zdCBjcmVhdGVTdG9yZXMgPSAoZGIsIGRlZmluaXRpb25zKSA9PiBkZWZpbml0aW9ucy5mb3JFYWNoKGQgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICBkYi5jcmVhdGVPYmplY3RTdG9yZS5hcHBseShkYiwgZClcbilcblxuLyoqXG4gKiBAcGFyYW0ge0lEQkRhdGFiYXNlfSBkYlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBzdG9yZXNcbiAqIEBwYXJhbSB7XCJyZWFkd3JpdGVcInxcInJlYWRvbmx5XCJ9IFthY2Nlc3NdXG4gKiBAcmV0dXJuIHtBcnJheTxJREJPYmplY3RTdG9yZT59XG4gKi9cbmV4cG9ydCBjb25zdCB0cmFuc2FjdCA9IChkYiwgc3RvcmVzLCBhY2Nlc3MgPSAncmVhZHdyaXRlJykgPT4ge1xuICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKHN0b3JlcywgYWNjZXNzKVxuICByZXR1cm4gc3RvcmVzLm1hcChzdG9yZSA9PiBnZXRTdG9yZSh0cmFuc2FjdGlvbiwgc3RvcmUpKVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPG51bWJlcj59XG4gKi9cbmV4cG9ydCBjb25zdCBjb3VudCA9IChzdG9yZSwgcmFuZ2UpID0+XG4gIHJ0b3Aoc3RvcmUuY291bnQocmFuZ2UpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT4gfSBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pj59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXQgPSAoc3RvcmUsIGtleSkgPT5cbiAgcnRvcChzdG9yZS5nZXQoa2V5KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtTdHJpbmcgfCBudW1iZXIgfCBBcnJheUJ1ZmZlciB8IERhdGUgfCBJREJLZXlSYW5nZSB8IEFycmF5PGFueT4gfSBrZXlcbiAqL1xuZXhwb3J0IGNvbnN0IGRlbCA9IChzdG9yZSwga2V5KSA9PlxuICBydG9wKHN0b3JlLmRlbGV0ZShrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IGJvb2xlYW59IGl0ZW1cbiAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgQXJyYXk8YW55Pn0gW2tleV1cbiAqL1xuZXhwb3J0IGNvbnN0IHB1dCA9IChzdG9yZSwgaXRlbSwga2V5KSA9PlxuICBydG9wKHN0b3JlLnB1dChpdGVtLCBrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IGJvb2xlYW59ICBpdGVtXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZSB8IEFycmF5PGFueT59ICBrZXlcbiAqIEByZXR1cm4ge1Byb21pc2U8YW55Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGFkZCA9IChzdG9yZSwgaXRlbSwga2V5KSA9PlxuICBydG9wKHN0b3JlLmFkZChpdGVtLCBrZXkpKVxuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0gIGl0ZW1cbiAqIEByZXR1cm4ge1Byb21pc2U8bnVtYmVyPn0gUmV0dXJucyB0aGUgZ2VuZXJhdGVkIGtleVxuICovXG5leHBvcnQgY29uc3QgYWRkQXV0b0tleSA9IChzdG9yZSwgaXRlbSkgPT5cbiAgcnRvcChzdG9yZS5hZGQoaXRlbSkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGFueT4+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0QWxsID0gKHN0b3JlLCByYW5nZSwgbGltaXQpID0+XG4gIHJ0b3Aoc3RvcmUuZ2V0QWxsKHJhbmdlLCBsaW1pdCkpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V9IFtyYW5nZV1cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdXG4gKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PGFueT4+fVxuICovXG5leHBvcnQgY29uc3QgZ2V0QWxsS2V5cyA9IChzdG9yZSwgcmFuZ2UsIGxpbWl0KSA9PlxuICBydG9wKHN0b3JlLmdldEFsbEtleXMocmFuZ2UsIGxpbWl0KSlcblxuLyoqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBxdWVyeVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICogQHJldHVybiB7UHJvbWlzZTxhbnk+fVxuICovXG5leHBvcnQgY29uc3QgcXVlcnlGaXJzdCA9IChzdG9yZSwgcXVlcnksIGRpcmVjdGlvbikgPT4ge1xuICAvKipcbiAgICogQHR5cGUge2FueX1cbiAgICovXG4gIGxldCBmaXJzdCA9IG51bGxcbiAgcmV0dXJuIGl0ZXJhdGVLZXlzKHN0b3JlLCBxdWVyeSwga2V5ID0+IHtcbiAgICBmaXJzdCA9IGtleVxuICAgIHJldHVybiBmYWxzZVxuICB9LCBkaXJlY3Rpb24pLnRoZW4oKCkgPT4gZmlyc3QpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2U/fSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRMYXN0S2V5ID0gKHN0b3JlLCByYW5nZSA9IG51bGwpID0+IHF1ZXJ5Rmlyc3Qoc3RvcmUsIHJhbmdlLCAncHJldicpXG5cbi8qKlxuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2U/fSBbcmFuZ2VdXG4gKiBAcmV0dXJuIHtQcm9taXNlPGFueT59XG4gKi9cbmV4cG9ydCBjb25zdCBnZXRGaXJzdEtleSA9IChzdG9yZSwgcmFuZ2UgPSBudWxsKSA9PiBxdWVyeUZpcnN0KHN0b3JlLCByYW5nZSwgJ25leHQnKVxuXG4vKipcbiAqIEB0eXBlZGVmIEtleVZhbHVlUGFpclxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7YW55fSBrIGtleVxuICogQHByb3BlcnR5IHthbnl9IHYgVmFsdWVcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHN0b3JlXG4gKiBAcGFyYW0ge0lEQktleVJhbmdlfSBbcmFuZ2VdXG4gKiBAcGFyYW0ge251bWJlcn0gW2xpbWl0XVxuICogQHJldHVybiB7UHJvbWlzZTxBcnJheTxLZXlWYWx1ZVBhaXI+Pn1cbiAqL1xuZXhwb3J0IGNvbnN0IGdldEFsbEtleXNWYWx1ZXMgPSAoc3RvcmUsIHJhbmdlLCBsaW1pdCkgPT5cbiAgLy8gQHRzLWlnbm9yZVxuICBwcm9taXNlLmFsbChbZ2V0QWxsS2V5cyhzdG9yZSwgcmFuZ2UsIGxpbWl0KSwgZ2V0QWxsKHN0b3JlLCByYW5nZSwgbGltaXQpXSkudGhlbigoW2tzLCB2c10pID0+IGtzLm1hcCgoaywgaSkgPT4gKHsgaywgdjogdnNbaV0gfSkpKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSByZXF1ZXN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9uKElEQkN1cnNvcldpdGhWYWx1ZSk6dm9pZHxib29sZWFufFByb21pc2U8dm9pZHxib29sZWFuPn0gZlxuICogQHJldHVybiB7UHJvbWlzZTx2b2lkPn1cbiAqL1xuY29uc3QgaXRlcmF0ZU9uUmVxdWVzdCA9IChyZXF1ZXN0LCBmKSA9PiBwcm9taXNlLmNyZWF0ZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gIHJlcXVlc3Qub25lcnJvciA9IHJlamVjdFxuICAvKipcbiAgICogQHBhcmFtIHthbnl9IGV2ZW50XG4gICAqL1xuICByZXF1ZXN0Lm9uc3VjY2VzcyA9IGFzeW5jIGV2ZW50ID0+IHtcbiAgICBjb25zdCBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0XG4gICAgaWYgKGN1cnNvciA9PT0gbnVsbCB8fCAoYXdhaXQgZihjdXJzb3IpKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByZXNvbHZlKClcbiAgICB9XG4gICAgY3Vyc29yLmNvbnRpbnVlKClcbiAgfVxufSlcblxuLyoqXG4gKiBJdGVyYXRlIG9uIGtleXMgYW5kIHZhbHVlc1xuICogQHBhcmFtIHtJREJPYmplY3RTdG9yZX0gc3RvcmVcbiAqIEBwYXJhbSB7SURCS2V5UmFuZ2V8bnVsbH0ga2V5cmFuZ2VcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oYW55LGFueSk6dm9pZHxib29sZWFufFByb21pc2U8dm9pZHxib29sZWFuPn0gZiBDYWxsYmFjayB0aGF0IHJlY2VpdmVzICh2YWx1ZSwga2V5KVxuICogQHBhcmFtIHsnbmV4dCd8J3ByZXYnfCduZXh0dW5pcXVlJ3wncHJldnVuaXF1ZSd9IGRpcmVjdGlvblxuICovXG5leHBvcnQgY29uc3QgaXRlcmF0ZSA9IChzdG9yZSwga2V5cmFuZ2UsIGYsIGRpcmVjdGlvbiA9ICduZXh0JykgPT5cbiAgaXRlcmF0ZU9uUmVxdWVzdChzdG9yZS5vcGVuQ3Vyc29yKGtleXJhbmdlLCBkaXJlY3Rpb24pLCBjdXJzb3IgPT4gZihjdXJzb3IudmFsdWUsIGN1cnNvci5rZXkpKVxuXG4vKipcbiAqIEl0ZXJhdGUgb24gdGhlIGtleXMgKG5vIHZhbHVlcylcbiAqXG4gKiBAcGFyYW0ge0lEQk9iamVjdFN0b3JlfSBzdG9yZVxuICogQHBhcmFtIHtJREJLZXlSYW5nZXxudWxsfSBrZXlyYW5nZVxuICogQHBhcmFtIHtmdW5jdGlvbihhbnkpOnZvaWR8Ym9vbGVhbnxQcm9taXNlPHZvaWR8Ym9vbGVhbj59IGYgY2FsbGJhY2sgdGhhdCByZWNlaXZlcyB0aGUga2V5XG4gKiBAcGFyYW0geyduZXh0J3wncHJldid8J25leHR1bmlxdWUnfCdwcmV2dW5pcXVlJ30gZGlyZWN0aW9uXG4gKi9cbmV4cG9ydCBjb25zdCBpdGVyYXRlS2V5cyA9IChzdG9yZSwga2V5cmFuZ2UsIGYsIGRpcmVjdGlvbiA9ICduZXh0JykgPT5cbiAgaXRlcmF0ZU9uUmVxdWVzdChzdG9yZS5vcGVuS2V5Q3Vyc29yKGtleXJhbmdlLCBkaXJlY3Rpb24pLCBjdXJzb3IgPT4gZihjdXJzb3Iua2V5KSlcblxuLyoqXG4gKiBPcGVuIHN0b3JlIGZyb20gdHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7SURCVHJhbnNhY3Rpb259IHRcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdG9yZVxuICogQHJldHVybnMge0lEQk9iamVjdFN0b3JlfVxuICovXG5leHBvcnQgY29uc3QgZ2V0U3RvcmUgPSAodCwgc3RvcmUpID0+IHQub2JqZWN0U3RvcmUoc3RvcmUpXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGxvd2VyXG4gKiBAcGFyYW0ge2FueX0gdXBwZXJcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gbG93ZXJPcGVuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHVwcGVyT3BlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VCb3VuZCA9IChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKSA9PiBJREJLZXlSYW5nZS5ib3VuZChsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVuKVxuXG4vKipcbiAqIEBwYXJhbSB7YW55fSB1cHBlclxuICogQHBhcmFtIHtib29sZWFufSB1cHBlck9wZW5cbiAqL1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUlEQktleVJhbmdlVXBwZXJCb3VuZCA9ICh1cHBlciwgdXBwZXJPcGVuKSA9PiBJREJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCB1cHBlck9wZW4pXG5cbi8qKlxuICogQHBhcmFtIHthbnl9IGxvd2VyXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvd2VyT3BlblxuICovXG5leHBvcnQgY29uc3QgY3JlYXRlSURCS2V5UmFuZ2VMb3dlckJvdW5kID0gKGxvd2VyLCBsb3dlck9wZW4pID0+IElEQktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsIGxvd2VyT3BlbilcblxuLyogYzggaWdub3JlIHN0b3AgKi9cbiIsICJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCAqIGFzIGlkYiBmcm9tICdsaWIwL2luZGV4ZWRkYidcbmltcG9ydCAqIGFzIHByb21pc2UgZnJvbSAnbGliMC9wcm9taXNlJ1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ2xpYjAvb2JzZXJ2YWJsZSdcblxuY29uc3QgY3VzdG9tU3RvcmVOYW1lID0gJ2N1c3RvbSdcbmNvbnN0IHVwZGF0ZXNTdG9yZU5hbWUgPSAndXBkYXRlcydcblxuZXhwb3J0IGNvbnN0IFBSRUZFUlJFRF9UUklNX1NJWkUgPSA1MDBcblxuLyoqXG4gKiBAcGFyYW0ge0luZGV4ZWRkYlBlcnNpc3RlbmNlfSBpZGJQZXJzaXN0ZW5jZVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJPYmplY3RTdG9yZSk6dm9pZH0gW2JlZm9yZUFwcGx5VXBkYXRlc0NhbGxiYWNrXVxuICogQHBhcmFtIHtmdW5jdGlvbihJREJPYmplY3RTdG9yZSk6dm9pZH0gW2FmdGVyQXBwbHlVcGRhdGVzQ2FsbGJhY2tdXG4gKi9cbmV4cG9ydCBjb25zdCBmZXRjaFVwZGF0ZXMgPSAoaWRiUGVyc2lzdGVuY2UsIGJlZm9yZUFwcGx5VXBkYXRlc0NhbGxiYWNrID0gKCkgPT4ge30sIGFmdGVyQXBwbHlVcGRhdGVzQ2FsbGJhY2sgPSAoKSA9PiB7fSkgPT4ge1xuICBjb25zdCBbdXBkYXRlc1N0b3JlXSA9IGlkYi50cmFuc2FjdCgvKiogQHR5cGUge0lEQkRhdGFiYXNlfSAqLyAoaWRiUGVyc2lzdGVuY2UuZGIpLCBbdXBkYXRlc1N0b3JlTmFtZV0pIC8vICwgJ3JlYWRvbmx5JylcbiAgcmV0dXJuIGlkYi5nZXRBbGwodXBkYXRlc1N0b3JlLCBpZGIuY3JlYXRlSURCS2V5UmFuZ2VMb3dlckJvdW5kKGlkYlBlcnNpc3RlbmNlLl9kYnJlZiwgZmFsc2UpKS50aGVuKHVwZGF0ZXMgPT4ge1xuICAgIGlmICghaWRiUGVyc2lzdGVuY2UuX2Rlc3Ryb3llZCkge1xuICAgICAgYmVmb3JlQXBwbHlVcGRhdGVzQ2FsbGJhY2sodXBkYXRlc1N0b3JlKVxuICAgICAgWS50cmFuc2FjdChpZGJQZXJzaXN0ZW5jZS5kb2MsICgpID0+IHtcbiAgICAgICAgdXBkYXRlcy5mb3JFYWNoKHZhbCA9PiBZLmFwcGx5VXBkYXRlKGlkYlBlcnNpc3RlbmNlLmRvYywgdmFsKSlcbiAgICAgIH0sIGlkYlBlcnNpc3RlbmNlLCBmYWxzZSlcbiAgICAgIGFmdGVyQXBwbHlVcGRhdGVzQ2FsbGJhY2sodXBkYXRlc1N0b3JlKVxuICAgIH1cbiAgfSlcbiAgICAudGhlbigoKSA9PiBpZGIuZ2V0TGFzdEtleSh1cGRhdGVzU3RvcmUpLnRoZW4obGFzdEtleSA9PiB7IGlkYlBlcnNpc3RlbmNlLl9kYnJlZiA9IGxhc3RLZXkgKyAxIH0pKVxuICAgIC50aGVuKCgpID0+IGlkYi5jb3VudCh1cGRhdGVzU3RvcmUpLnRoZW4oY250ID0+IHsgaWRiUGVyc2lzdGVuY2UuX2Ric2l6ZSA9IGNudCB9KSlcbiAgICAudGhlbigoKSA9PiB1cGRhdGVzU3RvcmUpXG59XG5cbi8qKlxuICogQHBhcmFtIHtJbmRleGVkZGJQZXJzaXN0ZW5jZX0gaWRiUGVyc2lzdGVuY2VcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZm9yY2VTdG9yZVxuICovXG5leHBvcnQgY29uc3Qgc3RvcmVTdGF0ZSA9IChpZGJQZXJzaXN0ZW5jZSwgZm9yY2VTdG9yZSA9IHRydWUpID0+XG4gIGZldGNoVXBkYXRlcyhpZGJQZXJzaXN0ZW5jZSlcbiAgICAudGhlbih1cGRhdGVzU3RvcmUgPT4ge1xuICAgICAgaWYgKGZvcmNlU3RvcmUgfHwgaWRiUGVyc2lzdGVuY2UuX2Ric2l6ZSA+PSBQUkVGRVJSRURfVFJJTV9TSVpFKSB7XG4gICAgICAgIGlkYi5hZGRBdXRvS2V5KHVwZGF0ZXNTdG9yZSwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGlkYlBlcnNpc3RlbmNlLmRvYykpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gaWRiLmRlbCh1cGRhdGVzU3RvcmUsIGlkYi5jcmVhdGVJREJLZXlSYW5nZVVwcGVyQm91bmQoaWRiUGVyc2lzdGVuY2UuX2RicmVmLCB0cnVlKSkpXG4gICAgICAgICAgLnRoZW4oKCkgPT4gaWRiLmNvdW50KHVwZGF0ZXNTdG9yZSkudGhlbihjbnQgPT4geyBpZGJQZXJzaXN0ZW5jZS5fZGJzaXplID0gY250IH0pKVxuICAgICAgfVxuICAgIH0pXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZXhwb3J0IGNvbnN0IGNsZWFyRG9jdW1lbnQgPSBuYW1lID0+IGlkYi5kZWxldGVEQihuYW1lKVxuXG4vKipcbiAqIEBleHRlbmRzIE9ic2VydmFibGU8c3RyaW5nPlxuICovXG5leHBvcnQgY2xhc3MgSW5kZXhlZGRiUGVyc2lzdGVuY2UgZXh0ZW5kcyBPYnNlcnZhYmxlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7WS5Eb2N9IGRvY1xuICAgKi9cbiAgY29uc3RydWN0b3IgKG5hbWUsIGRvYykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLmRvYyA9IGRvY1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLl9kYnJlZiA9IDBcbiAgICB0aGlzLl9kYnNpemUgPSAwXG4gICAgdGhpcy5fZGVzdHJveWVkID0gZmFsc2VcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7SURCRGF0YWJhc2V8bnVsbH1cbiAgICAgKi9cbiAgICB0aGlzLmRiID0gbnVsbFxuICAgIHRoaXMuc3luY2VkID0gZmFsc2VcbiAgICB0aGlzLl9kYiA9IGlkYi5vcGVuREIobmFtZSwgZGIgPT5cbiAgICAgIGlkYi5jcmVhdGVTdG9yZXMoZGIsIFtcbiAgICAgICAgWyd1cGRhdGVzJywgeyBhdXRvSW5jcmVtZW50OiB0cnVlIH1dLFxuICAgICAgICBbJ2N1c3RvbSddXG4gICAgICBdKVxuICAgIClcbiAgICAvKipcbiAgICAgKiBAdHlwZSB7UHJvbWlzZTxJbmRleGVkZGJQZXJzaXN0ZW5jZT59XG4gICAgICovXG4gICAgdGhpcy53aGVuU3luY2VkID0gcHJvbWlzZS5jcmVhdGUocmVzb2x2ZSA9PiB0aGlzLm9uKCdzeW5jZWQnLCAoKSA9PiByZXNvbHZlKHRoaXMpKSlcblxuICAgIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgdGhpcy5kYiA9IGRiXG4gICAgICAvKipcbiAgICAgICAqIEBwYXJhbSB7SURCT2JqZWN0U3RvcmV9IHVwZGF0ZXNTdG9yZVxuICAgICAgICovXG4gICAgICBjb25zdCBiZWZvcmVBcHBseVVwZGF0ZXNDYWxsYmFjayA9ICh1cGRhdGVzU3RvcmUpID0+IGlkYi5hZGRBdXRvS2V5KHVwZGF0ZXNTdG9yZSwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYykpXG4gICAgICBjb25zdCBhZnRlckFwcGx5VXBkYXRlc0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fZGVzdHJveWVkKSByZXR1cm4gdGhpc1xuICAgICAgICB0aGlzLnN5bmNlZCA9IHRydWVcbiAgICAgICAgdGhpcy5lbWl0KCdzeW5jZWQnLCBbdGhpc10pXG4gICAgICB9XG4gICAgICBmZXRjaFVwZGF0ZXModGhpcywgYmVmb3JlQXBwbHlVcGRhdGVzQ2FsbGJhY2ssIGFmdGVyQXBwbHlVcGRhdGVzQ2FsbGJhY2spXG4gICAgfSlcbiAgICAvKipcbiAgICAgKiBUaW1lb3V0IGluIG1zIHVudGlsbCBkYXRhIGlzIG1lcmdlZCBhbmQgcGVyc2lzdGVkIGluIGlkYi5cbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVRpbWVvdXQgPSAxMDAwXG4gICAgLyoqXG4gICAgICogQHR5cGUge2FueX1cbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVRpbWVvdXRJZCA9IG51bGxcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IHVwZGF0ZVxuICAgICAqIEBwYXJhbSB7YW55fSBvcmlnaW5cbiAgICAgKi9cbiAgICB0aGlzLl9zdG9yZVVwZGF0ZSA9ICh1cGRhdGUsIG9yaWdpbikgPT4ge1xuICAgICAgaWYgKHRoaXMuZGIgJiYgb3JpZ2luICE9PSB0aGlzKSB7XG4gICAgICAgIGNvbnN0IFt1cGRhdGVzU3RvcmVdID0gaWRiLnRyYW5zYWN0KC8qKiBAdHlwZSB7SURCRGF0YWJhc2V9ICovICh0aGlzLmRiKSwgW3VwZGF0ZXNTdG9yZU5hbWVdKVxuICAgICAgICBpZGIuYWRkQXV0b0tleSh1cGRhdGVzU3RvcmUsIHVwZGF0ZSlcbiAgICAgICAgaWYgKCsrdGhpcy5fZGJzaXplID49IFBSRUZFUlJFRF9UUklNX1NJWkUpIHtcbiAgICAgICAgICAvLyBkZWJvdW5jZSBzdG9yZSBjYWxsXG4gICAgICAgICAgaWYgKHRoaXMuX3N0b3JlVGltZW91dElkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fc3RvcmVUaW1lb3V0SWQpXG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuX3N0b3JlVGltZW91dElkID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBzdG9yZVN0YXRlKHRoaXMsIGZhbHNlKVxuICAgICAgICAgICAgdGhpcy5fc3RvcmVUaW1lb3V0SWQgPSBudWxsXG4gICAgICAgICAgfSwgdGhpcy5fc3RvcmVUaW1lb3V0KVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvYy5vbigndXBkYXRlJywgdGhpcy5fc3RvcmVVcGRhdGUpXG4gICAgdGhpcy5kZXN0cm95ID0gdGhpcy5kZXN0cm95LmJpbmQodGhpcylcbiAgICBkb2Mub24oJ2Rlc3Ryb3knLCB0aGlzLmRlc3Ryb3kpXG4gIH1cblxuICBkZXN0cm95ICgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVUaW1lb3V0SWQpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdG9yZVRpbWVvdXRJZClcbiAgICB9XG4gICAgdGhpcy5kb2Mub2ZmKCd1cGRhdGUnLCB0aGlzLl9zdG9yZVVwZGF0ZSlcbiAgICB0aGlzLmRvYy5vZmYoJ2Rlc3Ryb3knLCB0aGlzLmRlc3Ryb3kpXG4gICAgdGhpcy5fZGVzdHJveWVkID0gdHJ1ZVxuICAgIHJldHVybiB0aGlzLl9kYi50aGVuKGRiID0+IHtcbiAgICAgIGRiLmNsb3NlKClcbiAgICB9KVxuICB9XG5cbiAgLyoqXG4gICAqIERlc3Ryb3lzIHRoaXMgaW5zdGFuY2UgYW5kIHJlbW92ZXMgYWxsIGRhdGEgZnJvbSBpbmRleGVkZGIuXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8dm9pZD59XG4gICAqL1xuICBjbGVhckRhdGEgKCkge1xuICAgIHJldHVybiB0aGlzLmRlc3Ryb3koKS50aGVuKCgpID0+IHtcbiAgICAgIGlkYi5kZWxldGVEQih0aGlzLm5hbWUpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlIHwgYW55Pn1cbiAgICovXG4gIGdldCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdLCAncmVhZG9ubHknKVxuICAgICAgcmV0dXJuIGlkYi5nZXQoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEBwYXJhbSB7U3RyaW5nIHwgbnVtYmVyIHwgQXJyYXlCdWZmZXIgfCBEYXRlfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFN0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZT59XG4gICAqL1xuICBzZXQgKGtleSwgdmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGIudGhlbihkYiA9PiB7XG4gICAgICBjb25zdCBbY3VzdG9tXSA9IGlkYi50cmFuc2FjdChkYiwgW2N1c3RvbVN0b3JlTmFtZV0pXG4gICAgICByZXR1cm4gaWRiLnB1dChjdXN0b20sIHZhbHVlLCBrZXkpXG4gICAgfSlcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IG51bWJlciB8IEFycmF5QnVmZmVyIHwgRGF0ZX0ga2V5XG4gICAqIEByZXR1cm4ge1Byb21pc2U8dW5kZWZpbmVkPn1cbiAgICovXG4gIGRlbCAoa2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2RiLnRoZW4oZGIgPT4ge1xuICAgICAgY29uc3QgW2N1c3RvbV0gPSBpZGIudHJhbnNhY3QoZGIsIFtjdXN0b21TdG9yZU5hbWVdKVxuICAgICAgcmV0dXJuIGlkYi5kZWwoY3VzdG9tLCBrZXkpXG4gICAgfSlcbiAgfVxufVxuIiwgImltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcInNyYy9wZWVyZHJhZnRQbHVnaW5cIlxuXG5leHBvcnQgY29uc3QgYWRkSXNTaGFyZWRDbGFzcyA9IChwYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IGZpbGVFeHBsb3JlcnMgPSBwbHVnaW4uYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoJ2ZpbGUtZXhwbG9yZXInKVxuICBmaWxlRXhwbG9yZXJzLmZvckVhY2goZmlsZUV4cGxvcmVyID0+IHtcbiAgICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgICBjb25zdCBmaWxlSXRlbSA9IGZpbGVFeHBsb3Jlci52aWV3LmZpbGVJdGVtc1twYXRoXTtcbiAgICBpZiAoIWZpbGVJdGVtKSByZXR1cm5cbiAgICBjb25zdCBlbCA9IGZpbGVJdGVtLmlubmVyRWwgYXMgSFRNTEVsZW1lbnRcbiAgICBlbC5hZGRDbGFzcygncGQtZXhwbG9yZXItc2hhcmVkJylcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHJlbW92ZUlzU2hhcmVkQ2xhc3MgPSAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBmaWxlRXhwbG9yZXJzID0gcGx1Z2luLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKCdmaWxlLWV4cGxvcmVyJylcbiAgZmlsZUV4cGxvcmVycy5mb3JFYWNoKGZpbGVFeHBsb3JlciA9PiB7XG4gICAgLy9AdHMtZXhwZWN0LWVycm9yXG4gICAgY29uc3QgZmlsZUl0ZW0gPSBmaWxlRXhwbG9yZXIudmlldy5maWxlSXRlbXNbcGF0aF07XG4gICAgaWYgKCFmaWxlSXRlbSkgcmV0dXJuXG4gICAgY29uc3QgZWwgPSBmaWxlSXRlbS5pbm5lckVsIGFzIEhUTUxFbGVtZW50XG4gICAgZWwucmVtb3ZlQ2xhc3MoJ3BkLWV4cGxvcmVyLXNoYXJlZCcpXG4gIH0pXG59IiwgImltcG9ydCB7IFRBYnN0cmFjdEZpbGUsIFRGaWxlLCBURm9sZGVyLCBub3JtYWxpemVQYXRoIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnXG5pbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCB7IHNob3dOb3RpY2UgfSBmcm9tIFwiLi4vdWlcIjtcbmltcG9ydCB7IGNhbGN1bGF0ZUhhc2gsIGdlbmVyYXRlUmFuZG9tU3RyaW5nLCBzZXJpYWxpemUgfSBmcm9tIFwiLi4vdG9vbHNcIjtcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gXCIuL3NoYXJlZEVudGl0eVwiO1xuaW1wb3J0IFBlZXJEcmFmdFBsdWdpbiBmcm9tIFwic3JjL21haW5cIjtcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRG9jdW1lbnRcIjtcbmltcG9ydCB7IFBlcm1hbmVudFNoYXJlRm9sZGVyIH0gZnJvbSBcInNyYy9wZXJtYW5lbnRTaGFyZVN0b3JlXCI7XG5pbXBvcnQgeyBJbmRleGVkZGJQZXJzaXN0ZW5jZSB9IGZyb20gXCJ5LWluZGV4ZWRkYlwiO1xuaW1wb3J0IHsgYWRkSXNTaGFyZWRDbGFzcywgcmVtb3ZlSXNTaGFyZWRDbGFzcyB9IGZyb20gXCJzcmMvd29ya3NwYWNlL2V4cGxvcmVyVmlld1wiO1xuaW1wb3J0IHsgYWRkLCBnZXRGb2xkZXJCeVBhdGgsIG1vdmVGb2xkZXIsIHJlbW92ZUZvbGRlciB9IGZyb20gXCJzcmMvcGVybWFuZW50U2hhcmVTdG9yZUZTXCI7XG5pbXBvcnQgeyBvcGVuRm9sZGVyT3B0aW9ucyB9IGZyb20gXCJzcmMvdWkvZm9sZGVyT3B0aW9uc1wiO1xuaW1wb3J0IHsgb3BlbkxvZ2luTW9kYWwgfSBmcm9tIFwic3JjL3VpL2xvZ2luXCI7XG5cbmNvbnN0IGhhbmRsZVVwZGF0ZSA9IChldjogWS5ZTWFwRXZlbnQ8dW5rbm93bj4sIHR4OiBZLlRyYW5zYWN0aW9uLCBmb2xkZXI6IFNoYXJlZEZvbGRlciwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pID0+IHtcblxuICBpZiAoIShbcGx1Z2luLnNlcnZlclN5bmMsIGZvbGRlci53ZWJSVENQcm92aWRlcj8ucm9vbV0uaW5jbHVkZXModHgub3JpZ2luKSkpIHJldHVyblxuXG4gIGNvbnN0IGNoYW5nZWRLZXlzID0gZXYuY2hhbmdlcy5rZXlzXG5cbiAgY2hhbmdlZEtleXMuZm9yRWFjaChhc3luYyAoZGF0YSwga2V5KSA9PiB7XG4gICAgcGx1Z2luLmxvZyhcIkFjdGlvbjogXCIgKyBkYXRhLmFjdGlvbiArIFwiZm9yIFwiICsga2V5ICsgXCIgLS0+IFwiICsgdHguZG9jLmdldE1hcChcImRvY3VtZW50c1wiKS5nZXQoa2V5KSBhcyBzdHJpbmcpXG5cbiAgICBpZiAoZGF0YS5hY3Rpb24gPT09IFwiYWRkXCIpIHtcbiAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHR4LmRvYy5nZXRNYXAoXCJkb2N1bWVudHNcIikuZ2V0KGtleSkgYXMgc3RyaW5nXG4gICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oZm9sZGVyLnBhdGgsIHJlbGF0aXZlUGF0aClcbiAgICAgIGNvbnN0IGZpbGUgPSBwbHVnaW4uYXBwLnZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChhYnNvbHV0ZVBhdGgpXG4gICAgICBpZiAoZmlsZSkge1xuXG4gICAgICAgIC8vIHNhZmV0eSBjaGVjayBpZiBmcyBhbHJlYWR5IGluIHN5bmNcblxuICAgICAgICBjb25zdCBleGlzdGluZ0RvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKGtleSlcbiAgICAgICAgaWYgKGV4aXN0aW5nRG9jKSB7XG4gICAgICAgICAgaWYgKGV4aXN0aW5nRG9jLmZpbGUucGF0aCA9PT0gZmlsZS5wYXRoKSB7XG4gICAgICAgICAgICAvLyBEbyBub3RoaW5nLlxuICAgICAgICAgICAgcGx1Z2luLmxvZyhcIlJlY2VpdmVkIHVwZGF0ZSwgYnV0IEZTIGlzIGFscmVhZHkgaW4gY29ycmVjdCBzdGF0ZVwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBzaG91bGQgbm90IG9jY3VyIDotKFxuICAgICAgICAgICAgc2hvd05vdGljZShcIlRoZXJlIGlzIHNvbWV0aGluZyB3cm9uZyB3aXRoIHlvdXIgc3luY2VkIGZpbGUgXCIgKyBmaWxlLnBhdGggKyBcIi4gQ29uc2lkZXIgcmUtY3JlYXRpbmcgdGhlIHN5bmNlZCBmb2xkZXIgZnJvbSBzZXJ2ZXIuXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3dOb3RpY2UoXCJGaWxlIFwiICsgZmlsZS5wYXRoICsgXCIgYWxyZWFkeSBleGlzdHMuIFJlbmFtaW5nIGxvY2FsIGZpbGUuXCIpXG5cbiAgICAgICAgICBjb25zdCBhbHRlcmVkUGF0aCA9IHBhdGguam9pbihwYXRoLmRpcm5hbWUocmVsYXRpdmVQYXRoKSwgcGF0aC5iYXNlbmFtZShyZWxhdGl2ZVBhdGgsIHBhdGguZXh0bmFtZShyZWxhdGl2ZVBhdGgpKSArIFwiX1wiICsgZ2VuZXJhdGVSYW5kb21TdHJpbmcoKSArIHBhdGguZXh0bmFtZShyZWxhdGl2ZVBhdGgpKVxuICAgICAgICAgIGNvbnN0IGFsdGVyZWRBYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oZm9sZGVyLnJvb3QucGF0aCwgYWx0ZXJlZFBhdGgpXG4gICAgICAgICAgcGx1Z2luLmFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKGZpbGUsIGFsdGVyZWRBYnNvbHV0ZVBhdGgpXG4gICAgICAgICAgU2hhcmVkRG9jdW1lbnQuZnJvbUlkQW5kUGF0aChrZXksIGFic29sdXRlUGF0aCwgcGx1Z2luKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaG93Tm90aWNlKFwiQ3JlYXRpbmcgbmV3IHNoYXJlZCBkb2N1bWVudDogXCIgKyBhYnNvbHV0ZVBhdGgpXG4gICAgICAgIGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5wYXJzZShhYnNvbHV0ZVBhdGgpLmRpciwgcGx1Z2luKVxuICAgICAgICBhd2FpdCBTaGFyZWREb2N1bWVudC5mcm9tSWRBbmRQYXRoKGtleSwgYWJzb2x1dGVQYXRoLCBwbHVnaW4pXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLmFjdGlvbiA9PT0gXCJ1cGRhdGVcIikge1xuICAgICAgY29uc3QgbmV3UGF0aCA9IHR4LmRvYy5nZXRNYXAoXCJkb2N1bWVudHNcIikuZ2V0KGtleSkgYXMgc3RyaW5nXG4gICAgICBjb25zdCBkb2N1bWVudCA9IFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKGtleSlcbiAgICAgIGlmICghZG9jdW1lbnQpIHtcbiAgICAgICAgc2hvd05vdGljZShcIkRvY3VtZW50IGF0IFwiICsgbmV3UGF0aCArIFwiIGRvZXNuJ3QgZXhpc3QgaW4geW91ciB2YXVsdC4gQ29uc2lkZXIgcmUtY3JlYXRpbmcgdGhlIHN5bmNlZCBmb2xkZXIgZnJvbSBzZXJ2ZXIuXCIpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgcGx1Z2luLmxvZyhcIlVwZGF0ZSBcIiArIGRvY3VtZW50LnBhdGggKyBcIiAgIFwiICsga2V5KVxuICAgICAgY29uc3QgZm9sZGVyID0gU2hhcmVkRm9sZGVyLmdldFNoYXJlZEZvbGRlckZvclN1YlBhdGgoZG9jdW1lbnQucGF0aClcbiAgICAgIGlmICghZm9sZGVyKSByZXR1cm5cbiAgICAgIGxldCBuZXdBYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oZm9sZGVyLnJvb3QucGF0aCwgbmV3UGF0aClcbiAgICAgIGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5wYXJzZShuZXdBYnNvbHV0ZVBhdGgpLmRpciwgcGx1Z2luKVxuXG4gICAgICBjb25zdCBhbHJlYWR5RXhpc3RzID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChuZXdBYnNvbHV0ZVBhdGgpXG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICAvLyBjaGVjayBpZiBpbiBzeW5jIGFscmVhZHlcbiAgICAgICAgaWYgKGFscmVhZHlFeGlzdHMuc2hhcmVJZCA9PT0ga2V5KSB7XG4gICAgICAgICAgLy8gRG8gbm90aGluZy5cbiAgICAgICAgICBwbHVnaW4ubG9nKFwiUmVjZWl2ZWQgdXBkYXRlLCBidXQgRlMgaXMgYWxyZWFkeSBpbiBjb3JyZWN0IHN0YXRlLlwiKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNob3dOb3RpY2UoXCJGaWxlIFwiICsgbmV3UGF0aCArIFwiIGFscmVhZHkgZXhpc3RzLiBSZW5hbWluZyBsb2NhbCBmaWxlLlwiKVxuICAgICAgICAgIGNvbnN0IGFsdGVyZWRQYXRoID0gcGF0aC5qb2luKHBhdGguZGlybmFtZShuZXdQYXRoKSwgcGF0aC5iYXNlbmFtZShuZXdQYXRoLCBwYXRoLmV4dG5hbWUobmV3UGF0aCkpICsgXCJfXCIgKyBnZW5lcmF0ZVJhbmRvbVN0cmluZygpICsgcGF0aC5leHRuYW1lKG5ld1BhdGgpKVxuICAgICAgICAgIGNvbnN0IGFsdGVyZWRBYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4oZm9sZGVyLnJvb3QucGF0aCwgYWx0ZXJlZFBhdGgpXG4gICAgICAgICAgcGx1Z2luLmFwcC5maWxlTWFuYWdlci5yZW5hbWVGaWxlKGFscmVhZHlFeGlzdHMuZmlsZSwgYWx0ZXJlZEFic29sdXRlUGF0aClcbiAgICAgICAgICBTaGFyZWREb2N1bWVudC5mcm9tSWRBbmRQYXRoKGtleSwgYWx0ZXJlZEFic29sdXRlUGF0aCwgcGx1Z2luKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhd2FpdCBwbHVnaW4uYXBwLmZpbGVNYW5hZ2VyLnJlbmFtZUZpbGUoZG9jdW1lbnQuZmlsZSwgbmV3QWJzb2x1dGVQYXRoKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24gPT09IFwiZGVsZXRlXCIpIHtcbiAgICAgIGNvbnN0IGRvY3VtZW50ID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoa2V5KVxuICAgICAgaWYgKCFkb2N1bWVudCkgcmV0dXJuXG4gICAgICBwbHVnaW4ubG9nKFwiRGVsZXRlIFwiICsgZG9jdW1lbnQucGF0aCArIFwiICAgXCIgKyBrZXkpXG4gICAgICBjb25zdCBmaWxlID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoZG9jdW1lbnQucGF0aClcbiAgICAgIGlmICghZmlsZSkgcmV0dXJuXG4gICAgICBwbHVnaW4uYXBwLnZhdWx0LmRlbGV0ZShmaWxlKVxuICAgIH1cbiAgfSlcbn1cblxuZXhwb3J0IGNsYXNzIFNoYXJlZEZvbGRlciBleHRlbmRzIFNoYXJlZEVudGl0eSB7XG5cbiAgcm9vdDogVEZvbGRlclxuICBwcm90ZWN0ZWQgc3RhdGljIF9zaGFyZWRFbnRpdGVzOiBBcnJheTxTaGFyZWRGb2xkZXI+ID0gbmV3IEFycmF5PFNoYXJlZEZvbGRlcj4oKVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tVEZvbGRlcihyb290OiBURm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIHNob3dOb3RpY2UoYEluaXRpdGlhbGl6aW5nIHNoYXJlIGZvciAke3Jvb3QucGF0aH0uYClcbiAgICBjb25zdCBmaWxlcyA9IHRoaXMuZ2V0QWxsRmlsZXNJbkZvbGRlcihyb290KVxuXG4gICAgLy8gY2hlY2sgaWYgZG9jcyBmb3Igc29tZSBvZiB0aGVtIGFyZSBhbHJlYWR5IHRoZXJlXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBpZiAoU2hhcmVkRG9jdW1lbnQuZmluZEJ5UGF0aChmaWxlLnBhdGgpKSB7XG4gICAgICAgIHNob3dOb3RpY2UoXCJZb3UgY2FuIG5vdCBzaGFyZSBhIGRpcmVjdG9yeSB0aGF0IGFscmVhZHkgaGFzIHNoYXJlZCBmaWxlcyBpbiBpdCAocmlnaHQgbm93KS5cIilcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYoIXBsdWdpbi5zZXJ2ZXJTeW5jLmF1dGhlbnRpY2F0ZWQpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJQbGVhc2UgbG9nIGluIHRvIFBlZXJkcmFmdCBmaXJzdC5cIilcbiAgICAgIGNvbnN0IGF1dGggPSBhd2FpdCBvcGVuTG9naW5Nb2RhbChwbHVnaW4pXG4gICAgICBpZiAoIWF1dGgpIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRvY3MgPSBhd2FpdCBQcm9taXNlLmFsbChmaWxlcy5tYXAoKGZpbGUpID0+IHtcbiAgICAgIHJldHVybiBTaGFyZWREb2N1bWVudC5mcm9tVEZpbGUoZmlsZSwge1xuICAgICAgICBwZXJtYW5lbnQ6IHRydWVcbiAgICAgIH0sIHBsdWdpbilcbiAgICB9KSlcblxuICAgIGNvbnN0IGZvbGRlciA9IG5ldyBTaGFyZWRGb2xkZXIocm9vdCwgcGx1Z2luKVxuXG4gICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jcykge1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICBmb2xkZXIuYWRkRG9jdW1lbnQoZG9jKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvbGRlci55RG9jLmdldFRleHQoXCJvcmlnaW5hbEZvbGRlcm5hbWVcIikuaW5zZXJ0KDAsIHJvb3QubmFtZSlcblxuICAgIGF3YWl0IGZvbGRlci5pbml0U2VydmVyWURvYygpXG5cbiAgICBhd2FpdCBhZGQoZm9sZGVyLCBwbHVnaW4pXG4gICAgYXdhaXQgZm9sZGVyLnN0YXJ0SW5kZXhlZERCU3luYygpXG4gICAgZm9sZGVyLnN0YXJ0V2ViUlRDU3luYygpXG5cbiAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dChwbHVnaW4uc2V0dGluZ3MuYmFzZVBhdGggKyAnL3RlYW0vJyArIGZvbGRlci5zaGFyZUlkKVxuICAgIHNob3dOb3RpY2UoYEZvbGRlciAke2ZvbGRlci5wYXRofSB3aXRoICR7ZG9jcy5sZW5ndGh9IGRvY3VtZW50cyBzaGFyZWQuIFVSTCBjb3BpZWQgdG8geW91ciBjbGlwYm9hcmQuYCwgMClcbiAgICBvcGVuRm9sZGVyT3B0aW9ucyhwbHVnaW4uYXBwLCBmb2xkZXIpXG4gICAgcmV0dXJuIGZvbGRlclxuICB9XG5cbiAgZ2V0U2hhcmVVUkwoKSB7XG4gICAgcmV0dXJuIHRoaXMucGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgXCIvdGVhbS9cIiArIHRoaXMuc2hhcmVJZFxuICB9XG5cbiAgc3RhdGljIGFzeW5jIHJlY3JlYXRlKGZvbGRlcjogU2hhcmVkRm9sZGVyLCBwbHVnaW46IFBlZXJEcmFmdFBsdWdpbikge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gZm9sZGVyLnJvb3QucGF0aFxuICAgIGF3YWl0IGZvbGRlci51bnNoYXJlKClcbiAgICBhd2FpdCBwbHVnaW4uYXBwLnZhdWx0LmRlbGV0ZShmb2xkZXIucm9vdCwgdHJ1ZSlcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5mcm9tU2hhcmVVUkwocGx1Z2luLnNldHRpbmdzLmJhc2VQYXRoICsgJy90ZWFtLycgKyBmb2xkZXIuc2hhcmVJZCwgcGx1Z2luLCBsb2NhdGlvbilcbiAgfVxuXG4gIHN0YXRpYyBhc3luYyBmcm9tU2hhcmVVUkwodXJsOiBzdHJpbmcsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luLCBsb2NhdGlvbj86IHN0cmluZyk6IFByb21pc2U8U2hhcmVkRm9sZGVyIHwgdm9pZD4ge1xuICAgIGNvbnN0IGlkID0gdXJsLnNwbGl0KCcvJykucG9wKClcbiAgICBpZiAoIWlkIHx8ICFpZC5tYXRjaCgnXlswLTlhLWZdezh9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezR9LVswLTlhLWZdezEyfSQnKSkge1xuICAgICAgc2hvd05vdGljZShcIk5vIHZhbGlkIHBlZXJkcmFmdCBsaW5rXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBsZXQgZm9sZGVyUGF0aCA9IGxvY2F0aW9uXG4gICAgY29uc3QgcHJlRmV0Y2hlZERvYyA9IGF3YWl0IHBsdWdpbi5zZXJ2ZXJTeW5jLnJlcXVlc3REb2N1bWVudChpZClcblxuXG4gICAgaWYgKCFmb2xkZXJQYXRoKSB7XG4gICAgICBsZXQgaW5pdGlhbFJvb3ROYW1lID0gYF9wZWVyZHJhZnRfdGVhbV9mb2xkZXJfJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfWBcbiAgICAgIGNvbnN0IGRvY0ZvbGRlcm5hbWUgPSBwcmVGZXRjaGVkRG9jLmdldFRleHQoXCJvcmlnaW5hbEZvbGRlcm5hbWVcIikudG9TdHJpbmcoKVxuICAgICAgaWYgKGRvY0ZvbGRlcm5hbWUgIT0gJycpIHtcbiAgICAgICAgY29uc3QgZm9sZGVyRXhpc3RzID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aC5qb2luKHBsdWdpbi5zZXR0aW5ncy5yb290LCBkb2NGb2xkZXJuYW1lKSlcbiAgICAgICAgaWYgKCFmb2xkZXJFeGlzdHMpIHtcbiAgICAgICAgICBpbml0aWFsUm9vdE5hbWUgPSBkb2NGb2xkZXJuYW1lXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5pdGlhbFJvb3ROYW1lID0gYF9wZWVyZHJhZnRfJHtnZW5lcmF0ZVJhbmRvbVN0cmluZygpfV8ke2RvY0ZvbGRlcm5hbWV9YFxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvbGRlclBhdGggPSBwYXRoLmpvaW4ocGx1Z2luLnNldHRpbmdzLnJvb3QsIGluaXRpYWxSb290TmFtZSlcbiAgICB9XG5cbiAgICBjb25zdCBmb2xkZXIgPSBhd2FpdCBTaGFyZWRGb2xkZXIuZ2V0T3JDcmVhdGVQYXRoKGZvbGRlclBhdGghLCBwbHVnaW4pXG5cbiAgICBpZiAoIWZvbGRlcikge1xuICAgICAgc2hvd05vdGljZShcIkNvdWxkIG5vdCBjcmVhdGUgZm9sZGVyIFwiICsgZm9sZGVyUGF0aClcbiAgICAgIHJldHVyblxuICAgIH07XG5cbiAgICBjb25zdCBwYXRoczogQXJyYXk8c3RyaW5nPiA9IFtdXG4gICAgY29uc3QgZG9jdW1lbnRNYXAgPSBwcmVGZXRjaGVkRG9jLmdldE1hcChcImRvY3VtZW50c1wiKSBhcyBZLk1hcDxzdHJpbmc+XG5cbiAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGRvY3VtZW50TWFwLmVudHJpZXMoKSkge1xuICAgICAgbGV0IGRvY1BhdGggPSBlbnRyeVsxXVxuICAgICAgY29uc3QgYWJzUGF0aCA9IHBhdGguam9pbihmb2xkZXJQYXRoISwgZG9jUGF0aClcbiAgICAgIC8vIHJlcGFpciBpbmNvbnNpc3RlbnQgc2VydmVyIHZlcnNpb25cbiAgICAgIGlmIChkb2NQYXRoICYmIHBhdGhzLmluY2x1ZGVzKG5vcm1hbGl6ZVBhdGgoZG9jUGF0aCkpKSB7XG4gICAgICAgIC8vIHNhbml0eSBjaGVja1xuICAgICAgICBjb25zdCBleGlzdGluZ0RvYyA9IFNoYXJlZERvY3VtZW50LmZpbmRCeUlkKGVudHJ5WzBdKVxuICAgICAgICBpZiAoZXhpc3RpbmdEb2MpIHtcbiAgICAgICAgICBpZiAoZXhpc3RpbmdEb2MucGF0aCA9PT0gYWJzUGF0aCkge1xuICAgICAgICAgICAgcGx1Z2luLmxvZyhcImFscmVhZHkgc3luY2VkXCIpXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBsdWdpbi5hcHAuZmlsZU1hbmFnZXIucmVuYW1lRmlsZShleGlzdGluZ0RvYy5maWxlLCBhYnNQYXRoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkb2NQYXRoID0gbm9ybWFsaXplUGF0aChwYXRoLmpvaW4ocGF0aC5kaXJuYW1lKGRvY1BhdGgpLCBwYXRoLmJhc2VuYW1lKGRvY1BhdGgsIHBhdGguZXh0bmFtZShkb2NQYXRoKSkgKyBcIl9cIiArIGdlbmVyYXRlUmFuZG9tU3RyaW5nKCkgKyBwYXRoLmV4dG5hbWUoZG9jUGF0aCkpKVxuICAgICAgICAgIGRvY3VtZW50TWFwLnNldChlbnRyeVswXSwgZG9jUGF0aClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYXdhaXQgU2hhcmVkRG9jdW1lbnQuZnJvbUlkQW5kUGF0aChlbnRyeVswXSwgYWJzUGF0aCwgcGx1Z2luKVxuICAgICAgcGF0aHMucHVzaChub3JtYWxpemVQYXRoKGRvY1BhdGgpKVxuICAgIH1cblxuICAgIGNvbnN0IHNGb2xkZXIgPSBuZXcgU2hhcmVkRm9sZGVyKGZvbGRlciwgcGx1Z2luLCBwcmVGZXRjaGVkRG9jKVxuICAgIHNGb2xkZXIuX3NoYXJlSWQgPSBpZFxuXG4gICAgYXdhaXQgYWRkKHNGb2xkZXIsIHBsdWdpbilcbiAgICBhd2FpdCBzRm9sZGVyLnN0YXJ0SW5kZXhlZERCU3luYygpXG4gICAgaWYgKHNGb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIpIHtcbiAgICAgIGlmICghc0ZvbGRlci5pbmRleGVkREJQcm92aWRlci5zeW5jZWQpIGF3YWl0IHNGb2xkZXIuaW5kZXhlZERCUHJvdmlkZXIud2hlblN5bmNlZFxuICAgICAgc0ZvbGRlci5zeW5jV2l0aFNlcnZlcigpXG4gICAgICBzRm9sZGVyLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgfVxuICAgIHJldHVybiBzRm9sZGVyXG4gIH1cblxuICBzdGF0aWMgYXN5bmMgZnJvbVBlcm1hbmVudFNoYXJlRm9sZGVyKHBzZjogUGVybWFuZW50U2hhcmVGb2xkZXIsIHBsdWdpbjogUGVlckRyYWZ0UGx1Z2luKSB7XG4gICAgaWYgKHRoaXMuZmluZEJ5UGF0aChwc2YucGF0aCkpIHJldHVyblxuICAgIGxldCB0Rm9sZGVyOiB2b2lkIHwgbnVsbCB8IFRBYnN0cmFjdEZpbGVcbiAgICB0Rm9sZGVyID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocHNmLnBhdGgpXG4gICAgaWYgKHRGb2xkZXIgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgc2hvd05vdGljZShcIkV4cGVjdGVkIFwiICsgcHNmLnBhdGggKyBcIiB0byBiZSBhIGZvbGRlciwgYnV0IGl0IGlzIGEgZmlsZT9cIilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoISh0Rm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJTaGFyZWQgZm9sZGVyIFwiICsgcHNmLnBhdGggKyBcIiBub3QgZm91bmQuIENyZWF0aW5nIGl0IG5vdy5cIilcbiAgICAgIHRGb2xkZXIgPSBhd2FpdCB0aGlzLmdldE9yQ3JlYXRlUGF0aChwc2YucGF0aCwgcGx1Z2luKVxuICAgIH1cbiAgICBpZiAoISh0Rm9sZGVyIGluc3RhbmNlb2YgVEZvbGRlcikpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJDb3VsZCBub3QgY3JlYXRlIGZvbGRlciBcIiArIHBzZi5wYXRoICsgXCIuXCIpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBmb2xkZXIgPSBuZXcgU2hhcmVkRm9sZGVyKHRGb2xkZXIsIHBsdWdpbilcbiAgICBmb2xkZXIuX3NoYXJlSWQgPSBwc2Yuc2hhcmVJZFxuICAgIGNvbnN0IGxvY2FsID0gYXdhaXQgZm9sZGVyLnN0YXJ0SW5kZXhlZERCU3luYygpXG4gICAgaWYgKGxvY2FsKSB7XG4gICAgICBpZiAobG9jYWwuc3luY2VkIHx8IGF3YWl0IGxvY2FsLndoZW5TeW5jZWQpIHtcbiAgICAgICAgZm9sZGVyLnN5bmNXaXRoU2VydmVyKClcbiAgICAgICAgZm9sZGVyLnN0YXJ0V2ViUlRDU3luYygpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb2xkZXJcbiAgfVxuXG4gIHN0YXRpYyBmaW5kQnlQYXRoKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiBzdXBlci5maW5kQnlQYXRoKHBhdGgpIGFzIFNoYXJlZEZvbGRlciB8IHVuZGVmaW5lZFxuICB9XG5cbiAgc3RhdGljIGZpbmRCeUlkKGlkOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gc3VwZXIuZmluZEJ5SWQoaWQpIGFzIFNoYXJlZEZvbGRlciB8IHVuZGVmaW5lZFxuICB9XG5cblxuICBzdGF0aWMgZ2V0QWxsKCkge1xuICAgIHJldHVybiBzdXBlci5nZXRBbGwoKSBhcyBBcnJheTxTaGFyZWRGb2xkZXI+XG4gIH1cblxuICBzdGF0aWMgZ2V0U2hhcmVkRm9sZGVyRm9yU3ViUGF0aChkaXI6IHN0cmluZykge1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gbm9ybWFsaXplUGF0aChkaXIpXG4gICAgY29uc3QgZm9sZGVycyA9IHRoaXMuZ2V0QWxsKClcbiAgICBmb3IgKGNvbnN0IGZvbGRlciBvZiBmb2xkZXJzKSB7XG4gICAgICBpZiAoZm9sZGVyLnJvb3QucGF0aCA9PT0gbm9ybWFsaXplZFBhdGgpIHJldHVyblxuICAgICAgaWYgKGZvbGRlci5pc1BhdGhTdWJQYXRoKG5vcm1hbGl6ZWRQYXRoKSkgcmV0dXJuIGZvbGRlclxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgY29uc3RydWN0b3Iocm9vdDogVEZvbGRlciwgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4sIHlkb2M/OiBZLkRvYykge1xuICAgIHN1cGVyKHBsdWdpbilcbiAgICB0aGlzLnJvb3QgPSByb290XG4gICAgdGhpcy5fcGF0aCA9IHJvb3QucGF0aFxuICAgIHRoaXMueURvYyA9IHlkb2MgPz8gbmV3IFkuRG9jKClcbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLm9ic2VydmUoKGV2LCB0eCkgPT4ge1xuICAgICAgaGFuZGxlVXBkYXRlKGV2LCB0eCwgdGhpcywgcGx1Z2luKVxuICAgIH0pXG4gICAgdGhpcy55RG9jLm9uKFwidXBkYXRlXCIsICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55LCB5RG9jOiBZLkRvYywgdHI6IFkuVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgIGlmICh0ci5sb2NhbCAmJiB0aGlzLnNoYXJlSWQpIHtcbiAgICAgICAgcGx1Z2luLnNlcnZlclN5bmMuc2VuZFVwZGF0ZSh0aGlzLCB1cGRhdGUpXG4gICAgICB9XG4gICAgfSlcbiAgICBTaGFyZWRGb2xkZXIuX3NoYXJlZEVudGl0ZXMucHVzaCh0aGlzKVxuICAgIGFkZElzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCBwbHVnaW4pXG4gIH1cblxuICBnZXREb2NzRnJhZ21lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMueURvYy5nZXRNYXAoJ2RvY3VtZW50cycpIGFzIFkuTWFwPHN0cmluZz5cbiAgfVxuXG5cbiAgZ2V0RG9jQnlSZWxhdGl2ZVBhdGgoZGlyOiBzdHJpbmcpIHtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IG5vcm1hbGl6ZVBhdGgoZGlyKVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS5lbnRyaWVzKCkgYXMgSXRlcmFibGVJdGVyYXRvcjxba2V5OiBzdHJpbmcsIHZhbHVlOiBzdHJpbmddPikge1xuICAgICAgaWYgKGVudHJ5WzFdID09PSBub3JtYWxpemVkUGF0aCkgcmV0dXJuIGVudHJ5WzBdXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlUGF0aChvbGRQYXRoOiBzdHJpbmcsIG5ld1BhdGg6IHN0cmluZykge1xuICAgIGNvbnN0IG9sZFBhdGhSZWxhdGl2ZSA9IHBhdGgucmVsYXRpdmUodGhpcy5yb290LnBhdGgsIG9sZFBhdGgpXG4gICAgY29uc3QgbmV3UGF0aFJlbGF0aXZlID0gcGF0aC5yZWxhdGl2ZSh0aGlzLnJvb3QucGF0aCwgbmV3UGF0aClcblxuICAgIGNvbnN0IGlkID0gdGhpcy5nZXREb2NCeVJlbGF0aXZlUGF0aChvbGRQYXRoUmVsYXRpdmUpXG4gICAgaWYgKGlkKSB7XG4gICAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLnNldChpZCwgbm9ybWFsaXplUGF0aChuZXdQYXRoUmVsYXRpdmUpKVxuICAgIH1cbiAgICByZXR1cm4gaWRcbiAgfVxuXG4gIGNhbGN1bGF0ZUhhc2goKTogc3RyaW5nIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gc2VyaWFsaXplKEFycmF5LmZyb20odGhpcy5nZXREb2NzRnJhZ21lbnQoKSkpXG4gICAgcmV0dXJuIGNhbGN1bGF0ZUhhc2goc2VyaWFsaXplZClcbiAgfVxuXG4gIGdldE9yaWdpbmFsRm9sZGVyTmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy55RG9jLmdldFRleHQoXCJvcmlnaW5hbEZvbGRlcm5hbWVcIikudG9TdHJpbmcoKVxuICB9XG5cbiAgc2V0T3JpZ2luYWxGb2xkZXJOYW1lKG5hbWU6IHN0cmluZykge1xuICAgIGNvbnN0IHRleHQgPSB0aGlzLnlEb2MuZ2V0VGV4dChcIm9yaWdpbmFsRm9sZGVybmFtZVwiKVxuICAgIHRleHQuZGVsZXRlKDAsIHRleHQubGVuZ3RoKVxuICAgIHRleHQuaW5zZXJ0KDAsIG5hbWUpXG4gIH1cblxuICBnZXRBdXRvRmlsbFByb3BlcnR5KCkge1xuICAgIHJldHVybiB0aGlzLnlEb2MuZ2V0VGV4dChcImF1dG9GaWxsUHJvcGVydHlcIikudG9TdHJpbmcoKVxuICB9XG5cbiAgc2V0QXV0b0ZpbGxQcm9wZXJ0eShwcm9wZXJ0eTogc3RyaW5nKSB7XG4gICAgY29uc3QgcHJvcCA9IHRoaXMueURvYy5nZXRUZXh0KFwiYXV0b0ZpbGxQcm9wZXJ0eVwiKVxuICAgIHByb3AuZGVsZXRlKDAsIHByb3AubGVuZ3RoKVxuICAgIHByb3AuaW5zZXJ0KDAsIHByb3BlcnR5KVxuICB9XG5cbiAgYXN5bmMgdXBkYXRlUHJvcGVydGllc09mQWxsRG9jdW1lbnRzKG9sZFByb3BlcnR5TmFtZT86IHN0cmluZykge1xuICAgIGNvbnN0IHByb3AgPSB0aGlzLmdldEF1dG9GaWxsUHJvcGVydHkoKVxuICAgIGlmICghcHJvcCB8fCBwcm9wID09PSBcIlwiKSByZXR1cm5cbiAgICBjb25zdCBkb2NzID0gdGhpcy5nZXREb2NzRnJhZ21lbnQoKVxuICAgIGZvciAoY29uc3QgZW50cnkgb2YgZG9jcykge1xuICAgICAgY29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoZW50cnlbMF0pXG4gICAgICBpZiAoIWRvYykgcmV0dXJuXG4gICAgICBkb2MudXBkYXRlUHJvcGVydHkocHJvcCwgZG9jLmdldFNoYXJlVVJMKCksIG9sZFByb3BlcnR5TmFtZSlcbiAgICB9XG4gIH1cblxuICBhZGREb2N1bWVudChkb2M6IFNoYXJlZERvY3VtZW50KSB7XG4gICAgLy8gZG9lc24ndCBleGlzdCB5ZXRcbiAgICBpZiAodGhpcy5nZXREb2NzRnJhZ21lbnQoKS5nZXQoZG9jLnNoYXJlSWQpKSByZXR1cm5cbiAgICAvLyBjaGVjayBpZiBkb2MgaXMgdW5kZXIgcm9vdFxuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHBhdGgucmVsYXRpdmUodGhpcy5yb290LnBhdGgsIGRvYy5wYXRoKVxuICAgIGlmIChyZWxhdGl2ZVBhdGguc3RhcnRzV2l0aCgnLi4nKSkgcmV0dXJuXG4gICAgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS5zZXQoZG9jLnNoYXJlSWQsIHJlbGF0aXZlUGF0aClcbiAgfVxuXG4gIHJlbW92ZURvY3VtZW50KGRvYzogU2hhcmVkRG9jdW1lbnQpIHtcbiAgICB0aGlzLmdldERvY3NGcmFnbWVudCgpLmRlbGV0ZShkb2Muc2hhcmVJZClcbiAgICBjb25zdCBkZWxldGVkID0gdGhpcy55RG9jLmdldEFycmF5KFwiZGVsZXRlZFwiKSBhcyBZLkFycmF5PHN0cmluZz5cbiAgICBpZiAoIWRlbGV0ZWQudG9BcnJheSgpLmluY2x1ZGVzKGRvYy5zaGFyZUlkKSl7XG4gICAgICBkZWxldGVkLnB1c2goW2RvYy5zaGFyZUlkXSlcbiAgICB9XG4gIH1cblxuICBpc1BhdGhTdWJQYXRoKGZvbGRlcjogc3RyaW5nKSB7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gcGF0aC5yZWxhdGl2ZSh0aGlzLnJvb3QucGF0aCwgZm9sZGVyKVxuICAgIHJldHVybiAhKHJlbGF0aXZlUGF0aC5zdGFydHNXaXRoKCcuLicpKVxuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0QWxsRmlsZXNJbkZvbGRlcihmb2xkZXI6IFRGb2xkZXIpOiBBcnJheTxURmlsZT4ge1xuICAgIGNvbnN0IGZpbGVzID0gZm9sZGVyLmNoaWxkcmVuLmZsYXRNYXAoKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBURmlsZSkge1xuICAgICAgICBpZiAoY2hpbGQuZXh0ZW5zaW9uID09PSBcIm1kXCIpIHtcbiAgICAgICAgICByZXR1cm4gY2hpbGRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNoaWxkIGluc3RhbmNlb2YgVEZvbGRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbGxGaWxlc0luRm9sZGVyKGNoaWxkKVxuICAgICAgfVxuICAgICAgcmV0dXJuIFtdXG4gICAgfSlcbiAgICByZXR1cm4gZmlsZXNcbiAgfVxuXG4gIGFzeW5jIHNldE5ld0ZvbGRlckxvY2F0aW9uKGZvbGRlcjogVEZvbGRlcikge1xuICAgIGNvbnN0IG9sZFBhdGggPSB0aGlzLl9wYXRoXG4gICAgdGhpcy5yb290ID0gZm9sZGVyXG4gICAgdGhpcy5fcGF0aCA9IG5vcm1hbGl6ZVBhdGgoZm9sZGVyLnBhdGgpXG4gICAgbW92ZUZvbGRlcihvbGRQYXRoLCBmb2xkZXIucGF0aCwgdGhpcy5wbHVnaW4pXG4gIH1cblxuICBhc3luYyBnZXRPckNyZWF0ZUZpbGUocmVsYXRpdmVQYXRoOiBzdHJpbmcpIHtcbiAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLmpvaW4odGhpcy5yb290LnBhdGgsIHJlbGF0aXZlUGF0aClcbiAgICBsZXQgZmlsZSA9IHRoaXMucGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgoYWJzb2x1dGVQYXRoKVxuICAgIGlmIChmaWxlICYmIGZpbGUgaW5zdGFuY2VvZiBURmlsZSkgcmV0dXJuIGZpbGVcblxuICAgIGNvbnN0IGZvbGRlciA9IGF3YWl0IFNoYXJlZEZvbGRlci5nZXRPckNyZWF0ZVBhdGgocGF0aC5wYXJzZShhYnNvbHV0ZVBhdGgpLmRpciwgdGhpcy5wbHVnaW4pXG4gICAgaWYgKCFmb2xkZXIpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBzaGFyZXNcIilcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy5wbHVnaW4uYXBwLnZhdWx0LmNyZWF0ZShhYnNvbHV0ZVBhdGgsICcnKVxuICB9XG5cbiAgc3RhdGljIGFzeW5jIGdldE9yQ3JlYXRlUGF0aChhYnNvbHV0ZVBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyRHJhZnRQbHVnaW4pOiBQcm9taXNlPFRGb2xkZXIgfCB2b2lkPiB7XG4gICAgbGV0IGZvbGRlciA9IHBsdWdpbi5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG5vcm1hbGl6ZVBhdGgoYWJzb2x1dGVQYXRoKSlcbiAgICBpZiAoZm9sZGVyICYmIGZvbGRlciBpbnN0YW5jZW9mIFRGb2xkZXIpIHJldHVybiBmb2xkZXJcbiAgICBjb25zdCBzZWdtZW50cyA9IGFic29sdXRlUGF0aC5zcGxpdChwYXRoLnNlcClcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgc2VnbWVudHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBzdWJQYXRoID0gc2VnbWVudHMuc2xpY2UoMCwgaW5kZXggKyAxKS5qb2luKHBhdGguc2VwKVxuICAgICAgZm9sZGVyID0gcGx1Z2luLmFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgobm9ybWFsaXplUGF0aChzdWJQYXRoKSlcbiAgICAgIGlmICghZm9sZGVyKSB7XG4gICAgICAgIGZvbGRlciA9IGF3YWl0IHBsdWdpbi5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKG5vcm1hbGl6ZVBhdGgoc3ViUGF0aCkpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb2xkZXIgYXMgVEZvbGRlclxuICB9XG5cbiAgaXNGaWxlSW5TeW5jT2JqZWN0KGZpbGU6IFRGaWxlKSB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBub3JtYWxpemVQYXRoKGZpbGUucGF0aClcbiAgICBmb3IgKGNvbnN0IHZhbHVlIG9mICh0aGlzLmdldERvY3NGcmFnbWVudCgpIGFzIFkuTWFwPHN0cmluZz4pLnZhbHVlcygpKSB7XG4gICAgICBpZiAobm9ybWFsaXplZFBhdGggPT09IHBhdGguam9pbih0aGlzLnJvb3QucGF0aCwgdmFsdWUpKSByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHN0YXJ0V2ViUlRDU3luYygpIHtcbiAgICByZXR1cm4gc3VwZXIuc3RhcnRXZWJSVENTeW5jKChwcm92aWRlcikgPT4ge1xuXG4gICAgICBjb25zdCBoYW5kbGVUaW1lb3V0ID0gKCkgPT4ge1xuICAgICAgICAvLyB0aGlzLnN0b3BXZWJSVENTeW5jKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5fd2ViUlRDVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIDYwMDAwKVxuICAgICAgcHJvdmlkZXIuZG9jLm9uKCd1cGRhdGUnLCBhc3luYyAodXBkYXRlOiBVaW50OEFycmF5LCBvcmlnaW46IGFueSwgZG9jOiBZLkRvYywgdHI6IFkuVHJhbnNhY3Rpb24pID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX3dlYlJUQ1RpbWVvdXQgIT0gbnVsbCkge1xuICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fd2ViUlRDVGltZW91dClcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93ZWJSVENUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoaGFuZGxlVGltZW91dCwgNjAwMDApXG4gICAgICB9KVxuICAgIH0pXG4gIH1cblxuICBhc3luYyBzdGFydEluZGV4ZWREQlN5bmMoKSB7XG4gICAgaWYgKHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyKSByZXR1cm4gdGhpcy5faW5kZXhlZERCUHJvdmlkZXJcbiAgICBjb25zdCBpZCA9IGdldEZvbGRlckJ5UGF0aCh0aGlzLnBhdGgsIHRoaXMucGx1Z2luKT8ucGVyc2lzdGVuY2VJZFxuICAgIGlmICghaWQpIHJldHVyblxuICAgIHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyID0gbmV3IEluZGV4ZWRkYlBlcnNpc3RlbmNlKFNoYXJlZEVudGl0eS5EQl9QRVJTSVNURU5DRV9QUkVGSVggKyBpZCwgdGhpcy55RG9jKVxuICAgIHJldHVybiB0aGlzLl9pbmRleGVkREJQcm92aWRlclxuICB9XG5cbiAgYXN5bmMgdW5zaGFyZSgpIHtcbiAgICBjb25zdCBkYkVudHJ5ID0gZ2V0Rm9sZGVyQnlQYXRoKHRoaXMucGF0aCwgdGhpcy5wbHVnaW4pXG4gICAgaWYgKGRiRW50cnkpIHtcbiAgICAgIHJlbW92ZUZvbGRlcih0aGlzLnBhdGgsIHRoaXMucGx1Z2luKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pbmRleGVkREJQcm92aWRlcikge1xuICAgICAgYXdhaXQgdGhpcy5faW5kZXhlZERCUHJvdmlkZXIuY2xlYXJEYXRhKClcbiAgICAgIGF3YWl0IHRoaXMuX2luZGV4ZWREQlByb3ZpZGVyLmRlc3Ryb3koKVxuICAgIH1cblxuXG4gICAgdGhpcy5nZXREb2NzRnJhZ21lbnQoKS5mb3JFYWNoKChwYXRoOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZykgPT4ge1xuICAgICAgU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoc2hhcmVJZCk/LnVuc2hhcmUoKVxuICAgIH0pXG5cbiAgICB0aGlzLmRlc3Ryb3koKVxuICAgIHJlbW92ZUlzU2hhcmVkQ2xhc3ModGhpcy5wYXRoLCB0aGlzLnBsdWdpbilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpXG4gICAgU2hhcmVkRm9sZGVyLl9zaGFyZWRFbnRpdGVzLnNwbGljZShTaGFyZWRGb2xkZXIuX3NoYXJlZEVudGl0ZXMuaW5kZXhPZih0aGlzKSwgMSlcbiAgfVxuXG59IiwgImltcG9ydCB7IE1vZGFsLCBQbHVnaW4sIFBsdWdpblNldHRpbmdUYWIsIFNldHRpbmcsIGRlYm91bmNlLCBub3JtYWxpemVQYXRoLCByZXF1ZXN0VXJsIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBzaG93VGV4dE1vZGFsIH0gZnJvbSBcIi4vdWlcIjtcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vcGVlcmRyYWZ0UGx1Z2luXCI7XG5pbXBvcnQgeyBwcm9tcHRGb3JGb2xkZXJTZWxlY3Rpb24gfSBmcm9tIFwiLi91aS9zZWxlY3RGb2xkZXJcIjtcbmltcG9ydCB7IFBlcm1hbmVudFNoYXJlU3RvcmVJbmRleGVkREIgfSBmcm9tIFwiLi9wZXJtYW5lbnRTaGFyZVN0b3JlXCI7XG5pbXBvcnQgeyBsb2dvdXQgfSBmcm9tIFwiLi9sb2dpblwiO1xuaW1wb3J0IHsgb3BlbkxvZ2luTW9kYWwgfSBmcm9tIFwiLi91aS9sb2dpblwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNldHRpbmdzIHtcbiAgc2lnbmFsaW5nOiBzdHJpbmcsXG4gIHN5bmM6IHN0cmluZyxcbiAgc3Vic2NyaXB0aW9uQVBJOiBzdHJpbmcsXG4gIGNvbm5lY3RBUEk6IHN0cmluZyxcbiAgc2Vzc2lvbkFQSTogc3RyaW5nXG4gIGFjdGl2ZXM6IHN0cmluZyxcbiAgYmFzZVBhdGg6IHN0cmluZyxcbiAgbmFtZTogc3RyaW5nLFxuICBvaWQ6IHN0cmluZyxcbiAgcGxhbjoge1xuICAgIHR5cGU6IFwiaG9iYnlcIiB8IFwicHJvZmVzc2lvbmFsXCIgfCBcInRlYW1cIlxuICAgIGVtYWlsPzogc3RyaW5nXG4gIH0sXG4gIHJvb3Q6IHN0cmluZyxcbiAgZHVyYXRpb246IG51bWJlcixcbiAgZGVidWc6IGJvb2xlYW4sXG4gIHZlcnNpb246IHN0cmluZyxcbiAgc2VydmVyU2hhcmVzOiB7XG4gICAgZm9sZGVyczogTWFwPHN0cmluZywgeyBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyB9PlxuICAgIGZpbGVzOiBNYXA8c3RyaW5nLCB7IHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIH0+XG4gIH1cbn1cblxuY29uc3QgREVGQVVMVF9TRVRUSU5HUzogT21pdDxTZXR0aW5ncywgXCJvaWRcIj4gPSB7XG4gIGJhc2VQYXRoOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHBcIixcbiAgc3Vic2NyaXB0aW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3Vic2NyaXB0aW9uXCIsXG4gIGNvbm5lY3RBUEk6IFwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9zdWJzY3JpcHRpb24vY29ubmVjdFwiLFxuICBzZXNzaW9uQVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc2Vzc2lvblwiLFxuICBzeW5jOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3N5bmNcIixcbiAgc2lnbmFsaW5nOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL3NpZ25hbFwiLFxuICBhY3RpdmVzOiBcIndzczovL3d3dy5wZWVyZHJhZnQuYXBwL2FjdGl2ZXNcIixcbiAgbmFtZTogXCJcIixcbiAgcm9vdDogXCJcIixcbiAgcGxhbjoge1xuICAgIHR5cGU6IFwiaG9iYnlcIixcbiAgICBlbWFpbDogXCJcIlxuICB9LFxuICBkdXJhdGlvbjogMCxcbiAgZGVidWc6IGZhbHNlLFxuICB2ZXJzaW9uOiAnJyxcbiAgc2VydmVyU2hhcmVzOiB7XG4gICAgZmlsZXM6IG5ldyBNYXA8c3RyaW5nLCB7IHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nIH0+KCksXG4gICAgZm9sZGVyczogbmV3IE1hcDxzdHJpbmcsIHsgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcgfT4oKVxuICB9XG59XG5cbmNvbnN0IEZPUkNFX1NFVFRJTkdTOiBQYXJ0aWFsPFNldHRpbmdzPiA9IHtcbi8qXG4gIGJhc2VQYXRoOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3M1wiLFxuICBzdWJzY3JpcHRpb25BUEk6IFwiaHR0cDovL2xvY2FsaG9zdDo1MTczL3N1YnNjcmlwdGlvblwiLFxuICBjb25uZWN0QVBJOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3My9zdWJzY3JpcHRpb24vY29ubmVjdFwiLFxuICBzZXNzaW9uQVBJOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3My9zZXNzaW9uXCIsXG4gIHN5bmM6IFwid3M6Ly9sb2NhbGhvc3Q6NTE3My9zeW5jXCIsXG4gIHNpZ25hbGluZzogXCJ3czovL2xvY2FsaG9zdDo1MTczL3NpZ25hbFwiLFxuICBhY3RpdmVzOiBcIndzOi8vbG9jYWxob3N0OjUxNzMvYWN0aXZlc1wiXG4qL1xuICBiYXNlUGF0aDogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwXCIsXG4gIHN1YnNjcmlwdGlvbkFQSTogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3N1YnNjcmlwdGlvblwiLFxuICBjb25uZWN0QVBJOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvc3Vic2NyaXB0aW9uL2Nvbm5lY3RcIixcbiAgc2Vzc2lvbkFQSTogXCJodHRwczovL3d3dy5wZWVyZHJhZnQuYXBwL3Nlc3Npb25cIixcbiAgc3luYzogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9zeW5jXCIsXG4gIHNpZ25hbGluZzogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9zaWduYWxcIixcbiAgYWN0aXZlczogXCJ3c3M6Ly93d3cucGVlcmRyYWZ0LmFwcC9hY3RpdmVzXCIsXG5cbn1cblxuZXhwb3J0IGNvbnN0IG1pZ3JhdGVTZXR0aW5ncyA9IGFzeW5jIChwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBvbGRTZXR0aW5ncyA9IGF3YWl0IGdldFNldHRpbmdzKHBsdWdpbilcblxuICBjb25zdCBuZXdTZXR0aW5nczogU2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBvbGRTZXR0aW5ncywgRk9SQ0VfU0VUVElOR1MsIHtcbiAgICB2ZXJzaW9uOiBwbHVnaW4ubWFuaWZlc3QudmVyc2lvblxuICB9KVxuICAvL0B0cy1leHBlY3QtZXJyb3JcbiAgbmV3U2V0dGluZ3Mub2lkID0gb2xkU2V0dGluZ3M/Lm9pZCA/PyBwbHVnaW4uYXBwLmFwcElkXG5cbiAgY29uc3QgZmlsZXMgPSBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXNcbiAgZm9yIChjb25zdCBrZXkgb2YgZmlsZXMua2V5cygpKSB7XG4gICAgaWYgKGtleS5jb250YWlucygnXFxcXCcpKSB7XG4gICAgICBmaWxlcy5zZXQobm9ybWFsaXplUGF0aChrZXkpLCBmaWxlcy5nZXQoa2V5KSEpXG4gICAgICBmaWxlcy5kZWxldGUoa2V5KVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGZvbGRlcnMgPSBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVyc1xuICBmb3IgKGNvbnN0IGtleSBvZiBmb2xkZXJzLmtleXMoKSkge1xuICAgIGlmIChrZXkuY29udGFpbnMoJ1xcXFwnKSkge1xuICAgICAgZm9sZGVycy5zZXQobm9ybWFsaXplUGF0aChrZXkpLCBmb2xkZXJzLmdldChrZXkpISlcbiAgICAgIGZvbGRlcnMuZGVsZXRlKGtleSlcbiAgICB9XG4gIH1cblxuICBpZiAob2xkU2V0dGluZ3M/Lm9pZCAmJiBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuc2l6ZSA9PT0gMCAmJiBuZXdTZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5zaXplID09PSAwKSB7XG4gICAgY29uc3QgZGIgPSBuZXcgUGVybWFuZW50U2hhcmVTdG9yZUluZGV4ZWREQihvbGRTZXR0aW5ncy5vaWQpXG4gICAgY29uc3QgZG9jcyA9IGF3YWl0IGRiLmdldEFsbERvY3MoKVxuICAgIGRvY3MuZm9yRWFjaChkb2MgPT4ge1xuICAgICAgbmV3U2V0dGluZ3Muc2VydmVyU2hhcmVzLmZpbGVzLnNldChub3JtYWxpemVQYXRoKGRvYy5wYXRoKSwgeyBwZXJzaXN0ZW5jZUlkOiBkb2MucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZG9jLnNoYXJlSWQgfSlcbiAgICB9KVxuICAgIGNvbnN0IGZvbGRlcnMgPSBhd2FpdCBkYi5nZXRBbGxGb2xkZXJzKClcbiAgICBmb2xkZXJzLmZvckVhY2goZG9jID0+IHtcbiAgICAgIG5ld1NldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLnNldChub3JtYWxpemVQYXRoKGRvYy5wYXRoKSwgeyBwZXJzaXN0ZW5jZUlkOiBkb2MucGVyc2lzdGVuY2VJZCwgc2hhcmVJZDogZG9jLnNoYXJlSWQgfSlcbiAgICB9KVxuICAgIHNhdmVTZXR0aW5ncyhuZXdTZXR0aW5ncywgcGx1Z2luKVxuICAgIGF3YWl0IGRiLmRlbGV0ZURCKClcbiAgfVxuXG4gIHNhdmVTZXR0aW5ncyhuZXdTZXR0aW5ncywgcGx1Z2luKVxuXG4gIGlmIChvbGRTZXR0aW5ncyAmJiBvbGRTZXR0aW5ncy52ZXJzaW9uICE9IG5ld1NldHRpbmdzLnZlcnNpb24pIHtcbiAgICBzaG93VGV4dE1vZGFsKHBsdWdpbi5hcHAsICdQZWVyZHJhZnQgdXBkYXRlZCcsICdBIG5ldyB2ZXJzaW9uIG9mIFBlZXJkcmFmdCB3YXMgaW5zdGFsbGVkLiBQbGVhc2UgcmVzdGFydCBPYnNpZGlhbiBiZWZvcmUgeW91IHVzZSBQZWVyZHJhZnQgYWdhaW4uJylcbiAgfVxuXG4gIHJldHVybiBuZXdTZXR0aW5nc1xuXG59XG5cbmV4cG9ydCBjb25zdCBnZXRTZXR0aW5ncyA9IGFzeW5jIChwbHVnaW46IFBsdWdpbikgPT4ge1xuICBjb25zdCBzZXR0aW5ncyA9IGF3YWl0IHBsdWdpbi5sb2FkRGF0YSgpIGFzIFNldHRpbmdzXG4gIGlmIChzZXR0aW5ncykge1xuICAgIHNldHRpbmdzLnNlcnZlclNoYXJlcyA9IHtcbiAgICAgIGZpbGVzOiBuZXcgTWFwKHNldHRpbmdzLnNlcnZlclNoYXJlcz8uZmlsZXMpLFxuICAgICAgZm9sZGVyczogbmV3IE1hcChzZXR0aW5ncy5zZXJ2ZXJTaGFyZXM/LmZvbGRlcnMpXG4gICAgfVxuICB9XG4gIHJldHVybiBzZXR0aW5nc1xufVxuXG5cbmV4cG9ydCBjb25zdCBzYXZlU2V0dGluZ3MgPSBkZWJvdW5jZShhc3luYyAoc2V0dGluZ3M6IFNldHRpbmdzLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuXG4gIGNvbnN0IHNlcmlhbGl6ZWQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSlcblxuICBzZXJpYWxpemVkLnNlcnZlclNoYXJlcyA9IHtcbiAgICBmaWxlczogQXJyYXkuZnJvbShzZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuZW50cmllcygpKSxcbiAgICBmb2xkZXJzOiBBcnJheS5mcm9tKHNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLmVudHJpZXMoKSlcbiAgfVxuXG4gIGF3YWl0IHBsdWdpbi5zYXZlRGF0YShzZXJpYWxpemVkKVxufSwgMTAwMCwgdHJ1ZSlcblxuZXhwb3J0IGNvbnN0IHJlbmRlclNldHRpbmdzID0gYXN5bmMgKGVsOiBIVE1MRWxlbWVudCwgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgZWwuZW1wdHkoKTtcblxuICBjb25zdCBzZXR0aW5ncyA9IHBsdWdpbi5zZXR0aW5nc1xuXG4gIGVsLmNyZWF0ZUVsKFwiaDFcIiwgeyB0ZXh0OiBcIkdlbmVyYWxcIiB9KTtcblxuICBuZXcgU2V0dGluZyhlbClcbiAgICAuc2V0TmFtZShcIkRpc3BsYXkgTmFtZVwiKVxuICAgIC5zZXREZXNjKFwiVGhpcyBuYW1lIHdpbGwgYmUgc2hvd24gdG8geW91ciBjb2xsYWJvcmF0b3JzXCIpXG4gICAgLmFkZFRleHQoKHRleHQpID0+IHtcbiAgICAgIHRleHQuc2V0VmFsdWUoc2V0dGluZ3MubmFtZSlcbiAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgIHNldHRpbmdzLm5hbWUgPSB2YWx1ZVxuICAgICAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbik7XG4gICAgICB9KVxuICAgIH0pXG5cbiAgY29uc3QgcGF0aFNldHRpbmcgPSBuZXcgU2V0dGluZyhlbClcbiAgcGF0aFNldHRpbmcuc2V0TmFtZShcIlJvb3QgRm9sZGVyXCIpXG4gIHBhdGhTZXR0aW5nLnNldERlc2MoXCJXaGVuIHlvdSBpbXBvcnQgYSBzaGFyZSBmcm9tIHNvbWVvbmUgZWxzZSBpdCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBmb2xkZXIuXCIpXG4gIHBhdGhTZXR0aW5nLmFkZFRleHQodGV4dCA9PiB7XG4gICAgdGV4dC5zZXRWYWx1ZShzZXR0aW5ncy5yb290KVxuICAgIHRleHQub25DaGFuZ2UoYXN5bmMgdmFsdWUgPT4ge1xuICAgICAgc2V0dGluZ3Mucm9vdCA9IHZhbHVlXG4gICAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MsIHBsdWdpbilcbiAgICB9KVxuXG4gICAgcGF0aFNldHRpbmcuYWRkRXh0cmFCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRJY29uKCdzZWFyY2gnKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBjb25zdCBmb2xkZXIgPSBhd2FpdCBwcm9tcHRGb3JGb2xkZXJTZWxlY3Rpb24ocGx1Z2luLmFwcClcbiAgICAgICAgaWYgKGZvbGRlcikge1xuICAgICAgICAgIHRleHQuc2V0VmFsdWUoZm9sZGVyLnBhdGgpXG4gICAgICAgICAgc2V0dGluZ3Mucm9vdCA9IGZvbGRlci5wYXRoXG4gICAgICAgICAgc2F2ZVNldHRpbmdzKHNldHRpbmdzLCBwbHVnaW4pXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcbiAgfSlcblxuICBlbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJZb3VyIEFjY291bnRcIiB9KVxuXG4gIGlmIChwbHVnaW4uc2VydmVyU3luYy5hdXRoZW50aWNhdGVkKSB7XG4gICAgZWwuY3JlYXRlRWwoXCJkaXZcIiwgeyB0ZXh0OiBgWW91IGFyZSBsb2dnZWQgaW4gYXMgJHtwbHVnaW4uc2V0dGluZ3MucGxhbi5lbWFpbH0uYCB9KVxuICAgIGVsLmNyZWF0ZUVsKFwicFwiKVxuICAgIGNvbnN0IGRpdiA9IGVsLmNyZWF0ZUVsKFwiZGl2XCIpXG4gICAgZGl2LmNyZWF0ZVNwYW4oeyB0ZXh0OiBcIllvdSBhcmUgb24gdGhlIFwifSkuY3JlYXRlRWwoJ2InLCB7IHRleHQ6ICBwbHVnaW4uc2V0dGluZ3MucGxhbi50eXBlfSlcbiAgICBkaXYuY3JlYXRlU3Bhbih7IHRleHQ6IFwiIHBsYW4uXCJ9KVxuICAgIGVsLmNyZWF0ZUVsKFwicFwiKVxuXG4gICAgaWYgKHBsdWdpbi5zZXR0aW5ncy5wbGFuLnR5cGUgPT09IFwiaG9iYnlcIikge1xuICAgICAgbmV3IFNldHRpbmcoZWwpXG4gICAgICAgIC5zZXROYW1lKFwiTWFuYWdlIHlvdXIgc3Vic2NyaXB0aW9uXCIpXG4gICAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlVwZ3JhZGUgdG8gcHJvXCIpXG4gICAgICAgICAgYnV0dG9uLnNldEN0YSgpXG4gICAgICAgICAgYnV0dG9uLm9uQ2xpY2soKGUpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5vcGVuKGBodHRwczovL3BlZXJkcmFmdC5hcHAvY2hlY2tvdXQ/ZW1haWw9JHtwbHVnaW4uc2V0dGluZ3MucGxhbi5lbWFpbH1gKVxuICAgICAgICAgIH0pXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgbmV3IFNldHRpbmcoZWwpXG4gICAgICAuc2V0TmFtZShcIkxvZyBvdXRcIilcbiAgICAgIC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJMb2cgb3V0XCIpXG4gICAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgYXdhaXQgbG9nb3V0KHBsdWdpbilcbiAgICAgICAgICByZW5kZXJTZXR0aW5ncyhlbCwgcGx1Z2luKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgfSBlbHNlIHtcbiAgICBlbC5jcmVhdGVFbChcImRpdlwiLCB7IHRleHQ6IGBZb3UgYXJlIG5vdCBsb2dnZWQgaW4uYCB9KVxuICAgIGVsLmNyZWF0ZUVsKFwicFwiKVxuICAgIGVsLmNyZWF0ZUVsKFwiZGl2XCIsIHsgdGV4dDogYFRvIGluaXRpYXRlIG5ldyBzaGFyZWQgZG9jdW1lbnRzIG9yIGZvbGRlcnMgeW91IG5lZWQgdG8gbG9nIGluIHRvIHlvdXIgUGVlcmRyYWZ0IGFjY291bnQuIElmIHlvdSBvbmx5IHdvcmsgb24gc2hhcmVkIGRvY3VtZW50cyBhbmQgZm9sZGVycyBjcmVhdGVkIGJ5IG90aGVycywgeW91IGRvbid0IG5lZWQgYW4gYWNjb3VudC5gIH0pXG4gICAgZWwuY3JlYXRlRWwoXCJwXCIpXG5cbiAgICBuZXcgU2V0dGluZyhlbClcbiAgICAgIC5zZXROYW1lKFwiTG9nIGluIG9yIGNyZWF0ZSBhY2NvdW50XCIpXG4gICAgICAuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiTG9nIGluIG9yIGNyZWF0ZSBhY2NvdW50XCIpXG4gICAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jIChlKSA9PiB7XG4gICAgICAgICAgYXdhaXQgb3BlbkxvZ2luTW9kYWwocGx1Z2luKVxuICAgICAgICAgIHJlbmRlclNldHRpbmdzKGVsLCBwbHVnaW4pXG4gICAgICAgIH0pXG4gICAgICB9KVxuICB9XG5cbiAgZWwuY3JlYXRlRWwoXCJoMVwiLCB7IHRleHQ6IFwiSGVscFwiIH0pXG4gIGNvbnN0IGRpdiA9IGVsLmNyZWF0ZURpdigpXG4gIGRpdi5jcmVhdGVTcGFuKHsgdGV4dDogXCJJZiB5b3UgbmVlZCBhbnkgaGVscCwgXCIgfSlcbiAgZGl2LmNyZWF0ZUVsKFwiYVwiLCB7XG4gICAgdGV4dDogXCJnZXQgaW4gdG91Y2hcIixcbiAgICBhdHRyOiB7XG4gICAgICBocmVmOiBcIm1haWx0bzpkb21pbmlrQHBlZXJkcmFmdC5hcHBcIlxuICAgIH1cbiAgfSlcbiAgZGl2LmNyZWF0ZVNwYW4oeyB0ZXh0OiAnLicgfSlcblxufVxuXG5leHBvcnQgY29uc3QgY3JlYXRlU2V0dGluZ3NUYWIgPSAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIFBsdWdpblNldHRpbmdUYWIge1xuICAgIGFzeW5jIGRpc3BsYXkoKSB7XG4gICAgICBhd2FpdCByZW5kZXJTZXR0aW5ncyh0aGlzLmNvbnRhaW5lckVsLCBwbHVnaW4pXG4gICAgfVxuICB9KHBsdWdpbi5hcHAsIHBsdWdpbilcbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVNldHRpbmdzTW9kYWwgPSAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcmV0dXJuIG5ldyBjbGFzcyBleHRlbmRzIE1vZGFsIHtcblxuICAgIGFzeW5jIG9uT3BlbigpIHtcbiAgICAgIGNvbnN0IGVsID0gdGhpcy5jb250ZW50RWxcbiAgICAgIGVsLmVtcHR5KCk7XG5cbiAgICAgIGNvbnN0IHNldHRpbmdzID0gYXdhaXQgZ2V0U2V0dGluZ3MocGx1Z2luKVxuXG4gICAgICBlbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJXaGF0J3MgeW91ciBuYW1lP1wiIH0pO1xuXG4gICAgICBjb25zdCBzZXR0aW5nID0gbmV3IFNldHRpbmcoZWwpXG4gICAgICBzZXR0aW5nLnNldE5hbWUoXCJOYW1lXCIpXG4gICAgICBzZXR0aW5nLnNldERlc2MoXCJUaGlzIG5hbWUgd2lsbCBiZSBzaG93biB0byB5b3VyIGNvbGxhYm9yYXRvcnNcIilcbiAgICAgIHNldHRpbmcuYWRkVGV4dCgodGV4dCkgPT4ge1xuICAgICAgICB0ZXh0LnNldFZhbHVlKHNldHRpbmdzLm5hbWUpXG4gICAgICAgIHRleHQub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgc2V0dGluZ3MubmFtZSA9IHZhbHVlXG4gICAgICAgICAgYXdhaXQgc2F2ZVNldHRpbmdzKHNldHRpbmdzLCBwbHVnaW4pO1xuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBvbkNsb3NlKCkge1xuICAgICAgdGhpcy5jb250ZW50RWwuZW1wdHkoKVxuICAgIH1cblxuICB9KHBsdWdpbi5hcHApXG59IiwgImltcG9ydCB7IEFwcCwgU3VnZ2VzdE1vZGFsLCBURmlsZSwgVEZvbGRlciwgVmF1bHQgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcblxuZXhwb3J0IGNsYXNzIFNlbGVjdEZvbGRlck1vZGFsIGV4dGVuZHMgU3VnZ2VzdE1vZGFsPFRGb2xkZXI+IHtcblxuICBmb2xkZXJzOiBBcnJheTxURm9sZGVyPlxuICBjYjogKGZvbGRlcjogVEZvbGRlcikgPT4gYW55XG4gIHNlbGVjdGVkRm9sZGVyOiBURm9sZGVyXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGNiOiAoZmlsZTogVEZvbGRlcikgPT4gYW55KSB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuY2IgPSBjYlxuXG4gICAgdGhpcy5mb2xkZXJzID0gW11cbiAgICBWYXVsdC5yZWN1cnNlQ2hpbGRyZW4oYXBwLnZhdWx0LmdldFJvb3QoKSwgKGZpbGUpID0+IHtcbiAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgVEZvbGRlcikgdGhpcy5mb2xkZXJzLnB1c2goZmlsZSlcbiAgICB9KVxuICAgIC8vIHJlbW92ZSByb290ICYgc29ydFxuICAgIHRoaXMuZm9sZGVycy5zaGlmdCgpXG4gICAgdGhpcy5mb2xkZXJzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIHJldHVybiBhLnBhdGgudG9Mb2NhbGVMb3dlckNhc2UoKS5sb2NhbGVDb21wYXJlKGIucGF0aC50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICAgIH0pXG4gIH1cblxuICBvbk9wZW4oKSB7XG4gICAgc3VwZXIub25PcGVuKClcbiAgICB0aGlzLmlucHV0RWwucGxhY2Vob2xkZXIgPSBcIkNob29zZSBhIGxvY2F0aW9uXCJcbiAgfVxuXG4gIGdldFN1Z2dlc3Rpb25zKHF1ZXJ5OiBzdHJpbmcpOiBURm9sZGVyW10ge1xuICAgIHJldHVybiB0aGlzLmZvbGRlcnMuZmlsdGVyKGZvbGRlciA9PiB7XG4gICAgICByZXR1cm4gZm9sZGVyLnBhdGgudG9Mb2NhbGVMb3dlckNhc2UoKS5pbmNsdWRlcyhxdWVyeS50b0xvY2FsZUxvd2VyQ2FzZSgpKVxuICAgIH0pXG4gIH1cblxuICByZW5kZXJTdWdnZXN0aW9uKHZhbHVlOiBURm9sZGVyLCBlbDogSFRNTEVsZW1lbnQpIHtcbiAgICBlbC5zZXRUZXh0KHZhbHVlLnBhdGgpXG4gIH1cblxuICBzZWxlY3RTdWdnZXN0aW9uKHZhbHVlOiBURm9sZGVyLCBldnQ6IE1vdXNlRXZlbnQgfCBLZXlib2FyZEV2ZW50KTogdm9pZCB7XG4gICAgdGhpcy5zZWxlY3RlZEZvbGRlciA9IHZhbHVlXG4gICAgc3VwZXIuc2VsZWN0U3VnZ2VzdGlvbih2YWx1ZSwgZXZ0KVxuICB9XG5cbiAgb25DaG9vc2VTdWdnZXN0aW9uKGl0ZW06IFRGb2xkZXIsIGV2dDogTW91c2VFdmVudCB8IEtleWJvYXJkRXZlbnQpIHtcbiAgfVxuXG4gIG9uQ2xvc2UoKTogdm9pZCB7XG4gICAgdGhpcy5jYih0aGlzLnNlbGVjdGVkRm9sZGVyKVxuICB9XG5cbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvckZvbGRlclNlbGVjdGlvbiA9IGFzeW5jIChhcHA6IEFwcCkgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2U8VEZvbGRlciB8IHZvaWQ+KChyZXNvbHZlKSA9PiB7XG4gICAgbmV3IFNlbGVjdEZvbGRlck1vZGFsKGFwcCwgKGZvbGRlcikgPT4ge1xuICAgICAgcmVzb2x2ZShmb2xkZXIpXG4gICAgfSkub3BlbigpXG4gIH0pXG59IiwgImRlY2xhcmUgdmFyIGdsb2JhbDtcbmV4cG9ydCBjb25zdCBfZ2xvYmFsOiBhbnkgPVxuICAgIHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOlxuICAgIHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOlxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDpcbiAgICBnbG9iYWw7XG4iLCAi77u/aW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gXCIuLi9nbG9iYWxzL2dsb2JhbFwiO1xuZXhwb3J0IGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cztcbmV4cG9ydCBjb25zdCBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgIV9nbG9iYWwuUHJvbWlzZSl7XG4gICAgLy8gSW4ganNkb20sIHRoaXMgaXQgY2FuIGJlIHRoZSBjYXNlIHRoYXQgUHJvbWlzZSBpcyBub3QgcHV0IG9uIHRoZSBnbG9iYWwgb2JqZWN0LlxuICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIHBhdGNoIHRoZSBnbG9iYWwgb2JqZWN0IGZvciB0aGUgcmVzdCBvZiB0aGUgY29kZSB0byB3b3JrIGFzIGV4cGVjdGVkLlxuICAgIC8vIE90aGVyIGRleGllIGNvZGUgZXhwZWN0cyBQcm9taXNlIHRvIGJlIG9uIHRoZSBnbG9iYWwgb2JqZWN0IChsaWtlIG5vcm1hbCBicm93c2VyIGVudmlyb25tZW50cylcbiAgICBfZ2xvYmFsLlByb21pc2UgPSBQcm9taXNlO1xufVxuZXhwb3J0IHsgX2dsb2JhbCB9XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRlbmQ8VCBleHRlbmRzIG9iamVjdCxYIGV4dGVuZHMgb2JqZWN0PihvYmo6IFQsIGV4dGVuc2lvbjogWCk6IFQgJiBYICB7XG4gICAgaWYgKHR5cGVvZiBleHRlbnNpb24gIT09ICdvYmplY3QnKSByZXR1cm4gb2JqIGFzIFQgJiBYO1xuICAgIGtleXMoZXh0ZW5zaW9uKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgb2JqW2tleV0gPSBleHRlbnNpb25ba2V5XTtcbiAgICB9KTtcbiAgICByZXR1cm4gb2JqIGFzIFQgJiBYO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5leHBvcnQgY29uc3QgX2hhc093biA9IHt9Lmhhc093blByb3BlcnR5O1xuZXhwb3J0IGZ1bmN0aW9uIGhhc093bihvYmosIHByb3ApIHtcbiAgICByZXR1cm4gX2hhc093bi5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwcm9wcyAocHJvdG8sIGV4dGVuc2lvbikge1xuICAgIGlmICh0eXBlb2YgZXh0ZW5zaW9uID09PSAnZnVuY3Rpb24nKSBleHRlbnNpb24gPSBleHRlbnNpb24oZ2V0UHJvdG8ocHJvdG8pKTtcbiAgICAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgPyBrZXlzIDogUmVmbGVjdC5vd25LZXlzKShleHRlbnNpb24pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgc2V0UHJvcChwcm90bywga2V5LCBleHRlbnNpb25ba2V5XSk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBjb25zdCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3Aob2JqLCBwcm9wLCBmdW5jdGlvbk9yR2V0U2V0LCBvcHRpb25zPykge1xuICAgIGRlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZXh0ZW5kKGZ1bmN0aW9uT3JHZXRTZXQgJiYgaGFzT3duKGZ1bmN0aW9uT3JHZXRTZXQsIFwiZ2V0XCIpICYmIHR5cGVvZiBmdW5jdGlvbk9yR2V0U2V0LmdldCA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIHtnZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuZ2V0LCBzZXQ6IGZ1bmN0aW9uT3JHZXRTZXQuc2V0LCBjb25maWd1cmFibGU6IHRydWV9IDpcbiAgICAgICAge3ZhbHVlOiBmdW5jdGlvbk9yR2V0U2V0LCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlfSwgb3B0aW9ucykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVyaXZlKENoaWxkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbTogZnVuY3Rpb24gKFBhcmVudCkge1xuICAgICAgICAgICAgQ2hpbGQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShQYXJlbnQucHJvdG90eXBlKTtcbiAgICAgICAgICAgIHNldFByb3AoQ2hpbGQucHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIENoaWxkKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXh0ZW5kOiBwcm9wcy5iaW5kKG51bGwsIENoaWxkLnByb3RvdHlwZSlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5leHBvcnQgY29uc3QgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApIHtcbiAgICBjb25zdCBwZCA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApO1xuICAgIGxldCBwcm90bztcbiAgICByZXR1cm4gcGQgfHwgKHByb3RvID0gZ2V0UHJvdG8ob2JqKSkgJiYgZ2V0UHJvcGVydHlEZXNjcmlwdG9yIChwcm90bywgcHJvcCk7XG59XG5cbmNvbnN0IF9zbGljZSA9IFtdLnNsaWNlO1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlKGFyZ3MsIHN0YXJ0PywgZW5kPykge1xuICAgIHJldHVybiBfc2xpY2UuY2FsbChhcmdzLCBzdGFydCwgZW5kKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG92ZXJyaWRlKG9yaWdGdW5jLCBvdmVycmlkZWRGYWN0b3J5KSB7XG4gICAgcmV0dXJuIG92ZXJyaWRlZEZhY3Rvcnkob3JpZ0Z1bmMpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0IChiKSB7XG4gICAgaWYgKCFiKSB0aHJvdyBuZXcgRXJyb3IoXCJBc3NlcnRpb24gRmFpbGVkXCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNhcChmbikge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoX2dsb2JhbC5zZXRJbW1lZGlhdGUpIHNldEltbWVkaWF0ZShmbik7IGVsc2Ugc2V0VGltZW91dChmbiwgMCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRVbmlxdWVBcnJheShhKSB7XG4gICAgcmV0dXJuIGEuZmlsdGVyKCh2YWx1ZSwgaW5kZXgsIHNlbGYpID0+IHNlbGYuaW5kZXhPZih2YWx1ZSkgPT09IGluZGV4KTtcbn1cblxuLyoqIEdlbmVyYXRlIGFuIG9iamVjdCAoaGFzaCBtYXApIGJhc2VkIG9uIGdpdmVuIGFycmF5LlxuICogQHBhcmFtIGV4dHJhY3RvciBGdW5jdGlvbiB0YWtpbmcgYW4gYXJyYXkgaXRlbSBhbmQgaXRzIGluZGV4IGFuZCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgMiBpdGVtcyAoW2tleSwgdmFsdWVdKSB0b1xuICogICAgICAgIGluc3RlcnQgb24gdGhlIHJlc3VsdGluZyBvYmplY3QgZm9yIGVhY2ggaXRlbSBpbiB0aGUgYXJyYXkuIElmIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCB0aGVcbiAqICAgICAgICBjdXJyZW50IGl0ZW0gd29udCBhZmZlY3QgdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcnJheVRvT2JqZWN0PFQsUj4gKGFycmF5OiBUW10sIGV4dHJhY3RvcjogKHg6VCwgaWR4OiBudW1iZXIpPT5bc3RyaW5nLCBSXSk6IHtbbmFtZTogc3RyaW5nXTogUn0ge1xuICAgIHJldHVybiBhcnJheS5yZWR1Y2UoKHJlc3VsdCwgaXRlbSwgaSkgPT4ge1xuICAgICAgICB2YXIgbmFtZUFuZFZhbHVlID0gZXh0cmFjdG9yKGl0ZW0sIGkpO1xuICAgICAgICBpZiAobmFtZUFuZFZhbHVlKSByZXN1bHRbbmFtZUFuZFZhbHVlWzBdXSA9IG5hbWVBbmRWYWx1ZVsxXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0cnljYXRjaGVyKGZuLCByZWplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeUNhdGNoKGZuOiAoLi4uYXJnczogYW55W10pPT52b2lkLCBvbmVycm9yLCBhcmdzPykgOiB2b2lkIHtcbiAgICB0cnkge1xuICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBvbmVycm9yICYmIG9uZXJyb3IoZXgpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpIHtcbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREIvI3N0ZXBzLWZvci1leHRyYWN0aW5nLWEta2V5LWZyb20tYS12YWx1ZS11c2luZy1hLWtleS1wYXRoXG4gICAgaWYgKHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyAmJiBoYXNPd24ob2JqLCBrZXlQYXRoKSkgcmV0dXJuIG9ialtrZXlQYXRoXTsgLy8gVGhpcyBsaW5lIGlzIG1vdmVkIGZyb20gbGFzdCB0byBmaXJzdCBmb3Igb3B0aW1pemF0aW9uIHB1cnBvc2UuXG4gICAgaWYgKCFrZXlQYXRoKSByZXR1cm4gb2JqO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIHJ2ID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHZhciB2YWwgPSBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoW2ldKTtcbiAgICAgICAgICAgIHJ2LnB1c2godmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICBpZiAocGVyaW9kICE9PSAtMSkge1xuICAgICAgICB2YXIgaW5uZXJPYmogPSBvYmpba2V5UGF0aC5zdWJzdHIoMCwgcGVyaW9kKV07XG4gICAgICAgIHJldHVybiBpbm5lck9iaiA9PSBudWxsID8gdW5kZWZpbmVkIDogZ2V0QnlLZXlQYXRoKGlubmVyT2JqLCBrZXlQYXRoLnN1YnN0cihwZXJpb2QgKyAxKSk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoLCB2YWx1ZSkge1xuICAgIGlmICghb2JqIHx8IGtleVBhdGggPT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuICAgIGlmICgnaXNGcm96ZW4nIGluIE9iamVjdCAmJiBPYmplY3QuaXNGcm96ZW4ob2JqKSkgcmV0dXJuO1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCAhPT0gJ3N0cmluZycgJiYgJ2xlbmd0aCcgaW4ga2V5UGF0aCkge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiAnbGVuZ3RoJyBpbiB2YWx1ZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0ga2V5UGF0aC5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGhbaV0sIHZhbHVlW2ldKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBwZXJpb2QgPSBrZXlQYXRoLmluZGV4T2YoJy4nKTtcbiAgICAgICAgaWYgKHBlcmlvZCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50S2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKDAsIHBlcmlvZCk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nS2V5UGF0aCA9IGtleVBhdGguc3Vic3RyKHBlcmlvZCArIDEpO1xuICAgICAgICAgICAgaWYgKHJlbWFpbmluZ0tleVBhdGggPT09IFwiXCIpXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkob2JqKSAmJiAhaXNOYU4ocGFyc2VJbnQoY3VycmVudEtleVBhdGgpKSkgb2JqLnNwbGljZShjdXJyZW50S2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgZGVsZXRlIG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIG9ialtjdXJyZW50S2V5UGF0aF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBpbm5lck9iaiA9IG9ialtjdXJyZW50S2V5UGF0aF07XG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lck9iaiB8fCAhaGFzT3duKG9iaiwgY3VycmVudEtleVBhdGgpKSBpbm5lck9iaiA9IChvYmpbY3VycmVudEtleVBhdGhdID0ge30pO1xuICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChpbm5lck9iaiwgcmVtYWluaW5nS2V5UGF0aCwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShvYmopICYmICFpc05hTihwYXJzZUludChrZXlQYXRoKSkpIG9iai5zcGxpY2Uoa2V5UGF0aCwgMSk7XG4gICAgICAgICAgICAgICAgZWxzZSBkZWxldGUgb2JqW2tleVBhdGhdO1xuICAgICAgICAgICAgfSBlbHNlIG9ialtrZXlQYXRoXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsQnlLZXlQYXRoKG9iaiwga2V5UGF0aCkge1xuICAgIGlmICh0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycpXG4gICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIHVuZGVmaW5lZCk7XG4gICAgZWxzZSBpZiAoJ2xlbmd0aCcgaW4ga2V5UGF0aClcbiAgICAgICAgW10ubWFwLmNhbGwoa2V5UGF0aCwgZnVuY3Rpb24oa3ApIHtcbiAgICAgICAgICAgIHNldEJ5S2V5UGF0aChvYmosIGtwLCB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYmopIHtcbiAgICB2YXIgcnYgPSB7fTtcbiAgICBmb3IgKHZhciBtIGluIG9iaikge1xuICAgICAgICBpZiAoaGFzT3duKG9iaiwgbSkpIHJ2W21dID0gb2JqW21dO1xuICAgIH1cbiAgICByZXR1cm4gcnY7XG59XG5cbmNvbnN0IGNvbmNhdCA9IFtdLmNvbmNhdDtcbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuPFQ+IChhOiAoVCB8IFRbXSlbXSkgOiBUW10ge1xuICAgIHJldHVybiBjb25jYXQuYXBwbHkoW10sIGEpO1xufVxuXG4vL2h0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XZWJfV29ya2Vyc19BUEkvU3RydWN0dXJlZF9jbG9uZV9hbGdvcml0aG1cbmNvbnN0IGludHJpbnNpY1R5cGVOYW1lcyA9XG4gICAgXCJCaWdVaW50NjRBcnJheSxCaWdJbnQ2NEFycmF5LEFycmF5LEJvb2xlYW4sU3RyaW5nLERhdGUsUmVnRXhwLEJsb2IsRmlsZSxGaWxlTGlzdCxGaWxlU3lzdGVtRmlsZUhhbmRsZSxGaWxlU3lzdGVtRGlyZWN0b3J5SGFuZGxlLEFycmF5QnVmZmVyLERhdGFWaWV3LFVpbnQ4Q2xhbXBlZEFycmF5LEltYWdlQml0bWFwLEltYWdlRGF0YSxNYXAsU2V0LENyeXB0b0tleVwiXG4gICAgLnNwbGl0KCcsJykuY29uY2F0KFxuICAgICAgICBmbGF0dGVuKFs4LDE2LDMyLDY0XS5tYXAobnVtPT5bXCJJbnRcIixcIlVpbnRcIixcIkZsb2F0XCJdLm1hcCh0PT50K251bStcIkFycmF5XCIpKSlcbiAgICApLmZpbHRlcih0PT5fZ2xvYmFsW3RdKTtcbmNvbnN0IGludHJpbnNpY1R5cGVzID0gaW50cmluc2ljVHlwZU5hbWVzLm1hcCh0PT5fZ2xvYmFsW3RdKTtcbmV4cG9ydCBjb25zdCBpbnRyaW5zaWNUeXBlTmFtZVNldCA9IGFycmF5VG9PYmplY3QoaW50cmluc2ljVHlwZU5hbWVzLCB4PT5beCx0cnVlXSk7XG5cbmxldCBjaXJjdWxhclJlZnM6IG51bGwgfCBXZWFrTWFwPGFueSxhbnk+ID0gbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ2xvbmU8VD4oYW55OiBUKTogVCB7XG4gICAgY2lyY3VsYXJSZWZzID0gdHlwZW9mIFdlYWtNYXAgIT09ICd1bmRlZmluZWQnICYmIG5ldyBXZWFrTWFwKCk7XG4gICAgY29uc3QgcnYgPSBpbm5lckRlZXBDbG9uZShhbnkpO1xuICAgIGNpcmN1bGFyUmVmcyA9IG51bGw7XG4gICAgcmV0dXJuIHJ2O1xufVxuXG5mdW5jdGlvbiBpbm5lckRlZXBDbG9uZTxUPihhbnk6IFQpOiBUIHtcbiAgICBpZiAoIWFueSB8fCB0eXBlb2YgYW55ICE9PSAnb2JqZWN0JykgcmV0dXJuIGFueTtcbiAgICBsZXQgcnYgPSBjaXJjdWxhclJlZnMgJiYgY2lyY3VsYXJSZWZzLmdldChhbnkpOyAvLyBSZXNvbHZlIGNpcmN1bGFyIHJlZmVyZW5jZXNcbiAgICBpZiAocnYpIHJldHVybiBydjtcbiAgICBpZiAoaXNBcnJheShhbnkpKSB7XG4gICAgICAgIHJ2ID0gW107XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGFueS5sZW5ndGg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIHJ2LnB1c2goaW5uZXJEZWVwQ2xvbmUoYW55W2ldKSk7XG4gICAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGludHJpbnNpY1R5cGVzLmluZGV4T2YoYW55LmNvbnN0cnVjdG9yKSA+PSAwKSB7XG4gICAgICAgIHJ2ID0gYW55O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHByb3RvID0gZ2V0UHJvdG8oYW55KTtcbiAgICAgICAgcnYgPSBwcm90byA9PT0gT2JqZWN0LnByb3RvdHlwZSA/IHt9IDogT2JqZWN0LmNyZWF0ZShwcm90byk7XG4gICAgICAgIGNpcmN1bGFyUmVmcyAmJiBjaXJjdWxhclJlZnMuc2V0KGFueSwgcnYpO1xuICAgICAgICBmb3IgKHZhciBwcm9wIGluIGFueSkge1xuICAgICAgICAgICAgaWYgKGhhc093bihhbnksIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgcnZbcHJvcF0gPSBpbm5lckRlZXBDbG9uZShhbnlbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBydjtcbn1cblxuY29uc3Qge3RvU3RyaW5nfSA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIHRvU3RyaW5nVGFnKG86IE9iamVjdCkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbn1cblxuLy8gSWYgZmlyc3QgYXJndW1lbnQgaXMgaXRlcmFibGUgb3IgYXJyYXktbGlrZSwgcmV0dXJuIGl0IGFzIGFuIGFycmF5XG5leHBvcnQgY29uc3QgaXRlcmF0b3JTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/XG4gICAgU3ltYm9sLml0ZXJhdG9yIDpcbiAgICAnQEBpdGVyYXRvcic7XG5leHBvcnQgY29uc3QgZ2V0SXRlcmF0b3JPZiA9IHR5cGVvZiBpdGVyYXRvclN5bWJvbCA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uKHgpIHtcbiAgICB2YXIgaTtcbiAgICByZXR1cm4geCAhPSBudWxsICYmIChpID0geFtpdGVyYXRvclN5bWJvbF0pICYmIGkuYXBwbHkoeCk7XG59IDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbnVsbDsgfTtcbmV4cG9ydCBjb25zdCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFN5bWJvbC5mb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvclwiKVxuICAgIDogJ0Bhc3luY0l0ZXJhdG9yJztcblxuZXhwb3J0IGNvbnN0IE5PX0NIQVJfQVJSQVkgPSB7fTtcbi8vIFRha2VzIG9uZSBvciBzZXZlcmFsIGFyZ3VtZW50cyBhbmQgcmV0dXJucyBhbiBhcnJheSBiYXNlZCBvbiB0aGUgZm9sbG93aW5nIGNyaXRlcmFzOlxuLy8gKiBJZiBzZXZlcmFsIGFyZ3VtZW50cyBwcm92aWRlZCwgcmV0dXJuIGFyZ3VtZW50cyBjb252ZXJ0ZWQgdG8gYW4gYXJyYXkgaW4gYSB3YXkgdGhhdFxuLy8gICBzdGlsbCBhbGxvd3MgamF2YXNjcmlwdCBlbmdpbmUgdG8gb3B0aW1pemUgdGhlIGNvZGUuXG4vLyAqIElmIHNpbmdsZSBhcmd1bWVudCBpcyBhbiBhcnJheSwgcmV0dXJuIGEgY2xvbmUgb2YgaXQuXG4vLyAqIElmIHRoaXMtcG9pbnRlciBlcXVhbHMgTk9fQ0hBUl9BUlJBWSwgZG9uJ3QgYWNjZXB0IHN0cmluZ3MgYXMgdmFsaWQgaXRlcmFibGVzIGFzIGEgc3BlY2lhbFxuLy8gICBjYXNlIHRvIHRoZSB0d28gYnVsbGV0cyBiZWxvdy5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFuIGl0ZXJhYmxlLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBhcnJheS5cbi8vICogSWYgc2luZ2xlIGFyZ3VtZW50IGlzIGFycmF5LWxpa2UgKGhhcyBsZW5ndGggb2YgdHlwZSBudW1iZXIpLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5LlxuZXhwb3J0IGZ1bmN0aW9uIGdldEFycmF5T2YgKGFycmF5TGlrZSkge1xuICAgIHZhciBpLCBhLCB4LCBpdDtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBpZiAoaXNBcnJheShhcnJheUxpa2UpKSByZXR1cm4gYXJyYXlMaWtlLnNsaWNlKCk7XG4gICAgICAgIGlmICh0aGlzID09PSBOT19DSEFSX0FSUkFZICYmIHR5cGVvZiBhcnJheUxpa2UgPT09ICdzdHJpbmcnKSByZXR1cm4gW2FycmF5TGlrZV07XG4gICAgICAgIGlmICgoaXQgPSBnZXRJdGVyYXRvck9mKGFycmF5TGlrZSkpKSB7XG4gICAgICAgICAgICBhID0gW107XG4gICAgICAgICAgICB3aGlsZSAoKHggPSBpdC5uZXh0KCkpLCAheC5kb25lKSBhLnB1c2goeC52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyYXlMaWtlID09IG51bGwpIHJldHVybiBbYXJyYXlMaWtlXTtcbiAgICAgICAgaSA9IGFycmF5TGlrZS5sZW5ndGg7XG4gICAgICAgIGlmICh0eXBlb2YgaSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGEgPSBuZXcgQXJyYXkoaSk7XG4gICAgICAgICAgICB3aGlsZSAoaS0tKSBhW2ldID0gYXJyYXlMaWtlW2ldO1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthcnJheUxpa2VdO1xuICAgIH1cbiAgICBpID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhID0gbmV3IEFycmF5KGkpO1xuICAgIHdoaWxlIChpLS0pIGFbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgcmV0dXJuIGE7XG59XG5leHBvcnQgY29uc3QgaXNBc3luY0Z1bmN0aW9uID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IChmbjogRnVuY3Rpb24pID0+IGZuW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdBc3luY0Z1bmN0aW9uJ1xuICAgIDogKCk9PmZhbHNlO1xuIiwgIi8vIEJ5IGRlZmF1bHQsIGRlYnVnIHdpbGwgYmUgdHJ1ZSBvbmx5IGlmIHBsYXRmb3JtIGlzIGEgd2ViIHBsYXRmb3JtIGFuZCBpdHMgcGFnZSBpcyBzZXJ2ZWQgZnJvbSBsb2NhbGhvc3QuXG4vLyBXaGVuIGRlYnVnID0gdHJ1ZSwgZXJyb3IncyBzdGFja3Mgd2lsbCBjb250YWluIGFzeW5jcm9uaWMgbG9uZyBzdGFja3MuXG5leHBvcnQgdmFyIGRlYnVnID0gdHlwZW9mIGxvY2F0aW9uICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAvLyBCeSBkZWZhdWx0LCB1c2UgZGVidWcgbW9kZSBpZiBzZXJ2ZWQgZnJvbSBsb2NhbGhvc3QuXG4gICAgICAgIC9eKGh0dHB8aHR0cHMpOlxcL1xcLyhsb2NhbGhvc3R8MTI3XFwuMFxcLjBcXC4xKS8udGVzdChsb2NhdGlvbi5ocmVmKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldERlYnVnKHZhbHVlLCBmaWx0ZXIpIHtcbiAgICBkZWJ1ZyA9IHZhbHVlO1xuICAgIGxpYnJhcnlGaWx0ZXIgPSBmaWx0ZXI7XG59XG5cbmV4cG9ydCB2YXIgbGlicmFyeUZpbHRlciA9ICgpID0+IHRydWU7XG5cbmV4cG9ydCBjb25zdCBORUVEU19USFJPV19GT1JfU1RBQ0sgPSAhbmV3IEVycm9yKFwiXCIpLnN0YWNrO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXJyb3JXaXRoU3RhY2soKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgaWYgKE5FRURTX1RIUk9XX0ZPUl9TVEFDSykgdHJ5IHtcbiAgICAgICAgLy8gRG9pbmcgc29tZXRoaW5nIG5hdWdodHkgaW4gc3RyaWN0IG1vZGUgaGVyZSB0byB0cmlnZ2VyIGEgc3BlY2lmaWMgZXJyb3JcbiAgICAgICAgLy8gdGhhdCBjYW4gYmUgZXhwbGljaXRlbHkgaWdub3JlZCBpbiBkZWJ1Z2dlcidzIGV4Y2VwdGlvbiBzZXR0aW5ncy5cbiAgICAgICAgLy8gSWYgd2UnZCBqdXN0IHRocm93IG5ldyBFcnJvcigpIGhlcmUsIElFJ3MgZGVidWdnZXIncyBleGNlcHRpb24gc2V0dGluZ3NcbiAgICAgICAgLy8gd2lsbCBqdXN0IGNvbnNpZGVyIGl0IGFzIFwiZXhjZXB0aW9uIHRocm93biBieSBqYXZhc2NyaXB0IGNvZGVcIiB3aGljaCBpc1xuICAgICAgICAvLyBzb21ldGhpbmcgeW91IHdvdWxkbid0IHdhbnQgaXQgdG8gaWdub3JlLlxuICAgICAgICBnZXRFcnJvcldpdGhTdGFjay5hcmd1bWVudHM7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcigpOyAvLyBGYWxsYmFjayBpZiBhYm92ZSBsaW5lIGRvbid0IHRocm93LlxuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICByZXR1cm4gZTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBFcnJvcigpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJldHR5U3RhY2soZXhjZXB0aW9uLCBudW1JZ25vcmVkRnJhbWVzKSB7XG4gICAgdmFyIHN0YWNrID0gZXhjZXB0aW9uLnN0YWNrO1xuICAgIGlmICghc3RhY2spIHJldHVybiBcIlwiO1xuICAgIG51bUlnbm9yZWRGcmFtZXMgPSAobnVtSWdub3JlZEZyYW1lcyB8fCAwKTtcbiAgICBpZiAoc3RhY2suaW5kZXhPZihleGNlcHRpb24ubmFtZSkgPT09IDApXG4gICAgICAgIG51bUlnbm9yZWRGcmFtZXMgKz0gKGV4Y2VwdGlvbi5uYW1lICsgZXhjZXB0aW9uLm1lc3NhZ2UpLnNwbGl0KCdcXG4nKS5sZW5ndGg7XG4gICAgcmV0dXJuIHN0YWNrLnNwbGl0KCdcXG4nKVxuICAgICAgICAuc2xpY2UobnVtSWdub3JlZEZyYW1lcylcbiAgICAgICAgLmZpbHRlcihsaWJyYXJ5RmlsdGVyKVxuICAgICAgICAubWFwKGZyYW1lID0+IFwiXFxuXCIgKyBmcmFtZSlcbiAgICAgICAgLmpvaW4oJycpO1xufVxuXG4vLyBUT0RPOiBSZXBsYWNlIHRoaXMgaW4gZmF2b3Igb2YgYSBkZWNvcmF0b3IgaW5zdGVhZC5cbmV4cG9ydCBmdW5jdGlvbiBkZXByZWNhdGVkPFQ+ICh3aGF0OiBzdHJpbmcsIGZuOiAoLi4uYXJncyk9PlQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zb2xlLndhcm4oYCR7d2hhdH0gaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvRGVwcmVjYXRpb25zLiAke3ByZXR0eVN0YWNrKGdldEVycm9yV2l0aFN0YWNrKCksIDEpfWApO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGFzICguLi5hcmdzKT0+VFxufVxuIiwgImltcG9ydCB7IGRlcml2ZSwgc2V0UHJvcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBnZXRFcnJvcldpdGhTdGFjaywgcHJldHR5U3RhY2sgfSBmcm9tICcuLi9oZWxwZXJzL2RlYnVnJztcblxudmFyIGRleGllRXJyb3JOYW1lcyA9IFtcbiAgICAnTW9kaWZ5JyxcbiAgICAnQnVsaycsXG4gICAgJ09wZW5GYWlsZWQnLFxuICAgICdWZXJzaW9uQ2hhbmdlJyxcbiAgICAnU2NoZW1hJyxcbiAgICAnVXBncmFkZScsXG4gICAgJ0ludmFsaWRUYWJsZScsXG4gICAgJ01pc3NpbmdBUEknLFxuICAgICdOb1N1Y2hEYXRhYmFzZScsXG4gICAgJ0ludmFsaWRBcmd1bWVudCcsXG4gICAgJ1N1YlRyYW5zYWN0aW9uJyxcbiAgICAnVW5zdXBwb3J0ZWQnLFxuICAgICdJbnRlcm5hbCcsXG4gICAgJ0RhdGFiYXNlQ2xvc2VkJyxcbiAgICAnUHJlbWF0dXJlQ29tbWl0JyxcbiAgICAnRm9yZWlnbkF3YWl0J1xuXTtcblxudmFyIGlkYkRvbUVycm9yTmFtZXMgPSBbXG4gICAgJ1Vua25vd24nLFxuICAgICdDb25zdHJhaW50JyxcbiAgICAnRGF0YScsXG4gICAgJ1RyYW5zYWN0aW9uSW5hY3RpdmUnLFxuICAgICdSZWFkT25seScsXG4gICAgJ1ZlcnNpb24nLFxuICAgICdOb3RGb3VuZCcsXG4gICAgJ0ludmFsaWRTdGF0ZScsXG4gICAgJ0ludmFsaWRBY2Nlc3MnLFxuICAgICdBYm9ydCcsXG4gICAgJ1RpbWVvdXQnLFxuICAgICdRdW90YUV4Y2VlZGVkJyxcbiAgICAnU3ludGF4JyxcbiAgICAnRGF0YUNsb25lJ1xuXTtcblxudmFyIGVycm9yTGlzdCA9IGRleGllRXJyb3JOYW1lcy5jb25jYXQoaWRiRG9tRXJyb3JOYW1lcyk7XG5cbnZhciBkZWZhdWx0VGV4dHMgPSB7XG4gICAgVmVyc2lvbkNoYW5nZWQ6IFwiRGF0YWJhc2UgdmVyc2lvbiBjaGFuZ2VkIGJ5IG90aGVyIGRhdGFiYXNlIGNvbm5lY3Rpb25cIixcbiAgICBEYXRhYmFzZUNsb3NlZDogXCJEYXRhYmFzZSBoYXMgYmVlbiBjbG9zZWRcIixcbiAgICBBYm9ydDogXCJUcmFuc2FjdGlvbiBhYm9ydGVkXCIsXG4gICAgVHJhbnNhY3Rpb25JbmFjdGl2ZTogXCJUcmFuc2FjdGlvbiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQgb3IgZmFpbGVkXCIsXG4gICAgTWlzc2luZ0FQSTogXCJJbmRleGVkREIgQVBJIG1pc3NpbmcuIFBsZWFzZSB2aXNpdCBodHRwczovL3Rpbnl1cmwuY29tL3kydXV2c2tiXCJcbn07XG5cbi8vXG4vLyBEZXhpZUVycm9yIC0gYmFzZSBjbGFzcyBvZiBhbGwgb3V0IGV4Y2VwdGlvbnMuXG4vL1xuZXhwb3J0IGZ1bmN0aW9uIERleGllRXJyb3IgKG5hbWUsIG1zZykge1xuICAgIC8vIFJlYXNvbiB3ZSBkb24ndCB1c2UgRVM2IGNsYXNzZXMgaXMgYmVjYXVzZTpcbiAgICAvLyAxLiBJdCBibG9hdHMgdHJhbnNwaWxlZCBjb2RlIGFuZCBpbmNyZWFzZXMgc2l6ZSBvZiBtaW5pZmllZCBjb2RlLlxuICAgIC8vIDIuIEl0IGRvZXNuJ3QgZ2l2ZSB1cyBtdWNoIGluIHRoaXMgY2FzZS5cbiAgICAvLyAzLiBJdCB3b3VsZCByZXF1aXJlIHN1YiBjbGFzc2VzIHRvIGNhbGwgc3VwZXIoKSwgd2hpY2hcbiAgICAvLyAgICBpcyBub3QgbmVlZGVkIHdoZW4gZGVyaXZpbmcgZnJvbSBFcnJvci5cbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbn1cblxuZGVyaXZlKERleGllRXJyb3IpLmZyb20oRXJyb3IpLmV4dGVuZCh7XG4gICAgc3RhY2s6IHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdGFjayB8fFxuICAgICAgICAgICAgICAgICh0aGlzLl9zdGFjayA9IHRoaXMubmFtZSArIFwiOiBcIiArIHRoaXMubWVzc2FnZSArIHByZXR0eVN0YWNrKHRoaXMuX2UsIDIpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLm5hbWUgKyBcIjogXCIgKyB0aGlzLm1lc3NhZ2U7IH1cbn0pO1xuXG5mdW5jdGlvbiBnZXRNdWx0aUVycm9yTWVzc2FnZSAobXNnLCBmYWlsdXJlcykge1xuICAgIHJldHVybiBtc2cgKyBcIi4gRXJyb3JzOiBcIiArIE9iamVjdC5rZXlzKGZhaWx1cmVzKVxuICAgICAgICAubWFwKGtleT0+ZmFpbHVyZXNba2V5XS50b1N0cmluZygpKVxuICAgICAgICAuZmlsdGVyKCh2LGkscyk9PnMuaW5kZXhPZih2KSA9PT0gaSkgLy8gT25seSB1bmlxdWUgZXJyb3Igc3RyaW5nc1xuICAgICAgICAuam9pbignXFxuJyk7XG59XG5cbi8vXG4vLyBNb2RpZnlFcnJvciAtIHRocm93biBpbiBDb2xsZWN0aW9uLm1vZGlmeSgpXG4vLyBTcGVjaWZpYyBjb25zdHJ1Y3RvciBiZWNhdXNlIGl0IGNvbnRhaW5zIG1lbWJlcnMgZmFpbHVyZXMgYW5kIGZhaWxlZEtleXMuXG4vL1xuZXhwb3J0IGZ1bmN0aW9uIE1vZGlmeUVycm9yIChtc2csIGZhaWx1cmVzLCBzdWNjZXNzQ291bnQsIGZhaWxlZEtleXMpIHtcbiAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICB0aGlzLmZhaWx1cmVzID0gZmFpbHVyZXM7XG4gICAgdGhpcy5mYWlsZWRLZXlzID0gZmFpbGVkS2V5cztcbiAgICB0aGlzLnN1Y2Nlc3NDb3VudCA9IHN1Y2Nlc3NDb3VudDtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNdWx0aUVycm9yTWVzc2FnZShtc2csIGZhaWx1cmVzKTtcbn1cbmRlcml2ZShNb2RpZnlFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcblxuZXhwb3J0IGZ1bmN0aW9uIEJ1bGtFcnJvciAobXNnLCBmYWlsdXJlcykge1xuICAgIHRoaXMuX2UgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgIHRoaXMubmFtZSA9IFwiQnVsa0Vycm9yXCI7XG4gICAgdGhpcy5mYWlsdXJlcyA9IE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pO1xuICAgIHRoaXMuZmFpbHVyZXNCeVBvcyA9IGZhaWx1cmVzO1xuICAgIHRoaXMubWVzc2FnZSA9IGdldE11bHRpRXJyb3JNZXNzYWdlKG1zZywgZmFpbHVyZXMpO1xufVxuZGVyaXZlKEJ1bGtFcnJvcikuZnJvbShEZXhpZUVycm9yKTtcblxuLy9cbi8vXG4vLyBEeW5hbWljYWxseSBnZW5lcmF0ZSBlcnJvciBuYW1lcyBhbmQgZXhjZXB0aW9uIGNsYXNzZXMgYmFzZWRcbi8vIG9uIHRoZSBuYW1lcyBpbiBlcnJvckxpc3QuXG4vL1xuLy9cblxuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gRXJyb3JOYW1lICsgXCJFcnJvclwifVxuZXhwb3J0IHZhciBlcnJuYW1lcyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaixuYW1lKT0+KG9ialtuYW1lXT1uYW1lK1wiRXJyb3JcIixvYmopLHt9KTtcblxuLy8gTmVlZCBhbiBhbGlhcyBmb3IgRGV4aWVFcnJvciBiZWNhdXNlIHdlJ3JlIGdvbm5hIGNyZWF0ZSBzdWJjbGFzc2VzIHdpdGggdGhlIHNhbWUgbmFtZS5cbmNvbnN0IEJhc2VFeGNlcHRpb24gPSBEZXhpZUVycm9yO1xuLy8gTWFwIG9mIHtFcnJvck5hbWUgLT4gZXhjZXB0aW9uIGNvbnN0cnVjdG9yfVxuZXhwb3J0IHZhciBleGNlcHRpb25zID0gZXJyb3JMaXN0LnJlZHVjZSgob2JqLG5hbWUpPT57XG4gICAgLy8gTGV0IHRoZSBuYW1lIGJlIFwiRGV4aWVFcnJvclwiIGJlY2F1c2UgdGhpcyBuYW1lIG1heVxuICAgIC8vIGJlIHNob3duIGluIGNhbGwgc3RhY2sgYW5kIHdoZW4gZGVidWdnaW5nLiBEZXhpZUVycm9yIGlzXG4gICAgLy8gdGhlIG1vc3QgdHJ1ZSBuYW1lIGJlY2F1c2UgaXQgZGVyaXZlcyBmcm9tIERleGllRXJyb3IsXG4gICAgLy8gYW5kIHdlIGNhbm5vdCBjaGFuZ2UgRnVuY3Rpb24ubmFtZSBwcm9ncmFtYXRpY2FsbHkgd2l0aG91dFxuICAgIC8vIGR5bmFtaWNhbGx5IGNyZWF0ZSBhIEZ1bmN0aW9uIG9iamVjdCwgd2hpY2ggd291bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vICdldmFsLWV2aWwnLlxuICAgIHZhciBmdWxsTmFtZSA9IG5hbWUgKyBcIkVycm9yXCI7XG4gICAgZnVuY3Rpb24gRGV4aWVFcnJvciAobXNnT3JJbm5lciwgaW5uZXIpe1xuICAgICAgICB0aGlzLl9lID0gZ2V0RXJyb3JXaXRoU3RhY2soKTtcbiAgICAgICAgdGhpcy5uYW1lID0gZnVsbE5hbWU7XG4gICAgICAgIGlmICghbXNnT3JJbm5lcikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gZGVmYXVsdFRleHRzW25hbWVdIHx8IGZ1bGxOYW1lO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHttc2dPcklubmVyfSR7IWlubmVyID8gJycgOiAnXFxuICcgKyBpbm5lcn1gO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IGlubmVyIHx8IG51bGw7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1zZ09ySW5uZXIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgJHttc2dPcklubmVyLm5hbWV9ICR7bXNnT3JJbm5lci5tZXNzYWdlfWA7XG4gICAgICAgICAgICB0aGlzLmlubmVyID0gbXNnT3JJbm5lcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZXJpdmUoRGV4aWVFcnJvcikuZnJvbShCYXNlRXhjZXB0aW9uKTtcbiAgICBvYmpbbmFtZV09RGV4aWVFcnJvcjtcbiAgICByZXR1cm4gb2JqO1xufSx7fSk7XG5cbi8vIFVzZSBFQ01BU0NSSVBUIHN0YW5kYXJkIGV4Y2VwdGlvbnMgd2hlcmUgYXBwbGljYWJsZTpcbmV4Y2VwdGlvbnMuU3ludGF4ID0gU3ludGF4RXJyb3I7XG5leGNlcHRpb25zLlR5cGUgPSBUeXBlRXJyb3I7XG5leGNlcHRpb25zLlJhbmdlID0gUmFuZ2VFcnJvcjtcblxuZXhwb3J0IHZhciBleGNlcHRpb25NYXAgPSBpZGJEb21FcnJvck5hbWVzLnJlZHVjZSgob2JqLCBuYW1lKT0+e1xuICAgIG9ialtuYW1lICsgXCJFcnJvclwiXSA9IGV4Y2VwdGlvbnNbbmFtZV07XG4gICAgcmV0dXJuIG9iajtcbn0sIHt9KTtcblxuZXhwb3J0IGZ1bmN0aW9uIG1hcEVycm9yIChkb21FcnJvciwgbWVzc2FnZSkge1xuICAgIGlmICghZG9tRXJyb3IgfHwgZG9tRXJyb3IgaW5zdGFuY2VvZiBEZXhpZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yIHx8IGRvbUVycm9yIGluc3RhbmNlb2YgU3ludGF4RXJyb3IgfHwgIWRvbUVycm9yLm5hbWUgfHwgIWV4Y2VwdGlvbk1hcFtkb21FcnJvci5uYW1lXSlcbiAgICAgICAgcmV0dXJuIGRvbUVycm9yO1xuICAgIHZhciBydiA9IG5ldyBleGNlcHRpb25NYXBbZG9tRXJyb3IubmFtZV0obWVzc2FnZSB8fCBkb21FcnJvci5tZXNzYWdlLCBkb21FcnJvcik7XG4gICAgaWYgKFwic3RhY2tcIiBpbiBkb21FcnJvcikge1xuICAgICAgICAvLyBEZXJpdmUgc3RhY2sgZnJvbSBpbm5lciBleGNlcHRpb24gaWYgaXQgaGFzIGEgc3RhY2tcbiAgICAgICAgc2V0UHJvcChydiwgXCJzdGFja1wiLCB7Z2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5uZXIuc3RhY2s7XG4gICAgICAgIH19KTtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xufVxuXG5leHBvcnQgdmFyIGZ1bGxOYW1lRXhjZXB0aW9ucyA9IGVycm9yTGlzdC5yZWR1Y2UoKG9iaiwgbmFtZSk9PntcbiAgICBpZiAoW1wiU3ludGF4XCIsXCJUeXBlXCIsXCJSYW5nZVwiXS5pbmRleE9mKG5hbWUpID09PSAtMSlcbiAgICAgICAgb2JqW25hbWUgKyBcIkVycm9yXCJdID0gZXhjZXB0aW9uc1tuYW1lXTtcbiAgICByZXR1cm4gb2JqO1xufSwge30pO1xuXG5mdWxsTmFtZUV4Y2VwdGlvbnMuTW9kaWZ5RXJyb3IgPSBNb2RpZnlFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5EZXhpZUVycm9yID0gRGV4aWVFcnJvcjtcbmZ1bGxOYW1lRXhjZXB0aW9ucy5CdWxrRXJyb3IgPSBCdWxrRXJyb3I7XG4iLCAiaW1wb3J0IHtleHRlbmR9IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gbm9wKCkgeyB9XG5leHBvcnQgZnVuY3Rpb24gbWlycm9yKHZhbCkgeyByZXR1cm4gdmFsOyB9XG5leHBvcnQgZnVuY3Rpb24gcHVyZUZ1bmN0aW9uQ2hhaW4oZjEsIGYyKSB7XG4gICAgLy8gRW5hYmxlcyBjaGFpbmVkIGV2ZW50cyB0aGF0IHRha2VzIE9ORSBhcmd1bWVudCBhbmQgcmV0dXJucyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbiBpbiBjaGFpbi5cbiAgICAvLyBUaGlzIHBhdHRlcm4gaXMgdXNlZCBpbiB0aGUgaG9vayhcInJlYWRpbmdcIikgZXZlbnQuXG4gICAgaWYgKGYxID09IG51bGwgfHwgZjEgPT09IG1pcnJvcikgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAodmFsKSB7XG4gICAgICAgIHJldHVybiBmMihmMSh2YWwpKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FsbEJvdGgob24xLCBvbjIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBvbjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgb24yLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tDcmVhdGluZ0NoYWluKGYxLCBmMikge1xuICAgIC8vIEVuYWJsZXMgY2hhaW5lZCBldmVudHMgdGhhdCB0YWtlcyBzZXZlcmFsIGFyZ3VtZW50cyBhbmQgbWF5IG1vZGlmeSBmaXJzdCBhcmd1bWVudCBieSBtYWtpbmcgYSBtb2RpZmljYXRpb24gYW5kIHRoZW4gcmV0dXJuaW5nIHRoZSBzYW1lIGluc3RhbmNlLlxuICAgIC8vIFRoaXMgcGF0dGVybiBpcyB1c2VkIGluIHRoZSBob29rKFwiY3JlYXRpbmdcIikgZXZlbnQuXG4gICAgaWYgKGYxID09PSBub3ApIHJldHVybiBmMjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKHJlcyAhPT0gdW5kZWZpbmVkKSBhcmd1bWVudHNbMF0gPSByZXM7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAgICAgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25lcnJvclxuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IG51bGw7XG4gICAgICAgIHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIHZhciByZXMyID0gZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKG9uc3VjY2VzcykgdGhpcy5vbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcyA/IGNhbGxCb3RoKG9uc3VjY2VzcywgdGhpcy5vbnN1Y2Nlc3MpIDogb25zdWNjZXNzO1xuICAgICAgICBpZiAob25lcnJvcikgdGhpcy5vbmVycm9yID0gdGhpcy5vbmVycm9yID8gY2FsbEJvdGgob25lcnJvciwgdGhpcy5vbmVycm9yKSA6IG9uZXJyb3I7XG4gICAgICAgIHJldHVybiByZXMyICE9PSB1bmRlZmluZWQgPyByZXMyIDogcmVzO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob29rRGVsZXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcCkgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIHZhciBvbnN1Y2Nlc3MgPSB0aGlzLm9uc3VjY2VzcywgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25zdWNjZXNzXG4gICAgICAgICAgICBvbmVycm9yID0gdGhpcy5vbmVycm9yOyAgICAgLy8gSW4gY2FzZSBldmVudCBsaXN0ZW5lciBoYXMgc2V0IHRoaXMub25lcnJvclxuICAgICAgICB0aGlzLm9uc3VjY2VzcyA9IHRoaXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob29rVXBkYXRpbmdDaGFpbihmMSwgZjIpIHtcbiAgICBpZiAoZjEgPT09IG5vcCkgcmV0dXJuIGYyO1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kaWZpY2F0aW9ucykge1xuICAgICAgICB2YXIgcmVzID0gZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZXh0ZW5kKG1vZGlmaWNhdGlvbnMsIHJlcyk7IC8vIElmIGYxIHJldHVybnMgbmV3IG1vZGlmaWNhdGlvbnMsIGV4dGVuZCBjYWxsZXIncyBtb2RpZmljYXRpb25zIHdpdGggdGhlIHJlc3VsdCBiZWZvcmUgY2FsbGluZyBuZXh0IGluIGNoYWluLlxuICAgICAgICB2YXIgb25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MsIC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uc3VjY2Vzc1xuICAgICAgICAgICAgb25lcnJvciA9IHRoaXMub25lcnJvcjsgICAgIC8vIEluIGNhc2UgZXZlbnQgbGlzdGVuZXIgaGFzIHNldCB0aGlzLm9uZXJyb3JcbiAgICAgICAgdGhpcy5vbnN1Y2Nlc3MgPSBudWxsO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICB2YXIgcmVzMiA9IGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChvbnN1Y2Nlc3MpIHRoaXMub25zdWNjZXNzID0gdGhpcy5vbnN1Y2Nlc3MgPyBjYWxsQm90aChvbnN1Y2Nlc3MsIHRoaXMub25zdWNjZXNzKSA6IG9uc3VjY2VzcztcbiAgICAgICAgaWYgKG9uZXJyb3IpIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvciA/IGNhbGxCb3RoKG9uZXJyb3IsIHRoaXMub25lcnJvcikgOiBvbmVycm9yO1xuICAgICAgICByZXR1cm4gcmVzID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgKHJlczIgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHJlczIpIDpcbiAgICAgICAgICAgIChleHRlbmQocmVzLCByZXMyKSk7XG4gICAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJldmVyc2VTdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGYyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiBmMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub25TdG9wcGFibGVFdmVudENoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZjEuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvbWlzYWJsZUNoYWluKGYxLCBmMikge1xuICAgIGlmIChmMSA9PT0gbm9wKSByZXR1cm4gZjI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlcyA9IGYxLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcy50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgdGhpeiA9IHRoaXMsXG4gICAgICAgICAgICAgICAgaSA9IGFyZ3VtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJncyA9IG5ldyBBcnJheShpKTtcbiAgICAgICAgICAgIHdoaWxlIChpLS0pIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMi5hcHBseSh0aGl6LCBhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG59XG4iLCAiLypcbiAqIENvcHlyaWdodCAoYykgMjAxNC0yMDE3IERhdmlkIEZhaGxhbmRlclxuICogQXBhY2hlIExpY2Vuc2UgVmVyc2lvbiAyLjAsIEphbnVhcnkgMjAwNCwgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKi9cbmltcG9ydCB7IF9nbG9iYWwgfSBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbCc7XG5pbXBvcnQge3RyeUNhdGNoLCBwcm9wcywgc2V0UHJvcCwgX2dsb2JhbCxcbiAgICBnZXRQcm9wZXJ0eURlc2NyaXB0b3IsIGdldEFycmF5T2YsIGV4dGVuZCwgZ2V0UHJvdG99IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQge25vcCwgY2FsbEJvdGgsIG1pcnJvcn0gZnJvbSAnLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQge2RlYnVnLCBwcmV0dHlTdGFjaywgZ2V0RXJyb3JXaXRoU3RhY2t9IGZyb20gJy4vZGVidWcnO1xuaW1wb3J0IHtleGNlcHRpb25zfSBmcm9tICcuLi9lcnJvcnMnO1xuXG4vL1xuLy8gUHJvbWlzZSBhbmQgWm9uZSAoUFNEKSBmb3IgRGV4aWUgbGlicmFyeVxuLy9cbi8vIEkgc3RhcnRlZCBvdXQgd3JpdGluZyB0aGlzIFByb21pc2UgY2xhc3MgYnkgY29weWluZyBwcm9taXNlLWxpZ2h0IChodHRwczovL2dpdGh1Yi5jb20vdGF5bG9yaGFrZXMvcHJvbWlzZS1saWdodCkgYnlcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YXlsb3JoYWtlcyAtIGFuIEErIGFuZCBFQ01BU0NSSVBUIDYgY29tcGxpYW50IFByb21pc2UgaW1wbGVtZW50YXRpb24uXG4vL1xuLy8gSW4gcHJldmlvdXMgdmVyc2lvbnMgdGhpcyB3YXMgZml4ZWQgYnkgbm90IGNhbGxpbmcgc2V0VGltZW91dCB3aGVuIGtub3dpbmcgdGhhdCB0aGUgcmVzb2x2ZSgpIG9yIHJlamVjdCgpIGNhbWUgZnJvbSBhbm90aGVyXG4vLyB0aWNrLiBJbiBEZXhpZSB2MS40LjAsIEkndmUgcmV3cml0dGVuIHRoZSBQcm9taXNlIGNsYXNzIGVudGlyZWx5LiBKdXN0IHNvbWUgZnJhZ21lbnRzIG9mIHByb21pc2UtbGlnaHQgaXMgbGVmdC4gSSB1c2Vcbi8vIGFub3RoZXIgc3RyYXRlZ3kgbm93IHRoYXQgc2ltcGxpZmllcyBldmVyeXRoaW5nIGEgbG90OiB0byBhbHdheXMgZXhlY3V0ZSBjYWxsYmFja3MgaW4gYSBuZXcgbWljcm8tdGFzaywgYnV0IGhhdmUgYW4gb3duIG1pY3JvLXRhc2tcbi8vIGVuZ2luZSB0aGF0IGlzIGluZGV4ZWREQiBjb21wbGlhbnQgYWNyb3NzIGFsbCBicm93c2Vycy5cbi8vIFByb21pc2UgY2xhc3MgaGFzIGFsc28gYmVlbiBvcHRpbWl6ZWQgYSBsb3Qgd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkIC0gdG8gYXZvaWQgY2xvc3VyZXMgYXMgbXVjaCBhcyBwb3NzaWJsZS5cbi8vIEFsc28gd2l0aCBpbnNwaXJhdGlvbiBmcm9tIGJsdWViaXJkLCBhc3luY3JvbmljIHN0YWNrcyBpbiBkZWJ1ZyBtb2RlLlxuLy9cbi8vIFNwZWNpZmljIG5vbi1zdGFuZGFyZCBmZWF0dXJlcyBvZiB0aGlzIFByb21pc2UgY2xhc3M6XG4vLyAqIEN1c3RvbSB6b25lIHN1cHBvcnQgKGEuay5hLiBQU0QpIHdpdGggYWJpbGl0eSB0byBrZWVwIHpvbmVzIGFsc28gd2hlbiB1c2luZyBuYXRpdmUgcHJvbWlzZXMgYXMgd2VsbCBhc1xuLy8gICBuYXRpdmUgYXN5bmMgLyBhd2FpdC5cbi8vICogUHJvbWlzZS5mb2xsb3coKSBtZXRob2QgYnVpbHQgdXBvbiB0aGUgY3VzdG9tIHpvbmUgZW5naW5lLCB0aGF0IGFsbG93cyB1c2VyIHRvIHRyYWNrIGFsbCBwcm9taXNlcyBjcmVhdGVkIGZyb20gY3VycmVudCBzdGFjayBmcmFtZVxuLy8gICBhbmQgYmVsb3cgKyBhbGwgcHJvbWlzZXMgdGhhdCB0aG9zZSBwcm9taXNlcyBjcmVhdGVzIG9yIGF3YWl0cy5cbi8vICogRGV0ZWN0IGFueSB1bmhhbmRsZWQgcHJvbWlzZSBpbiBhIFBTRC1zY29wZSAoUFNELm9udW5oYW5kbGVkKS4gXG4vL1xuLy8gRGF2aWQgRmFobGFuZGVyLCBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlclxuLy9cblxuLy8gSnVzdCBhIHBvaW50ZXIgdGhhdCBvbmx5IHRoaXMgbW9kdWxlIGtub3dzIGFib3V0LlxuLy8gVXNlZCBpbiBQcm9taXNlIGNvbnN0cnVjdG9yIHRvIGVtdWxhdGUgYSBwcml2YXRlIGNvbnN0cnVjdG9yLlxudmFyIElOVEVSTkFMID0ge307XG5cbi8vIEFzeW5jIHN0YWNrcyAobG9uZyBzdGFja3MpIG11c3Qgbm90IGdyb3cgaW5maW5pdGVseS5cbmNvbnN0XG4gICAgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCA9IDEwMCxcbiAgICAvLyBXaGVuIGNhbGxpbmcgZXJyb3Iuc3RhY2sgb3IgcHJvbWlzZS5zdGFjaywgbGltaXQgdGhlIG51bWJlciBvZiBhc3luY3JvbmljIHN0YWNrcyB0byBwcmludCBvdXQuIFxuICAgIE1BWF9MT05HX1NUQUNLUyA9IDIwLFxuICAgIFpPTkVfRUNIT19MSU1JVCA9IDEwMCxcbiAgICBbcmVzb2x2ZWROYXRpdmVQcm9taXNlLCBuYXRpdmVQcm9taXNlUHJvdG8sIHJlc29sdmVkR2xvYmFsUHJvbWlzZV0gPSB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgP1xuICAgICAgICBbXSA6XG4gICAgICAgICgoKT0+e1xuICAgICAgICAgICAgbGV0IGdsb2JhbFAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvID09PSAndW5kZWZpbmVkJyB8fCAhY3J5cHRvLnN1YnRsZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW2dsb2JhbFAsIGdldFByb3RvKGdsb2JhbFApLCBnbG9iYWxQXTtcbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmF0aXZlIHByb21pc2UgKGFzIHdpbmRvdy5Qcm9taXNlIG1heSBoYXZlIGJlZW4gcGF0Y2hlZClcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVAgPSBjcnlwdG8uc3VidGxlLmRpZ2VzdChcIlNIQS01MTJcIiwgbmV3IFVpbnQ4QXJyYXkoWzBdKSk7XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIG5hdGl2ZVAsXG4gICAgICAgICAgICAgICAgZ2V0UHJvdG8obmF0aXZlUCksXG4gICAgICAgICAgICAgICAgZ2xvYmFsUFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfSkoKSxcbiAgICBuYXRpdmVQcm9taXNlVGhlbiA9IG5hdGl2ZVByb21pc2VQcm90byAmJiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbjtcblxuZXhwb3J0IGNvbnN0IE5hdGl2ZVByb21pc2UgPSByZXNvbHZlZE5hdGl2ZVByb21pc2UgJiYgcmVzb2x2ZWROYXRpdmVQcm9taXNlLmNvbnN0cnVjdG9yO1xuY29uc3QgcGF0Y2hHbG9iYWxQcm9taXNlID0gISFyZXNvbHZlZEdsb2JhbFByb21pc2U7XG5cbnZhciBzdGFja19iZWluZ19nZW5lcmF0ZWQgPSBmYWxzZTtcblxuLyogVGhlIGRlZmF1bHQgZnVuY3Rpb24gdXNlZCBvbmx5IGZvciB0aGUgdmVyeSBmaXJzdCBwcm9taXNlIGluIGEgcHJvbWlzZSBjaGFpbi5cbiAgIEFzIHNvb24gYXMgdGhlbiBwcm9taXNlIGlzIHJlc29sdmVkIG9yIHJlamVjdGVkLCBhbGwgbmV4dCB0YXNrcyB3aWxsIGJlIGV4ZWN1dGVkIGluIG1pY3JvIHRpY2tzXG4gICBlbXVsYXRlZCBpbiB0aGlzIG1vZHVsZS4gRm9yIGluZGV4ZWREQiBjb21wYXRpYmlsaXR5LCB0aGlzIG1lYW5zIHRoYXQgZXZlcnkgbWV0aG9kIG5lZWRzIHRvIFxuICAgZXhlY3V0ZSBhdCBsZWFzdCBvbmUgcHJvbWlzZSBiZWZvcmUgZG9pbmcgYW4gaW5kZXhlZERCIG9wZXJhdGlvbi4gRGV4aWUgd2lsbCBhbHdheXMgY2FsbCBcbiAgIGRiLnJlYWR5KCkudGhlbigpIGZvciBldmVyeSBvcGVyYXRpb24gdG8gbWFrZSBzdXJlIHRoZSBpbmRleGVkREIgZXZlbnQgaXMgc3RhcnRlZCBpbiBhblxuICAgaW5kZXhlZERCLWNvbXBhdGlibGUgZW11bGF0ZWQgbWljcm8gdGFzayBsb29wLlxuKi9cbnZhciBzY2hlZHVsZVBoeXNpY2FsVGljayA9IHJlc29sdmVkR2xvYmFsUHJvbWlzZSA/XG4gICAgKCkgPT4ge3Jlc29sdmVkR2xvYmFsUHJvbWlzZS50aGVuKHBoeXNpY2FsVGljayk7fVxuICAgIDpcbiAgICBfZ2xvYmFsLnNldEltbWVkaWF0ZSA/IFxuICAgICAgICAvLyBzZXRJbW1lZGlhdGUgc3VwcG9ydGVkLiBUaG9zZSBtb2Rlcm4gcGxhdGZvcm1zIGFsc28gc3VwcG9ydHMgRnVuY3Rpb24uYmluZCgpLlxuICAgICAgICBzZXRJbW1lZGlhdGUuYmluZChudWxsLCBwaHlzaWNhbFRpY2spIDpcbiAgICAgICAgX2dsb2JhbC5NdXRhdGlvbk9ic2VydmVyID9cbiAgICAgICAgICAgIC8vIE11dGF0aW9uT2JzZXJ2ZXIgc3VwcG9ydGVkXG4gICAgICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIGhpZGRlbkRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICAgICAgKG5ldyBNdXRhdGlvbk9ic2VydmVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGh5c2ljYWxUaWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbkRpdiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfSkpLm9ic2VydmUoaGlkZGVuRGl2LCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgaGlkZGVuRGl2LnNldEF0dHJpYnV0ZSgnaScsICcxJyk7XG4gICAgICAgICAgICB9IDpcbiAgICAgICAgICAgIC8vIE5vIHN1cHBvcnQgZm9yIHNldEltbWVkaWF0ZSBvciBNdXRhdGlvbk9ic2VydmVyLiBObyB3b3JyeSwgc2V0VGltZW91dCBpcyBvbmx5IGNhbGxlZFxuICAgICAgICAgICAgLy8gb25jZSB0aW1lLiBFdmVyeSB0aWNrIHRoYXQgZm9sbG93cyB3aWxsIGJlIG91ciBlbXVsYXRlZCBtaWNybyB0aWNrLlxuICAgICAgICAgICAgLy8gQ291bGQgaGF2ZSB1c2VzIHNldFRpbWVvdXQuYmluZChudWxsLCAwLCBwaHlzaWNhbFRpY2spIGlmIGl0IHdhc250IGZvciB0aGF0IEZGMTMgYW5kIGJlbG93IGhhcyBhIGJ1ZyBcbiAgICAgICAgICAgICgpPT57c2V0VGltZW91dChwaHlzaWNhbFRpY2ssMCk7fTtcblxuLy8gQ29uZmlndXJhYmxlIHRocm91Z2ggUHJvbWlzZS5zY2hlZHVsZXIuXG4vLyBEb24ndCBleHBvcnQgYmVjYXVzZSBpdCB3b3VsZCBiZSB1bnNhZmUgdG8gbGV0IHVua25vd25cbi8vIGNvZGUgY2FsbCBpdCB1bmxlc3MgdGhleSBkbyB0cnkuLmNhdGNoIHdpdGhpbiB0aGVpciBjYWxsYmFjay5cbi8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHJldHJpZXZlZCB0aHJvdWdoIGdldHRlciBvZiBQcm9taXNlLnNjaGVkdWxlciB0aG91Z2gsXG4vLyBidXQgdXNlcnMgbXVzdCBub3QgZG8gUHJvbWlzZS5zY2hlZHVsZXIgPSBteUZ1bmNUaGF0VGhyb3dzRXhjZXB0aW9uXG52YXIgYXNhcCA9IGZ1bmN0aW9uIChjYWxsYmFjaywgYXJncykge1xuICAgIG1pY3JvdGlja1F1ZXVlLnB1c2goW2NhbGxiYWNrLCBhcmdzXSk7XG4gICAgaWYgKG5lZWRzTmV3UGh5c2ljYWxUaWNrKSB7XG4gICAgICAgIHNjaGVkdWxlUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgfVxufTtcblxudmFyIGlzT3V0c2lkZU1pY3JvVGljayA9IHRydWUsIC8vIFRydWUgd2hlbiBOT1QgaW4gYSB2aXJ0dWFsIG1pY3JvVGljay5cbiAgICBuZWVkc05ld1BoeXNpY2FsVGljayA9IHRydWUsIC8vIFRydWUgd2hlbiBhIHB1c2ggdG8gbWljcm90aWNrUXVldWUgbXVzdCBhbHNvIHNjaGVkdWxlUGh5c2ljYWxUaWNrKClcbiAgICB1bmhhbmRsZWRFcnJvcnMgPSBbXSwgLy8gUmVqZWN0ZWQgcHJvbWlzZXMgdGhhdCBoYXMgb2NjdXJlZC4gVXNlZCBmb3IgdHJpZ2dlcmluZyAndW5oYW5kbGVkcmVqZWN0aW9uJy5cbiAgICByZWplY3RpbmdFcnJvcnMgPSBbXSwgLy8gVHJhY2tzIGlmIGVycm9ycyBhcmUgYmVpbmcgcmUtcmVqZWN0ZWQgZHVyaW5nIG9uUmVqZWN0ZWQgY2FsbGJhY2suXG4gICAgY3VycmVudEZ1bGZpbGxlciA9IG51bGwsXG4gICAgcmVqZWN0aW9uTWFwcGVyID0gbWlycm9yOyAvLyBSZW1vdmUgaW4gbmV4dCBtYWpvciB3aGVuIHJlbW92aW5nIGVycm9yIG1hcHBpbmcgb2YgRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zXG4gICAgXG5leHBvcnQgdmFyIGdsb2JhbFBTRCA9IHtcbiAgICBpZDogJ2dsb2JhbCcsXG4gICAgZ2xvYmFsOiB0cnVlLFxuICAgIHJlZjogMCxcbiAgICB1bmhhbmRsZWRzOiBbXSxcbiAgICBvbnVuaGFuZGxlZDogZ2xvYmFsRXJyb3IsXG4gICAgcGdwOiBmYWxzZSxcbiAgICBlbnY6IHt9LFxuICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudW5oYW5kbGVkcy5mb3JFYWNoKHVoID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ2xvYmFsRXJyb3IodWhbMF0sIHVoWzFdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgICAgIH0pO1xuICAgIH1cbn07XG5cbmV4cG9ydCB2YXIgUFNEID0gZ2xvYmFsUFNEO1xuXG5leHBvcnQgdmFyIG1pY3JvdGlja1F1ZXVlID0gW107IC8vIENhbGxiYWNrcyB0byBjYWxsIGluIHRoaXMgb3IgbmV4dCBwaHlzaWNhbCB0aWNrLlxuZXhwb3J0IHZhciBudW1TY2hlZHVsZWRDYWxscyA9IDA7IC8vIE51bWJlciBvZiBsaXN0ZW5lci1jYWxscyBsZWZ0IHRvIGRvIGluIHRoaXMgcGh5c2ljYWwgdGljay5cbmV4cG9ydCB2YXIgdGlja0ZpbmFsaXplcnMgPSBbXTsgLy8gRmluYWxpemVycyB0byBjYWxsIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgYXN5bmMgY2FsbHMgc2NoZWR1bGVkIHdpdGhpbiBjdXJyZW50IHBoeXNpY2FsIHRpY2suXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERleGllUHJvbWlzZShmbikge1xuICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ29iamVjdCcpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpOyAgICBcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLm9udW5jYXRjaGVkID0gbm9wOyAvLyBEZXByZWNhdGUgaW4gbmV4dCBtYWpvci4gTm90IG5lZWRlZC4gQmV0dGVyIHRvIHVzZSBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICBcbiAgICAvLyBBIGxpYnJhcnkgbWF5IHNldCBgcHJvbWlzZS5fbGliID0gdHJ1ZTtgIGFmdGVyIHByb21pc2UgaXMgY3JlYXRlZCB0byBtYWtlIHJlc29sdmUoKSBvciByZWplY3QoKVxuICAgIC8vIGV4ZWN1dGUgdGhlIG1pY3JvdGFzayBlbmdpbmUgaW1wbGljaXRlbHkgd2l0aGluIHRoZSBjYWxsIHRvIHJlc29sdmUoKSBvciByZWplY3QoKS5cbiAgICAvLyBUbyByZW1haW4gQSsgY29tcGxpYW50LCBhIGxpYnJhcnkgbXVzdCBvbmx5IHNldCBgX2xpYj10cnVlYCBpZiBpdCBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHN0YWNrXG4gICAgLy8gb25seSBjb250YWlucyBsaWJyYXJ5IGNvZGUgd2hlbiBjYWxsaW5nIHJlc29sdmUoKSBvciByZWplY3QoKS5cbiAgICAvLyBSVUxFIE9GIFRIVU1COiBPTkxZIHNldCBfbGliID0gdHJ1ZSBmb3IgcHJvbWlzZXMgZXhwbGljaXRlbHkgcmVzb2x2aW5nL3JlamVjdGluZyBkaXJlY3RseSBmcm9tXG4gICAgLy8gZ2xvYmFsIHNjb3BlIChldmVudCBoYW5kbGVyLCB0aW1lciBldGMpIVxuICAgIHRoaXMuX2xpYiA9IGZhbHNlO1xuICAgIC8vIEN1cnJlbnQgYXN5bmMgc2NvcGVcbiAgICB2YXIgcHNkID0gKHRoaXMuX1BTRCA9IFBTRCk7XG5cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgdGhpcy5fc3RhY2tIb2xkZXIgPSBnZXRFcnJvcldpdGhTdGFjaygpO1xuICAgICAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbnVtUHJldiA9IDA7IC8vIE51bWJlciBvZiBwcmV2aW91cyBwcm9taXNlcyAoZm9yIGxvbmcgc3RhY2tzKVxuICAgIH1cbiAgICBcbiAgICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChmbiAhPT0gSU5URVJOQUwpIHRocm93IG5ldyBUeXBlRXJyb3IoJ05vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3IgKElOVEVSTkFMLCBzdGF0ZSwgdmFsdWUpLlxuICAgICAgICAvLyBVc2VkIGludGVybmFsbHkgYnkgUHJvbWlzZS5yZXNvbHZlKCkgYW5kIFByb21pc2UucmVqZWN0KCkuXG4gICAgICAgIHRoaXMuX3N0YXRlID0gYXJndW1lbnRzWzFdO1xuICAgICAgICB0aGlzLl92YWx1ZSA9IGFyZ3VtZW50c1syXTtcbiAgICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBmYWxzZSlcbiAgICAgICAgICAgIGhhbmRsZVJlamVjdGlvbih0aGlzLCB0aGlzLl92YWx1ZSk7IC8vIE1hcCBlcnJvciwgc2V0IHN0YWNrIGFuZCBhZGRQb3NzaWJseVVuaGFuZGxlZEVycm9yKCkuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fc3RhdGUgPSBudWxsOyAvLyBudWxsICg9cGVuZGluZyksIGZhbHNlICg9cmVqZWN0ZWQpIG9yIHRydWUgKD1yZXNvbHZlZClcbiAgICB0aGlzLl92YWx1ZSA9IG51bGw7IC8vIGVycm9yIG9yIHJlc3VsdFxuICAgICsrcHNkLnJlZjsgLy8gUmVmY291bnRpbmcgY3VycmVudCBzY29wZVxuICAgIGV4ZWN1dGVQcm9taXNlVGFzayh0aGlzLCBmbik7XG59XG5cbi8vIFByZXBhcmUgYSBwcm9wZXJ0eSBkZXNjcmlwdG9yIHRvIHB1dCBvbnRvIFByb21pc2UucHJvdG90eXBlLnRoZW5cbmNvbnN0IHRoZW5Qcm9wID0ge1xuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwc2QgPSBQU0QsIG1pY3JvVGFza0lkID0gdG90YWxFY2hvZXM7XG5cbiAgICAgICAgZnVuY3Rpb24gdGhlbiAob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHZhciBwb3NzaWJsZUF3YWl0ID0gIXBzZC5nbG9iYWwgJiYgKHBzZCAhPT0gUFNEIHx8IG1pY3JvVGFza0lkICE9PSB0b3RhbEVjaG9lcyk7XG4gICAgICAgICAgICBjb25zdCBjbGVhbnVwID0gcG9zc2libGVBd2FpdCAmJiAhZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTtcbiAgICAgICAgICAgIHZhciBydiA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIodGhpcywgbmV3IExpc3RlbmVyKFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uRnVsZmlsbGVkLCBwc2QsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApLFxuICAgICAgICAgICAgICAgICAgICBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHBzZCwgcG9zc2libGVBd2FpdCwgY2xlYW51cCksXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgcHNkKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRlYnVnICYmIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gcnY7XG4gICAgICAgIH1cblxuICAgICAgICB0aGVuLnByb3RvdHlwZSA9IElOVEVSTkFMOyAvLyBGb3IgaWRlbXBvdGVuc2UsIHNlZSBzZXR0ZXIgYmVsb3cuXG5cbiAgICAgICAgcmV0dXJuIHRoZW47XG4gICAgfSxcbiAgICAvLyBCZSBpZGVtcG90ZW50IGFuZCBhbGxvdyBhbm90aGVyIGZyYW1ld29yayAoc3VjaCBhcyB6b25lLmpzIG9yIGFub3RoZXIgaW5zdGFuY2Ugb2YgYSBEZXhpZS5Qcm9taXNlIG1vZHVsZSkgdG8gcmVwbGFjZSBQcm9taXNlLnByb3RvdHlwZS50aGVuXG4gICAgLy8gYW5kIHdoZW4gdGhhdCBmcmFtZXdvcmsgd2FudHMgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvcGVydHksIHdlIG11c3QgaWRlbnRpZnkgdGhhdCBhbmQgcmVzdG9yZSB0aGUgb3JpZ2luYWwgcHJvcGVydHkgZGVzY3JpcHRvci5cbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBzZXRQcm9wICh0aGlzLCAndGhlbicsIHZhbHVlICYmIHZhbHVlLnByb3RvdHlwZSA9PT0gSU5URVJOQUwgP1xuICAgICAgICAgICAgdGhlblByb3AgOiAvLyBSZXN0b3JlIHRvIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3IuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7IC8vIEdldHRlciByZXR1cm5pbmcgcHJvdmlkZWQgdmFsdWUgKGJlaGF2ZXMgbGlrZSB2YWx1ZSBpcyBqdXN0IGNoYW5nZWQpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IHRoZW5Qcm9wLnNldCAvLyBLZWVwIGEgc2V0dGVyIHRoYXQgaXMgcHJlcGFyZWQgdG8gcmVzdG9yZSBvcmlnaW5hbC5cbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9XG59O1xuXG5wcm9wcyhEZXhpZVByb21pc2UucHJvdG90eXBlLCB7XG4gICAgdGhlbjogdGhlblByb3AsIC8vIERlZmluZWQgYWJvdmUuXG4gICAgX3RoZW46IGZ1bmN0aW9uIChvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAvLyBBIGxpdHRsZSB0aW5pZXIgdmVyc2lvbiBvZiB0aGVuKCkgdGhhdCBkb24ndCBoYXZlIHRvIGNyZWF0ZSBhIHJlc3VsdGluZyBwcm9taXNlLlxuICAgICAgICBwcm9wYWdhdGVUb0xpc3RlbmVyKHRoaXMsIG5ldyBMaXN0ZW5lcihudWxsLCBudWxsLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgUFNEKSk7ICAgICAgICBcbiAgICB9LFxuXG4gICAgY2F0Y2g6IGZ1bmN0aW9uIChvblJlamVjdGVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAvLyBGaXJzdCBhcmd1bWVudCBpcyB0aGUgRXJyb3IgdHlwZSB0byBjYXRjaFxuICAgICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50c1swXSxcbiAgICAgICAgICAgIGhhbmRsZXIgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBieSBpdHMgY29uc3RydWN0b3IgdHlwZSAoc2ltaWxhciB0byBqYXZhIC8gYysrIC8gYyMpXG4gICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goVHlwZUVycm9yLCBmdW5jdGlvbiAoZSkgeyAuLi4gfSk7XG4gICAgICAgICAgICBlcnIgaW5zdGFuY2VvZiB0eXBlID8gaGFuZGxlcihlcnIpIDogUHJvbWlzZVJlamVjdChlcnIpKVxuICAgICAgICA6IHRoaXMudGhlbihudWxsLCBlcnIgPT5cbiAgICAgICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBieSB0aGUgZXJyb3IubmFtZSBwcm9wZXJ0eS4gTWFrZXMgc2Vuc2UgZm9yIGluZGV4ZWREQiB3aGVyZSBlcnJvciB0eXBlXG4gICAgICAgICAgICAvLyBpcyBhbHdheXMgRE9NRXJyb3IgYnV0IHdoZXJlIGUubmFtZSB0ZWxscyB0aGUgYWN0dWFsIGVycm9yIHR5cGUuXG4gICAgICAgICAgICAvLyBTYW1wbGU6IHByb21pc2UuY2F0Y2goJ0NvbnN0cmFpbnRFcnJvcicsIGZ1bmN0aW9uIChlKSB7IC4uLiB9KTtcbiAgICAgICAgICAgIGVyciAmJiBlcnIubmFtZSA9PT0gdHlwZSA/IGhhbmRsZXIoZXJyKSA6IFByb21pc2VSZWplY3QoZXJyKSk7XG4gICAgfSxcblxuICAgIGZpbmFsbHk6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhlbih2YWx1ZSA9PiB7XG4gICAgICAgICAgICBvbkZpbmFsbHkoKTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSwgZXJyID0+IHtcbiAgICAgICAgICAgIG9uRmluYWxseSgpO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICBzdGFjazoge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3N0YWNrKSByZXR1cm4gdGhpcy5fc3RhY2s7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdmFyIHN0YWNrcyA9IGdldFN0YWNrICh0aGlzLCBbXSwgTUFYX0xPTkdfU1RBQ0tTKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RhY2sgPSBzdGFja3Muam9pbihcIlxcbkZyb20gcHJldmlvdXM6IFwiKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fc3RhdGUgIT09IG51bGwpIHRoaXMuX3N0YWNrID0gc3RhY2s7IC8vIFN0YWNrIG1heSBiZSB1cGRhdGVkIG9uIHJlamVjdC5cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2s7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHN0YWNrX2JlaW5nX2dlbmVyYXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRpbWVvdXQ6IGZ1bmN0aW9uIChtcywgbXNnKSB7XG4gICAgICAgIHJldHVybiBtcyA8IEluZmluaXR5ID9cbiAgICAgICAgICAgIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHJlamVjdChuZXcgZXhjZXB0aW9ucy5UaW1lb3V0KG1zZykpLCBtcyk7XG4gICAgICAgICAgICAgICAgdGhpcy50aGVuKHJlc29sdmUsIHJlamVjdCkuZmluYWxseShjbGVhclRpbWVvdXQuYmluZChudWxsLCBoYW5kbGUpKTtcbiAgICAgICAgICAgIH0pIDogdGhpcztcbiAgICB9XG59KTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZylcbiAgICBzZXRQcm9wKERleGllUHJvbWlzZS5wcm90b3R5cGUsIFN5bWJvbC50b1N0cmluZ1RhZywgJ0RleGllLlByb21pc2UnKTtcblxuLy8gTm93IHRoYXQgUHJvbWlzZS5wcm90b3R5cGUgaXMgZGVmaW5lZCwgd2UgaGF2ZSBhbGwgaXQgdGFrZXMgdG8gc2V0IGdsb2JhbFBTRC5lbnYuXG4vLyBFbnZpcm9ubWVudCBnbG9iYWxzIHNuYXBzaG90dGVkIG9uIGxlYXZpbmcgZ2xvYmFsIHpvbmVcbmdsb2JhbFBTRC5lbnYgPSBzbmFwU2hvdCgpO1xuXG5mdW5jdGlvbiBMaXN0ZW5lcihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgcmVzb2x2ZSwgcmVqZWN0LCB6b25lKSB7XG4gICAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgICB0aGlzLm9uUmVqZWN0ZWQgPSB0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uUmVqZWN0ZWQgOiBudWxsO1xuICAgIHRoaXMucmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgdGhpcy5yZWplY3QgPSByZWplY3Q7XG4gICAgdGhpcy5wc2QgPSB6b25lO1xufVxuXG4vLyBQcm9taXNlIFN0YXRpYyBQcm9wZXJ0aWVzXG5wcm9wcyAoRGV4aWVQcm9taXNlLCB7XG4gICAgYWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykgLy8gU3VwcG9ydHMgaXRlcmFibGVzLCBpbXBsaWNpdCBhcmd1bWVudHMgYW5kIGFycmF5LWxpa2UuXG4gICAgICAgICAgICAubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7IC8vIEhhbmRsZSBwYXJhbGxlbGwgYXN5bmMvYXdhaXRzIFxuICAgICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMCkgcmVzb2x2ZShbXSk7XG4gICAgICAgICAgICB2YXIgcmVtYWluaW5nID0gdmFsdWVzLmxlbmd0aDtcbiAgICAgICAgICAgIHZhbHVlcy5mb3JFYWNoKChhLGkpID0+IERleGllUHJvbWlzZS5yZXNvbHZlKGEpLnRoZW4oeCA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0geDtcbiAgICAgICAgICAgICAgICBpZiAoIS0tcmVtYWluaW5nKSByZXNvbHZlKHZhbHVlcyk7XG4gICAgICAgICAgICB9LCByZWplY3QpKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBcbiAgICByZXNvbHZlOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSkgcmV0dXJuIHZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpPT57XG4gICAgICAgICAgICB2YWx1ZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcnYgPSBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCB0cnVlLCB2YWx1ZSk7XG4gICAgICAgIGxpbmtUb1ByZXZpb3VzUHJvbWlzZShydiwgY3VycmVudEZ1bGZpbGxlcik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9LFxuICAgIFxuICAgIHJlamVjdDogUHJvbWlzZVJlamVjdCxcbiAgICBcbiAgICByYWNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB2YWx1ZXMgPSBnZXRBcnJheU9mLmFwcGx5KG51bGwsIGFyZ3VtZW50cykubWFwKG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyk7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5tYXAodmFsdWUgPT4gRGV4aWVQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KSk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBQU0Q6IHtcbiAgICAgICAgZ2V0OiAoKT0+UFNELFxuICAgICAgICBzZXQ6IHZhbHVlID0+IFBTRCA9IHZhbHVlXG4gICAgfSxcblxuICAgIHRvdGFsRWNob2VzOiB7Z2V0OiAoKT0+dG90YWxFY2hvZXN9LFxuXG4gICAgLy90YXNrOiB7Z2V0OiAoKT0+dGFza30sXG4gICAgXG4gICAgbmV3UFNEOiBuZXdTY29wZSxcbiAgICBcbiAgICB1c2VQU0Q6IHVzZVBTRCxcbiAgICBcbiAgICBzY2hlZHVsZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBhc2FwLFxuICAgICAgICBzZXQ6IHZhbHVlID0+IHthc2FwID0gdmFsdWV9XG4gICAgfSxcbiAgICBcbiAgICByZWplY3Rpb25NYXBwZXI6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiByZWplY3Rpb25NYXBwZXIsXG4gICAgICAgIHNldDogdmFsdWUgPT4ge3JlamVjdGlvbk1hcHBlciA9IHZhbHVlO30gLy8gTWFwIHJlamVjdCBmYWlsdXJlc1xuICAgIH0sXG4gICAgICAgICAgICBcbiAgICBmb2xsb3c6IChmbiwgem9uZVByb3BzKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXdTY29wZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIHBzZCA9IFBTRDtcbiAgICAgICAgICAgICAgICBwc2QudW5oYW5kbGVkcyA9IFtdOyAvLyBGb3IgdW5oYW5kbGVkIHN0YW5kYXJkLSBvciAzcmQgcGFydHkgUHJvbWlzZXMuIENoZWNrZWQgYXQgcHNkLmZpbmFsaXplKClcbiAgICAgICAgICAgICAgICBwc2Qub251bmhhbmRsZWQgPSByZWplY3Q7IC8vIFRyaWdnZXJlZCBkaXJlY3RseSBvbiB1bmhhbmRsZWQgcHJvbWlzZXMgb2YgdGhpcyBsaWJyYXJ5LlxuICAgICAgICAgICAgICAgIHBzZC5maW5hbGl6ZSA9IGNhbGxCb3RoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVW5oYW5kbGVkIHN0YW5kYXJkIG9yIDNyZCBwYXJ0IHByb21pc2VzIGFyZSBwdXQgaW4gUFNELnVuaGFuZGxlZHMgYW5kXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4YW1pbmVkIHVwb24gc2NvcGUgY29tcGxldGlvbiB3aGlsZSB1bmhhbmRsZWQgcmVqZWN0aW9ucyBpbiB0aGlzIFByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCB0cmlnZ2VyIGRpcmVjdGx5IHRocm91Z2ggcHNkLm9udW5oYW5kbGVkXG4gICAgICAgICAgICAgICAgICAgIHJ1bl9hdF9lbmRfb2ZfdGhpc19vcl9uZXh0X3BoeXNpY2FsX3RpY2soKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudW5oYW5kbGVkcy5sZW5ndGggPT09IDAgPyByZXNvbHZlKCkgOiByZWplY3QodGhpcy51bmhhbmRsZWRzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgcHNkLmZpbmFsaXplKTtcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgfSwgem9uZVByb3BzLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuaWYgKE5hdGl2ZVByb21pc2UpIHtcbiAgICBpZiAoTmF0aXZlUHJvbWlzZS5hbGxTZXR0bGVkKSBzZXRQcm9wIChEZXhpZVByb21pc2UsIFwiYWxsU2V0dGxlZFwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICAgICAgICBpZiAocG9zc2libGVQcm9taXNlcy5sZW5ndGggPT09IDApIHJlc29sdmUoW10pO1xuICAgICAgICAgICAgbGV0IHJlbWFpbmluZyA9IHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKFxuICAgICAgICAgICAgICAgIHZhbHVlID0+IHJlc3VsdHNbaV0gPSB7c3RhdHVzOiBcImZ1bGZpbGxlZFwiLCB2YWx1ZX0sXG4gICAgICAgICAgICAgICAgcmVhc29uID0+IHJlc3VsdHNbaV0gPSB7c3RhdHVzOiBcInJlamVjdGVkXCIsIHJlYXNvbn0pXG4gICAgICAgICAgICAgICAgLnRoZW4oKCk9Pi0tcmVtYWluaW5nIHx8IHJlc29sdmUocmVzdWx0cykpKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKE5hdGl2ZVByb21pc2UuYW55ICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gJ3VuZGVmaW5lZCcpIHNldFByb3AoRGV4aWVQcm9taXNlLCBcImFueVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc3QgcG9zc2libGVQcm9taXNlcyA9IGdldEFycmF5T2YuYXBwbHkobnVsbCwgYXJndW1lbnRzKS5tYXAob25Qb3NzaWJsZVBhcmFsbGVsbEFzeW5jKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHBvc3NpYmxlUHJvbWlzZXMubGVuZ3RoID09PSAwKSByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKFtdKSk7XG4gICAgICAgICAgICBsZXQgcmVtYWluaW5nID0gcG9zc2libGVQcm9taXNlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBmYWlsdXJlcyA9IG5ldyBBcnJheShyZW1haW5pbmcpO1xuICAgICAgICAgICAgcG9zc2libGVQcm9taXNlcy5mb3JFYWNoKChwLCBpKSA9PiBEZXhpZVByb21pc2UucmVzb2x2ZShwKS50aGVuKFxuICAgICAgICAgICAgICAgIHZhbHVlID0+IHJlc29sdmUodmFsdWUpLFxuICAgICAgICAgICAgICAgIGZhaWx1cmUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBmYWlsdXJlc1tpXSA9IGZhaWx1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1yZW1haW5pbmcpIHJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoZmFpbHVyZXMpKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG4vKipcbiogVGFrZSBhIHBvdGVudGlhbGx5IG1pc2JlaGF2aW5nIHJlc29sdmVyIGZ1bmN0aW9uIGFuZCBtYWtlIHN1cmVcbiogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4qXG4qIE1ha2VzIG5vIGd1YXJhbnRlZXMgYWJvdXQgYXN5bmNocm9ueS5cbiovXG5mdW5jdGlvbiBleGVjdXRlUHJvbWlzZVRhc2sgKHByb21pc2UsIGZuKSB7XG4gICAgLy8gUHJvbWlzZSBSZXNvbHV0aW9uIFByb2NlZHVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcHJvbWlzZXMtYXBsdXMvcHJvbWlzZXMtc3BlYyN0aGUtcHJvbWlzZS1yZXNvbHV0aW9uLXByb2NlZHVyZVxuICAgIHRyeSB7XG4gICAgICAgIGZuKHZhbHVlID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbCkgcmV0dXJuOyAvLyBBbHJlYWR5IHNldHRsZWRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gcHJvbWlzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICAgICAgICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBleGVjdXRlUHJvbWlzZVRhc2socHJvbWlzZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIERleGllUHJvbWlzZSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fdGhlbihyZXNvbHZlLCByZWplY3QpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5fc3RhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHByb21pc2UuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZEV4ZWN1dGVUaWNrKSBlbmRNaWNyb1RpY2tTY29wZSgpO1xuICAgICAgICB9LCBoYW5kbGVSZWplY3Rpb24uYmluZChudWxsLCBwcm9taXNlKSk7IC8vIElmIEZ1bmN0aW9uLmJpbmQgaXMgbm90IHN1cHBvcnRlZC4gRXhjZXB0aW9uIGlzIGhhbmRsZWQgaW4gY2F0Y2ggYmVsb3dcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBoYW5kbGVSZWplY3Rpb24ocHJvbWlzZSwgZXgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlUmVqZWN0aW9uIChwcm9taXNlLCByZWFzb24pIHtcbiAgICByZWplY3RpbmdFcnJvcnMucHVzaChyZWFzb24pO1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSAhPT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBzaG91bGRFeGVjdXRlVGljayA9IHByb21pc2UuX2xpYiAmJiBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgcmVhc29uID0gcmVqZWN0aW9uTWFwcGVyKHJlYXNvbik7XG4gICAgcHJvbWlzZS5fc3RhdGUgPSBmYWxzZTtcbiAgICBwcm9taXNlLl92YWx1ZSA9IHJlYXNvbjtcbiAgICBkZWJ1ZyAmJiByZWFzb24gIT09IG51bGwgJiYgdHlwZW9mIHJlYXNvbiA9PT0gJ29iamVjdCcgJiYgIXJlYXNvbi5fcHJvbWlzZSAmJiB0cnlDYXRjaCgoKT0+e1xuICAgICAgICB2YXIgb3JpZ1Byb3AgPSBnZXRQcm9wZXJ0eURlc2NyaXB0b3IocmVhc29uLCBcInN0YWNrXCIpOyAgICAgICAgXG4gICAgICAgIHJlYXNvbi5fcHJvbWlzZSA9IHByb21pc2U7ICAgIFxuICAgICAgICBzZXRQcm9wKHJlYXNvbiwgXCJzdGFja1wiLCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+XG4gICAgICAgICAgICAgICAgc3RhY2tfYmVpbmdfZ2VuZXJhdGVkID9cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AgJiYgKG9yaWdQcm9wLmdldCA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWdQcm9wLmdldC5hcHBseShyZWFzb24pIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZ1Byb3AudmFsdWUpIDpcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZS5zdGFja1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGZhaWx1cmUgdG8gYSBsaXN0IG9mIHBvc3NpYmx5IHVuY2F1Z2h0IGVycm9yc1xuICAgIGFkZFBvc3NpYmx5VW5oYW5kbGVkRXJyb3IocHJvbWlzZSk7XG4gICAgcHJvcGFnYXRlQWxsTGlzdGVuZXJzKHByb21pc2UpO1xuICAgIGlmIChzaG91bGRFeGVjdXRlVGljaykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlQWxsTGlzdGVuZXJzIChwcm9taXNlKSB7XG4gICAgLy9kZWJ1ZyAmJiBsaW5rVG9QcmV2aW91c1Byb21pc2UocHJvbWlzZSk7XG4gICAgdmFyIGxpc3RlbmVycyA9IHByb21pc2UuX2xpc3RlbmVycztcbiAgICBwcm9taXNlLl9saXN0ZW5lcnMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIHByb3BhZ2F0ZVRvTGlzdGVuZXIocHJvbWlzZSwgbGlzdGVuZXJzW2ldKTtcbiAgICB9XG4gICAgdmFyIHBzZCA9IHByb21pc2UuX1BTRDtcbiAgICAtLXBzZC5yZWYgfHwgcHNkLmZpbmFsaXplKCk7IC8vIGlmIHBzZC5yZWYgcmVhY2hlcyB6ZXJvLCBjYWxsIHBzZC5maW5hbGl6ZSgpO1xuICAgIGlmIChudW1TY2hlZHVsZWRDYWxscyA9PT0gMCkge1xuICAgICAgICAvLyBJZiBudW1TY2hlZHVsZWRDYWxscyBpcyAwLCBpdCBtZWFucyB0aGF0IG91ciBzdGFjayBpcyBub3QgaW4gYSBjYWxsYmFjayBvZiBhIHNjaGVkdWxlZCBjYWxsLFxuICAgICAgICAvLyBhbmQgdGhhdCBubyBkZWZlcnJlZHMgd2hlcmUgbGlzdGVuaW5nIHRvIHRoaXMgcmVqZWN0aW9uIG9yIHN1Y2Nlc3MuXG4gICAgICAgIC8vIFNpbmNlIHRoZXJlIGlzIGEgcmlzayB0aGF0IG91ciBzdGFjayBjYW4gY29udGFpbiBhcHBsaWNhdGlvbiBjb2RlIHRoYXQgbWF5XG4gICAgICAgIC8vIGRvIHN0dWZmIGFmdGVyIHRoaXMgY29kZSBpcyBmaW5pc2hlZCB0aGF0IG1heSBnZW5lcmF0ZSBuZXcgY2FsbHMsIHdlIGNhbm5vdFxuICAgICAgICAvLyBjYWxsIGZpbmFsaXplcnMgaGVyZS5cbiAgICAgICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICAgICAgYXNhcCgoKT0+e1xuICAgICAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7IC8vIFdpbGwgZGV0ZWN0IHVuaGFuZGxlZCBlcnJvcnNcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlVG9MaXN0ZW5lcihwcm9taXNlLCBsaXN0ZW5lcikge1xuICAgIGlmIChwcm9taXNlLl9zdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwcm9taXNlLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgY2IgPSBwcm9taXNlLl9zdGF0ZSA/IGxpc3RlbmVyLm9uRnVsZmlsbGVkIDogbGlzdGVuZXIub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBMaXN0ZW5lciBkb2VzbnQgaGF2ZSBhIGxpc3RlbmVyIGZvciB0aGUgZXZlbnQgYmVpbmcgdHJpZ2dlcmVkIChvbkZ1bGZpbGxlZCBvciBvblJlamVjdCkgc28gbGV0cyBmb3J3YXJkIHRoZSBldmVudCB0byBhbnkgZXZlbnR1YWwgbGlzdGVuZXJzIG9uIHRoZSBQcm9taXNlIGluc3RhbmNlIHJldHVybmVkIGJ5IHRoZW4oKSBvciBjYXRjaCgpXG4gICAgICAgIHJldHVybiAocHJvbWlzZS5fc3RhdGUgPyBsaXN0ZW5lci5yZXNvbHZlIDogbGlzdGVuZXIucmVqZWN0KSAocHJvbWlzZS5fdmFsdWUpO1xuICAgIH1cbiAgICArK2xpc3RlbmVyLnBzZC5yZWY7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwIChjYWxsTGlzdGVuZXIsIFtjYiwgcHJvbWlzZSwgbGlzdGVuZXJdKTtcbn1cblxuZnVuY3Rpb24gY2FsbExpc3RlbmVyIChjYiwgcHJvbWlzZSwgbGlzdGVuZXIpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBTZXQgc3RhdGljIHZhcmlhYmxlIGN1cnJlbnRGdWxmaWxsZXIgdG8gdGhlIHByb21pc2UgdGhhdCBpcyBiZWluZyBmdWxsZmlsbGVkLFxuICAgICAgICAvLyBzbyB0aGF0IHdlIGNvbm5lY3QgdGhlIGNoYWluIG9mIHByb21pc2VzIChmb3IgbG9uZyBzdGFja3Mgc3VwcG9ydClcbiAgICAgICAgY3VycmVudEZ1bGZpbGxlciA9IHByb21pc2U7XG4gICAgICAgIFxuICAgICAgICAvLyBDYWxsIGNhbGxiYWNrIGFuZCByZXNvbHZlIG91ciBsaXN0ZW5lciB3aXRoIGl0J3MgcmV0dXJuIHZhbHVlLlxuICAgICAgICB2YXIgcmV0LCB2YWx1ZSA9IHByb21pc2UuX3ZhbHVlO1xuICAgICAgICAgICAgXG4gICAgICAgIGlmIChwcm9taXNlLl9zdGF0ZSkge1xuICAgICAgICAgICAgLy8gY2IgaXMgb25SZXNvbHZlZFxuICAgICAgICAgICAgcmV0ID0gY2IgKHZhbHVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNiIGlzIG9uUmVqZWN0ZWRcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMubGVuZ3RoKSByZWplY3RpbmdFcnJvcnMgPSBbXTtcbiAgICAgICAgICAgIHJldCA9IGNiKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChyZWplY3RpbmdFcnJvcnMuaW5kZXhPZih2YWx1ZSkgPT09IC0xKVxuICAgICAgICAgICAgICAgIG1hcmtFcnJvckFzSGFuZGxlZChwcm9taXNlKTsgLy8gQ2FsbGJhY2sgZGlkbnQgZG8gUHJvbWlzZS5yZWplY3QoZXJyKSBub3IgcmVqZWN0KGVycikgb250byBhbm90aGVyIHByb21pc2UuXG4gICAgICAgIH1cbiAgICAgICAgbGlzdGVuZXIucmVzb2x2ZShyZXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBpbiBjYWxsYmFjay4gUmVqZWN0IG91ciBsaXN0ZW5lci5cbiAgICAgICAgbGlzdGVuZXIucmVqZWN0KGUpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIFJlc3RvcmUgZW52IGFuZCBjdXJyZW50RnVsZmlsbGVyLlxuICAgICAgICBjdXJyZW50RnVsZmlsbGVyID0gbnVsbDtcbiAgICAgICAgaWYgKC0tbnVtU2NoZWR1bGVkQ2FsbHMgPT09IDApIGZpbmFsaXplUGh5c2ljYWxUaWNrKCk7XG4gICAgICAgIC0tbGlzdGVuZXIucHNkLnJlZiB8fCBsaXN0ZW5lci5wc2QuZmluYWxpemUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrIChwcm9taXNlLCBzdGFja3MsIGxpbWl0KSB7XG4gICAgaWYgKHN0YWNrcy5sZW5ndGggPT09IGxpbWl0KSByZXR1cm4gc3RhY2tzO1xuICAgIHZhciBzdGFjayA9IFwiXCI7XG4gICAgaWYgKHByb21pc2UuX3N0YXRlID09PSBmYWxzZSkge1xuICAgICAgICB2YXIgZmFpbHVyZSA9IHByb21pc2UuX3ZhbHVlLFxuICAgICAgICAgICAgZXJyb3JOYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTtcbiAgICAgICAgXG4gICAgICAgIGlmIChmYWlsdXJlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGVycm9yTmFtZSA9IGZhaWx1cmUubmFtZSB8fCBcIkVycm9yXCI7XG4gICAgICAgICAgICBtZXNzYWdlID0gZmFpbHVyZS5tZXNzYWdlIHx8IGZhaWx1cmU7XG4gICAgICAgICAgICBzdGFjayA9IHByZXR0eVN0YWNrKGZhaWx1cmUsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3JOYW1lID0gZmFpbHVyZTsgLy8gSWYgZXJyb3IgaXMgdW5kZWZpbmVkIG9yIG51bGwsIHNob3cgdGhhdC5cbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHN0YWNrcy5wdXNoKGVycm9yTmFtZSArIChtZXNzYWdlID8gXCI6IFwiICsgbWVzc2FnZSA6IFwiXCIpICsgc3RhY2spO1xuICAgIH1cbiAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgc3RhY2sgPSBwcmV0dHlTdGFjayhwcm9taXNlLl9zdGFja0hvbGRlciwgMik7XG4gICAgICAgIGlmIChzdGFjayAmJiBzdGFja3MuaW5kZXhPZihzdGFjaykgPT09IC0xKSBzdGFja3MucHVzaChzdGFjayk7XG4gICAgICAgIGlmIChwcm9taXNlLl9wcmV2KSBnZXRTdGFjayhwcm9taXNlLl9wcmV2LCBzdGFja3MsIGxpbWl0KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0YWNrcztcbn1cblxuZnVuY3Rpb24gbGlua1RvUHJldmlvdXNQcm9taXNlKHByb21pc2UsIHByZXYpIHtcbiAgICAvLyBTdXBwb3J0IGxvbmcgc3RhY2tzIGJ5IGxpbmtpbmcgdG8gcHJldmlvdXMgY29tcGxldGVkIHByb21pc2UuXG4gICAgdmFyIG51bVByZXYgPSBwcmV2ID8gcHJldi5fbnVtUHJldiArIDEgOiAwO1xuICAgIGlmIChudW1QcmV2IDwgTE9OR19TVEFDS1NfQ0xJUF9MSU1JVCkgeyAvLyBQcm9oaWJpdCBpbmZpbml0ZSBQcm9taXNlIGxvb3BzIHRvIGdldCBhbiBpbmZpbml0ZSBsb25nIG1lbW9yeSBjb25zdW1pbmcgXCJ0YWlsXCIuXG4gICAgICAgIHByb21pc2UuX3ByZXYgPSBwcmV2O1xuICAgICAgICBwcm9taXNlLl9udW1QcmV2ID0gbnVtUHJldjtcbiAgICB9XG59XG5cbi8qIFRoZSBjYWxsYmFjayB0byBzY2hlZHVsZSB3aXRoIHNldEltbWVkaWF0ZSgpIG9yIHNldFRpbWVvdXQoKS5cbiAgIEl0IHJ1bnMgYSB2aXJ0dWFsIG1pY3JvdGljayBhbmQgZXhlY3V0ZXMgYW55IGNhbGxiYWNrIHJlZ2lzdGVyZWQgaW4gbWljcm90aWNrUXVldWUuXG4gKi9cbmZ1bmN0aW9uIHBoeXNpY2FsVGljaygpIHtcbiAgICBiZWdpbk1pY3JvVGlja1Njb3BlKCkgJiYgZW5kTWljcm9UaWNrU2NvcGUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJlZ2luTWljcm9UaWNrU2NvcGUoKSB7XG4gICAgdmFyIHdhc1Jvb3RFeGVjID0gaXNPdXRzaWRlTWljcm9UaWNrO1xuICAgIGlzT3V0c2lkZU1pY3JvVGljayA9IGZhbHNlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gZmFsc2U7XG4gICAgcmV0dXJuIHdhc1Jvb3RFeGVjO1xufVxuXG4vKiBFeGVjdXRlcyBtaWNyby10aWNrcyB3aXRob3V0IGRvaW5nIHRyeS4uY2F0Y2guXG4gICBUaGlzIGNhbiBiZSBwb3NzaWJsZSBiZWNhdXNlIHdlIG9ubHkgdXNlIHRoaXMgaW50ZXJuYWxseSBhbmRcbiAgIHRoZSByZWdpc3RlcmVkIGZ1bmN0aW9ucyBhcmUgZXhjZXB0aW9uLXNhZmUgKHRoZXkgZG8gdHJ5Li5jYXRjaFxuICAgaW50ZXJuYWxseSBiZWZvcmUgY2FsbGluZyBhbnkgZXh0ZXJuYWwgbWV0aG9kKS4gSWYgcmVnaXN0ZXJpbmdcbiAgIGZ1bmN0aW9ucyBpbiB0aGUgbWljcm90aWNrUXVldWUgdGhhdCBhcmUgbm90IGV4Y2VwdGlvbi1zYWZlLCB0aGlzXG4gICB3b3VsZCBkZXN0cm95IHRoZSBmcmFtZXdvcmsgYW5kIG1ha2UgaXQgaW5zdGFibGUuIFNvIHdlIGRvbid0IGV4cG9ydFxuICAgb3VyIGFzYXAgbWV0aG9kLlxuKi9cbmV4cG9ydCBmdW5jdGlvbiBlbmRNaWNyb1RpY2tTY29wZSgpIHtcbiAgICB2YXIgY2FsbGJhY2tzLCBpLCBsO1xuICAgIGRvIHtcbiAgICAgICAgd2hpbGUgKG1pY3JvdGlja1F1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcyA9IG1pY3JvdGlja1F1ZXVlO1xuICAgICAgICAgICAgbWljcm90aWNrUXVldWUgPSBbXTtcbiAgICAgICAgICAgIGwgPSBjYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gY2FsbGJhY2tzW2ldO1xuICAgICAgICAgICAgICAgIGl0ZW1bMF0uYXBwbHkobnVsbCwgaXRlbVsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChtaWNyb3RpY2tRdWV1ZS5sZW5ndGggPiAwKTtcbiAgICBpc091dHNpZGVNaWNyb1RpY2sgPSB0cnVlO1xuICAgIG5lZWRzTmV3UGh5c2ljYWxUaWNrID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVQaHlzaWNhbFRpY2soKSB7XG4gICAgdmFyIHVuaGFuZGxlZEVycnMgPSB1bmhhbmRsZWRFcnJvcnM7XG4gICAgdW5oYW5kbGVkRXJyb3JzID0gW107XG4gICAgdW5oYW5kbGVkRXJycy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBwLl9QU0Qub251bmhhbmRsZWQuY2FsbChudWxsLCBwLl92YWx1ZSwgcCk7XG4gICAgfSk7XG4gICAgdmFyIGZpbmFsaXplcnMgPSB0aWNrRmluYWxpemVycy5zbGljZSgwKTsgLy8gQ2xvbmUgZmlyc3QgYmVjYXVzZSBmaW5hbGl6ZXIgbWF5IHJlbW92ZSBpdHNlbGYgZnJvbSBsaXN0LlxuICAgIHZhciBpID0gZmluYWxpemVycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpIGZpbmFsaXplcnNbLS1pXSgpOyAgICBcbn1cblxuZnVuY3Rpb24gcnVuX2F0X2VuZF9vZl90aGlzX29yX25leHRfcGh5c2ljYWxfdGljayAoZm4pIHtcbiAgICBmdW5jdGlvbiBmaW5hbGl6ZXIoKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICAgIHRpY2tGaW5hbGl6ZXJzLnNwbGljZSh0aWNrRmluYWxpemVycy5pbmRleE9mKGZpbmFsaXplciksIDEpO1xuICAgIH1cbiAgICB0aWNrRmluYWxpemVycy5wdXNoKGZpbmFsaXplcik7XG4gICAgKytudW1TY2hlZHVsZWRDYWxscztcbiAgICBhc2FwKCgpPT57XG4gICAgICAgIGlmICgtLW51bVNjaGVkdWxlZENhbGxzID09PSAwKSBmaW5hbGl6ZVBoeXNpY2FsVGljaygpO1xuICAgIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gYWRkUG9zc2libHlVbmhhbmRsZWRFcnJvcihwcm9taXNlKSB7XG4gICAgLy8gT25seSBhZGQgdG8gdW5oYW5kbGVkRXJyb3JzIGlmIG5vdCBhbHJlYWR5IHRoZXJlLiBUaGUgZmlyc3Qgb25lIHRvIGFkZCB0byB0aGlzIGxpc3RcbiAgICAvLyB3aWxsIGJlIHVwb24gdGhlIGZpcnN0IHJlamVjdGlvbiBzbyB0aGF0IHRoZSByb290IGNhdXNlIChmaXJzdCBwcm9taXNlIGluIHRoZVxuICAgIC8vIHJlamVjdGlvbiBjaGFpbikgaXMgdGhlIG9uZSBsaXN0ZWQuXG4gICAgaWYgKCF1bmhhbmRsZWRFcnJvcnMuc29tZShwID0+IHAuX3ZhbHVlID09PSBwcm9taXNlLl92YWx1ZSkpXG4gICAgICAgIHVuaGFuZGxlZEVycm9ycy5wdXNoKHByb21pc2UpO1xufVxuXG5mdW5jdGlvbiBtYXJrRXJyb3JBc0hhbmRsZWQocHJvbWlzZSkge1xuICAgIC8vIENhbGxlZCB3aGVuIGEgcmVqZWN0IGhhbmRsZWQgaXMgYWN0dWFsbHkgYmVpbmcgY2FsbGVkLlxuICAgIC8vIFNlYXJjaCBpbiB1bmhhbmRsZWRFcnJvcnMgZm9yIGFueSBwcm9taXNlIHdob3MgX3ZhbHVlIGlzIHRoaXMgcHJvbWlzZV92YWx1ZSAobGlzdFxuICAgIC8vIGNvbnRhaW5zIG9ubHkgcmVqZWN0ZWQgcHJvbWlzZXMsIGFuZCBvbmx5IG9uZSBpdGVtIHBlciBlcnJvcilcbiAgICB2YXIgaSA9IHVuaGFuZGxlZEVycm9ycy5sZW5ndGg7XG4gICAgd2hpbGUgKGkpIGlmICh1bmhhbmRsZWRFcnJvcnNbLS1pXS5fdmFsdWUgPT09IHByb21pc2UuX3ZhbHVlKSB7XG4gICAgICAgIC8vIEZvdW5kIGEgcHJvbWlzZSB0aGF0IGZhaWxlZCB3aXRoIHRoaXMgc2FtZSBlcnJvciBvYmplY3QgcG9pbnRlcixcbiAgICAgICAgLy8gUmVtb3ZlIHRoYXQgc2luY2UgdGhlcmUgaXMgYSBsaXN0ZW5lciB0aGF0IGFjdHVhbGx5IHRha2VzIGNhcmUgb2YgaXQuXG4gICAgICAgIHVuaGFuZGxlZEVycm9ycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIFByb21pc2VSZWplY3QgKHJlYXNvbikge1xuICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKElOVEVSTkFMLCBmYWxzZSwgcmVhc29uKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXAgKGZuLCBlcnJvckNhdGNoZXIpIHtcbiAgICB2YXIgcHNkID0gUFNEO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHdhc1Jvb3RFeGVjID0gYmVnaW5NaWNyb1RpY2tTY29wZSgpLFxuICAgICAgICAgICAgb3V0ZXJTY29wZSA9IFBTRDtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoVG9ab25lKHBzZCwgdHJ1ZSk7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZXJyb3JDYXRjaGVyICYmIGVycm9yQ2F0Y2hlcihlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgICAgICAgICBpZiAod2FzUm9vdEV4ZWMpIGVuZE1pY3JvVGlja1Njb3BlKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5cbi8vXG4vLyB2YXJpYWJsZXMgdXNlZCBmb3IgbmF0aXZlIGF3YWl0IHN1cHBvcnRcbi8vXG5jb25zdCB0YXNrID0geyBhd2FpdHM6IDAsIGVjaG9lczogMCwgaWQ6IDB9OyAvLyBUaGUgb25nb2luZyBtYWNyby10YXNrIHdoZW4gdXNpbmcgem9uZS1lY2hvaW5nLlxudmFyIHRhc2tDb3VudGVyID0gMDsgLy8gSUQgY291bnRlciBmb3IgbWFjcm8gdGFza3MuXG52YXIgem9uZVN0YWNrID0gW107IC8vIFN0YWNrIG9mIGxlZnQgem9uZXMgdG8gcmVzdG9yZSBhc3luY2hyb25pY2FsbHkuXG52YXIgem9uZUVjaG9lcyA9IDA7IC8vIHpvbmVFY2hvZXMgaXMgYSBtdXN0IGluIG9yZGVyIHRvIHBlcnNpc3Qgem9uZXMgYmV0d2VlbiBuYXRpdmUgYXdhaXQgZXhwcmVzc2lvbnMuXG52YXIgdG90YWxFY2hvZXMgPSAwOyAvLyBJRCBjb3VudGVyIGZvciBtaWNyby10YXNrcy4gVXNlZCB0byBkZXRlY3QgcG9zc2libGUgbmF0aXZlIGF3YWl0IGluIG91ciBQcm9taXNlLnByb3RvdHlwZS50aGVuLlxuXG5cbnZhciB6b25lX2lkX2NvdW50ZXIgPSAwO1xuZXhwb3J0IGZ1bmN0aW9uIG5ld1Njb3BlIChmbiwgcHJvcHMsIGExLCBhMikge1xuICAgIHZhciBwYXJlbnQgPSBQU0QsXG4gICAgICAgIHBzZCA9IE9iamVjdC5jcmVhdGUocGFyZW50KTtcbiAgICBwc2QucGFyZW50ID0gcGFyZW50O1xuICAgIHBzZC5yZWYgPSAwO1xuICAgIHBzZC5nbG9iYWwgPSBmYWxzZTtcbiAgICBwc2QuaWQgPSArK3pvbmVfaWRfY291bnRlcjtcbiAgICAvLyBQcmVwYXJlIGZvciBwcm9taXNlIHBhdGNoaW5nIChkb25lIGluIHVzZVBTRCk6XG4gICAgdmFyIGdsb2JhbEVudiA9IGdsb2JhbFBTRC5lbnY7XG4gICAgcHNkLmVudiA9IHBhdGNoR2xvYmFsUHJvbWlzZSA/IHtcbiAgICAgICAgUHJvbWlzZTogRGV4aWVQcm9taXNlLCAvLyBDaGFuZ2luZyB3aW5kb3cuUHJvbWlzZSBjb3VsZCBiZSBvbWl0dGVkIGZvciBDaHJvbWUgYW5kIEVkZ2UsIHdoZXJlIElEQitQcm9taXNlIHBsYXlzIHdlbGwhXG4gICAgICAgIFByb21pc2VQcm9wOiB7dmFsdWU6IERleGllUHJvbWlzZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZX0sXG4gICAgICAgIGFsbDogRGV4aWVQcm9taXNlLmFsbCxcbiAgICAgICAgcmFjZTogRGV4aWVQcm9taXNlLnJhY2UsXG4gICAgICAgIGFsbFNldHRsZWQ6IERleGllUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICBhbnk6IERleGllUHJvbWlzZS5hbnksXG4gICAgICAgIHJlc29sdmU6IERleGllUHJvbWlzZS5yZXNvbHZlLFxuICAgICAgICByZWplY3Q6IERleGllUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBnZXRQYXRjaGVkUHJvbWlzZVRoZW4gKGdsb2JhbEVudi5udGhlbiwgcHNkKSwgLy8gbmF0aXZlIHRoZW5cbiAgICAgICAgZ3RoZW46IGdldFBhdGNoZWRQcm9taXNlVGhlbiAoZ2xvYmFsRW52Lmd0aGVuLCBwc2QpIC8vIGdsb2JhbCB0aGVuXG4gICAgfSA6IHt9O1xuICAgIGlmIChwcm9wcykgZXh0ZW5kKHBzZCwgcHJvcHMpO1xuICAgIFxuICAgIC8vIHVuaGFuZGxlZHMgYW5kIG9udW5oYW5kbGVkIHNob3VsZCBub3QgYmUgc3BlY2lmaWNhbGx5IHNldCBoZXJlLlxuICAgIC8vIExlYXZlIHRoZW0gb24gcGFyZW50IHByb3RvdHlwZS5cbiAgICAvLyB1bmhhbmRsZWRzLnB1c2goZXJyKSB3aWxsIHB1c2ggdG8gcGFyZW50J3MgcHJvdG90eXBlXG4gICAgLy8gb251bmhhbmRsZWQoKSB3aWxsIGNhbGwgcGFyZW50cyBvbnVuaGFuZGxlZCAod2l0aCB0aGlzIHNjb3BlJ3MgdGhpcy1wb2ludGVyIHRob3VnaCEpXG4gICAgKytwYXJlbnQucmVmO1xuICAgIHBzZC5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLS10aGlzLnBhcmVudC5yZWYgfHwgdGhpcy5wYXJlbnQuZmluYWxpemUoKTtcbiAgICB9XG4gICAgdmFyIHJ2ID0gdXNlUFNEIChwc2QsIGZuLCBhMSwgYTIpO1xuICAgIGlmIChwc2QucmVmID09PSAwKSBwc2QuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcnY7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNhbGwgaWYgc2NvcGVGdW5jIHJldHVybnMgTmF0aXZlUHJvbWlzZVxuLy8gQWxzbyBmb3IgZWFjaCBOYXRpdmVQcm9taXNlIGluIHRoZSBhcmd1bWVudHMgdG8gUHJvbWlzZS5hbGwoKVxuZXhwb3J0IGZ1bmN0aW9uIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCkge1xuICAgIGlmICghdGFzay5pZCkgdGFzay5pZCA9ICsrdGFza0NvdW50ZXI7XG4gICAgKyt0YXNrLmF3YWl0cztcbiAgICB0YXNrLmVjaG9lcyArPSBaT05FX0VDSE9fTElNSVQ7XG4gICAgcmV0dXJuIHRhc2suaWQ7XG59XG5cbi8vIEZ1bmN0aW9uIHRvIGNhbGwgd2hlbiAndGhlbicgY2FsbHMgYmFjayBvbiBhIG5hdGl2ZSBwcm9taXNlIHdoZXJlIG9uQXdhaXRFeHBlY3RlZCgpIGhhZCBiZWVuIGNhbGxlZC5cbi8vIEFsc28gY2FsbCB0aGlzIHdoZW4gYSBuYXRpdmUgYXdhaXQgY2FsbHMgdGhlbiBtZXRob2Qgb24gYSBwcm9taXNlLiBJbiB0aGF0IGNhc2UsIGRvbid0IHN1cHBseVxuLy8gc291cmNlVGFza0lkIGJlY2F1c2Ugd2UgYWxyZWFkeSBrbm93IGl0IHJlZmVycyB0byBjdXJyZW50IHRhc2suXG5leHBvcnQgZnVuY3Rpb24gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMoKSB7XG4gICAgaWYgKCF0YXNrLmF3YWl0cykgcmV0dXJuIGZhbHNlO1xuICAgIGlmICgtLXRhc2suYXdhaXRzID09PSAwKSB0YXNrLmlkID0gMDtcbiAgICB0YXNrLmVjaG9lcyA9IHRhc2suYXdhaXRzICogWk9ORV9FQ0hPX0xJTUlUOyAvLyBXaWxsIHJlc2V0IGVjaG9lcyB0byAwIGlmIGF3YWl0cyBpcyAwLlxuICAgIHJldHVybiB0cnVlO1xufVxuXG5pZiAoKCcnK25hdGl2ZVByb21pc2VUaGVuKS5pbmRleE9mKCdbbmF0aXZlIGNvZGVdJykgPT09IC0xKSB7XG4gICAgLy8gSWYgdGhlIG5hdGl2ZSBwcm9taXNlJyBwcm90b3R5cGUgaXMgcGF0Y2hlZCwgd2UgY2Fubm90IHJlbHkgb24gem9uZSBlY2hvaW5nLlxuICAgIC8vIERpc2FibGUgdGhhdCBoZXJlOlxuICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzID0gZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMgPSBub3A7XG59XG5cbi8vIENhbGwgZnJvbSBQcm9taXNlLmFsbCgpIGFuZCBQcm9taXNlLnJhY2UoKVxuZXhwb3J0IGZ1bmN0aW9uIG9uUG9zc2libGVQYXJhbGxlbGxBc3luYyAocG9zc2libGVQcm9taXNlKSB7XG4gICAgaWYgKHRhc2suZWNob2VzICYmIHBvc3NpYmxlUHJvbWlzZSAmJiBwb3NzaWJsZVByb21pc2UuY29uc3RydWN0b3IgPT09IE5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgaW5jcmVtZW50RXhwZWN0ZWRBd2FpdHMoKTsgXG4gICAgICAgIHJldHVybiBwb3NzaWJsZVByb21pc2UudGhlbih4ID0+IHtcbiAgICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfSwgZSA9PiB7XG4gICAgICAgICAgICBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwb3NzaWJsZVByb21pc2U7XG59XG5cbmZ1bmN0aW9uIHpvbmVFbnRlckVjaG8odGFyZ2V0Wm9uZSkge1xuICAgICsrdG90YWxFY2hvZXM7XG4gICAgLy9jb25zb2xlLmxvZyhcIlRvdGFsIGVjaG9lcyBcIiwgdG90YWxFY2hvZXMpO1xuICAgIGlmICghdGFzay5lY2hvZXMgfHwgLS10YXNrLmVjaG9lcyA9PT0gMCkge1xuICAgICAgICB0YXNrLmVjaG9lcyA9IHRhc2suaWQgPSAwOyAvLyBDYW5jZWwgem9uZSBlY2hvaW5nLlxuICAgIH1cblxuICAgIHpvbmVTdGFjay5wdXNoKFBTRCk7XG4gICAgc3dpdGNoVG9ab25lKHRhcmdldFpvbmUsIHRydWUpO1xufVxuXG5mdW5jdGlvbiB6b25lTGVhdmVFY2hvKCkge1xuICAgIHZhciB6b25lID0gem9uZVN0YWNrW3pvbmVTdGFjay5sZW5ndGgtMV07XG4gICAgem9uZVN0YWNrLnBvcCgpO1xuICAgIHN3aXRjaFRvWm9uZSh6b25lLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN3aXRjaFRvWm9uZSAodGFyZ2V0Wm9uZSwgYkVudGVyaW5nWm9uZSkge1xuICAgIHZhciBjdXJyZW50Wm9uZSA9IFBTRDtcbiAgICBpZiAoYkVudGVyaW5nWm9uZSA/IHRhc2suZWNob2VzICYmICghem9uZUVjaG9lcysrIHx8IHRhcmdldFpvbmUgIT09IFBTRCkgOiB6b25lRWNob2VzICYmICghLS16b25lRWNob2VzIHx8IHRhcmdldFpvbmUgIT09IFBTRCkpIHtcbiAgICAgICAgLy8gRW50ZXIgb3IgbGVhdmUgem9uZSBhc3luY2hyb25pY2FsbHkgYXMgd2VsbCwgc28gdGhhdCB0YXNrcyBpbml0aWF0ZWQgZHVyaW5nIGN1cnJlbnQgdGlja1xuICAgICAgICAvLyB3aWxsIGJlIHN1cnJvdW5kZWQgYnkgdGhlIHpvbmUgd2hlbiB0aGV5IGFyZSBpbnZva2VkLlxuICAgICAgICBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGJFbnRlcmluZ1pvbmUgPyB6b25lRW50ZXJFY2hvLmJpbmQobnVsbCwgdGFyZ2V0Wm9uZSkgOiB6b25lTGVhdmVFY2hvKTtcbiAgICB9XG4gICAgaWYgKHRhcmdldFpvbmUgPT09IFBTRCkgcmV0dXJuO1xuXG4gICAgUFNEID0gdGFyZ2V0Wm9uZTsgLy8gVGhlIGFjdHVhbCB6b25lIHN3aXRjaCBvY2N1cnMgYXQgdGhpcyBsaW5lLlxuXG4gICAgLy8gU25hcHNob3Qgb24gZXZlcnkgbGVhdmUgZnJvbSBnbG9iYWwgem9uZS5cbiAgICBpZiAoY3VycmVudFpvbmUgPT09IGdsb2JhbFBTRCkgZ2xvYmFsUFNELmVudiA9IHNuYXBTaG90KCk7XG5cbiAgICBpZiAocGF0Y2hHbG9iYWxQcm9taXNlKSB7XG4gICAgICAgIC8vIExldCdzIHBhdGNoIHRoZSBnbG9iYWwgYW5kIG5hdGl2ZSBQcm9taXNlcyAobWF5IGJlIHNhbWUgb3IgbWF5IGJlIGRpZmZlcmVudClcbiAgICAgICAgdmFyIEdsb2JhbFByb21pc2UgPSBnbG9iYWxQU0QuZW52LlByb21pc2U7XG4gICAgICAgIC8vIFN3aWNoIGVudmlyb25tZW50cyAobWF5IGJlIFBTRC16b25lIG9yIHRoZSBnbG9iYWwgem9uZS4gQm90aCBhcHBseS4pXG4gICAgICAgIHZhciB0YXJnZXRFbnYgPSB0YXJnZXRab25lLmVudjtcblxuICAgICAgICAvLyBDaGFuZ2UgUHJvbWlzZS5wcm90b3R5cGUudGhlbiBmb3IgbmF0aXZlIGFuZCBnbG9iYWwgUHJvbWlzZSAodGhleSBNQVkgZGlmZmVyIG9uIHBvbHlmaWxsZWQgZW52aXJvbm1lbnRzLCBidXQgYm90aCBjYW4gYmUgYWNjZXNzZWQpXG4gICAgICAgIC8vIE11c3QgYmUgZG9uZSBvbiBlYWNoIHpvbmUgY2hhbmdlIGJlY2F1c2UgdGhlIHBhdGNoZWQgbWV0aG9kIGNvbnRhaW5zIHRhcmdldFpvbmUgaW4gaXRzIGNsb3N1cmUuXG4gICAgICAgIG5hdGl2ZVByb21pc2VQcm90by50aGVuID0gdGFyZ2V0RW52Lm50aGVuO1xuICAgICAgICBHbG9iYWxQcm9taXNlLnByb3RvdHlwZS50aGVuID0gdGFyZ2V0RW52Lmd0aGVuO1xuXG4gICAgICAgIGlmIChjdXJyZW50Wm9uZS5nbG9iYWwgfHwgdGFyZ2V0Wm9uZS5nbG9iYWwpIHtcbiAgICAgICAgICAgIC8vIExlYXZpbmcgb3IgZW50ZXJpbmcgZ2xvYmFsIHpvbmUuIEl0J3MgdGltZSB0byBwYXRjaCAvIHJlc3RvcmUgZ2xvYmFsIFByb21pc2UuXG5cbiAgICAgICAgICAgIC8vIFNldCB0aGlzIFByb21pc2UgdG8gd2luZG93LlByb21pc2Ugc28gdGhhdCB0cmFuc2lsZWQgYXN5bmMgZnVuY3Rpb25zIHdpbGwgd29yayBvbiBGaXJlZm94LCBTYWZhcmkgYW5kIElFLCBhcyB3ZWxsIGFzIHdpdGggWm9uZWpzIGFuZCBhbmd1bGFyLlxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF9nbG9iYWwsICdQcm9taXNlJywgdGFyZ2V0RW52LlByb21pc2VQcm9wKTtcblxuICAgICAgICAgICAgLy8gU3VwcG9ydCBQcm9taXNlLmFsbCgpIGV0YyB0byB3b3JrIGluZGV4ZWREQi1zYWZlIGFsc28gd2hlbiBwZW9wbGUgYXJlIGluY2x1ZGluZyBlczYtcHJvbWlzZSBhcyBhIG1vZHVsZSAodGhleSBtaWdodFxuICAgICAgICAgICAgLy8gbm90IGJlIGFjY2Vzc2luZyBnbG9iYWwuUHJvbWlzZSBidXQgYSBsb2NhbCByZWZlcmVuY2UgdG8gaXQpXG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLmFsbCA9IHRhcmdldEVudi5hbGw7XG4gICAgICAgICAgICBHbG9iYWxQcm9taXNlLnJhY2UgPSB0YXJnZXRFbnYucmFjZTtcbiAgICAgICAgICAgIEdsb2JhbFByb21pc2UucmVzb2x2ZSA9IHRhcmdldEVudi5yZXNvbHZlO1xuICAgICAgICAgICAgR2xvYmFsUHJvbWlzZS5yZWplY3QgPSB0YXJnZXRFbnYucmVqZWN0O1xuICAgICAgICAgICAgaWYgKHRhcmdldEVudi5hbGxTZXR0bGVkKSBHbG9iYWxQcm9taXNlLmFsbFNldHRsZWQgPSB0YXJnZXRFbnYuYWxsU2V0dGxlZDtcbiAgICAgICAgICAgIGlmICh0YXJnZXRFbnYuYW55KSBHbG9iYWxQcm9taXNlLmFueSA9IHRhcmdldEVudi5hbnk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNuYXBTaG90ICgpIHtcbiAgICB2YXIgR2xvYmFsUHJvbWlzZSA9IF9nbG9iYWwuUHJvbWlzZTtcbiAgICByZXR1cm4gcGF0Y2hHbG9iYWxQcm9taXNlID8ge1xuICAgICAgICBQcm9taXNlOiBHbG9iYWxQcm9taXNlLFxuICAgICAgICBQcm9taXNlUHJvcDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihfZ2xvYmFsLCBcIlByb21pc2VcIiksXG4gICAgICAgIGFsbDogR2xvYmFsUHJvbWlzZS5hbGwsXG4gICAgICAgIHJhY2U6IEdsb2JhbFByb21pc2UucmFjZSxcbiAgICAgICAgYWxsU2V0dGxlZDogR2xvYmFsUHJvbWlzZS5hbGxTZXR0bGVkLFxuICAgICAgICBhbnk6IEdsb2JhbFByb21pc2UuYW55LFxuICAgICAgICByZXNvbHZlOiBHbG9iYWxQcm9taXNlLnJlc29sdmUsXG4gICAgICAgIHJlamVjdDogR2xvYmFsUHJvbWlzZS5yZWplY3QsXG4gICAgICAgIG50aGVuOiBuYXRpdmVQcm9taXNlUHJvdG8udGhlbixcbiAgICAgICAgZ3RoZW46IEdsb2JhbFByb21pc2UucHJvdG90eXBlLnRoZW5cbiAgICB9IDoge307XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VQU0QgKHBzZCwgZm4sIGExLCBhMiwgYTMpIHtcbiAgICB2YXIgb3V0ZXJTY29wZSA9IFBTRDtcbiAgICB0cnkge1xuICAgICAgICBzd2l0Y2hUb1pvbmUocHNkLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGZuKGExLCBhMiwgYTMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclNjb3BlLCBmYWxzZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrIChqb2IpIHtcbiAgICAvL1xuICAgIC8vIFByZWNvbmRpdGlvbjogbmF0aXZlUHJvbWlzZVRoZW4gIT09IHVuZGVmaW5lZFxuICAgIC8vXG4gICAgbmF0aXZlUHJvbWlzZVRoZW4uY2FsbChyZXNvbHZlZE5hdGl2ZVByb21pc2UsIGpvYik7XG59XG5cbmZ1bmN0aW9uIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAoZm4sIHpvbmUsIHBvc3NpYmxlQXdhaXQsIGNsZWFudXApIHtcbiAgICByZXR1cm4gdHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nID8gZm4gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBvdXRlclpvbmUgPSBQU0Q7XG4gICAgICAgIGlmIChwb3NzaWJsZUF3YWl0KSBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgICBzd2l0Y2hUb1pvbmUoem9uZSwgdHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHN3aXRjaFRvWm9uZShvdXRlclpvbmUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChjbGVhbnVwKSBlbnF1ZXVlTmF0aXZlTWljcm9UYXNrKGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGdldFBhdGNoZWRQcm9taXNlVGhlbiAob3JpZ1RoZW4sIHpvbmUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG9uUmVzb2x2ZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIG9yaWdUaGVuLmNhbGwodGhpcyxcbiAgICAgICAgICAgIG5hdGl2ZUF3YWl0Q29tcGF0aWJsZVdyYXAob25SZXNvbHZlZCwgem9uZSksXG4gICAgICAgICAgICBuYXRpdmVBd2FpdENvbXBhdGlibGVXcmFwKG9uUmVqZWN0ZWQsIHpvbmUpKTtcbiAgICB9O1xufVxuXG5jb25zdCBVTkhBTkRMRURSRUpFQ1RJT04gPSBcInVuaGFuZGxlZHJlamVjdGlvblwiO1xuXG5mdW5jdGlvbiBnbG9iYWxFcnJvcihlcnIsIHByb21pc2UpIHtcbiAgICB2YXIgcnY7XG4gICAgdHJ5IHtcbiAgICAgICAgcnYgPSBwcm9taXNlLm9udW5jYXRjaGVkKGVycik7XG4gICAgfSBjYXRjaCAoZSkge31cbiAgICBpZiAocnYgIT09IGZhbHNlKSB0cnkge1xuICAgICAgICB2YXIgZXZlbnQsIGV2ZW50RGF0YSA9IHtwcm9taXNlOiBwcm9taXNlLCByZWFzb246IGVycn07XG4gICAgICAgIGlmIChfZ2xvYmFsLmRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgICAgICAgZXZlbnQuaW5pdEV2ZW50KFVOSEFORExFRFJFSkVDVElPTiwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgICBleHRlbmQoZXZlbnQsIGV2ZW50RGF0YSk7XG4gICAgICAgIH0gZWxzZSBpZiAoX2dsb2JhbC5DdXN0b21FdmVudCkge1xuICAgICAgICAgICAgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoVU5IQU5ETEVEUkVKRUNUSU9OLCB7ZGV0YWlsOiBldmVudERhdGF9KTtcbiAgICAgICAgICAgIGV4dGVuZChldmVudCwgZXZlbnREYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgJiYgX2dsb2JhbC5kaXNwYXRjaEV2ZW50KSB7XG4gICAgICAgICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIGlmICghX2dsb2JhbC5Qcm9taXNlUmVqZWN0aW9uRXZlbnQgJiYgX2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbilcbiAgICAgICAgICAgICAgICAvLyBObyBuYXRpdmUgc3VwcG9ydCBmb3IgUHJvbWlzZVJlamVjdGlvbkV2ZW50IGJ1dCB1c2VyIGhhcyBzZXQgd2luZG93Lm9udW5oYW5kbGVkcmVqZWN0aW9uLiBNYW51YWxseSBjYWxsIGl0LlxuICAgICAgICAgICAgICAgIHRyeSB7X2dsb2JhbC5vbnVuaGFuZGxlZHJlamVjdGlvbihldmVudCk7fSBjYXRjaCAoXykge31cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVidWcgJiYgZXZlbnQgJiYgIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgVW5oYW5kbGVkIHJlamVjdGlvbjogJHtlcnIuc3RhY2sgfHwgZXJyfWApO1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge31cbn1cblxuZXhwb3J0IHZhciByZWplY3Rpb24gPSBEZXhpZVByb21pc2UucmVqZWN0O1xuXG5leHBvcnQge0RleGllUHJvbWlzZX07XG4iLCAiaW1wb3J0IHsgUFNELCByZWplY3Rpb24sIG5ld1Njb3BlIH0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgRGV4aWVPcHRpb25zIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3RvclwiO1xuaW1wb3J0IHsgZXJybmFtZXMsIGV4Y2VwdGlvbnMgfSBmcm9tIFwiLi4vZXJyb3JzXCI7XG5pbXBvcnQgeyBub3AgfSBmcm9tIFwiLi9jaGFpbmluZy1mdW5jdGlvbnNcIjtcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSBcIi4uL2NsYXNzZXMvdHJhbnNhY3Rpb25cIjtcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vY2xhc3Nlcy9kZXhpZSc7XG5cbi8qIEdlbmVyYXRlIGEgdGVtcG9yYXJ5IHRyYW5zYWN0aW9uIHdoZW4gZGIgb3BlcmF0aW9ucyBhcmUgZG9uZSBvdXRzaWRlIGEgdHJhbnNhY3Rpb24gc2NvcGUuXG4qL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBUcmFuc2FjdGlvbiAoXG4gIGRiOiBEZXhpZSxcbiAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgZm46IChyZXNvbHZlLCByZWplY3QsIHRyYW5zOiBUcmFuc2FjdGlvbikgPT4gYW55KVxuICAvLyBMYXN0IGFyZ3VtZW50IGlzIFwid3JpdGVMb2NrZWRcIi4gQnV0IHRoaXMgZG9lc250IGFwcGx5IHRvIG9uZXNob3QgZGlyZWN0IGRiIG9wZXJhdGlvbnMsIHNvIHdlIGlnbm9yZSBpdC5cbntcbiAgaWYgKCFkYi5pZGJkYiB8fCAoIWRiLl9zdGF0ZS5vcGVuQ29tcGxldGUgJiYgKCFQU0QubGV0VGhyb3VnaCAmJiAhZGIuX3ZpcCkpKSB7XG4gICAgaWYgKGRiLl9zdGF0ZS5vcGVuQ29tcGxldGUpIHtcbiAgICAgIC8vIGRiLmlkYmRiIGlzIGZhbHN5IGJ1dCBvcGVuQ29tcGxldGUgaXMgdHJ1ZS4gTXVzdCBoYXZlIGJlZW4gYW4gZXhjZXB0aW9uIGR1cmluIG9wZW4uXG4gICAgICAvLyBEb24ndCB3YWl0IGZvciBvcGVuQ29tcGxldGUgYXMgaXQgd291bGQgbGVhZCB0byBpbmZpbml0ZSBsb29wLlxuICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZChkYi5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICB9XG4gICAgaWYgKCFkYi5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgaWYgKCFkYi5fb3B0aW9ucy5hdXRvT3BlbilcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5EYXRhYmFzZUNsb3NlZCgpKTtcbiAgICAgIGRiLm9wZW4oKS5jYXRjaChub3ApOyAvLyBPcGVuIGluIGJhY2tncm91bmQuIElmIGlmIGZhaWxzLCBpdCB3aWxsIGJlIGNhdGNoZWQgYnkgdGhlIGZpbmFsIHByb21pc2UgYW55d2F5LlxuICAgIH1cbiAgICByZXR1cm4gZGIuX3N0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oKCkgPT4gdGVtcFRyYW5zYWN0aW9uKGRiLCBtb2RlLCBzdG9yZU5hbWVzLCBmbikpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbihtb2RlLCBzdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgIHRyeSB7XG4gICAgICB0cmFucy5jcmVhdGUoKTtcbiAgICAgIGRiLl9zdGF0ZS5QUjEzOThfbWF4TG9vcCA9IDM7XG4gICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignRGV4aWU6IE5lZWQgdG8gcmVvcGVuIGRiJyk7XG4gICAgICAgIGRiLl9jbG9zZSgpO1xuICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oKCk9PnRlbXBUcmFuc2FjdGlvbihkYiwgbW9kZSwgc3RvcmVOYW1lcywgZm4pKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZWplY3Rpb24oZXgpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnMuX3Byb21pc2UobW9kZSwgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgcmV0dXJuIG5ld1Njb3BlKCgpID0+IHsgLy8gT1BUSU1JWkFUSU9OIFBPU1NJQkxFPyBuZXdTY29wZSgpIG5vdCBuZWVkZWQgYmVjYXVzZSBpdCdzIGFscmVhZHkgZG9uZSBpbiBfcHJvbWlzZS5cbiAgICAgICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgICAgIHJldHVybiBmbihyZXNvbHZlLCByZWplY3QsIHRyYW5zKTtcbiAgICAgIH0pO1xuICAgIH0pLnRoZW4ocmVzdWx0ID0+IHtcbiAgICAgIC8vIEluc3RlYWQgb2YgcmVzb2x2aW5nIHZhbHVlIGRpcmVjdGx5LCB3YWl0IHdpdGggcmVzb2x2aW5nIGl0IHVudGlsIHRyYW5zYWN0aW9uIGhhcyBjb21wbGV0ZWQuXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGRhdGEgd291bGQgbm90IGJlIGluIHRoZSBEQiBpZiByZXF1ZXN0aW5nIGl0IGluIHRoZSB0aGVuKCkgb3BlcmF0aW9uLlxuICAgICAgLy8gU3BlY2lmaWNhbGx5LCB0byBlbnN1cmUgdGhhdCB0aGUgZm9sbG93aW5nIGV4cHJlc3Npb24gd2lsbCB3b3JrOlxuICAgICAgLy9cbiAgICAgIC8vICAgZGIuZnJpZW5kcy5wdXQoe25hbWU6IFwiQXJuZVwifSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAvLyAgICAgICBkYi5mcmllbmRzLndoZXJlKFwibmFtZVwiKS5lcXVhbHMoXCJBcm5lXCIpLmNvdW50KGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAvLyAgICAgICAgICAgYXNzZXJ0IChjb3VudCA9PT0gMSk7XG4gICAgICAvLyAgICAgICB9KTtcbiAgICAgIC8vICAgfSk7XG4gICAgICAvL1xuICAgICAgcmV0dXJuIHRyYW5zLl9jb21wbGV0aW9uLnRoZW4oKCkgPT4gcmVzdWx0KTtcbiAgICB9KTsvKi5jYXRjaChlcnIgPT4geyAvLyBEb24ndCBkbyB0aGlzIGFzIG9mIG5vdy4gSWYgd291bGQgYWZmZWN0IGJ1bGstIGFuZCBtb2RpZnkgbWV0aG9kcyBpbiBhIHdheSB0aGF0IGNvdWxkIGJlIG1vcmUgaW50dWl0aXZlLiBCdXQgd2FpdCEgTWF5YmUgY2hhbmdlIGluIG5leHQgbWFqb3IuXG4gICAgICAgICAgdHJhbnMuX3JlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZXJyKTtcbiAgICAgIH0pOyovXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gXCIuLi9jbGFzc2VzL2RleGllXCI7XG5cbmV4cG9ydCBjb25zdCBERVhJRV9WRVJTSU9OID0gJ3t2ZXJzaW9ufSc7IC8vIFJlcGxhY2VkIGJ5IGJ1aWxkLXNjcmlwdC5cbmV4cG9ydCBjb25zdCBtYXhTdHJpbmcgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKDY1NTM1KTtcbmV4cG9ydCBjb25zdCBtaW5LZXkgPSAtSW5maW5pdHk7IC8vIG1pbktleSBjYW4gYmUgY29uc3RhbnQuIG1heEtleSBtdXN0IGJlIGEgcHJvcCBvZiBEZXhpZSAoX21heEtleSlcbmV4cG9ydCBjb25zdCBJTlZBTElEX0tFWV9BUkdVTUVOVCA9XG4gIFwiSW52YWxpZCBrZXkgcHJvdmlkZWQuIEtleXMgbXVzdCBiZSBvZiB0eXBlIHN0cmluZywgbnVtYmVyLCBEYXRlIG9yIEFycmF5PHN0cmluZyB8IG51bWJlciB8IERhdGU+LlwiO1xuZXhwb3J0IGNvbnN0IFNUUklOR19FWFBFQ1RFRCA9IFwiU3RyaW5nIGV4cGVjdGVkLlwiO1xuZXhwb3J0IGNvbnN0IGNvbm5lY3Rpb25zOiBEZXhpZVtdID0gW107XG5leHBvcnQgY29uc3QgaXNJRU9yRWRnZSA9XG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC8oTVNJRXxUcmlkZW50fEVkZ2UpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuZXhwb3J0IGNvbnN0IGhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcgPSBpc0lFT3JFZGdlO1xuZXhwb3J0IGNvbnN0IGhhbmdzT25EZWxldGVMYXJnZUtleVJhbmdlID0gaXNJRU9yRWRnZTtcbmV4cG9ydCBjb25zdCBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIgPSBmcmFtZSA9PiAhLyhkZXhpZVxcLmpzfGRleGllXFwubWluXFwuanMpLy50ZXN0KGZyYW1lKTtcbmV4cG9ydCBjb25zdCBEQk5BTUVTX0RCID0gJ19fZGJuYW1lcyc7XG5leHBvcnQgY29uc3QgUkVBRE9OTFkgPSAncmVhZG9ubHknO1xuZXhwb3J0IGNvbnN0IFJFQURXUklURSA9ICdyZWFkd3JpdGUnO1xuIiwgImV4cG9ydCBmdW5jdGlvbiBjb21iaW5lKGZpbHRlcjEsIGZpbHRlcjIpIHtcbiAgcmV0dXJuIGZpbHRlcjEgP1xuICAgICAgZmlsdGVyMiA/XG4gICAgICAgICAgZnVuY3Rpb24gKCkgeyByZXR1cm4gZmlsdGVyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpICYmIGZpbHRlcjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSA6XG4gICAgICAgICAgZmlsdGVyMSA6XG4gICAgICBmaWx0ZXIyO1xufVxuIiwgImltcG9ydCB7IERCQ29yZUtleVJhbmdlLCBEQkNvcmVSYW5nZVR5cGUgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcblxuZXhwb3J0IGNvbnN0IEFueVJhbmdlOiBEQkNvcmVLZXlSYW5nZSA9IHtcbiAgdHlwZTogREJDb3JlUmFuZ2VUeXBlLkFueSxcbiAgbG93ZXI6IC1JbmZpbml0eSxcbiAgbG93ZXJPcGVuOiBmYWxzZSxcbiAgdXBwZXI6IFtbXV0sXG4gIHVwcGVyT3BlbjogZmFsc2Vcbn1cblxuZXhwb3J0IGNvbnN0IE5ldmVyUmFuZ2U6IERCQ29yZUtleVJhbmdlID0ge1xuICB0eXBlOiBEQkNvcmVSYW5nZVR5cGUuTmV2ZXIsXG4gIGxvd2VyOiAtSW5maW5pdHksXG4gIGxvd2VyT3BlbjogdHJ1ZSxcbiAgdXBwZXI6IC1JbmZpbml0eSxcbiAgdXBwZXJPcGVuOiB0cnVlXG59XG4iLCAiaW1wb3J0IHsgZGVlcENsb25lLCBkZWxCeUtleVBhdGgsIGdldEJ5S2V5UGF0aCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyBUaGlzIHdvcmthcm91bmQgaXMgbmVlZGVkIHNpbmNlIG9iaiBjb3VsZCBiZSBhIGN1c3RvbS1jbGFzcyBpbnN0YW5jZSB3aXRoIGFuXG4vLyB1bmluaXRpYWxpemVkIGtleVBhdGguIFNlZSB0aGUgZm9sbG93aW5nIGNvbW1lbnQgZm9yIG1vcmUgY29udGV4dDpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2lzc3Vlcy8xMjgwI2lzc3VlY29tbWVudC04MjM1NTc4ODFcbmV4cG9ydCBmdW5jdGlvbiB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoOiBzdHJpbmcgfCBBcnJheUxpa2U8c3RyaW5nPikge1xuICAvLyBXb3JrYXJvdW5kIG9ubHkgbmVlZGVkIGZvciBwbGFpbiBub24tZG90dGVkIGtleVBhdGhzXG4gIHJldHVybiB0eXBlb2Yga2V5UGF0aCA9PT0gXCJzdHJpbmdcIiAmJiAhL1xcLi8udGVzdChrZXlQYXRoKSBcbiAgPyAob2JqOiBvYmplY3QpID0+IHtcbiAgICBpZiAob2JqW2tleVBhdGhdID09PSB1bmRlZmluZWQgJiYgKGtleVBhdGggaW4gb2JqKSkge1xuICAgICAgLy8gcHJvcGVydHkgZXhpc3RzIGJ1dCBpcyB1bmRlZmluZWQuIFRoaXMgd2lsbCBub3QgYmUgbGlrZWQgYnkgSW5kZXhlZGRiLlxuICAgICAgLy8gTmVlZCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGJlZm9yZSBhZGRpbmcgaXQgYnV0IHdlIG5lZWQgdG8gY2xvbmUgaXQgYmVmb3JlXG4gICAgICAvLyBkb2luZyB0aGF0IHRvIG5vdCBiZSBpbnRydXNpdmUuXG4gICAgICBvYmogPSBkZWVwQ2xvbmUob2JqKTtcbiAgICAgIGRlbGV0ZSBvYmpba2V5UGF0aF07XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgOiAob2JqOiBvYmplY3QpID0+IG9iajtcbn0iLCAiaW1wb3J0IHsgQnVsa0Vycm9yLCBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IFRhYmxlIGFzIElUYWJsZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1zY2hlbWEnO1xuaW1wb3J0IHsgVGFibGVIb29rcyB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZS1ob29rcyc7XG5pbXBvcnQgeyBEZXhpZVByb21pc2UgYXMgUHJvbWlzZSwgUFNELCBuZXdTY29wZSwgd3JhcCwgcmVqZWN0aW9uLCBiZWdpbk1pY3JvVGlja1Njb3BlLCBlbmRNaWNyb1RpY2tTY29wZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgdGVtcFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3RlbXAtdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgaXNBcnJheSwga2V5cywgZ2V0QnlLZXlQYXRoLCBoYXNPd24sIHNldEJ5S2V5UGF0aCwgZGVlcENsb25lLCB0cnlDYXRjaCwgYXJyYXlUb09iamVjdCwgZXh0ZW5kIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IG1heFN0cmluZyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGNvbWJpbmUgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY29tYmluZSc7XG5pbXBvcnQgeyBQcm9taXNlRXh0ZW5kZWQgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL3Byb21pc2UtZXh0ZW5kZWRcIjtcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvaW5kZXhhYmxlLXR5cGUnO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IERCQ29yZVRhYmxlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5pbXBvcnQgeyBBbnlSYW5nZSB9IGZyb20gJy4uLy4uL2RiY29yZS9rZXlyYW5nZSc7XG5pbXBvcnQgeyB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleSB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy93b3JrYXJvdW5kLXVuZGVmaW5lZC1wcmlta2V5JztcblxuLyoqIGNsYXNzIFRhYmxlXG4gKiBcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGVcbiAqL1xuZXhwb3J0IGNsYXNzIFRhYmxlIGltcGxlbWVudHMgSVRhYmxlPGFueSwgSW5kZXhhYmxlVHlwZT4ge1xuICBkYjogRGV4aWU7XG4gIF90eD86IFRyYW5zYWN0aW9uO1xuICBuYW1lOiBzdHJpbmc7XG4gIHNjaGVtYTogVGFibGVTY2hlbWE7XG4gIGhvb2s6IFRhYmxlSG9va3M7XG4gIGNvcmU6IERCQ29yZVRhYmxlO1xuXG4gIF90cmFucyhcbiAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgZm46IChpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24sIGR4VHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBQcm9taXNlTGlrZTxhbnk+IHwgdm9pZCxcbiAgICB3cml0ZUxvY2tlZD86IGJvb2xlYW4gfCBzdHJpbmcpIDogUHJvbWlzZUV4dGVuZGVkPGFueT5cbiAge1xuICAgIGNvbnN0IHRyYW5zOiBUcmFuc2FjdGlvbiA9IHRoaXMuX3R4IHx8IFBTRC50cmFucztcbiAgICBjb25zdCB0YWJsZU5hbWUgPSB0aGlzLm5hbWU7XG4gICAgXG4gICAgZnVuY3Rpb24gY2hlY2tUYWJsZUluVHJhbnNhY3Rpb24ocmVzb2x2ZSwgcmVqZWN0LCB0cmFuczogVHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmICghdHJhbnMuc2NoZW1hW3RhYmxlTmFtZV0pXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk5vdEZvdW5kKFwiVGFibGUgXCIgKyB0YWJsZU5hbWUgKyBcIiBub3QgcGFydCBvZiB0cmFuc2FjdGlvblwiKTtcbiAgICAgIHJldHVybiBmbih0cmFucy5pZGJ0cmFucywgdHJhbnMpO1xuICAgIH1cbiAgICAvLyBTdXJyb3VuZCBhbGwgaW4gYSBtaWNyb3RpY2sgc2NvcGUuXG4gICAgLy8gUmVhc29uOiBCcm93c2VycyAobW9kZXJuIFNhZmFyaSArIG9sZGVyIG90aGVycylcbiAgICAvLyBzdGlsbCBhcyBvZiAyMDE4LTEwLTEwIGhhcyBwcm9ibGVtcyBrZWVwaW5nIGEgdHJhbnNhY3Rpb25cbiAgICAvLyBhbGl2ZSBiZXR3ZWVuIG1pY3JvIHRpY2tzLiBTYWZhcmkgYmVjYXVzZSBpZiB0cmFuc2FjdGlvblxuICAgIC8vIGlzIGNyZWF0ZWQgYnV0IG5vdCB1c2VkIGluIHNhbWUgbWljcm90aWNrLCBpdCB3aWxsIGdvXG4gICAgLy8gYXdheS4gVGhhdCBzcGVjaWZpYyBpc3N1ZSBjb3VsZCBiZSBzb2x2ZWQgaW4gREJDb3JlXG4gICAgLy8gYnkgb3BlbmluZyB0aGUgdHJhbnNhY3Rpb24ganVzdCBiZWZvcmUgdXNpbmcgaXQgaW5zdGVhZC5cbiAgICAvLyBCdXQgb2xkZXIgRmlyZWZveGVzIGFuZCBJRTExICh3aXRoIFByb21pc2UgcG9seWZpbGxzKVxuICAgIC8vIHdpbGwgc3RpbGwgaGF2ZSBwcm9icy5cbiAgICAvLyBUaGUgYmVnaW5NaWNyb3RpY2tTY29wZSgpL2VuZE1pY3JvdGlja1Njb3BlKCkgd29ya3NcbiAgICAvLyBpbiBjb29wZXJhdGlvbiB3aXRoIERleGllLlByb21pc2UgdG8gb3JjaGVzdHJhdGVcbiAgICAvLyB0aGUgbWljcm8tdGlja3MgaW4gZW5kTWljcm90aWNrU2NvcGUoKSByYXRoZXIgdGhhblxuICAgIC8vIGluIG5hdGl2ZSBlbmdpbmUuXG4gICAgY29uc3Qgd2FzUm9vdEV4ZWMgPSBiZWdpbk1pY3JvVGlja1Njb3BlKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0cmFucyAmJiB0cmFucy5kYiA9PT0gdGhpcy5kYiA/XG4gICAgICAgIHRyYW5zID09PSBQU0QudHJhbnMgP1xuICAgICAgICAgIHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCkgOlxuICAgICAgICAgIG5ld1Njb3BlKCgpID0+IHRyYW5zLl9wcm9taXNlKG1vZGUsIGNoZWNrVGFibGVJblRyYW5zYWN0aW9uLCB3cml0ZUxvY2tlZCksIHsgdHJhbnM6IHRyYW5zLCB0cmFuc2xlc3M6IFBTRC50cmFuc2xlc3MgfHwgUFNEIH0pIDpcbiAgICAgICAgdGVtcFRyYW5zYWN0aW9uKHRoaXMuZGIsIG1vZGUsIFt0aGlzLm5hbWVdLCBjaGVja1RhYmxlSW5UcmFuc2FjdGlvbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh3YXNSb290RXhlYykgZW5kTWljcm9UaWNrU2NvcGUoKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGFibGUuZ2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZ2V0KClcbiAgICogXG4gICAqKi9cbiAgZ2V0KGtleU9yQ3JpdCwgY2I/KSB7XG4gICAgaWYgKGtleU9yQ3JpdCAmJiBrZXlPckNyaXQuY29uc3RydWN0b3IgPT09IE9iamVjdClcbiAgICAgIHJldHVybiB0aGlzLndoZXJlKGtleU9yQ3JpdCBhcyB7IFtrZXk6IHN0cmluZ106IEluZGV4YWJsZVR5cGUgfSkuZmlyc3QoY2IpO1xuXG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkb25seScsICh0cmFucykgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY29yZS5nZXQoe3RyYW5zLCBrZXk6IGtleU9yQ3JpdH0pXG4gICAgICAgIC50aGVuKHJlcyA9PiB0aGlzLmhvb2sucmVhZGluZy5maXJlKHJlcykpO1xuICAgIH0pLnRoZW4oY2IpO1xuICB9XG5cbiAgLyoqIFRhYmxlLndoZXJlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUud2hlcmUoKVxuICAgKiBcbiAgICoqL1xuICB3aGVyZShpbmRleE9yQ3JpdDogc3RyaW5nIHwgc3RyaW5nW10gfCB7IFtrZXk6IHN0cmluZ106IEluZGV4YWJsZVR5cGUgfSkge1xuICAgIGlmICh0eXBlb2YgaW5kZXhPckNyaXQgPT09ICdzdHJpbmcnKVxuICAgICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGluZGV4T3JDcml0KTtcbiAgICBpZiAoaXNBcnJheShpbmRleE9yQ3JpdCkpXG4gICAgICByZXR1cm4gbmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcywgYFske2luZGV4T3JDcml0LmpvaW4oJysnKX1dYCk7XG4gICAgLy8gaW5kZXhPckNyaXQgaXMgYW4gb2JqZWN0IG1hcCBvZiB7W2tleVBhdGhdOnZhbHVlfSBcbiAgICBjb25zdCBrZXlQYXRocyA9IGtleXMoaW5kZXhPckNyaXQpO1xuICAgIGlmIChrZXlQYXRocy5sZW5ndGggPT09IDEpXG4gICAgICAvLyBPbmx5IG9uZSBjcml0ZXJhLiBUaGlzIHdhcyB0aGUgZWFzeSBjYXNlOlxuICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLndoZXJlKGtleVBhdGhzWzBdKVxuICAgICAgICAuZXF1YWxzKGluZGV4T3JDcml0W2tleVBhdGhzWzBdXSk7XG5cbiAgICAvLyBNdWx0aXBsZSBjcml0ZXJpYXMuXG4gICAgLy8gTGV0J3MgdHJ5IGZpbmRpbmcgYSBjb21wb3VuZCBpbmRleCB0aGF0IG1hdGNoZXMgYWxsIGtleVBhdGhzIGluXG4gICAgLy8gYXJicml0YXJ5IG9yZGVyOlxuICAgIGNvbnN0IGNvbXBvdW5kSW5kZXggPSB0aGlzLnNjaGVtYS5pbmRleGVzLmNvbmNhdCh0aGlzLnNjaGVtYS5wcmltS2V5KS5maWx0ZXIoaXggPT4ge1xuICAgICAgaWYgKFxuICAgICAgICBpeC5jb21wb3VuZCAmJlxuICAgICAgICBrZXlQYXRocy5ldmVyeShrZXlQYXRoID0+IGl4LmtleVBhdGguaW5kZXhPZihrZXlQYXRoKSA+PSAwKSkge1xuICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxrZXlQYXRocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKGtleVBhdGhzLmluZGV4T2YoaXgua2V5UGF0aFtpXSkgPT09IC0xKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pLnNvcnQoKGEsYikgPT4gYS5rZXlQYXRoLmxlbmd0aCAtIGIua2V5UGF0aC5sZW5ndGgpWzBdO1xuICAgICAgICAgICAgXG4gICAgaWYgKGNvbXBvdW5kSW5kZXggJiYgdGhpcy5kYi5fbWF4S2V5ICE9PSBtYXhTdHJpbmcpIHtcbiAgICAgIC8vIENvb2whIFdlIGZvdW5kIHN1Y2ggY29tcG91bmQgaW5kZXhcbiAgICAgIC8vIGFuZCB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgY29tcG91bmQgaW5kZXhlcyAobWF4S2V5ICE9PSBtYXhTdHJpbmcpIVxuICAgICAgY29uc3Qga2V5UGF0aHNJblZhbGlkT3JkZXIgPSAoY29tcG91bmRJbmRleC5rZXlQYXRoIGFzIHN0cmluZ1tdKS5zbGljZSgwLCBrZXlQYXRocy5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHRoaXNcbiAgICAgICAgLndoZXJlKGtleVBhdGhzSW5WYWxpZE9yZGVyKVxuICAgICAgICAuZXF1YWxzKGtleVBhdGhzSW5WYWxpZE9yZGVyLm1hcChrcCA9PiBpbmRleE9yQ3JpdFtrcF0pKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbXBvdW5kSW5kZXggJiYgZGVidWcpIGNvbnNvbGUud2FybihcbiAgICAgIGBUaGUgcXVlcnkgJHtKU09OLnN0cmluZ2lmeShpbmRleE9yQ3JpdCl9IG9uICR7dGhpcy5uYW1lfSB3b3VsZCBiZW5lZml0IG9mIGEgYCArXG4gICAgICBgY29tcG91bmQgaW5kZXggWyR7a2V5UGF0aHMuam9pbignKycpfV1gKTtcblxuICAgIC8vIE9rLCBub3cgbGV0J3MgZmFsbGJhY2sgdG8gZmluZGluZyBhdCBsZWFzdCBvbmUgbWF0Y2hpbmcgaW5kZXhcbiAgICAvLyBhbmQgZmlsdGVyIHRoZSByZXN0LlxuICAgIGNvbnN0IHsgaWR4QnlOYW1lIH0gPSB0aGlzLnNjaGVtYTtcbiAgICBjb25zdCBpZGIgPSB0aGlzLmRiLl9kZXBzLmluZGV4ZWREQjtcblxuICAgIGZ1bmN0aW9uIGVxdWFscyAoYSwgYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGlkYi5jbXAoYSxiKSA9PT0gMDsgLy8gV29ya3Mgd2l0aCBhbGwgaW5kZXhhYmxlIHR5cGVzIGluY2x1ZGluZyBiaW5hcnkga2V5cy5cbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFtpZHgsIGZpbHRlckZ1bmN0aW9uXSA9IGtleVBhdGhzLnJlZHVjZSgoW3ByZXZJbmRleCwgcHJldkZpbHRlckZuXSwga2V5UGF0aCkgPT4ge1xuICAgICAgY29uc3QgaW5kZXggPSBpZHhCeU5hbWVba2V5UGF0aF07XG4gICAgICBjb25zdCB2YWx1ZSA9IGluZGV4T3JDcml0W2tleVBhdGhdO1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgcHJldkluZGV4IHx8IGluZGV4LCAvLyBpZHg6Oj1QaWNrIGluZGV4IG9mIGZpcnN0IG1hdGNoaW5nIGtleXBhdGhcbiAgICAgICAgcHJldkluZGV4IHx8ICFpbmRleCA/IC8vIGZpbHRlcjo6PW51bGwgaWYgbm90IG5lZWRlZCwgb3RoZXJ3aXNlIGNvbWJpbmUgZnVuY3Rpb24gZmlsdGVyXG4gICAgICAgICAgY29tYmluZShcbiAgICAgICAgICAgIHByZXZGaWx0ZXJGbixcbiAgICAgICAgICAgIGluZGV4ICYmIGluZGV4Lm11bHRpID9cbiAgICAgICAgICAgICAgeCA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IGdldEJ5S2V5UGF0aCh4LCBrZXlQYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNBcnJheShwcm9wKSAmJiBwcm9wLnNvbWUoaXRlbSA9PiBlcXVhbHModmFsdWUsIGl0ZW0pKTtcbiAgICAgICAgICAgICAgfSA6IHggPT4gZXF1YWxzKHZhbHVlLCBnZXRCeUtleVBhdGgoeCwga2V5UGF0aCkpKVxuICAgICAgICAgIDogcHJldkZpbHRlckZuXG4gICAgICBdO1xuICAgIH0sIFtudWxsLCBudWxsXSk7XG5cbiAgICByZXR1cm4gaWR4ID9cbiAgICAgIHRoaXMud2hlcmUoaWR4Lm5hbWUpLmVxdWFscyhpbmRleE9yQ3JpdFtpZHgua2V5UGF0aF0pXG4gICAgICAgIC5maWx0ZXIoZmlsdGVyRnVuY3Rpb24pIDpcbiAgICAgIGNvbXBvdW5kSW5kZXggP1xuICAgICAgICB0aGlzLmZpbHRlcihmaWx0ZXJGdW5jdGlvbikgOiAvLyBIYXMgY29tcG91bmQgYnV0IGJyb3dzZXIgYmFkLiBBbGxvdyBmaWx0ZXIuXG4gICAgICAgIHRoaXMud2hlcmUoa2V5UGF0aHMpLmVxdWFscygnJyk7IC8vIE5vIGluZGV4IGF0IGFsbC4gRmFpbCBsYXppbHkgd2l0aCBcIlthK2IrY10gaXMgbm90IGluZGV4ZWRcIlxuICB9XG5cbiAgLyoqIFRhYmxlLmZpbHRlcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmZpbHRlcigpXG4gICAqIFxuICAgKiovXG4gIGZpbHRlcihmaWx0ZXJGdW5jdGlvbjogKG9iajogYW55KSA9PiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuYW5kKGZpbHRlckZ1bmN0aW9uKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5jb3VudCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmNvdW50KClcbiAgICogXG4gICAqKi9cbiAgY291bnQodGhlblNob3J0Y3V0PzogYW55KSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuY291bnQodGhlblNob3J0Y3V0KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5vZmZzZXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5vZmZzZXQoKVxuICAgKiBcbiAgICoqL1xuICBvZmZzZXQob2Zmc2V0OiBudW1iZXIpIHtcbiAgICByZXR1cm4gdGhpcy50b0NvbGxlY3Rpb24oKS5vZmZzZXQob2Zmc2V0KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5saW1pdCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmxpbWl0KClcbiAgICogXG4gICAqKi9cbiAgbGltaXQobnVtUm93czogbnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkubGltaXQobnVtUm93cyk7XG4gIH1cblxuICAvKiogVGFibGUuZWFjaCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmVhY2goKVxuICAgKiBcbiAgICoqL1xuICBlYWNoKGNhbGxiYWNrOiAob2JqOiBhbnksIGN1cnNvcjogeyBrZXk6IEluZGV4YWJsZVR5cGUsIHByaW1hcnlLZXk6IEluZGV4YWJsZVR5cGUgfSkgPT4gYW55KSB7XG4gICAgcmV0dXJuIHRoaXMudG9Db2xsZWN0aW9uKCkuZWFjaChjYWxsYmFjayk7XG4gIH1cblxuICAvKiogVGFibGUudG9BcnJheSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLnRvQXJyYXkoKVxuICAgKiBcbiAgICoqL1xuICB0b0FycmF5KHRoZW5TaG9ydGN1dD86IGFueSkge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnRvQXJyYXkodGhlblNob3J0Y3V0KTtcbiAgfVxuXG4gIC8qKiBUYWJsZS50b0NvbGxlY3Rpb24oKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS50b0NvbGxlY3Rpb24oKVxuICAgKiBcbiAgICoqL1xuICB0b0NvbGxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmRiLkNvbGxlY3Rpb24obmV3IHRoaXMuZGIuV2hlcmVDbGF1c2UodGhpcykpO1xuICB9XG5cbiAgLyoqIFRhYmxlLm9yZGVyQnkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5vcmRlckJ5KClcbiAgICogXG4gICAqKi9cbiAgb3JkZXJCeShpbmRleDogc3RyaW5nIHwgc3RyaW5nW10pIHtcbiAgICByZXR1cm4gbmV3IHRoaXMuZGIuQ29sbGVjdGlvbihcbiAgICAgIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMsIGlzQXJyYXkoaW5kZXgpID9cbiAgICAgICAgYFske2luZGV4LmpvaW4oJysnKX1dYCA6XG4gICAgICAgIGluZGV4KSk7XG4gIH1cblxuICAvKiogVGFibGUucmV2ZXJzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLnJldmVyc2UoKVxuICAgKiBcbiAgICoqL1xuICByZXZlcnNlKCk6IENvbGxlY3Rpb24ge1xuICAgIHJldHVybiB0aGlzLnRvQ29sbGVjdGlvbigpLnJldmVyc2UoKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5tYXBUb0NsYXNzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUubWFwVG9DbGFzcygpXG4gICAqIFxuICAgKiovXG4gIG1hcFRvQ2xhc3MoY29uc3RydWN0b3I6IEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5zY2hlbWEubWFwcGVkQ2xhc3MgPSBjb25zdHJ1Y3RvcjtcbiAgICAvLyBOb3csIHN1YnNjcmliZSB0byB0aGUgd2hlbihcInJlYWRpbmdcIikgZXZlbnQgdG8gbWFrZSBhbGwgb2JqZWN0cyB0aGF0IGNvbWUgb3V0IGZyb20gdGhpcyB0YWJsZSBpbmhlcml0IGZyb20gZ2l2ZW4gY2xhc3NcbiAgICAvLyBubyBtYXR0ZXIgd2hpY2ggbWV0aG9kIHRvIHVzZSBmb3IgcmVhZGluZyAoVGFibGUuZ2V0KCkgb3IgVGFibGUud2hlcmUoLi4uKS4uLiApXG4gICAgY29uc3QgcmVhZEhvb2sgPSBvYmogPT4ge1xuICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7IC8vIE5vIHZhbGlkIG9iamVjdC4gKFZhbHVlIGlzIG51bGwpLiBSZXR1cm4gYXMgaXMuXG4gICAgICAvLyBDcmVhdGUgYSBuZXcgb2JqZWN0IHRoYXQgZGVyaXZlcyBmcm9tIGNvbnN0cnVjdG9yOlxuICAgICAgY29uc3QgcmVzID0gT2JqZWN0LmNyZWF0ZShjb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgLy8gQ2xvbmUgbWVtYmVyczpcbiAgICAgIGZvciAodmFyIG0gaW4gb2JqKSBpZiAoaGFzT3duKG9iaiwgbSkpIHRyeSB7IHJlc1ttXSA9IG9ialttXTsgfSBjYXRjaCAoXykgeyB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbiAgICBpZiAodGhpcy5zY2hlbWEucmVhZEhvb2spIHtcbiAgICAgIHRoaXMuaG9vay5yZWFkaW5nLnVuc3Vic2NyaWJlKHRoaXMuc2NoZW1hLnJlYWRIb29rKTtcbiAgICB9XG4gICAgdGhpcy5zY2hlbWEucmVhZEhvb2sgPSByZWFkSG9vaztcbiAgICB0aGlzLmhvb2soXCJyZWFkaW5nXCIsIHJlYWRIb29rKTtcbiAgICByZXR1cm4gY29uc3RydWN0b3I7XG4gIH1cblxuICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgZGVmaW5lQ2xhc3MoKSB7XG4gICAgZnVuY3Rpb24gQ2xhc3MgKGNvbnRlbnQpe1xuICAgICAgZXh0ZW5kKHRoaXMsIGNvbnRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIHRoaXMubWFwVG9DbGFzcyhDbGFzcyk7XG4gIH1cblxuICAvKiogVGFibGUuYWRkKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuYWRkKClcbiAgICogXG4gICAqKi9cbiAgYWRkKG9iaiwga2V5PzogSW5kZXhhYmxlVHlwZSk6IFByb21pc2VFeHRlbmRlZDxJbmRleGFibGVUeXBlPiB7XG4gICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKHt0cmFucywgdHlwZTogJ2FkZCcsIGtleXM6IGtleSAhPSBudWxsID8gW2tleV0gOiBudWxsLCB2YWx1ZXM6IFtvYmpUb0FkZF19KTtcbiAgICB9KS50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgLnRoZW4obGFzdFJlc3VsdCA9PiB7XG4gICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAvLyBUaGlzIHBhcnQgc2hvdWxkIGJlIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIC8vIElmIGV2ZXIgZmVlbGluZyB0b28gYmFkIGFib3V0IHRoaXMsIHBsZWFzZSB3YWl0IHRvIGEgbmV3IG1ham9yIGJlZm9yZSByZW1vdmluZyBpdCxcbiAgICAgICAgLy8gYW5kIGRvY3VtZW50IHRoZSBjaGFuZ2UgdGhvcm91Z2hseS5cbiAgICAgICAgdHJ5e3NldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO31jYXRjaChfKXt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUudXBkYXRlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUudXBkYXRlKClcbiAgICogXG4gICAqKi9cbiAgdXBkYXRlKGtleU9yT2JqZWN0LCBtb2RpZmljYXRpb25zOiB7IFtrZXlQYXRoOiBzdHJpbmddOiBhbnk7IH0gfCAoKG9iajogYW55LCBjdHg6e3ZhbHVlOiBhbnksIHByaW1LZXk6IEluZGV4YWJsZVR5cGV9KSA9PiB2b2lkIHwgYm9vbGVhbikpOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgaWYgKHR5cGVvZiBrZXlPck9iamVjdCA9PT0gJ29iamVjdCcgJiYgIWlzQXJyYXkoa2V5T3JPYmplY3QpKSB7XG4gICAgICBjb25zdCBrZXkgPSBnZXRCeUtleVBhdGgoa2V5T3JPYmplY3QsIHRoaXMuc2NoZW1hLnByaW1LZXkua2V5UGF0aCk7XG4gICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFxuICAgICAgICBcIkdpdmVuIG9iamVjdCBkb2VzIG5vdCBjb250YWluIGl0cyBwcmltYXJ5IGtleVwiKSk7XG4gICAgICAvLyBvYmplY3QgdG8gbW9kaWZ5LiBBbHNvIG1vZGlmeSBnaXZlbiBvYmplY3Qgd2l0aCB0aGUgbW9kaWZpY2F0aW9uczpcbiAgICAgIC8vIFRoaXMgcGFydCBzaG91bGQgYmUgaGVyZSBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eS5cbiAgICAgIC8vIElmIGV2ZXIgZmVlbGluZyB0b28gYmFkIGFib3V0IG11dGF0aW5nIGdpdmVuIG9iamVjdCwgcGxlYXNlIHdhaXQgdG8gYSBuZXcgbWFqb3IgYmVmb3JlIHJlbW92aW5nIGl0LFxuICAgICAgLy8gYW5kIGRvY3VtZW50IHRoZSBjaGFuZ2UgdGhvcm91Z2hseS5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgbW9kaWZpY2F0aW9ucyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAga2V5cyhtb2RpZmljYXRpb25zKS5mb3JFYWNoKGtleVBhdGggPT4ge1xuICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGtleU9yT2JqZWN0LCBrZXlQYXRoLCBtb2RpZmljYXRpb25zW2tleVBhdGhdKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBOb3cgc2luY2Ugd2Ugc3VwcG9ydCBmdW5jdGlvbiBhcmd1bWVudCwgd2Ugc2hvdWxkIGhhdmUgYSBzaW1pbGFyIGJlaGF2aW9yIGhlcmUgYXMgd2VsbFxuICAgICAgICAgIC8vIChhcyBsb25nIGFzIHdlIGRvIHRoaXMgbXV0YWJpbGl0eSBzdHVmZiBvbiB0aGUgZ2l2ZW4gb2JqZWN0KVxuICAgICAgICAgIG1vZGlmaWNhdGlvbnMoa2V5T3JPYmplY3QsIHt2YWx1ZToga2V5T3JPYmplY3QsIHByaW1LZXk6IGtleX0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIHtcbiAgICAgICAgLy8gTWF5YmUgZ2l2ZW4gb2JqZWN0IHdhcyBmcm96ZW4uXG4gICAgICAgIC8vIFRoaXMgcGFydCBpcyBub3QgZXNzZW50aWFsLiBKdXN0IG1vdmUgb24gYXMgbm90aGluZyBoYXBwZW5lZC4uLlxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMud2hlcmUoXCI6aWRcIikuZXF1YWxzKGtleSkubW9kaWZ5KG1vZGlmaWNhdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBrZXkgdG8gbW9kaWZ5XG4gICAgICByZXR1cm4gdGhpcy53aGVyZShcIjppZFwiKS5lcXVhbHMoa2V5T3JPYmplY3QpLm1vZGlmeShtb2RpZmljYXRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKiogVGFibGUucHV0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUucHV0KClcbiAgICogXG4gICAqKi9cbiAgcHV0KG9iaiwga2V5PzogSW5kZXhhYmxlVHlwZSk6IFByb21pc2VFeHRlbmRlZDxJbmRleGFibGVUeXBlPiB7XG4gICAgY29uc3Qge2F1dG8sIGtleVBhdGh9ID0gdGhpcy5zY2hlbWEucHJpbUtleTtcbiAgICBsZXQgb2JqVG9BZGQgPSBvYmo7XG4gICAgaWYgKGtleVBhdGggJiYgYXV0bykge1xuICAgICAgb2JqVG9BZGQgPSB3b3JrYXJvdW5kRm9yVW5kZWZpbmVkUHJpbUtleShrZXlQYXRoKShvYmopO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoXG4gICAgICAncmVhZHdyaXRlJyxcbiAgICAgIHRyYW5zID0+IHRoaXMuY29yZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAncHV0JywgdmFsdWVzOiBbb2JqVG9BZGRdLCBrZXlzOiBrZXkgIT0gbnVsbCA/IFtrZXldIDogbnVsbH0pKVxuICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogcmVzLmxhc3RSZXN1bHQpXG4gICAgLnRoZW4obGFzdFJlc3VsdCA9PiB7XG4gICAgICBpZiAoa2V5UGF0aCkge1xuICAgICAgICAvLyBUaGlzIHBhcnQgc2hvdWxkIGJlIGhlcmUgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkuXG4gICAgICAgIC8vIElmIGV2ZXIgZmVlbGluZyB0b28gYmFkIGFib3V0IHRoaXMsIHBsZWFzZSB3YWl0IHRvIGEgbmV3IG1ham9yIGJlZm9yZSByZW1vdmluZyBpdCxcbiAgICAgICAgLy8gYW5kIGRvY3VtZW50IHRoZSBjaGFuZ2UgdGhvcm91Z2hseS5cbiAgICAgICAgdHJ5e3NldEJ5S2V5UGF0aChvYmosIGtleVBhdGgsIGxhc3RSZXN1bHQpO31jYXRjaChfKXt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuZGVsZXRlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVGFibGUvVGFibGUuZGVsZXRlKClcbiAgICogXG4gICAqKi9cbiAgZGVsZXRlKGtleTogSW5kZXhhYmxlVHlwZSk6IFByb21pc2VFeHRlbmRlZDx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLFxuICAgICAgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBba2V5XX0pKVxuICAgIC50aGVuKHJlcyA9PiByZXMubnVtRmFpbHVyZXMgPyBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pIDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8qKiBUYWJsZS5jbGVhcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmNsZWFyKClcbiAgICogXG4gICAqKi9cbiAgY2xlYXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLFxuICAgICAgdHJhbnMgPT4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBBbnlSYW5nZX0pKVxuICAgICAgICAudGhlbihyZXMgPT4gcmVzLm51bUZhaWx1cmVzID8gUHJvbWlzZS5yZWplY3QocmVzLmZhaWx1cmVzWzBdKSA6IHVuZGVmaW5lZCk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa0dldCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtHZXQoKVxuICAgKiBcbiAgICogQHBhcmFtIGtleXMgXG4gICAqL1xuICBidWxrR2V0KGtleXM6IEluZGV4YWJsZVR5cGVbXSkge1xuICAgIHJldHVybiB0aGlzLl90cmFucygncmVhZG9ubHknLCB0cmFucyA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLmdldE1hbnkoe1xuICAgICAgICBrZXlzLFxuICAgICAgICB0cmFuc1xuICAgICAgfSkudGhlbihyZXN1bHQgPT4gcmVzdWx0Lm1hcChyZXMgPT4gdGhpcy5ob29rLnJlYWRpbmcuZmlyZShyZXMpKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKiogVGFibGUuYnVsa0FkZCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RhYmxlL1RhYmxlLmJ1bGtBZGQoKVxuICAgKiBcbiAgICoqL1xuICBidWxrQWRkKFxuICAgIG9iamVjdHM6IGFueVtdLFxuICAgIGtleXNPck9wdGlvbnM/OiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+IHwgeyBhbGxLZXlzPzogYm9vbGVhbiB9LFxuICAgIG9wdGlvbnM/OiB7IGFsbEtleXM/OiBib29sZWFuIH1cbiAgKSB7ICAgIFxuICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMgYXMgeyBhbGxLZXlzPzogYm9vbGVhbiB9KTtcbiAgICBjb25zdCB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgIGNvbnN0IHthdXRvLCBrZXlQYXRofSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrQWRkKCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG5cbiAgICAgIGNvbnN0IG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDsgLy8gUGljayBsZW5ndGggaGVyZSB0byBhbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyBsYXRlclxuICAgICAgbGV0IG9iamVjdHNUb0FkZCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgIG9iamVjdHM7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZShcbiAgICAgICAge3RyYW5zLCB0eXBlOiAnYWRkJywga2V5czoga2V5cyBhcyBJbmRleGFibGVUeXBlW10sIHZhbHVlczogb2JqZWN0c1RvQWRkLCB3YW50UmVzdWx0c31cbiAgICAgIClcbiAgICAgICAgLnRoZW4oKHtudW1GYWlsdXJlcywgcmVzdWx0cyxsYXN0UmVzdWx0LCBmYWlsdXJlc30pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFxuICAgICAgICAgICAgYCR7dGhpcy5uYW1lfS5idWxrQWRkKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtT2JqZWN0c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRhYmxlLmJ1bGtQdXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5idWxrUHV0KClcbiAgICogXG4gICAqKi9cbiAgYnVsa1B1dChcbiAgICBvYmplY3RzOiBhbnlbXSxcbiAgICBrZXlzT3JPcHRpb25zPzogUmVhZG9ubHlBcnJheTxJbmRleGFibGVUeXBlPiB8IHsgYWxsS2V5cz86IGJvb2xlYW4gfSxcbiAgICBvcHRpb25zPzogeyBhbGxLZXlzPzogYm9vbGVhbiB9XG4gICkgeyAgIFxuICAgIGNvbnN0IGtleXMgPSBBcnJheS5pc0FycmF5KGtleXNPck9wdGlvbnMpID8ga2V5c09yT3B0aW9ucyA6IHVuZGVmaW5lZDtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCAoa2V5cyA/IHVuZGVmaW5lZCA6IGtleXNPck9wdGlvbnMgYXMgeyBhbGxLZXlzPzogYm9vbGVhbiB9KTtcbiAgICBjb25zdCB3YW50UmVzdWx0cyA9IG9wdGlvbnMgPyBvcHRpb25zLmFsbEtleXMgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4gdGhpcy5fdHJhbnMoJ3JlYWR3cml0ZScsIHRyYW5zID0+IHtcbiAgICAgIGNvbnN0IHthdXRvLCBrZXlQYXRofSA9IHRoaXMuc2NoZW1hLnByaW1LZXk7XG4gICAgICBpZiAoa2V5UGF0aCAmJiBrZXlzKVxuICAgICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJidWxrUHV0KCk6IGtleXMgYXJndW1lbnQgaW52YWxpZCBvbiB0YWJsZXMgd2l0aCBpbmJvdW5kIGtleXNcIik7XG4gICAgICBpZiAoa2V5cyAmJiBrZXlzLmxlbmd0aCAhPT0gb2JqZWN0cy5sZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBvYmplY3RzIGFuZCBrZXlzIG11c3QgaGF2ZSB0aGUgc2FtZSBsZW5ndGhcIik7XG5cbiAgICAgIGNvbnN0IG51bU9iamVjdHMgPSBvYmplY3RzLmxlbmd0aDsgLy8gUGljayBsZW5ndGggaGVyZSB0byBhbGxvdyBnYXJiYWdlIGNvbGxlY3Rpb24gb2Ygb2JqZWN0cyBsYXRlclxuICAgICAgbGV0IG9iamVjdHNUb1B1dCA9IGtleVBhdGggJiYgYXV0byA/XG4gICAgICAgIG9iamVjdHMubWFwKHdvcmthcm91bmRGb3JVbmRlZmluZWRQcmltS2V5KGtleVBhdGgpKSA6XG4gICAgICAgIG9iamVjdHM7XG5cbiAgICAgIHJldHVybiB0aGlzLmNvcmUubXV0YXRlKFxuICAgICAgICB7dHJhbnMsIHR5cGU6ICdwdXQnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXSwgdmFsdWVzOiBvYmplY3RzVG9QdXQsIHdhbnRSZXN1bHRzfVxuICAgICAgKVxuICAgICAgICAudGhlbigoe251bUZhaWx1cmVzLCByZXN1bHRzLCBsYXN0UmVzdWx0LCBmYWlsdXJlc30pID0+IHtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB3YW50UmVzdWx0cyA/IHJlc3VsdHMgOiBsYXN0UmVzdWx0O1xuICAgICAgICAgIGlmIChudW1GYWlsdXJlcyA9PT0gMCkgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB0aHJvdyBuZXcgQnVsa0Vycm9yKFxuICAgICAgICAgICAgYCR7dGhpcy5uYW1lfS5idWxrUHV0KCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtT2JqZWN0c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFRhYmxlLmJ1bGtEZWxldGUoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9UYWJsZS9UYWJsZS5idWxrRGVsZXRlKClcbiAgICogXG4gICAqKi9cbiAgYnVsa0RlbGV0ZShrZXlzOiBSZWFkb25seUFycmF5PEluZGV4YWJsZVR5cGU+KTogUHJvbWlzZUV4dGVuZGVkPHZvaWQ+IHtcbiAgICBjb25zdCBudW1LZXlzID0ga2V5cy5sZW5ndGg7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zKCdyZWFkd3JpdGUnLCB0cmFucyA9PiB7XG4gICAgICByZXR1cm4gdGhpcy5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdkZWxldGUnLCBrZXlzOiBrZXlzIGFzIEluZGV4YWJsZVR5cGVbXX0pO1xuICAgIH0pLnRoZW4oKHtudW1GYWlsdXJlcywgbGFzdFJlc3VsdCwgZmFpbHVyZXN9KSA9PiB7XG4gICAgICBpZiAobnVtRmFpbHVyZXMgPT09IDApIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgdGhyb3cgbmV3IEJ1bGtFcnJvcihcbiAgICAgICAgYCR7dGhpcy5uYW1lfS5idWxrRGVsZXRlKCk6ICR7bnVtRmFpbHVyZXN9IG9mICR7bnVtS2V5c30gb3BlcmF0aW9ucyBmYWlsZWRgLCBmYWlsdXJlcyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsICJpbXBvcnQge2tleXMsIGlzQXJyYXksIGFzYXB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQge25vcCwgbWlycm9yLCByZXZlcnNlU3RvcHBhYmxlRXZlbnRDaGFpbn0gZnJvbSAnLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQge2V4Y2VwdGlvbnN9IGZyb20gJy4uL2Vycm9ycyc7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEV2ZW50cyhjdHgpIHtcbiAgICB2YXIgZXZzID0ge307XG4gICAgdmFyIHJ2ID0gZnVuY3Rpb24gKGV2ZW50TmFtZSwgc3Vic2NyaWJlcikge1xuICAgICAgICBpZiAoc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgLy8gU3Vic2NyaWJlLiBJZiBhZGRpdGlvbmFsIGFyZ3VtZW50cyB0aGFuIGp1c3QgdGhlIHN1YnNjcmliZXIgd2FzIHByb3ZpZGVkLCBmb3J3YXJkIHRoZW0gYXMgd2VsbC5cbiAgICAgICAgICAgIHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gICAgICAgICAgICB3aGlsZSAoLS1pKSBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgIGV2c1tldmVudE5hbWVdLnN1YnNjcmliZS5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGludGVyZmFjZSBhbGxvd2luZyB0byBmaXJlIG9yIHVuc3Vic2NyaWJlIGZyb20gZXZlbnRcbiAgICAgICAgICAgIHJldHVybiBldnNbZXZlbnROYW1lXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcnYuYWRkRXZlbnRUeXBlID0gYWRkO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgICAgICBhZGQoYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJ2O1xuXG4gICAgZnVuY3Rpb24gYWRkKGV2ZW50TmFtZSwgY2hhaW5GdW5jdGlvbiwgZGVmYXVsdEZ1bmN0aW9uKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnROYW1lID09PSAnb2JqZWN0JykgcmV0dXJuIGFkZENvbmZpZ3VyZWRFdmVudHMoZXZlbnROYW1lKTtcbiAgICAgICAgaWYgKCFjaGFpbkZ1bmN0aW9uKSBjaGFpbkZ1bmN0aW9uID0gcmV2ZXJzZVN0b3BwYWJsZUV2ZW50Q2hhaW47XG4gICAgICAgIGlmICghZGVmYXVsdEZ1bmN0aW9uKSBkZWZhdWx0RnVuY3Rpb24gPSBub3A7XG5cbiAgICAgICAgdmFyIGNvbnRleHQgPSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVyczogW10sXG4gICAgICAgICAgICBmaXJlOiBkZWZhdWx0RnVuY3Rpb24sXG4gICAgICAgICAgICBzdWJzY3JpYmU6IGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIGlmIChjb250ZXh0LnN1YnNjcmliZXJzLmluZGV4T2YoY2IpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjaGFpbkZ1bmN0aW9uKGNvbnRleHQuZmlyZSwgY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1bnN1YnNjcmliZTogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgY29udGV4dC5zdWJzY3JpYmVycyA9IGNvbnRleHQuc3Vic2NyaWJlcnMuZmlsdGVyKGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4gIT09IGNiOyB9KTtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmZpcmUgPSBjb250ZXh0LnN1YnNjcmliZXJzLnJlZHVjZShjaGFpbkZ1bmN0aW9uLCBkZWZhdWx0RnVuY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBldnNbZXZlbnROYW1lXSA9IHJ2W2V2ZW50TmFtZV0gPSBjb250ZXh0O1xuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRDb25maWd1cmVkRXZlbnRzKGNmZykge1xuICAgICAgICAvLyBldmVudHModGhpcywge3JlYWRpbmc6IFtmdW5jdGlvbkNoYWluLCBub3BdfSk7XG4gICAgICAgIGtleXMoY2ZnKS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gY2ZnW2V2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoaXNBcnJheShhcmdzKSkge1xuICAgICAgICAgICAgICAgIGFkZChldmVudE5hbWUsIGNmZ1tldmVudE5hbWVdWzBdLCBjZmdbZXZlbnROYW1lXVsxXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGFyZ3MgPT09ICdhc2FwJykge1xuICAgICAgICAgICAgICAgIC8vIFJhdGhlciB0aGFuIGFwcHJvYWNoaW5nIGV2ZW50IHN1YnNjcmlwdGlvbiB1c2luZyBhIGZ1bmN0aW9uYWwgYXBwcm9hY2gsIHdlIGhlcmUgZG8gaXQgaW4gYSBmb3ItbG9vcCB3aGVyZSBzdWJzY3JpYmVyIGlzIGV4ZWN1dGVkIGluIGl0cyBvd24gc3RhY2tcbiAgICAgICAgICAgICAgICAvLyBlbmFibGluZyB0aGF0IGFueSBleGNlcHRpb24gdGhhdCBvY2N1ciB3b250IGRpc3R1cmIgdGhlIGluaXRpYXRvciBhbmQgYWxzbyBub3QgbmVzY2Vzc2FyeSBiZSBjYXRjaGVkIGFuZCBmb3Jnb3R0ZW4uXG4gICAgICAgICAgICAgICAgdmFyIGNvbnRleHQgPSBhZGQoZXZlbnROYW1lLCBtaXJyb3IsIGZ1bmN0aW9uIGZpcmUoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9wdGltYXphdGlvbi1zYWZlIGNsb25pbmcgb2YgYXJndW1lbnRzIGludG8gYXJncy5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KGkpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaS0tKSBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgZWFjaCBzdWJzY3JpYmVyOlxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0LnN1YnNjcmliZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2FwKGZ1bmN0aW9uIGZpcmVFdmVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5JbnZhbGlkQXJndW1lbnQoXCJJbnZhbGlkIGV2ZW50IGNvbmZpZ1wiKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwgImltcG9ydCB7IGFycmF5VG9PYmplY3QsIGRlcml2ZSB9IGZyb20gJy4vdXRpbHMnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBtYWtlQ2xhc3NDb25zdHJ1Y3RvcjxUQ29uc3RydWN0b3I+IChwcm90b3R5cGU6IE9iamVjdCwgY29uc3RydWN0b3I6IEZ1bmN0aW9uKSB7XG4gIC8qY29uc3QgcHJvcGVydHlEZXNjcmlwdG9yTWFwID0gYXJyYXlUb09iamVjdChcbiAgICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90b3R5cGUpLFxuICAgIHByb3BLZXkgPT4gW3Byb3BLZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wS2V5KV0pO1xuXG4gIC8vIEJvdGggZGVyaXZlIGFuZCBjbG9uZSB0aGUgcHJvdG90eXBlLlxuICAvLyAgIGRlcml2ZTogU28gdGhhdCB4IGluc3RhbmNlb2YgVCByZXR1cm5zIHRydWUgd2hlbiBUIGlzIHRoZSBjbGFzcyB0ZW1wbGF0ZS5cbiAgLy8gICBjbG9uZTogT3B0aW1pemVzIG1ldGhvZCBhY2Nlc3MgYSBiaXQgKGJ1dCBhY3R1YWxseSBub3QgbmVzY2Vzc2FyeSlcbiAgY29uc3QgZGVyaXZlZFByb3RvdHlwZUNsb25lID0gT2JqZWN0LmNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnR5RGVzY3JpcHRvck1hcCk7XG4gIGRlcml2ZWRQcm90b3R5cGVDbG9uZS5jb25zdHJ1Y3RvciA9IGNvbnN0cnVjdG9yO1xuICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBkZXJpdmVkUHJvdG90eXBlQ2xvbmU7XG4gIHJldHVybiBjb25zdHJ1Y3RvciBhcyBhbnkgYXMgVENvbnN0cnVjdG9yOyovXG5cbiAgLy8gS2VlcCB0aGUgYWJvdmUgY29kZSBpbiBjYXNlIHdlIHdhbnQgdG8gY2xvbmUgQU5EIGRlcml2ZSB0aGUgcGFyZW50IHByb3RvdHlwZS5cbiAgLy8gUmVhc29uIHdvdWxkIGJlIG9wdGltaXphdGlvbiBvZiBwcm9wZXJ0eSBhY2Nlc3MuXG4gIC8vIFRoZSBjb2RlIGJlbG93IHdpbGwgb25seSBjcmVhdGUgYSBwcm90b3R5cGFsIGluaGVyaXRhbmNlIGZyb20gZ2l2ZW4gY29uc3RydWN0b3IgZnVuY3Rpb25cbiAgLy8gdG8gZ2l2ZW4gcHJvdG90eXBlLlxuICBkZXJpdmUoY29uc3RydWN0b3IpLmZyb20oe3Byb3RvdHlwZX0pO1xuICByZXR1cm4gY29uc3RydWN0b3IgYXMgYW55IGFzIFRDb25zdHJ1Y3RvcjsgIFxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgaG9va0NyZWF0aW5nQ2hhaW4sIHB1cmVGdW5jdGlvbkNoYWluLCBub3AsIG1pcnJvciwgaG9va1VwZGF0aW5nQ2hhaW4sIGhvb2tEZWxldGluZ0NoYWluIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBUYWJsZUhvb2tzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLWhvb2tzJztcbmltcG9ydCB7IFRhYmxlIH0gZnJvbSAnLi90YWJsZSc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRhYmxlQ29uc3RydWN0b3Ige1xuICBuZXcgKG5hbWU6IHN0cmluZywgdGFibGVTY2hlbWE6IFRhYmxlU2NoZW1hLCBvcHRpb25hbFRyYW5zPzogVHJhbnNhY3Rpb24pIDogVGFibGU7XG4gIHByb3RvdHlwZTogVGFibGU7XG59XG5cbi8qKiBHZW5lcmF0ZXMgYSBUYWJsZSBjb25zdHJ1Y3RvciBib3VuZCB0byBnaXZlbiBEZXhpZSBpbnN0YW5jZS5cbiAqIFxuICogVGhlIHB1cnBvc2Ugb2YgaGF2aW5nIGR5bmFtaWNhbGx5IGNyZWF0ZWQgY29uc3RydWN0b3JzLCBpcyB0byBhbGxvd1xuICogYWRkb25zIHRvIGV4dGVuZCBjbGFzc2VzIGZvciBhIGNlcnRhaW4gRGV4aWUgaW5zdGFuY2Ugd2l0aG91dCBhZmZlY3RpbmdcbiAqIG90aGVyIGRiIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IgKGRiOiBEZXhpZSkge1xuICByZXR1cm4gbWFrZUNsYXNzQ29uc3RydWN0b3I8VGFibGVDb25zdHJ1Y3Rvcj4oXG4gICAgVGFibGUucHJvdG90eXBlLFxuXG4gICAgZnVuY3Rpb24gVGFibGUgKHRoaXM6IFRhYmxlLCBuYW1lOiBzdHJpbmcsIHRhYmxlU2NoZW1hOiBUYWJsZVNjaGVtYSwgdHJhbnM/OiBUcmFuc2FjdGlvbikge1xuICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgdGhpcy5fdHggPSB0cmFucztcbiAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICB0aGlzLnNjaGVtYSA9IHRhYmxlU2NoZW1hO1xuICAgICAgdGhpcy5ob29rID0gZGIuX2FsbFRhYmxlc1tuYW1lXSA/IGRiLl9hbGxUYWJsZXNbbmFtZV0uaG9vayA6IEV2ZW50cyhudWxsLCB7XG4gICAgICAgIFwiY3JlYXRpbmdcIjogW2hvb2tDcmVhdGluZ0NoYWluLCBub3BdLFxuICAgICAgICBcInJlYWRpbmdcIjogW3B1cmVGdW5jdGlvbkNoYWluLCBtaXJyb3JdLFxuICAgICAgICBcInVwZGF0aW5nXCI6IFtob29rVXBkYXRpbmdDaGFpbiwgbm9wXSxcbiAgICAgICAgXCJkZWxldGluZ1wiOiBbaG9va0RlbGV0aW5nQ2hhaW4sIG5vcF1cbiAgICAgIH0pIGFzIFRhYmxlSG9va3M7XG4gICAgfVxuXG4gICk7XG59XG4iLCAiaW1wb3J0IHsgY29tYmluZSB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvY29tYmluZVwiO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gXCIuLi8uLi9lcnJvcnNcIjtcbmltcG9ydCB7IGhhc093biB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IHdyYXAgfSBmcm9tIFwiLi4vLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi8nO1xuaW1wb3J0IHsgREJDb3JlQ3Vyc29yLCBEQkNvcmVUYWJsZSwgREJDb3JlVHJhbnNhY3Rpb24sIERCQ29yZVRhYmxlU2NoZW1hLCBEQkNvcmVSYW5nZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGJjb3JlJztcbmltcG9ydCB7IG5vcCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuXG50eXBlIENvbGxlY3Rpb25Db250ZXh0ID0gQ29sbGVjdGlvbltcIl9jdHhcIl07XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1BsYWluS2V5UmFuZ2UgKGN0eDogQ29sbGVjdGlvbkNvbnRleHQsIGlnbm9yZUxpbWl0RmlsdGVyPzogYm9vbGVhbikge1xuICByZXR1cm4gIShjdHguZmlsdGVyIHx8IGN0eC5hbGdvcml0aG0gfHwgY3R4Lm9yKSAmJlxuICAgICAgKGlnbm9yZUxpbWl0RmlsdGVyID8gY3R4Lmp1c3RMaW1pdCA6ICFjdHgucmVwbGF5RmlsdGVyKTtcbn0gICAgXG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRGaWx0ZXIoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZm46IEZ1bmN0aW9uKSB7XG4gIGN0eC5maWx0ZXIgPSBjb21iaW5lKGN0eC5maWx0ZXIsIGZuKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZFJlcGxheUZpbHRlciAoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZmFjdG9yeSwgaXNMaW1pdEZpbHRlcj8pIHtcbiAgdmFyIGN1cnIgPSBjdHgucmVwbGF5RmlsdGVyO1xuICBjdHgucmVwbGF5RmlsdGVyID0gY3VyciA/ICgpPT5jb21iaW5lKGN1cnIoKSwgZmFjdG9yeSgpKSA6IGZhY3Rvcnk7XG4gIGN0eC5qdXN0TGltaXQgPSBpc0xpbWl0RmlsdGVyICYmICFjdXJyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkTWF0Y2hGaWx0ZXIoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgZm4pIHtcbiAgY3R4LmlzTWF0Y2ggPSBjb21iaW5lKGN0eC5pc01hdGNoLCBmbik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbmRleE9yU3RvcmUoY3R4OiBDb2xsZWN0aW9uQ29udGV4dCwgY29yZVNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEpIHtcbiAgLy8gVE9ETzogUmV3cml0ZSB0aGlzLiBObyBuZWVkIHRvIGtub3cgY3R4LmlzUHJpbUtleS4gY3R4LmluZGV4IHNob3VsZCBob2xkIHRoZSBrZXlwYXRoLlxuICAvLyBTdGlsbCwgdGhyb3cgaWYgbm90IGZvdW5kIVxuICBpZiAoY3R4LmlzUHJpbUtleSkgcmV0dXJuIGNvcmVTY2hlbWEucHJpbWFyeUtleTtcbiAgY29uc3QgaW5kZXggPSBjb3JlU2NoZW1hLmdldEluZGV4QnlLZXlQYXRoKGN0eC5pbmRleCk7XG4gIGlmICghaW5kZXgpIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIktleVBhdGggXCIgKyBjdHguaW5kZXggKyBcIiBvbiBvYmplY3Qgc3RvcmUgXCIgKyBjb3JlU2NoZW1hLm5hbWUgKyBcIiBpcyBub3QgaW5kZXhlZFwiKTtcbiAgcmV0dXJuIGluZGV4O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkN1cnNvcihjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBjb3JlVGFibGU6IERCQ29yZVRhYmxlLCB0cmFuczogREJDb3JlVHJhbnNhY3Rpb24pIHtcbiAgY29uc3QgaW5kZXggPSBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKTtcbiAgcmV0dXJuIGNvcmVUYWJsZS5vcGVuQ3Vyc29yKHtcbiAgICB0cmFucyxcbiAgICB2YWx1ZXM6ICFjdHgua2V5c09ubHksXG4gICAgcmV2ZXJzZTogY3R4LmRpciA9PT0gJ3ByZXYnLFxuICAgIHVuaXF1ZTogISFjdHgudW5pcXVlLFxuICAgIHF1ZXJ5OiB7XG4gICAgICBpbmRleCwgXG4gICAgICByYW5nZTogY3R4LnJhbmdlXG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGl0ZXIgKFxuICBjdHg6IENvbGxlY3Rpb25Db250ZXh0LCBcbiAgZm46IChpdGVtLCBjdXJzb3I6IERCQ29yZUN1cnNvciwgYWR2YW5jZTogRnVuY3Rpb24pPT52b2lkLFxuICBjb3JlVHJhbnM6IERCQ29yZVRyYW5zYWN0aW9uLFxuICBjb3JlVGFibGU6IERCQ29yZVRhYmxlKTogUHJvbWlzZTxhbnk+XG57XG4gIGNvbnN0IGZpbHRlciA9IGN0eC5yZXBsYXlGaWx0ZXIgPyBjb21iaW5lKGN0eC5maWx0ZXIsIGN0eC5yZXBsYXlGaWx0ZXIoKSkgOiBjdHguZmlsdGVyO1xuICBpZiAoIWN0eC5vcikge1xuICAgICAgcmV0dXJuIGl0ZXJhdGUoXG4gICAgICAgIG9wZW5DdXJzb3IoY3R4LCBjb3JlVGFibGUsIGNvcmVUcmFucyksXG4gICAgICAgIGNvbWJpbmUoY3R4LmFsZ29yaXRobSwgZmlsdGVyKSwgZm4sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKTtcbiAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNldCA9IHt9O1xuXG4gICAgICBjb25zdCB1bmlvbiA9IChpdGVtOiBhbnksIGN1cnNvcjogREJDb3JlQ3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGN1cnNvciwgYWR2YW5jZSwgcmVzdWx0PT5jdXJzb3Iuc3RvcChyZXN1bHQpLCBlcnIgPT4gY3Vyc29yLmZhaWwoZXJyKSkpIHtcbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlLZXkgPSBjdXJzb3IucHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgdmFyIGtleSA9ICcnICsgcHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgaWYgKGtleSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJykga2V5ID0gJycgKyBuZXcgVWludDhBcnJheShwcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgaWYgKCFoYXNPd24oc2V0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICBzZXRba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBmbihpdGVtLCBjdXJzb3IsIGFkdmFuY2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwoW1xuICAgICAgICBjdHgub3IuX2l0ZXJhdGUodW5pb24sIGNvcmVUcmFucyksXG4gICAgICAgIGl0ZXJhdGUob3BlbkN1cnNvcihjdHgsIGNvcmVUYWJsZSwgY29yZVRyYW5zKSwgY3R4LmFsZ29yaXRobSwgdW5pb24sICFjdHgua2V5c09ubHkgJiYgY3R4LnZhbHVlTWFwcGVyKVxuICAgICAgXSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXRlcmF0ZShjdXJzb3JQcm9taXNlOiBQcm9taXNlPERCQ29yZUN1cnNvcj4sIGZpbHRlciwgZm4sIHZhbHVlTWFwcGVyKTogUHJvbWlzZTxhbnk+IHtcbiAgXG4gIC8vIEFwcGx5IHZhbHVlTWFwcGVyIChob29rKCdyZWFkaW5nJykgb3IgbWFwcHBlZCBjbGFzcylcbiAgdmFyIG1hcHBlZEZuID0gdmFsdWVNYXBwZXIgPyAoeCxjLGEpID0+IGZuKHZhbHVlTWFwcGVyKHgpLGMsYSkgOiBmbjtcbiAgLy8gV3JhcCBmbiB3aXRoIFBTRCBhbmQgbWljcm90aWNrIHN0dWZmIGZyb20gUHJvbWlzZS5cbiAgdmFyIHdyYXBwZWRGbiA9IHdyYXAobWFwcGVkRm4pO1xuICBcbiAgcmV0dXJuIGN1cnNvclByb21pc2UudGhlbihjdXJzb3IgPT4ge1xuICAgIGlmIChjdXJzb3IpIHtcbiAgICAgIHJldHVybiBjdXJzb3Iuc3RhcnQoKCk9PntcbiAgICAgICAgdmFyIGMgPSAoKT0+Y3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihjdXJzb3IsIGFkdmFuY2VyID0+IGMgPSBhZHZhbmNlciwgdmFsPT57Y3Vyc29yLnN0b3AodmFsKTtjPW5vcH0sIGUgPT4ge2N1cnNvci5mYWlsKGUpO2MgPSBub3A7fSkpXG4gICAgICAgICAgd3JhcHBlZEZuKGN1cnNvci52YWx1ZSwgY3Vyc29yLCBhZHZhbmNlciA9PiBjID0gYWR2YW5jZXIpO1xuICAgICAgICBjKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuIiwgIi8vIEltcGxlbWVudGF0aW9uIG9mIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9JbmRleGVkREItMy8jY29tcGFyZS10d28ta2V5c1xuXG5pbXBvcnQgeyB0b1N0cmluZ1RhZyB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyAuLi4gd2l0aCB0aGUgYWRqdXN0bWVudCB0byByZXR1cm4gTmFOIGluc3RlYWQgb2YgdGhyb3dpbmcuXG5leHBvcnQgZnVuY3Rpb24gY21wKGE6IGFueSwgYjogYW55KTogbnVtYmVyIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB0YSA9IHR5cGUoYSk7XG4gICAgY29uc3QgdGIgPSB0eXBlKGIpO1xuICAgIGlmICh0YSAhPT0gdGIpIHtcbiAgICAgIGlmICh0YSA9PT0gJ0FycmF5JykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdBcnJheScpIHJldHVybiAtMTtcbiAgICAgIGlmICh0YSA9PT0gJ2JpbmFyeScpIHJldHVybiAxO1xuICAgICAgaWYgKHRiID09PSAnYmluYXJ5JykgcmV0dXJuIC0xO1xuICAgICAgaWYgKHRhID09PSAnc3RyaW5nJykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgPT09ICdzdHJpbmcnKSByZXR1cm4gLTE7XG4gICAgICBpZiAodGEgPT09ICdEYXRlJykgcmV0dXJuIDE7XG4gICAgICBpZiAodGIgIT09ICdEYXRlJykgcmV0dXJuIE5hTjtcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgc3dpdGNoICh0YSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ0RhdGUnOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgcmV0dXJuIGEgPiBiID8gMSA6IGEgPCBiID8gLTEgOiAwO1xuICAgICAgY2FzZSAnYmluYXJ5Jzoge1xuICAgICAgICByZXR1cm4gY29tcGFyZVVpbnQ4QXJyYXlzKGdldFVpbnQ4QXJyYXkoYSksIGdldFVpbnQ4QXJyYXkoYikpO1xuICAgICAgfVxuICAgICAgY2FzZSAnQXJyYXknOlxuICAgICAgICByZXR1cm4gY29tcGFyZUFycmF5cyhhLCBiKTtcbiAgICB9XG4gIH0gY2F0Y2gge31cbiAgcmV0dXJuIE5hTjsgLy8gUmV0dXJuIHZhbHVlIGlmIGFueSBnaXZlbiBhcmdzIGFyZSB2YWxpZCBrZXlzLlxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhOiBhbnlbXSwgYjogYW55W10pOiBudW1iZXIge1xuICBjb25zdCBhbCA9IGEubGVuZ3RoO1xuICBjb25zdCBibCA9IGIubGVuZ3RoO1xuICBjb25zdCBsID0gYWwgPCBibCA/IGFsIDogYmw7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgKytpKSB7XG4gICAgY29uc3QgcmVzID0gY21wKGFbaV0sIGJbaV0pO1xuICAgIGlmIChyZXMgIT09IDApIHJldHVybiByZXM7XG4gIH1cbiAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZVVpbnQ4QXJyYXlzKFxuICBhOiBVaW50OEFycmF5LFxuICBiOiBVaW50OEFycmF5XG4pIHtcbiAgY29uc3QgYWwgPSBhLmxlbmd0aDtcbiAgY29uc3QgYmwgPSBiLmxlbmd0aDtcbiAgY29uc3QgbCA9IGFsIDwgYmwgPyBhbCA6IGJsO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gYVtpXSA8IGJbaV0gPyAtMSA6IDE7XG4gIH1cbiAgcmV0dXJuIGFsID09PSBibCA/IDAgOiBhbCA8IGJsID8gLTEgOiAxO1xufVxuXG4vLyBJbXBsZW1lbnRhdGlvbiBvZiBodHRwczovL3d3dy53My5vcmcvVFIvSW5kZXhlZERCLTMvI2tleS10eXBlXG5mdW5jdGlvbiB0eXBlKHg6IGFueSkge1xuICBjb25zdCB0ID0gdHlwZW9mIHg7XG4gIGlmICh0ICE9PSAnb2JqZWN0JykgcmV0dXJuIHQ7XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoeCkpIHJldHVybiAnYmluYXJ5JztcbiAgY29uc3QgdHNUYWcgPSB0b1N0cmluZ1RhZyh4KTsgLy8gQ2Fubm90IHVzZSBpbnN0YW5jZW9mIGluIFNhZmFyaVxuICByZXR1cm4gdHNUYWcgPT09ICdBcnJheUJ1ZmZlcicgPyAnYmluYXJ5JyA6ICh0c1RhZyBhcyAnQXJyYXknIHwgJ0RhdGUnKTtcbn1cblxudHlwZSBCaW5hcnlUeXBlID1cbiAgfCBBcnJheUJ1ZmZlclxuICB8IERhdGFWaWV3XG4gIHwgVWludDhDbGFtcGVkQXJyYXlcbiAgfCBBcnJheUJ1ZmZlclZpZXdcbiAgfCBVaW50OEFycmF5XG4gIHwgSW50OEFycmF5XG4gIHwgVWludDE2QXJyYXlcbiAgfCBJbnQxNkFycmF5XG4gIHwgVWludDMyQXJyYXlcbiAgfCBJbnQzMkFycmF5XG4gIHwgRmxvYXQzMkFycmF5XG4gIHwgRmxvYXQ2NEFycmF5O1xuXG5mdW5jdGlvbiBnZXRVaW50OEFycmF5KGE6IEJpbmFyeVR5cGUpOiBVaW50OEFycmF5IHtcbiAgaWYgKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSByZXR1cm4gYTtcbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhhKSlcbiAgICAvLyBUeXBlZEFycmF5IG9yIERhdGFWaWV3XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGEuYnVmZmVyLCBhLmJ5dGVPZmZzZXQsIGEuYnl0ZUxlbmd0aCk7XG4gIHJldHVybiBuZXcgVWludDhBcnJheShhKTsgLy8gQXJyYXlCdWZmZXJcbn1cbiIsICJpbXBvcnQgeyBDb2xsZWN0aW9uIGFzIElDb2xsZWN0aW9uIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9jb2xsZWN0aW9uXCI7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gXCIuLi9kZXhpZVwiO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tIFwiLi4vdGFibGVcIjtcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUsIEluZGV4YWJsZVR5cGVBcnJheVJlYWRvbmx5IH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZVwiO1xuaW1wb3J0IHsgUHJvbWlzZUV4dGVuZGVkIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9wcm9taXNlLWV4dGVuZGVkXCI7XG5pbXBvcnQgeyBpdGVyLCBpc1BsYWluS2V5UmFuZ2UsIGdldEluZGV4T3JTdG9yZSwgYWRkUmVwbGF5RmlsdGVyLCBhZGRGaWx0ZXIsIGFkZE1hdGNoRmlsdGVyIH0gZnJvbSBcIi4vY29sbGVjdGlvbi1oZWxwZXJzXCI7XG5pbXBvcnQgeyByZWplY3Rpb24gfSBmcm9tIFwiLi4vLi4vaGVscGVycy9wcm9taXNlXCI7XG5pbXBvcnQgeyBjb21iaW5lIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy9jb21iaW5lXCI7XG5pbXBvcnQgeyBleHRlbmQsIGhhc093biwgZGVlcENsb25lLCBrZXlzLCBzZXRCeUtleVBhdGgsIGdldEJ5S2V5UGF0aCB9IGZyb20gXCIuLi8uLi9mdW5jdGlvbnMvdXRpbHNcIjtcbmltcG9ydCB7IE1vZGlmeUVycm9yIH0gZnJvbSBcIi4uLy4uL2Vycm9yc1wiO1xuaW1wb3J0IHsgaGFuZ3NPbkRlbGV0ZUxhcmdlS2V5UmFuZ2UgfSBmcm9tIFwiLi4vLi4vZ2xvYmFscy9jb25zdGFudHNcIjtcbmltcG9ydCB7IFRoZW5TaG9ydGN1dCB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvdGhlbi1zaG9ydGN1dFwiO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBEQkNvcmVDdXJzb3IsIERCQ29yZVRyYW5zYWN0aW9uLCBEQkNvcmVSYW5nZVR5cGUsIERCQ29yZU11dGF0ZVJlc3BvbnNlLCBEQkNvcmVLZXlSYW5nZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgY21wIH0gZnJvbSBcIi4uLy4uL2Z1bmN0aW9ucy9jbXBcIjtcblxuLyoqIGNsYXNzIENvbGxlY3Rpb25cbiAqIFxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb25cbiAqL1xuZXhwb3J0IGNsYXNzIENvbGxlY3Rpb24gaW1wbGVtZW50cyBJQ29sbGVjdGlvbiB7XG4gIGRiOiBEZXhpZTtcbiAgX2N0eDoge1xuICAgIHRhYmxlOiBUYWJsZTtcbiAgICBpbmRleD86IHN0cmluZyB8IG51bGw7XG4gICAgaXNQcmltS2V5PzogYm9vbGVhbjtcbiAgICByYW5nZTogREJDb3JlS2V5UmFuZ2U7XG4gICAga2V5c09ubHk6IGJvb2xlYW47XG4gICAgZGlyOiBcIm5leHRcIiB8IFwicHJldlwiO1xuICAgIHVuaXF1ZTogXCJcIiB8IFwidW5pcXVlXCI7XG4gICAgYWxnb3JpdGhtPzogRnVuY3Rpb24gfCBudWxsO1xuICAgIGZpbHRlcj86IEZ1bmN0aW9uIHwgbnVsbDtcbiAgICByZXBsYXlGaWx0ZXI6IEZ1bmN0aW9uIHwgbnVsbDtcbiAgICBqdXN0TGltaXQ6IGJvb2xlYW47IC8vIFRydWUgaWYgYSByZXBsYXlGaWx0ZXIgaXMganVzdCBhIGZpbHRlciB0aGF0IHBlcmZvcm1zIGEgXCJsaW1pdFwiIG9wZXJhdGlvbiAob3Igbm9uZSBhdCBhbGwpXG4gICAgaXNNYXRjaDogRnVuY3Rpb24gfCBudWxsO1xuICAgIG9mZnNldDogbnVtYmVyLFxuICAgIGxpbWl0OiBudW1iZXIsXG4gICAgZXJyb3I6IGFueSwgLy8gSWYgc2V0LCBhbnkgcHJvbWlzZSBtdXN0IGJlIHJlamVjdGVkIHdpdGggdGhpcyBlcnJvclxuICAgIG9yOiBDb2xsZWN0aW9uLFxuICAgIHZhbHVlTWFwcGVyOiAoYW55KSA9PiBhbnlcbiAgfVxuICBcbiAgX29uZGlyZWN0aW9uY2hhbmdlPzogRnVuY3Rpb247XG5cbiAgX3JlYWQ8VD4oZm46IChpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24sIGR4VHJhbnM6IFRyYW5zYWN0aW9uKSA9PiBQcm9taXNlTGlrZTxUPiwgY2I/KTogUHJvbWlzZUV4dGVuZGVkPFQ+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkb25seScsIGZuKS50aGVuKGNiKTtcbiAgfVxuXG4gIF93cml0ZTxUPihmbjogKGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbiwgZHhUcmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPFQ+KTogUHJvbWlzZUV4dGVuZGVkPFQ+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIHJldHVybiBjdHguZXJyb3IgP1xuICAgICAgY3R4LnRhYmxlLl90cmFucyhudWxsLCByZWplY3Rpb24uYmluZChudWxsLCBjdHguZXJyb3IpKSA6XG4gICAgICBjdHgudGFibGUuX3RyYW5zKCdyZWFkd3JpdGUnLCBmbiwgXCJsb2NrZWRcIik7IC8vIFdoZW4gZG9pbmcgd3JpdGUgb3BlcmF0aW9ucyBvbiBjb2xsZWN0aW9ucywgYWx3YXlzIGxvY2sgdGhlIG9wZXJhdGlvbiBzbyB0aGF0IHVwY29taW5nIG9wZXJhdGlvbnMgZ2V0cyBxdWV1ZWQuXG4gIH1cblxuICBfYWRkQWxnb3JpdGhtKGZuKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjdHguYWxnb3JpdGhtID0gY29tYmluZShjdHguYWxnb3JpdGhtLCBmbik7XG4gIH1cblxuICBfaXRlcmF0ZShcbiAgICBmbjogKGl0ZW0sIGN1cnNvcjogREJDb3JlQ3Vyc29yLCBhZHZhbmNlOiBGdW5jdGlvbikgPT4gdm9pZCxcbiAgICBjb3JlVHJhbnM6IERCQ29yZVRyYW5zYWN0aW9uKSA6IFByb21pc2U8YW55PlxuICB7XG4gICAgcmV0dXJuIGl0ZXIodGhpcy5fY3R4LCBmbiwgY29yZVRyYW5zLCB0aGlzLl9jdHgudGFibGUuY29yZSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5jbG9uZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5jbG9uZSgpXG4gICAqIFxuICAgKiovXG4gIGNsb25lKHByb3BzPykge1xuICAgIHZhciBydiA9IE9iamVjdC5jcmVhdGUodGhpcy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpLFxuICAgICAgY3R4ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLl9jdHgpO1xuICAgIGlmIChwcm9wcykgZXh0ZW5kKGN0eCwgcHJvcHMpO1xuICAgIHJ2Ll9jdHggPSBjdHg7XG4gICAgcmV0dXJuIHJ2O1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ucmF3KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnJhdygpXG4gICAqIFxuICAgKiovXG4gIHJhdygpIHtcbiAgICB0aGlzLl9jdHgudmFsdWVNYXBwZXIgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZWFjaCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5lYWNoKClcbiAgICogXG4gICAqKi9cbiAgZWFjaChmbjogKG9iaiwgY3Vyc29yOiBEQkNvcmVDdXJzb3IpID0+IGFueSk6IFByb21pc2VFeHRlbmRlZDx2b2lkPiB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcblxuICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IGl0ZXIoY3R4LCBmbiwgdHJhbnMsIGN0eC50YWJsZS5jb3JlKSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5jb3VudCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5jb3VudCgpXG4gICAqIFxuICAgKiovXG4gIGNvdW50KGNiPykge1xuICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IHtcbiAgICAgIGNvbnN0IGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgIGNvbnN0IGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgaWYgKGlzUGxhaW5LZXlSYW5nZShjdHgsIHRydWUpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBwbGFpbiBrZXkgcmFuZ2UuIFdlIGNhbiB1c2UgdGhlIGNvdW50KCkgbWV0aG9kIGlmIHRoZSBpbmRleC5cbiAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5jb3VudCh7XG4gICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGluZGV4OiBnZXRJbmRleE9yU3RvcmUoY3R4LCBjb3JlVGFibGUuc2NoZW1hKSxcbiAgICAgICAgICAgIHJhbmdlOiBjdHgucmFuZ2VcbiAgICAgICAgICB9XG4gICAgICAgIH0pLnRoZW4oY291bnQgPT4gTWF0aC5taW4oY291bnQsIGN0eC5saW1pdCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQWxnb3JpdGhtcywgZmlsdGVycyBvciBleHByZXNzaW9ucyBhcmUgYXBwbGllZC4gTmVlZCB0byBjb3VudCBtYW51YWxseS5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIGl0ZXIoY3R4LCAoKSA9PiB7ICsrY291bnQ7IHJldHVybiBmYWxzZTsgfSwgdHJhbnMsIGNvcmVUYWJsZSlcbiAgICAgICAgLnRoZW4oKCk9PmNvdW50KTtcbiAgICAgIH1cbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnNvcnRCeSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5zb3J0QnkoKVxuICAgKiBcbiAgICoqL1xuICBzb3J0Qnkoa2V5UGF0aDogc3RyaW5nKTogUHJvbWlzZUV4dGVuZGVkPGFueVtdPjtcbiAgc29ydEJ5PFI+KGtleVBhdGg6IHN0cmluZywgdGhlblNob3J0Y3V0OiBUaGVuU2hvcnRjdXQ8YW55W10sIFI+KSA6IFByb21pc2VFeHRlbmRlZDxSPjtcbiAgc29ydEJ5KGtleVBhdGg6IHN0cmluZywgY2I/OiBUaGVuU2hvcnRjdXQ8YW55W10sIGFueT4pIHtcbiAgICBjb25zdCBwYXJ0cyA9IGtleVBhdGguc3BsaXQoJy4nKS5yZXZlcnNlKCksXG4gICAgICBsYXN0UGFydCA9IHBhcnRzWzBdLFxuICAgICAgbGFzdEluZGV4ID0gcGFydHMubGVuZ3RoIC0gMTtcbiAgICBmdW5jdGlvbiBnZXR2YWwob2JqLCBpKSB7XG4gICAgICBpZiAoaSkgcmV0dXJuIGdldHZhbChvYmpbcGFydHNbaV1dLCBpIC0gMSk7XG4gICAgICByZXR1cm4gb2JqW2xhc3RQYXJ0XTtcbiAgICB9XG4gICAgdmFyIG9yZGVyID0gdGhpcy5fY3R4LmRpciA9PT0gXCJuZXh0XCIgPyAxIDogLTE7XG5cbiAgICBmdW5jdGlvbiBzb3J0ZXIoYSwgYikge1xuICAgICAgdmFyIGFWYWwgPSBnZXR2YWwoYSwgbGFzdEluZGV4KSxcbiAgICAgICAgYlZhbCA9IGdldHZhbChiLCBsYXN0SW5kZXgpO1xuICAgICAgcmV0dXJuIGFWYWwgPCBiVmFsID8gLW9yZGVyIDogYVZhbCA+IGJWYWwgPyBvcmRlciA6IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRvQXJyYXkoZnVuY3Rpb24gKGEpIHtcbiAgICAgIHJldHVybiBhLnNvcnQoc29ydGVyKTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnRvQXJyYXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24udG9BcnJheSgpXG4gICAqIFxuICAgKiovXG4gIHRvQXJyYXkoY2I/KTogUHJvbWlzZUV4dGVuZGVkPGFueVtdPiB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWQodHJhbnMgPT4ge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgICAvLyBTcGVjaWFsIG9wdGltYXRpb24gaWYgd2UgY291bGQgdXNlIElEQk9iamVjdFN0b3JlLmdldEFsbCgpIG9yXG4gICAgICAgIC8vIElEQktleVJhbmdlLmdldEFsbCgpOlxuICAgICAgICBjb25zdCB7dmFsdWVNYXBwZXJ9ID0gY3R4O1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4T3JTdG9yZShjdHgsIGN0eC50YWJsZS5jb3JlLnNjaGVtYSk7XG4gICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5xdWVyeSh7XG4gICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgbGltaXQ6IGN0eC5saW1pdCxcbiAgICAgICAgICB2YWx1ZXM6IHRydWUsXG4gICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoe3Jlc3VsdH0pID0+IHZhbHVlTWFwcGVyID8gcmVzdWx0Lm1hcCh2YWx1ZU1hcHBlcikgOiByZXN1bHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gR2V0dGluZyBhcnJheSB0aHJvdWdoIGEgY3Vyc29yLlxuICAgICAgICBjb25zdCBhID0gW107XG4gICAgICAgIHJldHVybiBpdGVyKGN0eCwgaXRlbSA9PiBhLnB1c2goaXRlbSksIHRyYW5zLCBjdHgudGFibGUuY29yZSkudGhlbigoKT0+YSk7XG4gICAgICB9XG4gICAgfSwgY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ub2Zmc2V0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLm9mZnNldCgpXG4gICAqIFxuICAgKiovXG4gIG9mZnNldChvZmZzZXQ6IG51bWJlcikgOiBDb2xsZWN0aW9ue1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgaWYgKG9mZnNldCA8PSAwKSByZXR1cm4gdGhpcztcbiAgICBjdHgub2Zmc2V0ICs9IG9mZnNldDsgLy8gRm9yIGNvdW50KClcbiAgICBpZiAoaXNQbGFpbktleVJhbmdlKGN0eCkpIHtcbiAgICAgIGFkZFJlcGxheUZpbHRlcihjdHgsICgpID0+IHtcbiAgICAgICAgdmFyIG9mZnNldExlZnQgPSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiAoY3Vyc29yLCBhZHZhbmNlKSA9PiB7XG4gICAgICAgICAgaWYgKG9mZnNldExlZnQgPT09IDApIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmIChvZmZzZXRMZWZ0ID09PSAxKSB7IC0tb2Zmc2V0TGVmdDsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgYWR2YW5jZSgoKSA9PiB7XG4gICAgICAgICAgICBjdXJzb3IuYWR2YW5jZShvZmZzZXRMZWZ0KTtcbiAgICAgICAgICAgIG9mZnNldExlZnQgPSAwO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRSZXBsYXlGaWx0ZXIoY3R4LCAoKSA9PiB7XG4gICAgICAgIHZhciBvZmZzZXRMZWZ0ID0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gKCkgPT4gKC0tb2Zmc2V0TGVmdCA8IDApO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24ubGltaXQoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ubGltaXQoKVxuICAgKiBcbiAgICoqL1xuICBsaW1pdChudW1Sb3dzOiBudW1iZXIpIDogQ29sbGVjdGlvbiB7XG4gICAgdGhpcy5fY3R4LmxpbWl0ID0gTWF0aC5taW4odGhpcy5fY3R4LmxpbWl0LCBudW1Sb3dzKTsgLy8gRm9yIGNvdW50KClcbiAgICBhZGRSZXBsYXlGaWx0ZXIodGhpcy5fY3R4LCAoKSA9PiB7XG4gICAgICB2YXIgcm93c0xlZnQgPSBudW1Sb3dzO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpIHtcbiAgICAgICAgaWYgKC0tcm93c0xlZnQgPD0gMCkgYWR2YW5jZShyZXNvbHZlKTsgLy8gU3RvcCBhZnRlciB0aGlzIGl0ZW0gaGFzIGJlZW4gaW5jbHVkZWRcbiAgICAgICAgcmV0dXJuIHJvd3NMZWZ0ID49IDA7IC8vIElmIG51bVJvd3MgaXMgYWxyZWFkeSBiZWxvdyAwLCByZXR1cm4gZmFsc2UgYmVjYXVzZSB0aGVuIDAgd2FzIHBhc3NlZCB0byBudW1Sb3dzIGluaXRpYWxseS4gT3RoZXJ3aXNlIHdlIHdvdWxkbnQgY29tZSBoZXJlLlxuICAgICAgfTtcbiAgICB9LCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnVudGlsKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnVudGlsKClcbiAgICogXG4gICAqKi9cbiAgdW50aWwoZmlsdGVyRnVuY3Rpb246ICh4KSA9PiBib29sZWFuLCBiSW5jbHVkZVN0b3BFbnRyeT8pIHtcbiAgICBhZGRGaWx0ZXIodGhpcy5fY3R4LCBmdW5jdGlvbiAoY3Vyc29yLCBhZHZhbmNlLCByZXNvbHZlKSB7XG4gICAgICBpZiAoZmlsdGVyRnVuY3Rpb24oY3Vyc29yLnZhbHVlKSkge1xuICAgICAgICBhZHZhbmNlKHJlc29sdmUpO1xuICAgICAgICByZXR1cm4gYkluY2x1ZGVTdG9wRW50cnk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmZpcnN0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmZpcnN0KClcbiAgICogXG4gICAqKi9cbiAgZmlyc3QoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMubGltaXQoMSkudG9BcnJheShmdW5jdGlvbiAoYSkgeyByZXR1cm4gYVswXTsgfSkudGhlbihjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5sYXN0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmxhc3QoKVxuICAgKiBcbiAgICoqL1xuICBsYXN0KGNiPykge1xuICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maXJzdChjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5maWx0ZXIoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZmlsdGVyKClcbiAgICogXG4gICAqKi9cbiAgZmlsdGVyKGZpbHRlckZ1bmN0aW9uOiAoeCkgPT4gYm9vbGVhbik6IENvbGxlY3Rpb24ge1xuICAgIC8vLyA8cGFyYW0gbmFtZT1cImpzRnVuY3Rpb25GaWx0ZXJcIiB0eXBlPVwiRnVuY3Rpb25cIj5mdW5jdGlvbih2YWwpe3JldHVybiB0cnVlL2ZhbHNlfTwvcGFyYW0+XG4gICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcikge1xuICAgICAgcmV0dXJuIGZpbHRlckZ1bmN0aW9uKGN1cnNvci52YWx1ZSk7XG4gICAgfSk7XG4gICAgLy8gbWF0Y2ggZmlsdGVycyBub3QgdXNlZCBpbiBEZXhpZS5qcyBidXQgY2FuIGJlIHVzZWQgYnkgM3JkIHBhcnQgbGlicmFyaWVzIHRvIHRlc3QgYVxuICAgIC8vIGNvbGxlY3Rpb24gZm9yIGEgbWF0Y2ggd2l0aG91dCBxdWVyeWluZyBEQi4gVXNlZCBieSBEZXhpZS5PYnNlcnZhYmxlLlxuICAgIGFkZE1hdGNoRmlsdGVyKHRoaXMuX2N0eCwgZmlsdGVyRnVuY3Rpb24pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uYW5kKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmFuZCgpXG4gICAqIFxuICAgKiovXG4gIGFuZChmaWx0ZXI6ICh4KSA9PiBib29sZWFuKSB7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKGZpbHRlcik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5vcigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5vcigpXG4gICAqIFxuICAgKiovXG4gIG9yKGluZGV4TmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzLmRiLldoZXJlQ2xhdXNlKHRoaXMuX2N0eC50YWJsZSwgaW5kZXhOYW1lLCB0aGlzKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnJldmVyc2UoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ucmV2ZXJzZSgpXG4gICAqIFxuICAgKiovXG4gIHJldmVyc2UoKSB7XG4gICAgdGhpcy5fY3R4LmRpciA9ICh0aGlzLl9jdHguZGlyID09PSBcInByZXZcIiA/IFwibmV4dFwiIDogXCJwcmV2XCIpO1xuICAgIGlmICh0aGlzLl9vbmRpcmVjdGlvbmNoYW5nZSkgdGhpcy5fb25kaXJlY3Rpb25jaGFuZ2UodGhpcy5fY3R4LmRpcik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5kZXNjKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmRlc2MoKVxuICAgKiBcbiAgICoqL1xuICBkZXNjKCkge1xuICAgIHJldHVybiB0aGlzLnJldmVyc2UoKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmVhY2hLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZWFjaEtleSgpXG4gICAqIFxuICAgKiovXG4gIGVhY2hLZXkoY2I/KSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICBjdHgua2V5c09ubHkgPSAhY3R4LmlzTWF0Y2g7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAodmFsLCBjdXJzb3IpIHsgY2IoY3Vyc29yLmtleSwgY3Vyc29yKTsgfSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5lYWNoVW5pcXVlS2V5KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmVhY2hVbmlxdWVLZXkoKVxuICAgKiBcbiAgICoqL1xuICBlYWNoVW5pcXVlS2V5KGNiPykge1xuICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgIHJldHVybiB0aGlzLmVhY2hLZXkoY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZWFjaFByaW1hcnlLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZWFjaFByaW1hcnlLZXkoKVxuICAgKiBcbiAgICoqL1xuICBlYWNoUHJpbWFyeUtleShjYj8pIHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGN0eC5rZXlzT25seSA9ICFjdHguaXNNYXRjaDtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICh2YWwsIGN1cnNvcikgeyBjYihjdXJzb3IucHJpbWFyeUtleSwgY3Vyc29yKTsgfSk7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi5rZXlzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmtleXMoKVxuICAgKiBcbiAgICoqL1xuICBrZXlzKGNiPykge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHg7XG4gICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgIHZhciBhID0gW107XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICBhLnB1c2goY3Vyc29yLmtleSk7XG4gICAgfSkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYTtcbiAgICB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLnByaW1hcnlLZXlzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnByaW1hcnlLZXlzKClcbiAgICogXG4gICAqKi9cbiAgcHJpbWFyeUtleXMoY2I/KSA6IFByb21pc2VFeHRlbmRlZDxJbmRleGFibGVUeXBlW10+IHtcbiAgICB2YXIgY3R4ID0gdGhpcy5fY3R4O1xuICAgIGlmIChjdHguZGlyID09PSAnbmV4dCcgJiYgaXNQbGFpbktleVJhbmdlKGN0eCwgdHJ1ZSkgJiYgY3R4LmxpbWl0ID4gMCkge1xuICAgICAgLy8gU3BlY2lhbCBvcHRpbWF0aW9uIGlmIHdlIGNvdWxkIHVzZSBJREJPYmplY3RTdG9yZS5nZXRBbGxLZXlzKCkgb3JcbiAgICAgIC8vIElEQktleVJhbmdlLmdldEFsbEtleXMoKTpcbiAgICAgIHJldHVybiB0aGlzLl9yZWFkKHRyYW5zID0+IHtcbiAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXhPclN0b3JlKGN0eCwgY3R4LnRhYmxlLmNvcmUuc2NoZW1hKTtcbiAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLnF1ZXJ5KHtcbiAgICAgICAgICB0cmFucyxcbiAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgIGxpbWl0OiBjdHgubGltaXQsXG4gICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgIH19KTtcbiAgICAgIH0pLnRoZW4oKHtyZXN1bHR9KT0+cmVzdWx0KS50aGVuKGNiKTtcbiAgICB9XG4gICAgY3R4LmtleXNPbmx5ID0gIWN0eC5pc01hdGNoO1xuICAgIHZhciBhID0gW107XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoaXRlbSwgY3Vyc29yKSB7XG4gICAgICBhLnB1c2goY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfSkudGhlbihjYik7XG4gIH1cblxuICAvKiogQ29sbGVjdGlvbi51bmlxdWVLZXlzKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLnVuaXF1ZUtleXMoKVxuICAgKiBcbiAgICoqL1xuICB1bmlxdWVLZXlzKGNiPykge1xuICAgIHRoaXMuX2N0eC51bmlxdWUgPSBcInVuaXF1ZVwiO1xuICAgIHJldHVybiB0aGlzLmtleXMoY2IpO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZmlyc3RLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24uZmlyc3RLZXkoKVxuICAgKiBcbiAgICoqL1xuICBmaXJzdEtleShjYj8pIHtcbiAgICByZXR1cm4gdGhpcy5saW1pdCgxKS5rZXlzKGZ1bmN0aW9uIChhKSB7IHJldHVybiBhWzBdOyB9KS50aGVuKGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmxhc3RLZXkoKVxuICAgKiBcbiAgICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9Db2xsZWN0aW9uL0NvbGxlY3Rpb24ubGFzdEtleSgpXG4gICAqIFxuICAgKiovXG4gIGxhc3RLZXkoY2I/KSB7XG4gICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpLmZpcnN0S2V5KGNiKTtcbiAgfVxuXG4gIC8qKiBDb2xsZWN0aW9uLmRpc3RpbmN0KClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmRpc3RpbmN0KClcbiAgICogXG4gICAqKi9cbiAgZGlzdGluY3QoKSB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eCxcbiAgICAgIGlkeCA9IGN0eC5pbmRleCAmJiBjdHgudGFibGUuc2NoZW1hLmlkeEJ5TmFtZVtjdHguaW5kZXhdO1xuICAgIGlmICghaWR4IHx8ICFpZHgubXVsdGkpIHJldHVybiB0aGlzOyAvLyBkaXN0aW5jdCgpIG9ubHkgbWFrZXMgZGlmZmVyZW5jaWVzIG9uIG11bHRpRW50cnkgaW5kZXhlcy5cbiAgICB2YXIgc2V0ID0ge307XG4gICAgYWRkRmlsdGVyKHRoaXMuX2N0eCwgZnVuY3Rpb24gKGN1cnNvcjogREJDb3JlQ3Vyc29yKSB7XG4gICAgICB2YXIgc3RyS2V5ID0gY3Vyc29yLnByaW1hcnlLZXkudG9TdHJpbmcoKTsgLy8gQ29udmVydHMgYW55IERhdGUgdG8gU3RyaW5nLCBTdHJpbmcgdG8gU3RyaW5nLCBOdW1iZXIgdG8gU3RyaW5nIGFuZCBBcnJheSB0byBjb21tYS1zZXBhcmF0ZWQgc3RyaW5nXG4gICAgICB2YXIgZm91bmQgPSBoYXNPd24oc2V0LCBzdHJLZXkpO1xuICAgICAgc2V0W3N0cktleV0gPSB0cnVlO1xuICAgICAgcmV0dXJuICFmb3VuZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vXG4gIC8vIE1ldGhvZHMgdGhhdCBtdXRhdGUgc3RvcmFnZVxuICAvL1xuXG4gIC8qKiBDb2xsZWN0aW9uLm1vZGlmeSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL0NvbGxlY3Rpb24vQ29sbGVjdGlvbi5tb2RpZnkoKVxuICAgKiBcbiAgICoqL1xuICBtb2RpZnkoY2hhbmdlczogeyBba2V5UGF0aDogc3RyaW5nXTogYW55IH0pIDogUHJvbWlzZUV4dGVuZGVkPG51bWJlcj5cbiAgbW9kaWZ5KGNoYW5nZXM6IChvYmo6IGFueSwgY3R4Ont2YWx1ZTogYW55LCBwcmltS2V5OiBJbmRleGFibGVUeXBlfSkgPT4gdm9pZCB8IGJvb2xlYW4pOiBQcm9taXNlRXh0ZW5kZWQ8bnVtYmVyPiB7XG4gICAgdmFyIGN0eCA9IHRoaXMuX2N0eDtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgdmFyIG1vZGlmeWVyOiAob2JqOiBhbnksIGN0eDp7dmFsdWU6IGFueSwgcHJpbUtleTogSW5kZXhhYmxlVHlwZX0pID0+IHZvaWQgfCBib29sZWFuXG4gICAgICBpZiAodHlwZW9mIGNoYW5nZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQ2hhbmdlcyBpcyBhIGZ1bmN0aW9uIHRoYXQgbWF5IHVwZGF0ZSwgYWRkIG9yIGRlbGV0ZSBwcm9wdGVydGllcyBvciBldmVuIHJlcXVpcmUgYSBkZWxldGlvbiB0aGUgb2JqZWN0IGl0c2VsZiAoZGVsZXRlIHRoaXMuaXRlbSlcbiAgICAgICAgbW9kaWZ5ZXIgPSBjaGFuZ2VzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY2hhbmdlcyBpcyBhIHNldCBvZiB7a2V5UGF0aDogdmFsdWV9IGFuZCBubyBvbmUgaXMgbGlzdGVuaW5nIHRvIHRoZSB1cGRhdGluZyBob29rLlxuICAgICAgICB2YXIga2V5UGF0aHMgPSBrZXlzKGNoYW5nZXMpO1xuICAgICAgICB2YXIgbnVtS2V5cyA9IGtleVBhdGhzLmxlbmd0aDtcbiAgICAgICAgbW9kaWZ5ZXIgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHZhciBhbnl0aGluZ01vZGlmaWVkID0gZmFsc2U7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW1LZXlzOyArK2kpIHtcbiAgICAgICAgICAgIHZhciBrZXlQYXRoID0ga2V5UGF0aHNbaV0sIHZhbCA9IGNoYW5nZXNba2V5UGF0aF07XG4gICAgICAgICAgICBpZiAoZ2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgpICE9PSB2YWwpIHtcbiAgICAgICAgICAgICAgc2V0QnlLZXlQYXRoKGl0ZW0sIGtleVBhdGgsIHZhbCk7IC8vIEFkZGluZyB7a2V5UGF0aDogdW5kZWZpbmVkfSBtZWFucyB0aGF0IHRoZSBrZXlQYXRoIHNob3VsZCBiZSBkZWxldGVkLiBIYW5kbGVkIGJ5IHNldEJ5S2V5UGF0aFxuICAgICAgICAgICAgICBhbnl0aGluZ01vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGFueXRoaW5nTW9kaWZpZWQ7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvcmVUYWJsZSA9IGN0eC50YWJsZS5jb3JlO1xuICAgICAgY29uc3Qge291dGJvdW5kLCBleHRyYWN0S2V5fSA9IGNvcmVUYWJsZS5zY2hlbWEucHJpbWFyeUtleTtcbiAgICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5kYi5fb3B0aW9ucy5tb2RpZnlDaHVua1NpemUgfHwgMjAwO1xuICAgICAgY29uc3QgdG90YWxGYWlsdXJlcyA9IFtdO1xuICAgICAgbGV0IHN1Y2Nlc3NDb3VudCA9IDA7XG4gICAgICBjb25zdCBmYWlsZWRLZXlzOiBJbmRleGFibGVUeXBlW10gPSBbXTtcbiAgICAgIGNvbnN0IGFwcGx5TXV0YXRlUmVzdWx0ID0gKGV4cGVjdGVkQ291bnQ6IG51bWJlciwgcmVzOiBEQkNvcmVNdXRhdGVSZXNwb25zZSkgPT4ge1xuICAgICAgICBjb25zdCB7ZmFpbHVyZXMsIG51bUZhaWx1cmVzfSA9IHJlcztcbiAgICAgICAgc3VjY2Vzc0NvdW50ICs9IGV4cGVjdGVkQ291bnQgLSBudW1GYWlsdXJlcztcbiAgICAgICAgZm9yIChsZXQgcG9zIG9mIGtleXMoZmFpbHVyZXMpKSB7XG4gICAgICAgICAgdG90YWxGYWlsdXJlcy5wdXNoKGZhaWx1cmVzW3Bvc10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLnByaW1hcnlLZXlzKCkudGhlbihrZXlzID0+IHtcblxuICAgICAgICBjb25zdCBuZXh0Q2h1bmsgPSAob2Zmc2V0OiBudW1iZXIpID0+IHtcbiAgICAgICAgICBjb25zdCBjb3VudCA9IE1hdGgubWluKGxpbWl0LCBrZXlzLmxlbmd0aCAtIG9mZnNldCk7XG4gICAgICAgICAgcmV0dXJuIGNvcmVUYWJsZS5nZXRNYW55KHtcbiAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAga2V5czoga2V5cy5zbGljZShvZmZzZXQsIG9mZnNldCArIGNvdW50KSxcbiAgICAgICAgICAgIGNhY2hlOiBcImltbXV0YWJsZVwiIC8vIE9wdGltaXplIGZvciAyIHRoaW5nczpcbiAgICAgICAgICAgIC8vIDEpIG9ic2VydmFiaWxpdHktbWlkZGxld2FyZSBjYW4gdHJhY2sgY2hhbmdlcyBiZXR0ZXIuXG4gICAgICAgICAgICAvLyAyKSBob29rcyBtaWRkbGV3YXJlIGRvbid0IGhhdmUgdG8gcXVlcnkgdGhlIGV4aXN0aW5nIHZhbHVlcyBhZ2FpbiB3aGVuIHRyYWNraW5nIGNoYW5nZXMuXG4gICAgICAgICAgICAvLyBXZSBjYW4gdXNlIFwiaW1tdXRhYmxlXCIgYmVjYXVzZSB3ZSBwcm9taXNlIHRvIG5vdCB0b3VjaCB0aGUgdmFsdWVzIHdlIHJldHJpZXZlIGhlcmUhXG4gICAgICAgICAgfSkudGhlbih2YWx1ZXMgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWRkVmFsdWVzID0gW107XG4gICAgICAgICAgICBjb25zdCBwdXRWYWx1ZXMgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHB1dEtleXMgPSBvdXRib3VuZCA/IFtdIDogbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZUtleXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgY29uc3QgY3R4ID0ge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBkZWVwQ2xvbmUob3JpZ1ZhbHVlKSxcbiAgICAgICAgICAgICAgICBwcmltS2V5OiBrZXlzW29mZnNldCtpXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBpZiAobW9kaWZ5ZXIuY2FsbChjdHgsIGN0eC52YWx1ZSwgY3R4KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3R4LnZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIERlbGV0ZWRcbiAgICAgICAgICAgICAgICAgIGRlbGV0ZUtleXMucHVzaChrZXlzW29mZnNldCtpXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICghb3V0Ym91bmQgJiYgY21wKGV4dHJhY3RLZXkob3JpZ1ZhbHVlKSwgZXh0cmFjdEtleShjdHgudmFsdWUpKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgLy8gQ2hhbmdlZCBwcmltYXJ5IGtleSBvZiBpbmJvdW5kXG4gICAgICAgICAgICAgICAgICBkZWxldGVLZXlzLnB1c2goa2V5c1tvZmZzZXQraV0pO1xuICAgICAgICAgICAgICAgICAgYWRkVmFsdWVzLnB1c2goY3R4LnZhbHVlKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBDaGFuZ2VkIHZhbHVlXG4gICAgICAgICAgICAgICAgICBwdXRWYWx1ZXMucHVzaChjdHgudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kKSBwdXRLZXlzLnB1c2goa2V5c1tvZmZzZXQraV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY3JpdGVyaWEgPSBpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgICAgICAgICBjdHgubGltaXQgPT09IEluZmluaXR5ICYmXG4gICAgICAgICAgICAgICh0eXBlb2YgY2hhbmdlcyAhPT0gJ2Z1bmN0aW9uJyB8fCBjaGFuZ2VzID09PSBkZWxldGVDYWxsYmFjaykgJiYge1xuICAgICAgICAgICAgICAgIGluZGV4OiBjdHguaW5kZXgsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IGN0eC5yYW5nZVxuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGFkZFZhbHVlcy5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe3RyYW5zLCB0eXBlOiAnYWRkJywgdmFsdWVzOiBhZGRWYWx1ZXN9KVxuICAgICAgICAgICAgICAgIC50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGxldCBwb3MgaW4gcmVzLmZhaWx1cmVzKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBmcm9tIGRlbGV0ZUtleXMgdGhlIGtleSBvZiB0aGUgb2JqZWN0IHRoYXQgZmFpbGVkIHRvIGNoYW5nZSBpdHMgcHJpbWFyeSBrZXlcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlS2V5cy5zcGxpY2UocGFyc2VJbnQocG9zKSwgMSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBhcHBseU11dGF0ZVJlc3VsdChhZGRWYWx1ZXMubGVuZ3RoLCByZXMpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApLnRoZW4oKCk9PihwdXRWYWx1ZXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgdHlwZW9mIGNoYW5nZXMgPT09ICdvYmplY3QnKSkgJiZcbiAgICAgICAgICAgICAgICBjb3JlVGFibGUubXV0YXRlKHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zLFxuICAgICAgICAgICAgICAgICAgdHlwZTogJ3B1dCcsXG4gICAgICAgICAgICAgICAgICBrZXlzOiBwdXRLZXlzLFxuICAgICAgICAgICAgICAgICAgdmFsdWVzOiBwdXRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgICBjcml0ZXJpYSxcbiAgICAgICAgICAgICAgICAgIGNoYW5nZVNwZWM6IHR5cGVvZiBjaGFuZ2VzICE9PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICAgICAgICAgICYmIGNoYW5nZXNcbiAgICAgICAgICAgICAgICB9KS50aGVuKHJlcz0+YXBwbHlNdXRhdGVSZXN1bHQocHV0VmFsdWVzLmxlbmd0aCwgcmVzKSlcbiAgICAgICAgICAgICkudGhlbigoKT0+KGRlbGV0ZUtleXMubGVuZ3RoID4gMCB8fCAoY3JpdGVyaWEgJiYgY2hhbmdlcyA9PT0gZGVsZXRlQ2FsbGJhY2spKSAmJlxuICAgICAgICAgICAgICAgIGNvcmVUYWJsZS5tdXRhdGUoe1xuICAgICAgICAgICAgICAgICAgdHJhbnMsXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnZGVsZXRlJyxcbiAgICAgICAgICAgICAgICAgIGtleXM6IGRlbGV0ZUtleXMsXG4gICAgICAgICAgICAgICAgICBjcml0ZXJpYVxuICAgICAgICAgICAgICAgIH0pLnRoZW4ocmVzPT5hcHBseU11dGF0ZVJlc3VsdChkZWxldGVLZXlzLmxlbmd0aCwgcmVzKSlcbiAgICAgICAgICAgICkudGhlbigoKT0+e1xuICAgICAgICAgICAgICByZXR1cm4ga2V5cy5sZW5ndGggPiBvZmZzZXQgKyBjb3VudCAmJiBuZXh0Q2h1bmsob2Zmc2V0ICsgbGltaXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmV4dENodW5rKDApLnRoZW4oKCk9PntcbiAgICAgICAgICBpZiAodG90YWxGYWlsdXJlcy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1vZGlmeUVycm9yKFwiRXJyb3IgbW9kaWZ5aW5nIG9uZSBvciBtb3JlIG9iamVjdHNcIiwgdG90YWxGYWlsdXJlcywgc3VjY2Vzc0NvdW50LCBmYWlsZWRLZXlzIGFzIEluZGV4YWJsZVR5cGVBcnJheVJlYWRvbmx5KTtcblxuICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgIH0pO1xuICB9XG5cbiAgLyoqIENvbGxlY3Rpb24uZGVsZXRlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvQ29sbGVjdGlvbi9Db2xsZWN0aW9uLmRlbGV0ZSgpXG4gICAqIFxuICAgKiovXG4gIGRlbGV0ZSgpIDogUHJvbWlzZUV4dGVuZGVkPG51bWJlcj4ge1xuICAgIHZhciBjdHggPSB0aGlzLl9jdHgsXG4gICAgICByYW5nZSA9IGN0eC5yYW5nZTtcbiAgICAgIC8vZGVsZXRpbmdIb29rID0gY3R4LnRhYmxlLmhvb2suZGVsZXRpbmcuZmlyZSxcbiAgICAgIC8vaGFzRGVsZXRlSG9vayA9IGRlbGV0aW5nSG9vayAhPT0gbm9wO1xuICAgIGlmIChpc1BsYWluS2V5UmFuZ2UoY3R4KSAmJlxuICAgICAgKChjdHguaXNQcmltS2V5ICYmICFoYW5nc09uRGVsZXRlTGFyZ2VLZXlSYW5nZSkgfHwgcmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLkFueSkpIC8vIGlmIG5vIHJhbmdlLCB3ZSdsbCB1c2UgY2xlYXIoKS5cbiAgICB7XG4gICAgICAvLyBNYXkgdXNlIElEQk9iamVjdFN0b3JlLmRlbGV0ZShJREJLZXlSYW5nZSkgaW4gdGhpcyBjYXNlIChJc3N1ZSAjMjA4KVxuICAgICAgLy8gRm9yIGNocm9taXVtLCB0aGlzIGlzIHRoZSB3YXkgbW9zdCBvcHRpbWl6ZWQgdmVyc2lvbi5cbiAgICAgIC8vIEZvciBJRS9FZGdlLCB0aGlzIGNvdWxkIGhhbmcgdGhlIGluZGV4ZWREQiBlbmdpbmUgYW5kIG1ha2Ugb3BlcmF0aW5nIHN5c3RlbSBpbnN0YWJsZVxuICAgICAgLy8gKGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2RmYWhsYW5kZXIvNWEzOTMyOGYwMjlkZTE4MjIyY2YyMTI1ZDU2YzM4ZjcpXG4gICAgICByZXR1cm4gdGhpcy5fd3JpdGUodHJhbnMgPT4ge1xuICAgICAgICAvLyBPdXIgQVBJIGNvbnRyYWN0IGlzIHRvIHJldHVybiBhIGNvdW50IG9mIGRlbGV0ZWQgaXRlbXMsIHNvIHdlIGhhdmUgdG8gY291bnQoKSBiZWZvcmUgZGVsZXRlKCkuXG4gICAgICAgIGNvbnN0IHtwcmltYXJ5S2V5fSA9IGN0eC50YWJsZS5jb3JlLnNjaGVtYTtcbiAgICAgICAgY29uc3QgY29yZVJhbmdlID0gcmFuZ2U7XG4gICAgICAgIHJldHVybiBjdHgudGFibGUuY29yZS5jb3VudCh7dHJhbnMsIHF1ZXJ5OiB7aW5kZXg6IHByaW1hcnlLZXksIHJhbmdlOiBjb3JlUmFuZ2V9fSkudGhlbihjb3VudCA9PiB7XG4gICAgICAgICAgcmV0dXJuIGN0eC50YWJsZS5jb3JlLm11dGF0ZSh7dHJhbnMsIHR5cGU6ICdkZWxldGVSYW5nZScsIHJhbmdlOiBjb3JlUmFuZ2V9KVxuICAgICAgICAgIC50aGVuKCh7ZmFpbHVyZXMsIGxhc3RSZXN1bHQsIHJlc3VsdHMsIG51bUZhaWx1cmVzfSkgPT4ge1xuICAgICAgICAgICAgaWYgKG51bUZhaWx1cmVzKSB0aHJvdyBuZXcgTW9kaWZ5RXJyb3IoXCJDb3VsZCBub3QgZGVsZXRlIHNvbWUgdmFsdWVzXCIsXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKGZhaWx1cmVzKS5tYXAocG9zID0+IGZhaWx1cmVzW3Bvc10pLFxuICAgICAgICAgICAgICBjb3VudCAtIG51bUZhaWx1cmVzKTtcbiAgICAgICAgICAgIHJldHVybiBjb3VudCAtIG51bUZhaWx1cmVzO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm1vZGlmeShkZWxldGVDYWxsYmFjayk7XG4gIH1cbn1cblxuY29uc3QgZGVsZXRlQ2FsbGJhY2sgPSAodmFsdWUsIGN0eCkgPT4gY3R4LnZhbHVlID0gbnVsbDtcbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uLy4uL2NsYXNzZXMvZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlIH0gZnJvbSAnLi4vd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBBbnlSYW5nZSB9IGZyb20gJy4uLy4uL2RiY29yZS9rZXlyYW5nZSc7XG5pbXBvcnQgeyBEQkNvcmVLZXlSYW5nZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgbWlycm9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9ucyc7XG5cbi8qKiBDb25zdHJ1Y3RzIGEgQ29sbGVjdGlvbiBpbnN0YW5jZS4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQ29sbGVjdGlvbkNvbnN0cnVjdG9yIHtcbiAgbmV3KHdoZXJlQ2xhdXNlPzogV2hlcmVDbGF1c2UgfCBudWxsLCBrZXlSYW5nZUdlbmVyYXRvcj86ICgpID0+IERCQ29yZUtleVJhbmdlKTogQ29sbGVjdGlvbjtcbiAgcHJvdG90eXBlOiBDb2xsZWN0aW9uO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgQ29sbGVjdGlvbiBjb25zdHJ1Y3RvciBib3VuZCB0byBnaXZlbiBEZXhpZSBpbnN0YW5jZS5cbiAqIFxuICogVGhlIHB1cnBvc2Ugb2YgaGF2aW5nIGR5bmFtaWNhbGx5IGNyZWF0ZWQgY29uc3RydWN0b3JzLCBpcyB0byBhbGxvd1xuICogYWRkb25zIHRvIGV4dGVuZCBjbGFzc2VzIGZvciBhIGNlcnRhaW4gRGV4aWUgaW5zdGFuY2Ugd2l0aG91dCBhZmZlY3RpbmdcbiAqIG90aGVyIGRiIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNvbGxlY3Rpb25Db25zdHJ1Y3RvcihkYjogRGV4aWUpIHtcbiAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yPENvbGxlY3Rpb25Db25zdHJ1Y3Rvcj4oXG4gICAgQ29sbGVjdGlvbi5wcm90b3R5cGUsXG5cbiAgICBmdW5jdGlvbiBDb2xsZWN0aW9uKFxuICAgICAgdGhpczogQ29sbGVjdGlvbixcbiAgICAgIHdoZXJlQ2xhdXNlPzogV2hlcmVDbGF1c2UgfCBudWxsLFxuICAgICAga2V5UmFuZ2VHZW5lcmF0b3I/OiAoKSA9PiBEQkNvcmVLZXlSYW5nZSlcbiAgICB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICBsZXQga2V5UmFuZ2UgPSBBbnlSYW5nZSwgZXJyb3IgPSBudWxsO1xuICAgICAgaWYgKGtleVJhbmdlR2VuZXJhdG9yKSB0cnkge1xuICAgICAgICBrZXlSYW5nZSA9IGtleVJhbmdlR2VuZXJhdG9yKCk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3aGVyZUN0eCA9IHdoZXJlQ2xhdXNlLl9jdHg7XG4gICAgICBjb25zdCB0YWJsZSA9IHdoZXJlQ3R4LnRhYmxlO1xuICAgICAgY29uc3QgcmVhZGluZ0hvb2sgPSB0YWJsZS5ob29rLnJlYWRpbmcuZmlyZTtcbiAgICAgIHRoaXMuX2N0eCA9IHtcbiAgICAgICAgdGFibGU6IHRhYmxlLFxuICAgICAgICBpbmRleDogd2hlcmVDdHguaW5kZXgsXG4gICAgICAgIGlzUHJpbUtleTogKCF3aGVyZUN0eC5pbmRleCB8fCAodGFibGUuc2NoZW1hLnByaW1LZXkua2V5UGF0aCAmJiB3aGVyZUN0eC5pbmRleCA9PT0gdGFibGUuc2NoZW1hLnByaW1LZXkubmFtZSkpLFxuICAgICAgICByYW5nZToga2V5UmFuZ2UsXG4gICAgICAgIGtleXNPbmx5OiBmYWxzZSxcbiAgICAgICAgZGlyOiBcIm5leHRcIixcbiAgICAgICAgdW5pcXVlOiBcIlwiLFxuICAgICAgICBhbGdvcml0aG06IG51bGwsXG4gICAgICAgIGZpbHRlcjogbnVsbCxcbiAgICAgICAgcmVwbGF5RmlsdGVyOiBudWxsLFxuICAgICAgICBqdXN0TGltaXQ6IHRydWUsIC8vIFRydWUgaWYgYSByZXBsYXlGaWx0ZXIgaXMganVzdCBhIGZpbHRlciB0aGF0IHBlcmZvcm1zIGEgXCJsaW1pdFwiIG9wZXJhdGlvbiAob3Igbm9uZSBhdCBhbGwpXG4gICAgICAgIGlzTWF0Y2g6IG51bGwsXG4gICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgbGltaXQ6IEluZmluaXR5LFxuICAgICAgICBlcnJvcjogZXJyb3IsIC8vIElmIHNldCwgYW55IHByb21pc2UgbXVzdCBiZSByZWplY3RlZCB3aXRoIHRoaXMgZXJyb3JcbiAgICAgICAgb3I6IHdoZXJlQ3R4Lm9yLFxuICAgICAgICB2YWx1ZU1hcHBlcjogcmVhZGluZ0hvb2sgIT09IG1pcnJvciA/IHJlYWRpbmdIb29rIDogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICk7XG59XG4iLCAiaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9pbmRleGFibGUtdHlwZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVDb21wYXJlKGEsIGIpIHtcbiAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID09PSBiID8gMCA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaW1wbGVDb21wYXJlUmV2ZXJzZShhLCBiKSB7XG4gIHJldHVybiBhID4gYiA/IC0xIDogYSA9PT0gYiA/IDAgOiAxO1xufVxuIiwgImltcG9ydCB7IFdoZXJlQ2xhdXNlIH0gZnJvbSAnLi93aGVyZS1jbGF1c2UnO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiB9IGZyb20gJy4uL2NvbGxlY3Rpb24nO1xuaW1wb3J0IHsgU1RSSU5HX0VYUEVDVEVEIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgc2ltcGxlQ29tcGFyZSwgc2ltcGxlQ29tcGFyZVJldmVyc2UgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY29tcGFyZS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uLy4uL3B1YmxpYyc7XG5pbXBvcnQgeyBEQkNvcmVLZXlSYW5nZSwgREJDb3JlUmFuZ2VUeXBlIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiY29yZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBmYWlsKGNvbGxlY3Rpb25PcldoZXJlQ2xhdXNlOiBDb2xsZWN0aW9uIHwgV2hlcmVDbGF1c2UsIGVyciwgVD8pIHtcbiAgdmFyIGNvbGxlY3Rpb24gPSBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSBpbnN0YW5jZW9mIFdoZXJlQ2xhdXNlID9cbiAgICAgIG5ldyBjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZS5Db2xsZWN0aW9uIChjb2xsZWN0aW9uT3JXaGVyZUNsYXVzZSkgOlxuICAgICAgY29sbGVjdGlvbk9yV2hlcmVDbGF1c2U7XG4gICAgICBcbiAgY29sbGVjdGlvbi5fY3R4LmVycm9yID0gVCA/IG5ldyBUKGVycikgOiBuZXcgVHlwZUVycm9yKGVycik7XG4gIHJldHVybiBjb2xsZWN0aW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW1wdHlDb2xsZWN0aW9uKHdoZXJlQ2xhdXNlOiBXaGVyZUNsYXVzZSkge1xuICByZXR1cm4gbmV3IHdoZXJlQ2xhdXNlLkNvbGxlY3Rpb24gKHdoZXJlQ2xhdXNlLCAoKSA9PiByYW5nZUVxdWFsKFwiXCIpKS5saW1pdCgwKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwcGVyRmFjdG9yeShkaXI6ICduZXh0JyB8ICdwcmV2Jykge1xuICByZXR1cm4gZGlyID09PSBcIm5leHRcIiA/XG4gICAgKHM6IHN0cmluZykgPT4gcy50b1VwcGVyQ2FzZSgpIDpcbiAgICAoczogc3RyaW5nKSA9PiBzLnRvTG93ZXJDYXNlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckZhY3RvcnkoZGlyOiAnbmV4dCcgfCAncHJldicpIHtcbiAgcmV0dXJuIGRpciA9PT0gXCJuZXh0XCIgP1xuICAgIChzOiBzdHJpbmcpID0+IHMudG9Mb3dlckNhc2UoKSA6XG4gICAgKHM6IHN0cmluZykgPT4gcy50b1VwcGVyQ2FzZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbmV4dENhc2luZyhrZXksIGxvd2VyS2V5LCB1cHBlck5lZWRsZSwgbG93ZXJOZWVkbGUsIGNtcCwgZGlyKSB7XG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihrZXkubGVuZ3RoLCBsb3dlck5lZWRsZS5sZW5ndGgpO1xuICB2YXIgbGxwID0gLTE7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBsd3JLZXlDaGFyID0gbG93ZXJLZXlbaV07XG4gICAgICBpZiAobHdyS2V5Q2hhciAhPT0gbG93ZXJOZWVkbGVbaV0pIHtcbiAgICAgICAgICBpZiAoY21wKGtleVtpXSwgdXBwZXJOZWVkbGVbaV0pIDwgMCkgcmV0dXJuIGtleS5zdWJzdHIoMCwgaSkgKyB1cHBlck5lZWRsZVtpXSArIHVwcGVyTmVlZGxlLnN1YnN0cihpICsgMSk7XG4gICAgICAgICAgaWYgKGNtcChrZXlbaV0sIGxvd2VyTmVlZGxlW2ldKSA8IDApIHJldHVybiBrZXkuc3Vic3RyKDAsIGkpICsgbG93ZXJOZWVkbGVbaV0gKyB1cHBlck5lZWRsZS5zdWJzdHIoaSArIDEpO1xuICAgICAgICAgIGlmIChsbHAgPj0gMCkgcmV0dXJuIGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyS2V5W2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY21wKGtleVtpXSwgbHdyS2V5Q2hhcikgPCAwKSBsbHAgPSBpO1xuICB9XG4gIGlmIChsZW5ndGggPCBsb3dlck5lZWRsZS5sZW5ndGggJiYgZGlyID09PSBcIm5leHRcIikgcmV0dXJuIGtleSArIHVwcGVyTmVlZGxlLnN1YnN0cihrZXkubGVuZ3RoKTtcbiAgaWYgKGxlbmd0aCA8IGtleS5sZW5ndGggJiYgZGlyID09PSBcInByZXZcIikgcmV0dXJuIGtleS5zdWJzdHIoMCwgdXBwZXJOZWVkbGUubGVuZ3RoKTtcbiAgcmV0dXJuIChsbHAgPCAwID8gbnVsbCA6IGtleS5zdWJzdHIoMCwgbGxwKSArIGxvd2VyTmVlZGxlW2xscF0gKyB1cHBlck5lZWRsZS5zdWJzdHIobGxwICsgMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh3aGVyZUNsYXVzZTogV2hlcmVDbGF1c2UsIG1hdGNoLCBuZWVkbGVzLCBzdWZmaXgpIHtcbiAgLy8vIDxwYXJhbSBuYW1lPVwibmVlZGxlc1wiIHR5cGU9XCJBcnJheVwiIGVsZW1lbnRUeXBlPVwiU3RyaW5nXCI+PC9wYXJhbT5cbiAgdmFyIHVwcGVyLCBsb3dlciwgY29tcGFyZSwgdXBwZXJOZWVkbGVzLCBsb3dlck5lZWRsZXMsIGRpcmVjdGlvbiwgbmV4dEtleVN1ZmZpeCxcbiAgICAgIG5lZWRsZXNMZW4gPSBuZWVkbGVzLmxlbmd0aDtcbiAgaWYgKCFuZWVkbGVzLmV2ZXJ5KHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgcmV0dXJuIGZhaWwod2hlcmVDbGF1c2UsIFNUUklOR19FWFBFQ1RFRCk7XG4gIH1cbiAgZnVuY3Rpb24gaW5pdERpcmVjdGlvbihkaXIpIHtcbiAgICAgIHVwcGVyID0gdXBwZXJGYWN0b3J5KGRpcik7XG4gICAgICBsb3dlciA9IGxvd2VyRmFjdG9yeShkaXIpO1xuICAgICAgY29tcGFyZSA9IChkaXIgPT09IFwibmV4dFwiID8gc2ltcGxlQ29tcGFyZSA6IHNpbXBsZUNvbXBhcmVSZXZlcnNlKTtcbiAgICAgIHZhciBuZWVkbGVCb3VuZHMgPSBuZWVkbGVzLm1hcChmdW5jdGlvbiAobmVlZGxlKXtcbiAgICAgICAgICByZXR1cm4ge2xvd2VyOiBsb3dlcihuZWVkbGUpLCB1cHBlcjogdXBwZXIobmVlZGxlKX07XG4gICAgICB9KS5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgICAgICAgIHJldHVybiBjb21wYXJlKGEubG93ZXIsIGIubG93ZXIpO1xuICAgICAgfSk7XG4gICAgICB1cHBlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYil7IHJldHVybiBuYi51cHBlcjsgfSk7XG4gICAgICBsb3dlck5lZWRsZXMgPSBuZWVkbGVCb3VuZHMubWFwKGZ1bmN0aW9uIChuYil7IHJldHVybiBuYi5sb3dlcjsgfSk7XG4gICAgICBkaXJlY3Rpb24gPSBkaXI7XG4gICAgICBuZXh0S2V5U3VmZml4ID0gKGRpciA9PT0gXCJuZXh0XCIgPyBcIlwiIDogc3VmZml4KTtcbiAgfVxuICBpbml0RGlyZWN0aW9uKFwibmV4dFwiKTtcblxuICB2YXIgYyA9IG5ldyB3aGVyZUNsYXVzZS5Db2xsZWN0aW9uIChcbiAgICAgIHdoZXJlQ2xhdXNlLFxuICAgICAgKCk9PmNyZWF0ZVJhbmdlKHVwcGVyTmVlZGxlc1swXSwgbG93ZXJOZWVkbGVzW25lZWRsZXNMZW4tMV0gKyBzdWZmaXgpXG4gICk7XG5cbiAgYy5fb25kaXJlY3Rpb25jaGFuZ2UgPSBmdW5jdGlvbiAoZGlyZWN0aW9uKSB7XG4gICAgICAvLyBUaGlzIGV2ZW50IG9ubHlzIG9jY3VyIGJlZm9yZSBmaWx0ZXIgaXMgY2FsbGVkIHRoZSBmaXJzdCB0aW1lLlxuICAgICAgaW5pdERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICB9O1xuXG4gIHZhciBmaXJzdFBvc3NpYmxlTmVlZGxlID0gMDtcblxuICBjLl9hZGRBbGdvcml0aG0oZnVuY3Rpb24gKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkge1xuICAgICAgLy8vIDxwYXJhbSBuYW1lPVwiY3Vyc29yXCIgdHlwZT1cIklEQkN1cnNvclwiPjwvcGFyYW0+XG4gICAgICAvLy8gPHBhcmFtIG5hbWU9XCJhZHZhbmNlXCIgdHlwZT1cIkZ1bmN0aW9uXCI+PC9wYXJhbT5cbiAgICAgIC8vLyA8cGFyYW0gbmFtZT1cInJlc29sdmVcIiB0eXBlPVwiRnVuY3Rpb25cIj48L3BhcmFtPlxuICAgICAgdmFyIGtleSA9IGN1cnNvci5rZXk7XG4gICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHJldHVybiBmYWxzZTtcbiAgICAgIHZhciBsb3dlcktleSA9IGxvd2VyKGtleSk7XG4gICAgICBpZiAobWF0Y2gobG93ZXJLZXksIGxvd2VyTmVlZGxlcywgZmlyc3RQb3NzaWJsZU5lZWRsZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID0gbnVsbDtcbiAgICAgICAgICBmb3IgKHZhciBpPWZpcnN0UG9zc2libGVOZWVkbGU7IGk8bmVlZGxlc0xlbjsgKytpKSB7XG4gICAgICAgICAgICAgIHZhciBjYXNpbmcgPSBuZXh0Q2FzaW5nKGtleSwgbG93ZXJLZXksIHVwcGVyTmVlZGxlc1tpXSwgbG93ZXJOZWVkbGVzW2ldLCBjb21wYXJlLCBkaXJlY3Rpb24pO1xuICAgICAgICAgICAgICBpZiAoY2FzaW5nID09PSBudWxsICYmIGxvd2VzdFBvc3NpYmxlQ2FzaW5nID09PSBudWxsKVxuICAgICAgICAgICAgICAgICAgZmlyc3RQb3NzaWJsZU5lZWRsZSA9IGkgKyAxO1xuICAgICAgICAgICAgICBlbHNlIGlmIChsb3dlc3RQb3NzaWJsZUNhc2luZyA9PT0gbnVsbCB8fCBjb21wYXJlKGxvd2VzdFBvc3NpYmxlQ2FzaW5nLCBjYXNpbmcpID4gMCkge1xuICAgICAgICAgICAgICAgICAgbG93ZXN0UG9zc2libGVDYXNpbmcgPSBjYXNpbmc7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxvd2VzdFBvc3NpYmxlQ2FzaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGFkdmFuY2UoZnVuY3Rpb24gKCkgeyBjdXJzb3IuY29udGludWUobG93ZXN0UG9zc2libGVDYXNpbmcgKyBuZXh0S2V5U3VmZml4KTsgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICB9KTtcbiAgcmV0dXJuIGM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVSYW5nZSAobG93ZXI6IEluZGV4YWJsZVR5cGUsIHVwcGVyOiBJbmRleGFibGVUeXBlLCBsb3dlck9wZW4/OiBib29sZWFuLCB1cHBlck9wZW4/OiBib29sZWFuKTogREJDb3JlS2V5UmFuZ2Uge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IERCQ29yZVJhbmdlVHlwZS5SYW5nZSxcbiAgICAgICAgbG93ZXIsXG4gICAgICAgIHVwcGVyLFxuICAgICAgICBsb3dlck9wZW4sXG4gICAgICAgIHVwcGVyT3BlblxuICAgIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZUVxdWFsICh2YWx1ZTogSW5kZXhhYmxlVHlwZSkgOiBEQkNvcmVLZXlSYW5nZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogREJDb3JlUmFuZ2VUeXBlLkVxdWFsLFxuICAgICAgICBsb3dlcjogdmFsdWUsXG4gICAgICAgIHVwcGVyOiB2YWx1ZVxuICAgIH07XG59XG4iLCAiaW1wb3J0IHsgV2hlcmVDbGF1c2UgYXMgSVdoZXJlQ2xhdXNlIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy93aGVyZS1jbGF1c2VcIjtcbmltcG9ydCB7IENvbGxlY3Rpb24gfSBmcm9tIFwiLi4vY29sbGVjdGlvblwiO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tIFwiLi4vdGFibGVcIjtcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUgfSBmcm9tIFwiLi4vLi4vcHVibGljL3R5cGVzL2luZGV4YWJsZS10eXBlXCI7XG5pbXBvcnQgeyBlbXB0eUNvbGxlY3Rpb24sIGZhaWwsIGFkZElnbm9yZUNhc2VBbGdvcml0aG0sIGNyZWF0ZVJhbmdlLCByYW5nZUVxdWFsIH0gZnJvbSAnLi93aGVyZS1jbGF1c2UtaGVscGVycyc7XG5pbXBvcnQgeyBJTlZBTElEX0tFWV9BUkdVTUVOVCwgU1RSSU5HX0VYUEVDVEVELCBtYXhTdHJpbmcsIG1pbktleSB9IGZyb20gJy4uLy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCB7IGdldEFycmF5T2YsIE5PX0NIQVJfQVJSQVkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IENvbGxlY3Rpb24gYXMgSUNvbGxlY3Rpb259IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvY29sbGVjdGlvblwiO1xuXG4vKiogY2xhc3MgV2hlcmVDbGF1c2VcbiAqIFxuICogaHR0cHM6Ly9kZXhpZS5vcmcvZG9jcy9XaGVyZUNsYXVzZS9XaGVyZUNsYXVzZVxuICovXG5leHBvcnQgY2xhc3MgV2hlcmVDbGF1c2UgaW1wbGVtZW50cyBJV2hlcmVDbGF1c2Uge1xuICBkYjogRGV4aWU7XG4gIF9JREJLZXlSYW5nZTogdHlwZW9mIElEQktleVJhbmdlO1xuICBfY3R4OiB7XG4gICAgdGFibGU6IFRhYmxlO1xuICAgIGluZGV4OiBzdHJpbmc7XG4gICAgb3I6IENvbGxlY3Rpb247XG4gIH1cbiAgX2NtcDogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IG51bWJlcjtcbiAgX2FzY2VuZGluZzogKGE6IEluZGV4YWJsZVR5cGUsIGI6IEluZGV4YWJsZVR5cGUpID0+IG51bWJlcjtcbiAgX2Rlc2NlbmRpbmc6IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBudW1iZXI7XG4gIF9taW46IChhOiBJbmRleGFibGVUeXBlLCBiOiBJbmRleGFibGVUeXBlKSA9PiBJbmRleGFibGVUeXBlO1xuICBfbWF4OiAoYTogSW5kZXhhYmxlVHlwZSwgYjogSW5kZXhhYmxlVHlwZSkgPT4gSW5kZXhhYmxlVHlwZTtcblxuICBnZXQgQ29sbGVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fY3R4LnRhYmxlLmRiLkNvbGxlY3Rpb247XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYmV0d2VlbigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmJldHdlZW4oKVxuICAgKiBcbiAgICoqL1xuICBiZXR3ZWVuKGxvd2VyOiBJbmRleGFibGVUeXBlLCB1cHBlcjogSW5kZXhhYmxlVHlwZSwgaW5jbHVkZUxvd2VyPzogYm9vbGVhbiwgaW5jbHVkZVVwcGVyPzogYm9vbGVhbikge1xuICAgIGluY2x1ZGVMb3dlciA9IGluY2x1ZGVMb3dlciAhPT0gZmFsc2U7ICAgLy8gRGVmYXVsdCB0byB0cnVlXG4gICAgaW5jbHVkZVVwcGVyID0gaW5jbHVkZVVwcGVyID09PSB0cnVlOyAgICAvLyBEZWZhdWx0IHRvIGZhbHNlXG4gICAgdHJ5IHtcbiAgICAgIGlmICgodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPiAwKSB8fFxuICAgICAgICAodGhpcy5fY21wKGxvd2VyLCB1cHBlcikgPT09IDAgJiYgKGluY2x1ZGVMb3dlciB8fCBpbmNsdWRlVXBwZXIpICYmICEoaW5jbHVkZUxvd2VyICYmIGluY2x1ZGVVcHBlcikpKVxuICAgICAgICByZXR1cm4gZW1wdHlDb2xsZWN0aW9uKHRoaXMpOyAvLyBXb3JrYXJvdW5kIGZvciBpZGlvdGljIFczQyBTcGVjaWZpY2F0aW9uIHRoYXQgRGF0YUVycm9yIG11c3QgYmUgdGhyb3duIGlmIGxvd2VyID4gdXBwZXIuIFRoZSBuYXR1cmFsIHJlc3VsdCB3b3VsZCBiZSB0byByZXR1cm4gYW4gZW1wdHkgY29sbGVjdGlvbi5cbiAgICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpPT5jcmVhdGVSYW5nZShsb3dlciwgdXBwZXIsICFpbmNsdWRlTG93ZXIsICFpbmNsdWRlVXBwZXIpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmVxdWFscygpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmVxdWFscygpXG4gICAqIFxuICAgKiovXG4gIGVxdWFscyh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gcmFuZ2VFcXVhbCh2YWx1ZSkpIGFzIElDb2xsZWN0aW9uO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmFib3ZlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYWJvdmUoKVxuICAgKiBcbiAgICoqL1xuICBhYm92ZSh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmFib3ZlT3JFcXVhbCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmFib3ZlT3JFcXVhbCgpXG4gICAqIFxuICAgKiovXG4gIGFib3ZlT3JFcXVhbCh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7XG4gICAgcmV0dXJuIG5ldyB0aGlzLkNvbGxlY3Rpb24odGhpcywgKCkgPT4gY3JlYXRlUmFuZ2UodmFsdWUsIHVuZGVmaW5lZCwgZmFsc2UpKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5iZWxvdygpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmJlbG93KClcbiAgICogXG4gICAqKi9cbiAgYmVsb3codmFsdWU6IEluZGV4YWJsZVR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMsICgpID0+IGNyZWF0ZVJhbmdlKHVuZGVmaW5lZCwgdmFsdWUsIGZhbHNlLCB0cnVlKSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuYmVsb3dPckVxdWFsKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYmVsb3dPckVxdWFsKClcbiAgICogXG4gICAqKi9cbiAgYmVsb3dPckVxdWFsKHZhbHVlOiBJbmRleGFibGVUeXBlKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBmYWlsKHRoaXMsIElOVkFMSURfS0VZX0FSR1VNRU5UKTtcbiAgICByZXR1cm4gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZSh1bmRlZmluZWQsIHZhbHVlKSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLnN0YXJ0c1dpdGgoKVxuICAgKiBcbiAgICoqL1xuICBzdGFydHNXaXRoKHN0cjogc3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSByZXR1cm4gZmFpbCh0aGlzLCBTVFJJTkdfRVhQRUNURUQpO1xuICAgIHJldHVybiB0aGlzLmJldHdlZW4oc3RyLCBzdHIgKyBtYXhTdHJpbmcsIHRydWUsIHRydWUpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLnN0YXJ0c1dpdGhJZ25vcmVDYXNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aElnbm9yZUNhc2UoKVxuICAgKiBcbiAgICoqL1xuICBzdGFydHNXaXRoSWdub3JlQ2FzZShzdHI6IHN0cmluZykge1xuICAgIGlmIChzdHIgPT09IFwiXCIpIHJldHVybiB0aGlzLnN0YXJ0c1dpdGgoc3RyKTtcbiAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4geC5pbmRleE9mKGFbMF0pID09PSAwLCBbc3RyXSwgbWF4U3RyaW5nKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5lcXVhbHNJZ25vcmVDYXNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuZXF1YWxzSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiovXG4gIGVxdWFsc0lnbm9yZUNhc2Uoc3RyOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4geCA9PT0gYVswXSwgW3N0cl0sIFwiXCIpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmFueU9mSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmFueU9mSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiovXG4gIGFueU9mSWdub3JlQ2FzZSguLi52YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgYW55T2ZJZ25vcmVDYXNlKHZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBhbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5pbmRleE9mKHgpICE9PSAtMSwgc2V0LCBcIlwiKTtcbiAgfVxuXG4gIC8qKiBXaGVyZUNsYXVzZS5zdGFydHNXaXRoQW55T2ZJZ25vcmVDYXNlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uuc3RhcnRzV2l0aEFueU9mSWdub3JlQ2FzZSgpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoLi4udmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIHN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UodmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIHN0YXJ0c1dpdGhBbnlPZklnbm9yZUNhc2UoKSB7XG4gICAgdmFyIHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICByZXR1cm4gYWRkSWdub3JlQ2FzZUFsZ29yaXRobSh0aGlzLCAoeCwgYSkgPT4gYS5zb21lKG4gPT4geC5pbmRleE9mKG4pID09PSAwKSwgc2V0LCBtYXhTdHJpbmcpO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLmFueU9mKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2UuYW55T2YoKVxuICAgKiBcbiAgICoqL1xuICBhbnlPZiguLi52YWx1ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgYW55T2YodmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIGFueU9mKCkge1xuICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcbiAgICBsZXQgY29tcGFyZSA9IHRoaXMuX2NtcDtcbiAgICB0cnkgeyBzZXQuc29ydChjb21wYXJlKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7IH1cbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICBjb25zdCBjID0gbmV3IHRoaXMuQ29sbGVjdGlvbih0aGlzLCAoKSA9PiBjcmVhdGVSYW5nZShzZXRbMF0sIHNldFtzZXQubGVuZ3RoIC0gMV0pKTtcblxuICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgIGNvbXBhcmUgPSAoZGlyZWN0aW9uID09PSBcIm5leHRcIiA/XG4gICAgICAgIHRoaXMuX2FzY2VuZGluZyA6XG4gICAgICAgIHRoaXMuX2Rlc2NlbmRpbmcpO1xuICAgICAgc2V0LnNvcnQoY29tcGFyZSk7XG4gICAgfTtcblxuICAgIGxldCBpID0gMDtcbiAgICBjLl9hZGRBbGdvcml0aG0oKGN1cnNvciwgYWR2YW5jZSwgcmVzb2x2ZSkgPT4ge1xuICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleTtcbiAgICAgIHdoaWxlIChjb21wYXJlKGtleSwgc2V0W2ldKSA+IDApIHtcbiAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgKytpO1xuICAgICAgICBpZiAoaSA9PT0gc2V0Lmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5leHQuIFN0b3Agc2VhcmNoaW5nLlxuICAgICAgICAgIGFkdmFuY2UocmVzb2x2ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY29tcGFyZShrZXksIHNldFtpXSkgPT09IDApIHtcbiAgICAgICAgLy8gVGhlIGN1cnJlbnQgY3Vyc29yIHZhbHVlIHNob3VsZCBiZSBpbmNsdWRlZCBhbmQgd2Ugc2hvdWxkIGNvbnRpbnVlIGEgc2luZ2xlIHN0ZXAgaW4gY2FzZSBuZXh0IGl0ZW0gaGFzIHRoZSBzYW1lIGtleSBvciBwb3NzaWJseSBvdXIgbmV4dCBrZXkgaW4gc2V0LlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGN1cnNvci5rZXkgbm90IHlldCBhdCBzZXRbaV0uIEZvcndhcmQgY3Vyc29yIHRvIHRoZSBuZXh0IGtleSB0byBodW50IGZvci5cbiAgICAgICAgYWR2YW5jZSgoKSA9PiB7IGN1cnNvci5jb250aW51ZShzZXRbaV0pOyB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLm5vdEVxdWFsKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uubm90RXF1YWwoKVxuICAgKiBcbiAgICoqL1xuICBub3RFcXVhbCh2YWx1ZTogSW5kZXhhYmxlVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2UoW1ttaW5LZXksIHZhbHVlXSwgW3ZhbHVlLCB0aGlzLmRiLl9tYXhLZXldXSwgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2Uubm9uZU9mKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvV2hlcmVDbGF1c2UvV2hlcmVDbGF1c2Uubm9uZU9mKClcbiAgICogXG4gICAqKi9cbiAgbm9uZU9mKC4uLnZhbHVlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBub25lT2YodmFsdWVzOiBzdHJpbmdbXSk6IENvbGxlY3Rpb247XG4gIG5vbmVPZigpIHtcbiAgICBjb25zdCBzZXQgPSBnZXRBcnJheU9mLmFwcGx5KE5PX0NIQVJfQVJSQVksIGFyZ3VtZW50cyk7XG4gICAgaWYgKHNldC5sZW5ndGggPT09IDApIHJldHVybiBuZXcgdGhpcy5Db2xsZWN0aW9uKHRoaXMpOyAvLyBSZXR1cm4gZW50aXJlIGNvbGxlY3Rpb24uXG4gICAgdHJ5IHsgc2V0LnNvcnQodGhpcy5fYXNjZW5kaW5nKTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFpbCh0aGlzLCBJTlZBTElEX0tFWV9BUkdVTUVOVCk7IH1cbiAgICAvLyBUcmFuc2Zvcm0gW1wiYVwiLFwiYlwiLFwiY1wiXSB0byBhIHNldCBvZiByYW5nZXMgZm9yIGJldHdlZW4vYWJvdmUvYmVsb3c6IFtbbWluS2V5LFwiYVwiXSwgW1wiYVwiLFwiYlwiXSwgW1wiYlwiLFwiY1wiXSwgW1wiY1wiLG1heEtleV1dXG4gICAgY29uc3QgcmFuZ2VzID0gc2V0LnJlZHVjZShcbiAgICAgIChyZXMsIHZhbCkgPT4gcmVzID9cbiAgICAgICAgcmVzLmNvbmNhdChbW3Jlc1tyZXMubGVuZ3RoIC0gMV1bMV0sIHZhbF1dKSA6XG4gICAgICAgIFtbbWluS2V5LCB2YWxdXSxcbiAgICAgIG51bGwpO1xuICAgIHJhbmdlcy5wdXNoKFtzZXRbc2V0Lmxlbmd0aCAtIDFdLCB0aGlzLmRiLl9tYXhLZXldKTtcbiAgICByZXR1cm4gdGhpcy5pbkFueVJhbmdlKHJhbmdlcywgeyBpbmNsdWRlTG93ZXJzOiBmYWxzZSwgaW5jbHVkZVVwcGVyczogZmFsc2UgfSk7XG4gIH1cblxuICAvKiogV2hlcmVDbGF1c2UuaW5BbnlSYW5nZSgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLmluQW55UmFuZ2UoKVxuICAgKiBcbiAgICoqL1xuICBpbkFueVJhbmdlKFxuICAgIHJhbmdlczogUmVhZG9ubHlBcnJheTx7IDA6IEluZGV4YWJsZVR5cGUsIDE6IEluZGV4YWJsZVR5cGUgfT4sXG4gICAgb3B0aW9ucz86IHsgaW5jbHVkZUxvd2Vycz86IGJvb2xlYW4sIGluY2x1ZGVVcHBlcnM/OiBib29sZWFuIH0pXG4gIHtcbiAgICBjb25zdCBjbXAgPSB0aGlzLl9jbXAsXG4gICAgICAgICAgYXNjZW5kaW5nID0gdGhpcy5fYXNjZW5kaW5nLFxuICAgICAgICAgIGRlc2NlbmRpbmcgPSB0aGlzLl9kZXNjZW5kaW5nLFxuICAgICAgICAgIG1pbiA9IHRoaXMuX21pbixcbiAgICAgICAgICBtYXggPSB0aGlzLl9tYXg7XG5cbiAgICBpZiAocmFuZ2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcbiAgICBpZiAoIXJhbmdlcy5ldmVyeShyYW5nZSA9PlxuICAgICAgcmFuZ2VbMF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgcmFuZ2VbMV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgYXNjZW5kaW5nKHJhbmdlWzBdLCByYW5nZVsxXSkgPD0gMCkpIHtcbiAgICAgIHJldHVybiBmYWlsKFxuICAgICAgICB0aGlzLFxuICAgICAgICBcIkZpcnN0IGFyZ3VtZW50IHRvIGluQW55UmFuZ2UoKSBtdXN0IGJlIGFuIEFycmF5IG9mIHR3by12YWx1ZSBBcnJheXMgW2xvd2VyLHVwcGVyXSB3aGVyZSB1cHBlciBtdXN0IG5vdCBiZSBsb3dlciB0aGFuIGxvd2VyXCIsXG4gICAgICAgIGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KTtcbiAgICB9XG4gICAgY29uc3QgaW5jbHVkZUxvd2VycyA9ICFvcHRpb25zIHx8IG9wdGlvbnMuaW5jbHVkZUxvd2VycyAhPT0gZmFsc2U7ICAgLy8gRGVmYXVsdCB0byB0cnVlXG4gICAgY29uc3QgaW5jbHVkZVVwcGVycyA9IG9wdGlvbnMgJiYgb3B0aW9ucy5pbmNsdWRlVXBwZXJzID09PSB0cnVlOyAgICAvLyBEZWZhdWx0IHRvIGZhbHNlXG5cbiAgICBmdW5jdGlvbiBhZGRSYW5nZShyYW5nZXMsIG5ld1JhbmdlKSB7XG4gICAgICBsZXQgaSA9IDAsIGwgPSByYW5nZXMubGVuZ3RoO1xuICAgICAgZm9yICg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSByYW5nZXNbaV07XG4gICAgICAgIGlmIChjbXAobmV3UmFuZ2VbMF0sIHJhbmdlWzFdKSA8IDAgJiYgY21wKG5ld1JhbmdlWzFdLCByYW5nZVswXSkgPiAwKSB7XG4gICAgICAgICAgcmFuZ2VbMF0gPSBtaW4ocmFuZ2VbMF0sIG5ld1JhbmdlWzBdKTtcbiAgICAgICAgICByYW5nZVsxXSA9IG1heChyYW5nZVsxXSwgbmV3UmFuZ2VbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaSA9PT0gbClcbiAgICAgICAgcmFuZ2VzLnB1c2gobmV3UmFuZ2UpO1xuICAgICAgcmV0dXJuIHJhbmdlcztcbiAgICB9XG5cbiAgICBsZXQgc29ydERpcmVjdGlvbiA9IGFzY2VuZGluZztcbiAgICBmdW5jdGlvbiByYW5nZVNvcnRlcihhLCBiKSB7IHJldHVybiBzb3J0RGlyZWN0aW9uKGFbMF0sIGJbMF0pOyB9XG5cbiAgICAvLyBKb2luIG92ZXJsYXBwaW5nIHJhbmdlc1xuICAgIGxldCBzZXQ7XG4gICAgdHJ5IHtcbiAgICAgIHNldCA9IHJhbmdlcy5yZWR1Y2UoYWRkUmFuZ2UsIFtdKTtcbiAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgcmV0dXJuIGZhaWwodGhpcywgSU5WQUxJRF9LRVlfQVJHVU1FTlQpO1xuICAgIH1cblxuICAgIGxldCByYW5nZVBvcyA9IDA7XG4gICAgY29uc3Qga2V5SXNCZXlvbmRDdXJyZW50RW50cnkgPSBpbmNsdWRlVXBwZXJzID9cbiAgICAgIGtleSA9PiBhc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA+IDAgOlxuICAgICAga2V5ID0+IGFzY2VuZGluZyhrZXksIHNldFtyYW5nZVBvc11bMV0pID49IDA7XG5cbiAgICBjb25zdCBrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeSA9IGluY2x1ZGVMb3dlcnMgP1xuICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+IDAgOlxuICAgICAga2V5ID0+IGRlc2NlbmRpbmcoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA+PSAwO1xuXG4gICAgZnVuY3Rpb24ga2V5V2l0aGluQ3VycmVudFJhbmdlKGtleSkge1xuICAgICAgcmV0dXJuICFrZXlJc0JleW9uZEN1cnJlbnRFbnRyeShrZXkpICYmICFrZXlJc0JlZm9yZUN1cnJlbnRFbnRyeShrZXkpO1xuICAgIH1cblxuICAgIGxldCBjaGVja0tleSA9IGtleUlzQmV5b25kQ3VycmVudEVudHJ5O1xuXG4gICAgY29uc3QgYyA9IG5ldyB0aGlzLkNvbGxlY3Rpb24oXG4gICAgICB0aGlzLFxuICAgICAgKCkgPT4gY3JlYXRlUmFuZ2Uoc2V0WzBdWzBdLCBzZXRbc2V0Lmxlbmd0aCAtIDFdWzFdLCAhaW5jbHVkZUxvd2VycywgIWluY2x1ZGVVcHBlcnMpKTtcblxuICAgIGMuX29uZGlyZWN0aW9uY2hhbmdlID0gZGlyZWN0aW9uID0+IHtcbiAgICAgIGlmIChkaXJlY3Rpb24gPT09IFwibmV4dFwiKSB7XG4gICAgICAgIGNoZWNrS2V5ID0ga2V5SXNCZXlvbmRDdXJyZW50RW50cnk7XG4gICAgICAgIHNvcnREaXJlY3Rpb24gPSBhc2NlbmRpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGVja0tleSA9IGtleUlzQmVmb3JlQ3VycmVudEVudHJ5O1xuICAgICAgICBzb3J0RGlyZWN0aW9uID0gZGVzY2VuZGluZztcbiAgICAgIH1cbiAgICAgIHNldC5zb3J0KHJhbmdlU29ydGVyKTtcbiAgICB9O1xuXG4gICAgYy5fYWRkQWxnb3JpdGhtKChjdXJzb3IsIGFkdmFuY2UsIHJlc29sdmUpID0+IHtcbiAgICAgIHZhciBrZXkgPSBjdXJzb3Iua2V5O1xuICAgICAgd2hpbGUgKGNoZWNrS2V5KGtleSkpIHtcbiAgICAgICAgLy8gVGhlIGN1cnNvciBoYXMgcGFzc2VkIGJleW9uZCB0aGlzIGtleS4gQ2hlY2sgbmV4dC5cbiAgICAgICAgKytyYW5nZVBvcztcbiAgICAgICAgaWYgKHJhbmdlUG9zID09PSBzZXQubGVuZ3RoKSB7XG4gICAgICAgICAgLy8gVGhlcmUgaXMgbm8gbmV4dC4gU3RvcCBzZWFyY2hpbmcuXG4gICAgICAgICAgYWR2YW5jZShyZXNvbHZlKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXlXaXRoaW5DdXJyZW50UmFuZ2Uoa2V5KSkge1xuICAgICAgICAvLyBUaGUgY3VycmVudCBjdXJzb3IgdmFsdWUgc2hvdWxkIGJlIGluY2x1ZGVkIGFuZCB3ZSBzaG91bGQgY29udGludWUgYSBzaW5nbGUgc3RlcCBpbiBjYXNlIG5leHQgaXRlbSBoYXMgdGhlIHNhbWUga2V5IG9yIHBvc3NpYmx5IG91ciBuZXh0IGtleSBpbiBzZXQuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzFdKSA9PT0gMCB8fCB0aGlzLl9jbXAoa2V5LCBzZXRbcmFuZ2VQb3NdWzBdKSA9PT0gMCkge1xuICAgICAgICAvLyBpbmNsdWRlVXBwZXIgb3IgaW5jbHVkZUxvd2VyIGlzIGZhbHNlIHNvIGtleVdpdGhpbkN1cnJlbnRSYW5nZSgpIHJldHVybnMgZmFsc2UgZXZlbiB0aG91Z2ggd2UgYXJlIGF0IHJhbmdlIGJvcmRlci5cbiAgICAgICAgLy8gQ29udGludWUgdG8gbmV4dCBrZXkgYnV0IGRvbid0IGluY2x1ZGUgdGhpcyBvbmUuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGN1cnNvci5rZXkgbm90IHlldCBhdCBzZXRbaV0uIEZvcndhcmQgY3Vyc29yIHRvIHRoZSBuZXh0IGtleSB0byBodW50IGZvci5cbiAgICAgICAgYWR2YW5jZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHNvcnREaXJlY3Rpb24gPT09IGFzY2VuZGluZykgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMF0pO1xuICAgICAgICAgIGVsc2UgY3Vyc29yLmNvbnRpbnVlKHNldFtyYW5nZVBvc11bMV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjO1xuICB9XG5cbiAgLyoqIFdoZXJlQ2xhdXNlLnN0YXJ0c1dpdGhBbnlPZigpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1doZXJlQ2xhdXNlL1doZXJlQ2xhdXNlLnN0YXJ0c1dpdGhBbnlPZigpXG4gICAqIFxuICAgKiovXG4gIHN0YXJ0c1dpdGhBbnlPZiguLi5wcmVmaXhlczogc3RyaW5nW10pOiBDb2xsZWN0aW9uO1xuICBzdGFydHNXaXRoQW55T2YocHJlZml4ZXM6IHN0cmluZ1tdKTogQ29sbGVjdGlvbjtcbiAgc3RhcnRzV2l0aEFueU9mKCkge1xuICAgIGNvbnN0IHNldCA9IGdldEFycmF5T2YuYXBwbHkoTk9fQ0hBUl9BUlJBWSwgYXJndW1lbnRzKTtcblxuICAgIGlmICghc2V0LmV2ZXJ5KHMgPT4gdHlwZW9mIHMgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICByZXR1cm4gZmFpbCh0aGlzLCBcInN0YXJ0c1dpdGhBbnlPZigpIG9ubHkgd29ya3Mgd2l0aCBzdHJpbmdzXCIpO1xuICAgIH1cbiAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIGVtcHR5Q29sbGVjdGlvbih0aGlzKTtcblxuICAgIHJldHVybiB0aGlzLmluQW55UmFuZ2Uoc2V0Lm1hcCgoc3RyOiBzdHJpbmcpID0+IFtzdHIsIHN0ciArIG1heFN0cmluZ10pKTtcbiAgfVxuXG59XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuLi9kZXhpZSc7XG5pbXBvcnQgeyBtYWtlQ2xhc3NDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9tYWtlLWNsYXNzLWNvbnN0cnVjdG9yJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlIH0gZnJvbSAnLi93aGVyZS1jbGF1c2UnO1xuaW1wb3J0IHsgVGFibGUgfSBmcm9tICcuLi90YWJsZSc7XG5pbXBvcnQgeyBDb2xsZWN0aW9uIH0gZnJvbSAnLi4vY29sbGVjdGlvbic7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIHtcbiAgbmV3KHRhYmxlOiBUYWJsZSwgaW5kZXg/OiBzdHJpbmcsIG9yQ29sbGVjdGlvbj86IENvbGxlY3Rpb24pOiBXaGVyZUNsYXVzZTtcbiAgcHJvdG90eXBlOiBXaGVyZUNsYXVzZTtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFdoZXJlQ2xhdXNlIGNvbnN0cnVjdG9yLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlV2hlcmVDbGF1c2VDb25zdHJ1Y3RvcihkYjogRGV4aWUpIHtcbiAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFdoZXJlQ2xhdXNlQ29uc3RydWN0b3I+KFxuICAgIFdoZXJlQ2xhdXNlLnByb3RvdHlwZSxcblxuICAgIGZ1bmN0aW9uIFdoZXJlQ2xhdXNlKHRoaXM6IFdoZXJlQ2xhdXNlLCB0YWJsZTogVGFibGUsIGluZGV4Pzogc3RyaW5nLCBvckNvbGxlY3Rpb24/OiBDb2xsZWN0aW9uKSB7XG4gICAgICB0aGlzLmRiID0gZGI7XG4gICAgICB0aGlzLl9jdHggPSB7XG4gICAgICAgIHRhYmxlOiB0YWJsZSxcbiAgICAgICAgaW5kZXg6IGluZGV4ID09PSBcIjppZFwiID8gbnVsbCA6IGluZGV4LFxuICAgICAgICBvcjogb3JDb2xsZWN0aW9uXG4gICAgICB9O1xuICAgICAgY29uc3QgaW5kZXhlZERCID0gZGIuX2RlcHMuaW5kZXhlZERCO1xuICAgICAgaWYgKCFpbmRleGVkREIpIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKTtcbiAgICAgIHRoaXMuX2NtcCA9IHRoaXMuX2FzY2VuZGluZyA9IGluZGV4ZWREQi5jbXAuYmluZChpbmRleGVkREIpO1xuICAgICAgdGhpcy5fZGVzY2VuZGluZyA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGIsIGEpO1xuICAgICAgdGhpcy5fbWF4ID0gKGEsIGIpID0+IGluZGV4ZWREQi5jbXAoYSxiKSA+IDAgPyBhIDogYjtcbiAgICAgIHRoaXMuX21pbiA9IChhLCBiKSA9PiBpbmRleGVkREIuY21wKGEsYikgPCAwID8gYSA6IGI7XG4gICAgICB0aGlzLl9JREJLZXlSYW5nZSA9IGRiLl9kZXBzLklEQktleVJhbmdlO1xuICAgIH1cbiAgKTtcbn1cbiIsICJpbXBvcnQgeyB3cmFwIH0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdCkge1xuICByZXR1cm4gd3JhcChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgIHJlamVjdCAoZXZlbnQudGFyZ2V0LmVycm9yKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBldmVudFN1Y2Nlc3NIYW5kbGVyIChyZXNvbHZlKSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCl7XG4gICAgICByZXNvbHZlKGV2ZW50LnRhcmdldC5yZXN1bHQpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciAocmVqZWN0KSB7XG4gIHJldHVybiB3cmFwKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgLy8gU2VlIGNvbW1lbnQgb24gaG9va2VkRXZlbnRTdWNjZXNzSGFuZGxlcigpIHdoeSB3cmFwKCkgaXMgbmVlZGVkIG9ubHkgd2hlbiBzdXBwb3J0aW5nIGhvb2tzLlxuICAgICAgXG4gICAgICB2YXIgcmVxID0gZXZlbnQudGFyZ2V0LFxuICAgICAgICAgIGVyciA9IHJlcS5lcnJvcixcbiAgICAgICAgICBjdHggPSByZXEuX2hvb2tDdHgsLy8gQ29udGFpbnMgdGhlIGhvb2sgZXJyb3IgaGFuZGxlci4gUHV0IGhlcmUgaW5zdGVhZCBvZiBjbG9zdXJlIHRvIGJvb3N0IHBlcmZvcm1hbmNlLlxuICAgICAgICAgIGhvb2tFcnJvckhhbmRsZXIgPSBjdHggJiYgY3R4Lm9uZXJyb3I7XG4gICAgICBob29rRXJyb3JIYW5kbGVyICYmIGhvb2tFcnJvckhhbmRsZXIoZXJyKTtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2ZW50KTtcbiAgICAgIHJlamVjdCAoZXJyKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob29rZWRFdmVudFN1Y2Nlc3NIYW5kbGVyKHJlc29sdmUpIHtcbiAgLy8gd3JhcCgpIGlzIG5lZWRlZCB3aGVuIGNhbGxpbmcgaG9va3MgYmVjYXVzZSB0aGUgcmFyZSBzY2VuYXJpbyBvZjpcbiAgLy8gICogaG9vayBkb2VzIGEgZGIgb3BlcmF0aW9uIHRoYXQgZmFpbHMgaW1tZWRpYXRlbHkgKElEQiB0aHJvd3MgZXhjZXB0aW9uKVxuICAvLyAgICBGb3IgY2FsbGluZyBkYiBvcGVyYXRpb25zIG9uIGNvcnJlY3QgdHJhbnNhY3Rpb24sIHdyYXAgbWFrZXMgc3VyZSB0byBzZXQgUFNEIGNvcnJlY3RseS5cbiAgLy8gICAgd3JhcCgpIHdpbGwgYWxzbyBleGVjdXRlIGluIGEgdmlydHVhbCB0aWNrLlxuICAvLyAgKiBJZiBub3Qgd3JhcHBlZCBpbiBhIHZpcnR1YWwgdGljaywgZGlyZWN0IGV4Y2VwdGlvbiB3aWxsIGxhdW5jaCBhIG5ldyBwaHlzaWNhbCB0aWNrLlxuICAvLyAgKiBJZiB0aGlzIHdhcyB0aGUgbGFzdCBldmVudCBpbiB0aGUgYnVsaywgdGhlIHByb21pc2Ugd2lsbCByZXNvbHZlIGFmdGVyIGEgcGh5c2ljYWwgdGlja1xuICAvLyAgICBhbmQgdGhlIHRyYW5zYWN0aW9uIHdpbGwgaGF2ZSBjb21taXR0ZWQgYWxyZWFkeS5cbiAgLy8gSWYgbm8gaG9vaywgdGhlIHZpcnR1YWwgdGljayB3aWxsIGJlIGV4ZWN1dGVkIGluIHRoZSByZWplY3QoKS9yZXNvbHZlIG9mIHRoZSBmaW5hbCBwcm9taXNlLFxuICAvLyBiZWNhdXNlIGl0IGlzIGFsd2F5cyBtYXJrZWQgd2l0aCBfbGliID0gdHJ1ZSB3aGVuIGNyZWF0ZWQgdXNpbmcgVHJhbnNhY3Rpb24uX3Byb21pc2UoKS5cbiAgcmV0dXJuIHdyYXAoZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgIHZhciByZXEgPSBldmVudC50YXJnZXQsXG4gICAgICAgICAgY3R4ID0gcmVxLl9ob29rQ3R4LC8vIENvbnRhaW5zIHRoZSBob29rIGVycm9yIGhhbmRsZXIuIFB1dCBoZXJlIGluc3RlYWQgb2YgY2xvc3VyZSB0byBib29zdCBwZXJmb3JtYW5jZS5cbiAgICAgICAgICByZXN1bHQgPSBjdHgudmFsdWUgfHwgcmVxLnJlc3VsdCwgLy8gUGFzcyB0aGUgb2JqZWN0IHZhbHVlIG9uIHVwZGF0ZXMuIFRoZSByZXN1bHQgZnJvbSBJREIgaXMgdGhlIHByaW1hcnkga2V5LlxuICAgICAgICAgIGhvb2tTdWNjZXNzSGFuZGxlciA9IGN0eCAmJiBjdHgub25zdWNjZXNzO1xuICAgICAgaG9va1N1Y2Nlc3NIYW5kbGVyICYmIGhvb2tTdWNjZXNzSGFuZGxlcihyZXN1bHQpO1xuICAgICAgcmVzb2x2ZSAmJiByZXNvbHZlKHJlc3VsdCk7XG4gIH0sIHJlc29sdmUpO1xufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBwcmV2ZW50RGVmYXVsdChldmVudCkge1xuICBpZiAoZXZlbnQuc3RvcFByb3BhZ2F0aW9uKSAvLyBJbmRleGVkREJTaGltIGRvZXNudCBzdXBwb3J0IHRoaXMgb24gU2FmYXJpIDggYW5kIGJlbG93LlxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkgLy8gSW5kZXhlZERCU2hpbSBkb2VzbnQgc3VwcG9ydCB0aGlzIG9uIFNhZmFyaSA4IGFuZCBiZWxvdy5cbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCdWxrRXJyb3JIYW5kbGVyQ2F0Y2hBbGwoZXJyb3JMaXN0LCBkb25lPywgc3VwcG9ydEhvb2tzPykge1xuICByZXR1cm4gKHN1cHBvcnRIb29rcyA/IGhvb2tlZEV2ZW50UmVqZWN0SGFuZGxlciA6IGV2ZW50UmVqZWN0SGFuZGxlcikoZSA9PiB7XG4gICAgICBlcnJvckxpc3QucHVzaChlKTtcbiAgICAgIGRvbmUgJiYgZG9uZSgpO1xuICB9KTtcbn1cblxuIiwgImltcG9ydCBFdmVudHMgZnJvbSAnLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IHsgR2xvYmFsRGV4aWVFdmVudHMgfSBmcm9tICcuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzJztcblxuZXhwb3J0IGNvbnN0IERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FID0gJ3N0b3JhZ2VtdXRhdGVkJyBhcyAnc3RvcmFnZW11dGF0ZWQnO1xuXG4vLyBOYW1lIG9mIHRoZSBnbG9iYWwgZXZlbnQgZmlyZWQgdXNpbmcgRE9NIGRpc3BhdGNoRXZlbnQgKGlmIG5vdCBpbiBub2RlKS5cbi8vIFJlYXNvbiBmb3IgcHJvcGFnYXRpbmcgdGhpcyBhcyBhIERPTSBldmVudCBpcyBmb3IgZ2V0dGluZyByZWFjdGl2aXR5IGFjcm9zc1xuLy8gbXVsdGlwbGUgdmVyc2lvbnMgb2YgRGV4aWUgd2l0aGluIHRoZSBzYW1lIGFwcCAoYXMgbG9uZyBhcyB0aGV5IGFyZVxuLy8gY29tcGF0aWJsZSB3aXRoIHJlZ2FyZHMgdG8gdGhlIGV2ZW50IGRhdGEpLlxuLy8gSWYgdGhlIE9ic2VydmFiaWxpdHlTZXQgcHJvdG9jb2wgY2hhbmdlIGluIGEgd2F5IHRoYXQgd291bGQgbm90IGJlIGJhY2t3YXJkXG4vLyBjb21wYXRpYmxlLCBtYWtlIHN1cmUgYWxzbyB1cGRhdGUgdGhlIGV2ZW50IG5hbWUgdG8gYSBuZXcgbnVtYmVyIGF0IHRoZSBlbmRcbi8vIHNvIHRoYXQgdHdvIERleGllIGluc3RhbmNlcyBvZiBkaWZmZXJlbnQgdmVyc2lvbnMgY29udGludWUgdG8gd29yayB0b2dldGhlclxuLy8gIC0gbWF5YmUgbm90IGFibGUgdG8gY29tbXVuaWNhdGUgYnV0IHdvbid0IGZhaWwgZHVlIHRvIHVuZXhwZWN0ZWQgZGF0YSBpblxuLy8gdGhlIGRldGFpbCBwcm9wZXJ0eSBvZiB0aGUgQ3VzdG9tRXZlbnQuIElmIHNvLCBhbHNvIG1ha2Ugc3VyZSB0byB1ZHBhdGVcbi8vIGRvY3MgYW5kIGV4cGxhaW4gYXQgd2hpY2ggRGV4aWUgdmVyc2lvbiB0aGUgbmV3IG5hbWUgYW5kIGZvcm1hdCBvZiB0aGUgZXZlbnRcbi8vIGlzIGJlaW5nIHVzZWQuXG5leHBvcnQgY29uc3QgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FID0gJ3gtc3RvcmFnZW11dGF0ZWQtMSc7XG5cbmV4cG9ydCBjb25zdCBnbG9iYWxFdmVudHMgPSBFdmVudHMobnVsbCwgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUpIGFzIEdsb2JhbERleGllRXZlbnRzO1xuIiwgImltcG9ydCB7IFRyYW5zYWN0aW9uIGFzIElUcmFuc2FjdGlvbiB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBEZXhpZVByb21pc2UsIHdyYXAsIHJlamVjdGlvbiB9IGZyb20gXCIuLi8uLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgeyBhc3NlcnQsIGhhc093biB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBQU0QsIHVzZVBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgc2FmYXJpTXVsdGlTdG9yZUZpeCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgbmV3U2NvcGUgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0ICogYXMgRGVidWcgZnJvbSAnLi4vLi4vaGVscGVycy9kZWJ1Zyc7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gJy4uL3RhYmxlJztcbmltcG9ydCB7IGdsb2JhbEV2ZW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5cbi8qKiBUcmFuc2FjdGlvblxuICogXG4gKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uXG4gKiBcbiAqKi9cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbiBpbXBsZW1lbnRzIElUcmFuc2FjdGlvbiB7XG4gIGRiOiBEZXhpZTtcbiAgYWN0aXZlOiBib29sZWFuO1xuICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGU7XG4gIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTogQ2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5O1xuICBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb247XG4gIHN0b3JlTmFtZXM6IHN0cmluZ1tdO1xuICBvbjogYW55O1xuICBwYXJlbnQ/OiBUcmFuc2FjdGlvbjtcbiAgc2NoZW1hOiBEYlNjaGVtYTtcbiAgX21lbW9pemVkVGFibGVzOiB7W3RhYmxlTmFtZTogc3RyaW5nXTogVGFibGV9O1xuXG4gIF9yZWN1bG9jazogbnVtYmVyO1xuICBfYmxvY2tlZEZ1bmNzOiB7IDA6ICgpID0+IGFueSwgMTogYW55IH1bXTtcbiAgX3Jlc29sdmU6ICgpID0+IHZvaWQ7XG4gIF9yZWplY3Q6IChFcnJvcikgPT4gdm9pZDtcbiAgX3dhaXRpbmdGb3I6IERleGllUHJvbWlzZTsgLy8gZm9yIHdhaXRGb3IoKVxuICBfd2FpdGluZ1F1ZXVlOiBGdW5jdGlvbltdOyAvLyBmb3Igd2FpdEZvcigpXG4gIF9zcGluQ291bnQ6IG51bWJlcjsgLy8gSnVzdCBmb3IgZGVidWdnaW5nIHdhaXRGb3IoKVxuICBfY29tcGxldGlvbjogRGV4aWVQcm9taXNlO1xuXG4gIC8vXG4gIC8vIFRyYW5zYWN0aW9uIGludGVybmFsIG1ldGhvZHMgKG5vdCByZXF1aXJlZCBieSBBUEkgdXNlcnMsIGJ1dCBuZWVkZWQgaW50ZXJuYWxseSBhbmQgZXZlbnR1YWxseSBieSBkZXhpZSBleHRlbnNpb25zKVxuICAvL1xuXG4gIC8qKiBUcmFuc2FjdGlvbi5fbG9jaygpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuXG4gICAqL1xuICBfbG9jaygpIHtcbiAgICBhc3NlcnQoIVBTRC5nbG9iYWwpOyAvLyBMb2NraW5nIGFuZCB1bmxvY2tpbmcgcmV1aXJlcyB0byBiZSB3aXRoaW4gYSBQU0Qgc2NvcGUuXG4gICAgLy8gVGVtcG9yYXJ5IHNldCBhbGwgcmVxdWVzdHMgaW50byBhIHBlbmRpbmcgcXVldWUgaWYgdGhleSBhcmUgY2FsbGVkIGJlZm9yZSBkYXRhYmFzZSBpcyByZWFkeS5cbiAgICArK3RoaXMuX3JlY3Vsb2NrOyAvLyBSZWN1cnNpdmUgcmVhZC93cml0ZSBsb2NrIHBhdHRlcm4gdXNpbmcgUFNEIChQcm9taXNlIFNwZWNpZmljIERhdGEpIGluc3RlYWQgb2YgVExTIChUaHJlYWQgTG9jYWwgU3RvcmFnZSlcbiAgICBpZiAodGhpcy5fcmVjdWxvY2sgPT09IDEgJiYgIVBTRC5nbG9iYWwpIFBTRC5sb2NrT3duZXJGb3IgPSB0aGlzO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLl91bmxvY2soKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKi9cbiAgX3VubG9jaygpIHtcbiAgICBhc3NlcnQoIVBTRC5nbG9iYWwpOyAvLyBMb2NraW5nIGFuZCB1bmxvY2tpbmcgcmV1aXJlcyB0byBiZSB3aXRoaW4gYSBQU0Qgc2NvcGUuXG4gICAgaWYgKC0tdGhpcy5fcmVjdWxvY2sgPT09IDApIHtcbiAgICAgIGlmICghUFNELmdsb2JhbCkgUFNELmxvY2tPd25lckZvciA9IG51bGw7XG4gICAgICB3aGlsZSAodGhpcy5fYmxvY2tlZEZ1bmNzLmxlbmd0aCA+IDAgJiYgIXRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICAgIHZhciBmbkFuZFBTRCA9IHRoaXMuX2Jsb2NrZWRGdW5jcy5zaGlmdCgpO1xuICAgICAgICB0cnkgeyB1c2VQU0QoZm5BbmRQU0RbMV0sIGZuQW5kUFNEWzBdKTsgfSBjYXRjaCAoZSkgeyB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLl9sb2NrKClcbiAgICogXG4gICAqIEludGVybmFsIG1ldGhvZC5cbiAgICovXG4gIF9sb2NrZWQoKSB7XG4gICAgLy8gQ2hlY2tzIGlmIGFueSB3cml0ZS1sb2NrIGlzIGFwcGxpZWQgb24gdGhpcyB0cmFuc2FjdGlvbi5cbiAgICAvLyBUbyBzaW1wbGlmeSB0aGUgRGV4aWUgQVBJIGZvciBleHRlbnNpb24gaW1wbGVtZW50YXRpb25zLCB3ZSBzdXBwb3J0IHJlY3Vyc2l2ZSBsb2Nrcy5cbiAgICAvLyBUaGlzIGlzIGFjY29tcGxpc2hlZCBieSB1c2luZyBcIlByb21pc2UgU3BlY2lmaWMgRGF0YVwiIChQU0QpLlxuICAgIC8vIFBTRCBkYXRhIGlzIGJvdW5kIHRvIGEgUHJvbWlzZSBhbmQgYW55IGNoaWxkIFByb21pc2UgZW1pdHRlZCB0aHJvdWdoIHRoZW4oKSBvciByZXNvbHZlKCBuZXcgUHJvbWlzZSgpICkuXG4gICAgLy8gUFNEIGlzIGxvY2FsIHRvIGNvZGUgZXhlY3V0aW5nIG9uIHRvcCBvZiB0aGUgY2FsbCBzdGFja3Mgb2YgYW55IG9mIGFueSBjb2RlIGV4ZWN1dGVkIGJ5IFByb21pc2UoKTpcbiAgICAvLyAgICAgICAgICogY2FsbGJhY2sgZ2l2ZW4gdG8gdGhlIFByb21pc2UoKSBjb25zdHJ1Y3RvciAgKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3Qpey4uLn0pXG4gICAgLy8gICAgICAgICAqIGNhbGxiYWNrcyBnaXZlbiB0byB0aGVuKCkvY2F0Y2goKS9maW5hbGx5KCkgbWV0aG9kcyAoZnVuY3Rpb24gKHZhbHVlKXsuLi59KVxuICAgIC8vIElmIGNyZWF0aW5nIGEgbmV3IGluZGVwZW5kYW50IFByb21pc2UgaW5zdGFuY2UgZnJvbSB3aXRoaW4gYSBQcm9taXNlIGNhbGwgc3RhY2ssIHRoZSBuZXcgUHJvbWlzZSB3aWxsIGRlcml2ZSB0aGUgUFNEIGZyb20gdGhlIGNhbGwgc3RhY2sgb2YgdGhlIHBhcmVudCBQcm9taXNlLlxuICAgIC8vIERlcml2YXRpb24gaXMgZG9uZSBzbyB0aGF0IHRoZSBpbm5lciBQU0QgX19wcm90b19fIHBvaW50cyB0byB0aGUgb3V0ZXIgUFNELlxuICAgIC8vIFBTRC5sb2NrT3duZXJGb3Igd2lsbCBwb2ludCB0byBjdXJyZW50IHRyYW5zYWN0aW9uIG9iamVjdCBpZiB0aGUgY3VycmVudGx5IGV4ZWN1dGluZyBQU0Qgc2NvcGUgb3ducyB0aGUgbG9jay5cbiAgICByZXR1cm4gdGhpcy5fcmVjdWxvY2sgJiYgUFNELmxvY2tPd25lckZvciAhPT0gdGhpcztcbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi5jcmVhdGUoKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKiBcbiAgICovXG4gIGNyZWF0ZShpZGJ0cmFucz86IElEQlRyYW5zYWN0aW9uKSB7XG4gICAgaWYgKCF0aGlzLm1vZGUpIHJldHVybiB0aGlzO1xuICAgIGNvbnN0IGlkYmRiID0gdGhpcy5kYi5pZGJkYjtcbiAgICBjb25zdCBkYk9wZW5FcnJvciA9IHRoaXMuZGIuX3N0YXRlLmRiT3BlbkVycm9yO1xuICAgIGFzc2VydCghdGhpcy5pZGJ0cmFucyk7XG4gICAgaWYgKCFpZGJ0cmFucyAmJiAhaWRiZGIpIHtcbiAgICAgIHN3aXRjaCAoZGJPcGVuRXJyb3IgJiYgZGJPcGVuRXJyb3IubmFtZSkge1xuICAgICAgICBjYXNlIFwiRGF0YWJhc2VDbG9zZWRFcnJvclwiOlxuICAgICAgICAgIC8vIEVycm9ycyB3aGVyZSBpdCBpcyBubyBkaWZmZXJlbmNlIHdoZXRoZXIgaXQgd2FzIGNhdXNlZCBieSB0aGUgdXNlciBvcGVyYXRpb24gb3IgYW4gZWFybGllciBjYWxsIHRvIGRiLm9wZW4oKVxuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkRhdGFiYXNlQ2xvc2VkKGRiT3BlbkVycm9yKTtcbiAgICAgICAgY2FzZSBcIk1pc3NpbmdBUElFcnJvclwiOlxuICAgICAgICAgIC8vIEVycm9ycyB3aGVyZSBpdCBpcyBubyBkaWZmZXJlbmNlIHdoZXRoZXIgaXQgd2FzIGNhdXNlZCBieSB0aGUgdXNlciBvcGVyYXRpb24gb3IgYW4gZWFybGllciBjYWxsIHRvIGRiLm9wZW4oKVxuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoZGJPcGVuRXJyb3IubWVzc2FnZSwgZGJPcGVuRXJyb3IpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIE1ha2UgaXQgY2xlYXIgdGhhdCB0aGUgdXNlciBvcGVyYXRpb24gd2FzIG5vdCB3aGF0IGNhdXNlZCB0aGUgZXJyb3IgLSB0aGUgZXJyb3IgaGFkIG9jY3VycmVkIGVhcmxpZXIgb24gZGIub3BlbigpIVxuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLk9wZW5GYWlsZWQoZGJPcGVuRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuYWN0aXZlKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCk7XG4gICAgYXNzZXJ0KHRoaXMuX2NvbXBsZXRpb24uX3N0YXRlID09PSBudWxsKTsgLy8gQ29tcGxldGlvbiBQcm9taXNlIG11c3Qgc3RpbGwgYmUgcGVuZGluZy5cblxuICAgIGlkYnRyYW5zID0gdGhpcy5pZGJ0cmFucyA9IGlkYnRyYW5zIHx8XG4gICAgICAodGhpcy5kYi5jb3JlIFxuICAgICAgICA/IHRoaXMuZGIuY29yZS50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSBhcyAncmVhZHdyaXRlJyB8ICdyZWFkb25seScsIHsgZHVyYWJpbGl0eTogdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgfSlcbiAgICAgICAgOiBpZGJkYi50cmFuc2FjdGlvbih0aGlzLnN0b3JlTmFtZXMsIHRoaXMubW9kZSwgeyBkdXJhYmlsaXR5OiB0aGlzLmNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eSB9KVxuICAgICAgKSBhcyBJREJUcmFuc2FjdGlvbjtcblxuICAgIGlkYnRyYW5zLm9uZXJyb3IgPSB3cmFwKGV2ID0+IHtcbiAgICAgIHByZXZlbnREZWZhdWx0KGV2KTsvLyBQcm9oaWJpdCBkZWZhdWx0IGJ1YmJsaW5nIHRvIHdpbmRvdy5lcnJvclxuICAgICAgdGhpcy5fcmVqZWN0KGlkYnRyYW5zLmVycm9yKTtcbiAgICB9KTtcbiAgICBpZGJ0cmFucy5vbmFib3J0ID0gd3JhcChldiA9PiB7XG4gICAgICBwcmV2ZW50RGVmYXVsdChldik7XG4gICAgICB0aGlzLmFjdGl2ZSAmJiB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoaWRidHJhbnMuZXJyb3IpKTtcbiAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICB0aGlzLm9uKFwiYWJvcnRcIikuZmlyZShldik7XG4gICAgfSk7XG4gICAgaWRidHJhbnMub25jb21wbGV0ZSA9IHdyYXAoKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Jlc29sdmUoKTtcbiAgICAgIGlmICgnbXV0YXRlZFBhcnRzJyBpbiBpZGJ0cmFucykge1xuICAgICAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZShpZGJ0cmFuc1tcIm11dGF0ZWRQYXJ0c1wiXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24uX3Byb21pc2UoKVxuICAgKiBcbiAgICogSW50ZXJuYWwgbWV0aG9kLlxuICAgKi9cbiAgX3Byb21pc2UoXG4gICAgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICAgIGZuOiAocmVzb2x2ZSwgcmVqZWN0LCB0cmFuczogVHJhbnNhY3Rpb24pID0+IFByb21pc2VMaWtlPGFueT4gfCB2b2lkLFxuICAgIGJXcml0ZUxvY2s/OiBzdHJpbmcgfCBib29sZWFuKTogRGV4aWVQcm9taXNlXG4gIHtcbiAgICBpZiAobW9kZSA9PT0gJ3JlYWR3cml0ZScgJiYgdGhpcy5tb2RlICE9PSAncmVhZHdyaXRlJylcbiAgICAgIHJldHVybiByZWplY3Rpb24obmV3IGV4Y2VwdGlvbnMuUmVhZE9ubHkoXCJUcmFuc2FjdGlvbiBpcyByZWFkb25seVwiKSk7XG5cbiAgICBpZiAoIXRoaXMuYWN0aXZlKVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihuZXcgZXhjZXB0aW9ucy5UcmFuc2FjdGlvbkluYWN0aXZlKCkpO1xuXG4gICAgaWYgKHRoaXMuX2xvY2tlZCgpKSB7XG4gICAgICByZXR1cm4gbmV3IERleGllUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuX2Jsb2NrZWRGdW5jcy5wdXNoKFsoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fcHJvbWlzZShtb2RlLCBmbiwgYldyaXRlTG9jaykudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCBQU0RdKTtcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChiV3JpdGVMb2NrKSB7XG4gICAgICByZXR1cm4gbmV3U2NvcGUoKCkgPT4ge1xuICAgICAgICB2YXIgcCA9IG5ldyBEZXhpZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2xvY2soKTtcbiAgICAgICAgICBjb25zdCBydiA9IGZuKHJlc29sdmUsIHJlamVjdCwgdGhpcyk7XG4gICAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHAuZmluYWxseSgoKSA9PiB0aGlzLl91bmxvY2soKSk7XG4gICAgICAgIHAuX2xpYiA9IHRydWU7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHAgPSBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgdmFyIHJ2ID0gZm4ocmVzb2x2ZSwgcmVqZWN0LCB0aGlzKTtcbiAgICAgICAgaWYgKHJ2ICYmIHJ2LnRoZW4pIHJ2LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcC5fbGliID0gdHJ1ZTtcbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBUcmFuc2FjdGlvbi5fcm9vdCgpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuIFJldHJpZXZlcyB0aGUgcm9vdCB0cmFuc2FjdGlvbiBpbiB0aGUgdHJlZSBvZiBzdWIgdHJhbnNhY3Rpb25zLlxuICAgKi9cbiAgX3Jvb3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50ID8gdGhpcy5wYXJlbnQuX3Jvb3QoKSA6IHRoaXM7XG4gIH1cblxuICAvKiogVHJhbnNhY3Rpb24ud2FpdEZvcigpXG4gICAqIFxuICAgKiBJbnRlcm5hbCBtZXRob2QuIENhbiBiZSBhY2Nlc3NlZCBmcm9tIHRoZSBwdWJsaWMgQVBJIHRocm91Z2hcbiAgICogRGV4aWUud2FpdEZvcigpOiBodHRwczovL2RleGllLm9yZy9kb2NzL0RleGllL0RleGllLndhaXRGb3IoKVxuICAgKiBcbiAgICoqL1xuICB3YWl0Rm9yKHByb21pc2VMaWtlOiBQcm9taXNlTGlrZTxhbnk+KSB7XG4gICAgLy8gQWx3YXlzIG9wZXJhdGUgb24gdGhlIHJvb3QgdHJhbnNhY3Rpb24gKGluIGNhc2UgdGhpcyBpcyBhIHN1YiBzdHJhbnNhY3Rpb24pXG4gICAgdmFyIHJvb3QgPSB0aGlzLl9yb290KCk7XG4gICAgLy8gRm9yIHN0YWJpbGl0eSByZWFzb25zLCBjb252ZXJ0IHBhcmFtZXRlciB0byBwcm9taXNlIG5vIG1hdHRlciB3aGF0IHR5cGUgaXMgcGFzc2VkIHRvIHdhaXRGb3IoKS5cbiAgICAvLyAoV2UgbXVzdCBiZSBhYmxlIHRvIGNhbGwgLnRoZW4oKSBvbiBpdC4pXG4gICAgY29uc3QgcHJvbWlzZSA9IERleGllUHJvbWlzZS5yZXNvbHZlKHByb21pc2VMaWtlKTtcbiAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikge1xuICAgICAgLy8gQWxyZWFkeSBjYWxsZWQgd2FpdEZvcigpLiBXYWl0IGZvciBib3RoIHRvIGNvbXBsZXRlLlxuICAgICAgcm9vdC5fd2FpdGluZ0ZvciA9IHJvb3QuX3dhaXRpbmdGb3IudGhlbigoKSA9PiBwcm9taXNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UncmUgbm90IGluIHdhaXRpbmcgc3RhdGUuIFN0YXJ0IHdhaXRpbmcgc3RhdGUuXG4gICAgICByb290Ll93YWl0aW5nRm9yID0gcHJvbWlzZTtcbiAgICAgIHJvb3QuX3dhaXRpbmdRdWV1ZSA9IFtdO1xuICAgICAgLy8gU3RhcnQgaW50ZXJhY3Rpbmcgd2l0aCBpbmRleGVkREIgdW50aWwgcHJvbWlzZSBjb21wbGV0ZXM6XG4gICAgICB2YXIgc3RvcmUgPSByb290LmlkYnRyYW5zLm9iamVjdFN0b3JlKHJvb3Quc3RvcmVOYW1lc1swXSk7XG4gICAgICAoZnVuY3Rpb24gc3BpbigpIHtcbiAgICAgICAgKytyb290Ll9zcGluQ291bnQ7IC8vIEZvciBkZWJ1Z2dpbmcgb25seVxuICAgICAgICB3aGlsZSAocm9vdC5fd2FpdGluZ1F1ZXVlLmxlbmd0aCkgKHJvb3QuX3dhaXRpbmdRdWV1ZS5zaGlmdCgpKSgpO1xuICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0Zvcikgc3RvcmUuZ2V0KC1JbmZpbml0eSkub25zdWNjZXNzID0gc3BpbjtcbiAgICAgIH0oKSk7XG4gICAgfVxuICAgIHZhciBjdXJyZW50V2FpdFByb21pc2UgPSByb290Ll93YWl0aW5nRm9yO1xuICAgIHJldHVybiBuZXcgRGV4aWVQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHByb21pc2UudGhlbihcbiAgICAgICAgcmVzID0+IHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVzb2x2ZS5iaW5kKG51bGwsIHJlcykpKSxcbiAgICAgICAgZXJyID0+IHJvb3QuX3dhaXRpbmdRdWV1ZS5wdXNoKHdyYXAocmVqZWN0LmJpbmQobnVsbCwgZXJyKSkpXG4gICAgICApLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICBpZiAocm9vdC5fd2FpdGluZ0ZvciA9PT0gY3VycmVudFdhaXRQcm9taXNlKSB7XG4gICAgICAgICAgLy8gTm8gb25lIGFkZGVkIGEgd2FpdCBhZnRlciB1cy4gU2FmZSB0byBzdG9wIHRoZSBzcGlubmluZy5cbiAgICAgICAgICByb290Ll93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0gIFxuXG4gIC8qKiBUcmFuc2FjdGlvbi5hYm9ydCgpXG4gICAqIFxuICAgKiBodHRwczovL2RleGllLm9yZy9kb2NzL1RyYW5zYWN0aW9uL1RyYW5zYWN0aW9uLmFib3J0KClcbiAgICovXG4gIGFib3J0KCkge1xuICAgIGlmICh0aGlzLmFjdGl2ZSkge1xuICAgICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgIGlmICh0aGlzLmlkYnRyYW5zKSB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICB0aGlzLl9yZWplY3QobmV3IGV4Y2VwdGlvbnMuQWJvcnQoKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqIFRyYW5zYWN0aW9uLnRhYmxlKClcbiAgICogXG4gICAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVHJhbnNhY3Rpb24vVHJhbnNhY3Rpb24udGFibGUoKVxuICAgKi9cbiAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICBjb25zdCBtZW1vaXplZFRhYmxlcyA9ICh0aGlzLl9tZW1vaXplZFRhYmxlcyB8fCAodGhpcy5fbWVtb2l6ZWRUYWJsZXMgPSB7fSkpO1xuICAgIGlmIChoYXNPd24obWVtb2l6ZWRUYWJsZXMsIHRhYmxlTmFtZSkpXG4gICAgICByZXR1cm4gbWVtb2l6ZWRUYWJsZXNbdGFibGVOYW1lXTtcbiAgICBjb25zdCB0YWJsZVNjaGVtYSA9IHRoaXMuc2NoZW1hW3RhYmxlTmFtZV07XG4gICAgaWYgKCF0YWJsZVNjaGVtYSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTm90Rm91bmQoXCJUYWJsZSBcIiArIHRhYmxlTmFtZSArIFwiIG5vdCBwYXJ0IG9mIHRyYW5zYWN0aW9uXCIpOyAgICAgICAgXG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlID0gbmV3IHRoaXMuZGIuVGFibGUodGFibGVOYW1lLCB0YWJsZVNjaGVtYSwgdGhpcyk7XG4gICAgdHJhbnNhY3Rpb25Cb3VuZFRhYmxlLmNvcmUgPSB0aGlzLmRiLmNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICBtZW1vaXplZFRhYmxlc1t0YWJsZU5hbWVdID0gdHJhbnNhY3Rpb25Cb3VuZFRhYmxlO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbkJvdW5kVGFibGU7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IG1ha2VDbGFzc0NvbnN0cnVjdG9yIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL21ha2UtY2xhc3MtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4uLy4uL2hlbHBlcnMvRXZlbnRzJztcbmltcG9ydCBQcm9taXNlLCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcjxUIGV4dGVuZHMgVHJhbnNhY3Rpb249VHJhbnNhY3Rpb24+IHtcbiAgbmV3IChcbiAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgc3RvcmVOYW1lczogc3RyaW5nW10sXG4gICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTogQ2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LFxuICAgIHBhcmVudD86IFRyYW5zYWN0aW9uKSA6IFQ7XG4gIHByb3RvdHlwZTogVDtcbn1cblxuLyoqIEdlbmVyYXRlcyBhIFRyYW5zYWN0aW9uIGNvbnN0cnVjdG9yIGJvdW5kIHRvIGdpdmVuIERleGllIGluc3RhbmNlLlxuICogXG4gKiBUaGUgcHVycG9zZSBvZiBoYXZpbmcgZHluYW1pY2FsbHkgY3JlYXRlZCBjb25zdHJ1Y3RvcnMsIGlzIHRvIGFsbG93XG4gKiBhZGRvbnMgdG8gZXh0ZW5kIGNsYXNzZXMgZm9yIGEgY2VydGFpbiBEZXhpZSBpbnN0YW5jZSB3aXRob3V0IGFmZmVjdGluZ1xuICogb3RoZXIgZGIgaW5zdGFuY2VzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVHJhbnNhY3Rpb25Db25zdHJ1Y3RvcihkYjogRGV4aWUpIHtcbiAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFRyYW5zYWN0aW9uQ29uc3RydWN0b3I8VHJhbnNhY3Rpb24+PihcbiAgICBUcmFuc2FjdGlvbi5wcm90b3R5cGUsXG4gICAgZnVuY3Rpb24gVHJhbnNhY3Rpb24gKFxuICAgICAgdGhpczogVHJhbnNhY3Rpb24sXG4gICAgICBtb2RlOiBJREJUcmFuc2FjdGlvbk1vZGUsXG4gICAgICBzdG9yZU5hbWVzOiBzdHJpbmdbXSxcbiAgICAgIGRic2NoZW1hOiBEYlNjaGVtYSxcbiAgICAgIGNocm9tZVRyYW5zYWN0aW9uRHVyYWJpbGl0eTogQ2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LFxuICAgICAgcGFyZW50PzogVHJhbnNhY3Rpb24pXG4gICAge1xuICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgIHRoaXMuc3RvcmVOYW1lcyA9IHN0b3JlTmFtZXM7XG4gICAgICB0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1xuICAgICAgdGhpcy5jaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHkgPSBjaHJvbWVUcmFuc2FjdGlvbkR1cmFiaWxpdHk7XG4gICAgICB0aGlzLmlkYnRyYW5zID0gbnVsbDtcbiAgICAgIHRoaXMub24gPSBFdmVudHModGhpcywgXCJjb21wbGV0ZVwiLCBcImVycm9yXCIsIFwiYWJvcnRcIik7XG4gICAgICB0aGlzLnBhcmVudCA9IHBhcmVudCB8fCBudWxsO1xuICAgICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVjdWxvY2sgPSAwO1xuICAgICAgdGhpcy5fYmxvY2tlZEZ1bmNzID0gW107XG4gICAgICB0aGlzLl9yZXNvbHZlID0gbnVsbDtcbiAgICAgIHRoaXMuX3JlamVjdCA9IG51bGw7XG4gICAgICB0aGlzLl93YWl0aW5nRm9yID0gbnVsbDtcbiAgICAgIHRoaXMuX3dhaXRpbmdRdWV1ZSA9IG51bGw7XG4gICAgICB0aGlzLl9zcGluQ291bnQgPSAwOyAvLyBKdXN0IGZvciBkZWJ1Z2dpbmcgd2FpdEZvcigpXG4gICAgICB0aGlzLl9jb21wbGV0aW9uID0gbmV3IFByb21pc2UgKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICB0aGlzLl9yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICB0aGlzLl9yZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcbiAgICAgIFxuICAgICAgdGhpcy5fY29tcGxldGlvbi50aGVuKFxuICAgICAgICAgICgpPT4ge1xuICAgICAgICAgICAgICB0aGlzLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICB0aGlzLm9uLmNvbXBsZXRlLmZpcmUoKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICB2YXIgd2FzQWN0aXZlID0gdGhpcy5hY3RpdmU7XG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgICAgICAgIHRoaXMub24uZXJyb3IuZmlyZShlKTtcbiAgICAgICAgICAgICAgdGhpcy5wYXJlbnQgP1xuICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQuX3JlamVjdChlKSA6XG4gICAgICAgICAgICAgICAgICB3YXNBY3RpdmUgJiYgdGhpcy5pZGJ0cmFucyAmJiB0aGlzLmlkYnRyYW5zLmFib3J0KCk7XG4gICAgICAgICAgICAgIHJldHVybiByZWplY3Rpb24oZSk7IC8vIEluZGljYXRlIHdlIGFjdHVhbGx5IERPIE5PVCBjYXRjaCB0aGlzIGVycm9yLlxuICAgICAgICAgIH0pO1xuICAgIFxuICAgIH0pO1xufVxuIiwgImltcG9ydCB7IEluZGV4U3BlYyB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9pbmRleC1zcGVjJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUluZGV4U3BlYyhcbiAgbmFtZTogc3RyaW5nLFxuICBrZXlQYXRoOiBzdHJpbmcgfCBzdHJpbmdbXSxcbiAgdW5pcXVlOiBib29sZWFuLFxuICBtdWx0aTogYm9vbGVhbixcbiAgYXV0bzogYm9vbGVhbixcbiAgY29tcG91bmQ6IGJvb2xlYW4sXG4gIGlzUHJpbUtleTogYm9vbGVhblxuKTogSW5kZXhTcGVjIHtcbiAgcmV0dXJuIHtcbiAgICBuYW1lLFxuICAgIGtleVBhdGgsXG4gICAgdW5pcXVlLFxuICAgIG11bHRpLFxuICAgIGF1dG8sXG4gICAgY29tcG91bmQsXG4gICAgc3JjOiAodW5pcXVlICYmICFpc1ByaW1LZXkgPyAnJicgOiAnJykgKyAobXVsdGkgPyAnKicgOiAnJykgKyAoYXV0byA/IFwiKytcIiA6IFwiXCIpICsgbmFtZUZyb21LZXlQYXRoKGtleVBhdGgpXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG5hbWVGcm9tS2V5UGF0aCAoa2V5UGF0aD86IHN0cmluZyB8IHN0cmluZ1tdKTogc3RyaW5nIHtcbiAgcmV0dXJuIHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/XG4gICAga2V5UGF0aCA6XG4gICAga2V5UGF0aCA/ICgnWycgKyBbXS5qb2luLmNhbGwoa2V5UGF0aCwgJysnKSArICddJykgOiBcIlwiO1xufVxuIiwgImltcG9ydCB7IEluZGV4U3BlYyB9IGZyb20gJy4uL3B1YmxpYy90eXBlcy9pbmRleC1zcGVjJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBjcmVhdGVJbmRleFNwZWMgfSBmcm9tICcuL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgYXJyYXlUb09iamVjdCB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUYWJsZVNjaGVtYSAoXG4gIG5hbWU6IHN0cmluZyxcbiAgcHJpbUtleTogSW5kZXhTcGVjLFxuICBpbmRleGVzOiBJbmRleFNwZWNbXVxuKTogVGFibGVTY2hlbWEge1xuICByZXR1cm4ge1xuICAgIG5hbWUsXG4gICAgcHJpbUtleSxcbiAgICBpbmRleGVzLFxuICAgIG1hcHBlZENsYXNzOiBudWxsLFxuICAgIGlkeEJ5TmFtZTogYXJyYXlUb09iamVjdChpbmRleGVzLCBpbmRleCA9PiBbaW5kZXgubmFtZSwgaW5kZXhdKVxuICB9O1xufVxuIiwgImltcG9ydCB7IG1heFN0cmluZyB9IGZyb20gJy4uL2dsb2JhbHMvY29uc3RhbnRzJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNhZmFyaU11bHRpU3RvcmVGaXgoc3RvcmVOYW1lczogc3RyaW5nW10pIHtcbiAgcmV0dXJuIHN0b3JlTmFtZXMubGVuZ3RoID09PSAxID8gc3RvcmVOYW1lc1swXSA6IHN0b3JlTmFtZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROYXRpdmVHZXREYXRhYmFzZU5hbWVzRm4oaW5kZXhlZERCKSB7XG4gIHZhciBmbiA9IGluZGV4ZWREQiAmJiAoaW5kZXhlZERCLmdldERhdGFiYXNlTmFtZXMgfHwgaW5kZXhlZERCLndlYmtpdEdldERhdGFiYXNlTmFtZXMpO1xuICByZXR1cm4gZm4gJiYgZm4uYmluZChpbmRleGVkREIpO1xufVxuXG5leHBvcnQgbGV0IGdldE1heEtleSA9IChJZGJLZXlSYW5nZTogdHlwZW9mIElEQktleVJhbmdlKSA9PiB7XG4gIHRyeSB7XG4gICAgSWRiS2V5UmFuZ2Uub25seShbW11dKTtcbiAgICBnZXRNYXhLZXkgPSAoKSA9PiBbW11dO1xuICAgIHJldHVybiBbW11dO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZ2V0TWF4S2V5ID0gKCkgPT4gbWF4U3RyaW5nO1xuICAgIHJldHVybiBtYXhTdHJpbmc7XG4gIH1cbn1cbiIsICJpbXBvcnQgeyBnZXRCeUtleVBhdGggfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5RXh0cmFjdG9yIChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10pIDogKGE6IGFueSkgPT4gYW55IHtcbiAgaWYgKGtleVBhdGggPT0gbnVsbCkge1xuICAgIHJldHVybiAoKSA9PiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGdldFNpbmdsZVBhdGhLZXlFeHRyYWN0b3Ioa2V5UGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG9iaiA9PiBnZXRCeUtleVBhdGgob2JqLCBrZXlQYXRoKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2luZ2xlUGF0aEtleUV4dHJhY3RvcihrZXlQYXRoOiBzdHJpbmcpIHtcbiAgY29uc3Qgc3BsaXQgPSBrZXlQYXRoLnNwbGl0KCcuJyk7XG4gIGlmIChzcGxpdC5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gb2JqID0+IG9ialtrZXlQYXRoXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqID0+IGdldEJ5S2V5UGF0aChvYmosIGtleVBhdGgpO1xuICB9XG59XG4iLCAiaW1wb3J0IHtcbiAgREJDb3JlLFxuICBEQkNvcmVDdXJzb3IsXG4gIERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0LFxuICBEQkNvcmVRdWVyeVJlcXVlc3QsXG4gIERCQ29yZUluZGV4LFxuICBEQkNvcmVLZXlSYW5nZSxcbiAgREJDb3JlUXVlcnlSZXNwb25zZSxcbiAgREJDb3JlUmFuZ2VUeXBlLFxuICBEQkNvcmVTY2hlbWEsXG4gIERCQ29yZVRhYmxlU2NoZW1hLFxuICBEQkNvcmVUYWJsZSxcbiAgREJDb3JlTXV0YXRlUmVzcG9uc2UsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5pbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGV2ZW50UmVqZWN0SGFuZGxlciwgcHJldmVudERlZmF1bHQgfSBmcm9tICcuLi9mdW5jdGlvbnMvZXZlbnQtd3JhcHBlcnMnO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBnZXRNYXhLZXkgfSBmcm9tICcuLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IGdldEtleUV4dHJhY3RvciB9IGZyb20gJy4vZ2V0LWtleS1leHRyYWN0b3InO1xuXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlpZnk8VD4oYXJyYXlMaWtlOiB7bGVuZ3RoOiBudW1iZXIsIFtpbmRleDogbnVtYmVyXTogVH0pOiBUW10ge1xuICByZXR1cm4gW10uc2xpY2UuY2FsbChhcnJheUxpa2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBpY2s8VCxQcm9wIGV4dGVuZHMga2V5b2YgVD4ob2JqOiBULCBwcm9wczogUHJvcFtdKTogUGljazxULCBQcm9wPiB7XG4gIGNvbnN0IHJlc3VsdCA9IHt9IGFzIFBpY2s8VCwgUHJvcD47XG4gIHByb3BzLmZvckVhY2gocHJvcCA9PiByZXN1bHRbcHJvcF0gPSBvYmpbcHJvcF0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5sZXQgX2lkX2NvdW50ZXIgPSAwO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGg6IG51bGwgfCBzdHJpbmcgfCBzdHJpbmdbXSkge1xuICByZXR1cm4ga2V5UGF0aCA9PSBudWxsID9cbiAgICBcIjppZFwiIDpcbiAgICB0eXBlb2Yga2V5UGF0aCA9PT0gJ3N0cmluZycgP1xuICAgICAga2V5UGF0aCA6XG4gICAgICBgWyR7a2V5UGF0aC5qb2luKCcrJyl9XWA7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEQkNvcmUgKFxuICBkYjogSURCRGF0YWJhc2UsXG4gIElkYktleVJhbmdlOiB0eXBlb2YgSURCS2V5UmFuZ2UsXG4gIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbikgOiBEQkNvcmVcbntcbiAgZnVuY3Rpb24gZXh0cmFjdFNjaGVtYShkYjogSURCRGF0YWJhc2UsIHRyYW5zOiBJREJUcmFuc2FjdGlvbikgOiB7c2NoZW1hOiBEQkNvcmVTY2hlbWEsIGhhc0dldEFsbDogYm9vbGVhbn0ge1xuICAgIGNvbnN0IHRhYmxlcyA9IGFycmF5aWZ5KGRiLm9iamVjdFN0b3JlTmFtZXMpO1xuICAgIHJldHVybiB7XG4gICAgICBzY2hlbWE6IHtcbiAgICAgICAgbmFtZTogZGIubmFtZSxcbiAgICAgICAgdGFibGVzOiB0YWJsZXMubWFwKHRhYmxlID0+IHRyYW5zLm9iamVjdFN0b3JlKHRhYmxlKSkubWFwKHN0b3JlID0+IHtcbiAgICAgICAgICBjb25zdCB7a2V5UGF0aCwgYXV0b0luY3JlbWVudH0gPSBzdG9yZTtcbiAgICAgICAgICBjb25zdCBjb21wb3VuZCA9IGlzQXJyYXkoa2V5UGF0aCk7XG4gICAgICAgICAgY29uc3Qgb3V0Ym91bmQgPSBrZXlQYXRoID09IG51bGw7XG4gICAgICAgICAgY29uc3QgaW5kZXhCeUtleVBhdGg6IHtba2V5UGF0aEFsaWFzOiBzdHJpbmddOiBEQkNvcmVJbmRleH0gPSB7fTtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lOiBzdG9yZS5uYW1lLFxuICAgICAgICAgICAgcHJpbWFyeUtleToge1xuICAgICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgICBpc1ByaW1hcnlLZXk6IHRydWUsXG4gICAgICAgICAgICAgIG91dGJvdW5kLFxuICAgICAgICAgICAgICBjb21wb3VuZCxcbiAgICAgICAgICAgICAga2V5UGF0aCxcbiAgICAgICAgICAgICAgYXV0b0luY3JlbWVudCxcbiAgICAgICAgICAgICAgdW5pcXVlOiB0cnVlLFxuICAgICAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aClcbiAgICAgICAgICAgIH0gYXMgREJDb3JlSW5kZXgsXG4gICAgICAgICAgICBpbmRleGVzOiBhcnJheWlmeShzdG9yZS5pbmRleE5hbWVzKS5tYXAoaW5kZXhOYW1lID0+IHN0b3JlLmluZGV4KGluZGV4TmFtZSkpXG4gICAgICAgICAgICAgIC5tYXAoaW5kZXggPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHtuYW1lLCB1bmlxdWUsIG11bHRpRW50cnksIGtleVBhdGh9ID0gaW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgY29tcG91bmQgPSBpc0FycmF5KGtleVBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdDogREJDb3JlSW5kZXggPSB7XG4gICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgY29tcG91bmQsXG4gICAgICAgICAgICAgICAgICBrZXlQYXRoLFxuICAgICAgICAgICAgICAgICAgdW5pcXVlLFxuICAgICAgICAgICAgICAgICAgbXVsdGlFbnRyeSxcbiAgICAgICAgICAgICAgICAgIGV4dHJhY3RLZXk6IGdldEtleUV4dHJhY3RvcihrZXlQYXRoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaW5kZXhCeUtleVBhdGhbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGdldEluZGV4QnlLZXlQYXRoOiAoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdKSA9PiBpbmRleEJ5S2V5UGF0aFtnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCldXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpbmRleEJ5S2V5UGF0aFtcIjppZFwiXSA9IHJlc3VsdC5wcmltYXJ5S2V5O1xuICAgICAgICAgIGlmIChrZXlQYXRoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGluZGV4QnlLZXlQYXRoW2dldEtleVBhdGhBbGlhcyhrZXlQYXRoKV0gPSByZXN1bHQucHJpbWFyeUtleTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSlcbiAgICAgIH0sXG4gICAgICBoYXNHZXRBbGw6IHRhYmxlcy5sZW5ndGggPiAwICYmICgnZ2V0QWxsJyBpbiB0cmFucy5vYmplY3RTdG9yZSh0YWJsZXNbMF0pKSAmJlxuICAgICAgICAhKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIC9TYWZhcmkvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiZcbiAgICAgICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpIC8vIEJ1ZyB3aXRoIGdldEFsbCgpIG9uIFNhZmFyaSB2ZXI8NjA0LiBTZWUgZGlzY3Vzc2lvbiBmb2xsb3dpbmcgUFIgIzU3OVxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYWtlSURCS2V5UmFuZ2UgKHJhbmdlOiBEQkNvcmVLZXlSYW5nZSkgOiBJREJLZXlSYW5nZSB8IG51bGwge1xuICAgIGlmIChyYW5nZS50eXBlID09PSBEQkNvcmVSYW5nZVR5cGUuQW55KSByZXR1cm4gbnVsbDtcbiAgICBpZiAocmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLk5ldmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgY29udmVydCBuZXZlciB0eXBlIHRvIElEQktleVJhbmdlXCIpO1xuICAgIGNvbnN0IHtsb3dlciwgdXBwZXIsIGxvd2VyT3BlbiwgdXBwZXJPcGVufSA9IHJhbmdlO1xuICAgIGNvbnN0IGlkYlJhbmdlID0gbG93ZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICB1cHBlciA9PT0gdW5kZWZpbmVkID9cbiAgICAgICAgbnVsbCA6IC8vSURCS2V5UmFuZ2UubG93ZXJCb3VuZCgtSW5maW5pdHksIGZhbHNlKSA6IC8vIEFueSByYW5nZSAoVE9ETzogU2hvdWxkIHdlIHJldHVybiBudWxsIGluc3RlYWQ/KVxuICAgICAgICBJZGJLZXlSYW5nZS51cHBlckJvdW5kKHVwcGVyLCAhIXVwcGVyT3BlbikgOiAvLyBiZWxvd1xuICAgICAgdXBwZXIgPT09IHVuZGVmaW5lZCA/XG4gICAgICAgIElkYktleVJhbmdlLmxvd2VyQm91bmQobG93ZXIsICEhbG93ZXJPcGVuKSA6IC8vIGFib3ZlXG4gICAgICAgIElkYktleVJhbmdlLmJvdW5kKGxvd2VyLCB1cHBlciwgISFsb3dlck9wZW4sICEhdXBwZXJPcGVuKTtcbiAgICByZXR1cm4gaWRiUmFuZ2U7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVEYkNvcmVUYWJsZSh0YWJsZVNjaGVtYTogREJDb3JlVGFibGVTY2hlbWEpOiBEQkNvcmVUYWJsZSB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGVTY2hlbWEubmFtZTtcblxuICAgIGZ1bmN0aW9uIG11dGF0ZSAoe3RyYW5zLCB0eXBlLCBrZXlzLCB2YWx1ZXMsIHJhbmdlfSkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlPERCQ29yZU11dGF0ZVJlc3BvbnNlPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgY29uc3Qgb3V0Ym91bmQgPSBzdG9yZS5rZXlQYXRoID09IG51bGw7XG4gICAgICAgIGNvbnN0IGlzQWRkT3JQdXQgPSB0eXBlID09PSBcInB1dFwiIHx8IHR5cGUgPT09IFwiYWRkXCI7XG4gICAgICAgIGlmICghaXNBZGRPclB1dCAmJiB0eXBlICE9PSAnZGVsZXRlJyAmJiB0eXBlICE9PSAnZGVsZXRlUmFuZ2UnKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvciAoXCJJbnZhbGlkIG9wZXJhdGlvbiB0eXBlOiBcIiArIHR5cGUpO1xuXG4gICAgICAgIGNvbnN0IHtsZW5ndGh9ID0ga2V5cyB8fCB2YWx1ZXMgfHwge2xlbmd0aDogMX07IC8vIGtleXMubGVuZ3RoIGlmIGtleXMuIHZhbHVlcy5sZW5ndGggaWYgdmFsdWVzLiAxIGlmIHJhbmdlLlxuICAgICAgICBpZiAoa2V5cyAmJiB2YWx1ZXMgJiYga2V5cy5sZW5ndGggIT09IHZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHaXZlbiBrZXlzIGFycmF5IG11c3QgaGF2ZSBzYW1lIGxlbmd0aCBhcyBnaXZlbiB2YWx1ZXMgYXJyYXkuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGggPT09IDApXG4gICAgICAgICAgLy8gTm8gaXRlbXMgdG8gd3JpdGUuIERvbid0IGV2ZW4gYm90aGVyIVxuICAgICAgICAgIHJldHVybiByZXNvbHZlKHtudW1GYWlsdXJlczogMCwgZmFpbHVyZXM6IHt9LCByZXN1bHRzOiBbXSwgbGFzdFJlc3VsdDogdW5kZWZpbmVkfSk7XG5cbiAgICAgICAgbGV0IHJlcTogSURCUmVxdWVzdDtcbiAgICAgICAgY29uc3QgcmVxczogSURCUmVxdWVzdFtdID0gW107XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IGZhaWx1cmVzOiB7W29wZXJhdGlvbk51bWJlcjogbnVtYmVyXTogRXJyb3J9ID0gW107XG4gICAgICAgIGxldCBudW1GYWlsdXJlcyA9IDA7XG4gICAgICAgIGNvbnN0IGVycm9ySGFuZGxlciA9IFxuICAgICAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgICAgICsrbnVtRmFpbHVyZXM7XG4gICAgICAgICAgICBwcmV2ZW50RGVmYXVsdChldmVudCk7XG4gICAgICAgICAgfTtcbiAgXG4gICAgICAgIGlmICh0eXBlID09PSAnZGVsZXRlUmFuZ2UnKSB7XG4gICAgICAgICAgLy8gSGVyZSB0aGUgYXJndW1lbnQgaXMgdGhlIHJhbmdlXG4gICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5OZXZlcilcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHtudW1GYWlsdXJlcywgZmFpbHVyZXMsIHJlc3VsdHM6IFtdLCBsYXN0UmVzdWx0OiB1bmRlZmluZWR9KTsgLy8gRGVsZXRpbmcgdGhlIE5ldmVyIHJhbmdlIHNob3VsbnQgZG8gYW55dGhpbmcuXG4gICAgICAgICAgaWYgKHJhbmdlLnR5cGUgPT09IERCQ29yZVJhbmdlVHlwZS5BbnkpXG4gICAgICAgICAgICByZXFzLnB1c2gocmVxID0gc3RvcmUuY2xlYXIoKSk7IC8vIERlbGV0aW5nIHRoZSBBbnkgcmFuZ2UgaXMgZXF1aXZhbGVudCB0byBzdG9yZS5jbGVhcigpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IHN0b3JlLmRlbGV0ZShtYWtlSURCS2V5UmFuZ2UocmFuZ2UpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gTm8gbWF0dGVyIGFkZCwgcHV0IG9yIGRlbGV0ZSAtIGZpbmQgb3V0IGFycmF5cyBvZiBmaXJzdCBhbmQgc2Vjb25kIGFyZ3VtZW50cyB0byBpdC5cbiAgICAgICAgICBjb25zdCBbYXJnczEsIGFyZ3MyXSA9IGlzQWRkT3JQdXQgP1xuICAgICAgICAgICAgb3V0Ym91bmQgP1xuICAgICAgICAgICAgICBbdmFsdWVzLCBrZXlzXSA6XG4gICAgICAgICAgICAgIFt2YWx1ZXMsIG51bGxdIDpcbiAgICAgICAgICAgIFtrZXlzLCBudWxsXTtcblxuICAgICAgICAgIGlmIChpc0FkZE9yUHV0KSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgcmVxcy5wdXNoKHJlcSA9IChhcmdzMiAmJiBhcmdzMltpXSAhPT0gdW5kZWZpbmVkID9cbiAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSwgYXJnczJbaV0pIDpcbiAgICAgICAgICAgICAgICBzdG9yZVt0eXBlXShhcmdzMVtpXSkpIGFzIElEQlJlcXVlc3QpO1xuICAgICAgICAgICAgICByZXEub25lcnJvciA9IGVycm9ySGFuZGxlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHJlcXMucHVzaChyZXEgPSBzdG9yZVt0eXBlXShhcmdzMVtpXSkgYXMgSURCUmVxdWVzdCk7XG4gICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXJyb3JIYW5kbGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb25lID0gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IGxhc3RSZXN1bHQgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgIHJlcXMuZm9yRWFjaCgocmVxLCBpKSA9PiByZXEuZXJyb3IgIT0gbnVsbCAmJiAoZmFpbHVyZXNbaV0gPSByZXEuZXJyb3IpKTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIG51bUZhaWx1cmVzLFxuICAgICAgICAgICAgZmFpbHVyZXMsXG4gICAgICAgICAgICByZXN1bHRzOiB0eXBlID09PSBcImRlbGV0ZVwiID8ga2V5cyA6IHJlcXMubWFwKHJlcSA9PiByZXEucmVzdWx0KSxcbiAgICAgICAgICAgIGxhc3RSZXN1bHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnQgPT4geyAvLyB3cmFwKCkgbm90IG5lZWRlZC4gQWxsIHBhdGhzIGNhbGxpbmcgb3V0c2lkZSB3aWxsIHdyYXAhXG4gICAgICAgICAgZXJyb3JIYW5kbGVyKGV2ZW50KTtcbiAgICAgICAgICBkb25lKGV2ZW50KTtcbiAgICAgICAgfTtcbiAgXG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBkb25lO1xuICAgICAgfSk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG9wZW5DdXJzb3IgKHt0cmFucywgdmFsdWVzLCBxdWVyeSwgcmV2ZXJzZSwgdW5pcXVlfTogREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpOiBQcm9taXNlPERCQ29yZUN1cnNvcj5cbiAgICB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgY29uc3Qge2luZGV4LCByYW5nZX0gPSBxdWVyeTtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSAodHJhbnMgYXMgSURCVHJhbnNhY3Rpb24pLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgIC8vIHNvdXJjZVxuICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgP1xuICAgICAgICAgIHN0b3JlIDpcbiAgICAgICAgICBzdG9yZS5pbmRleChpbmRleC5uYW1lKTtcbiAgICAgICAgLy8gZGlyZWN0aW9uXG4gICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IHJldmVyc2UgP1xuICAgICAgICAgIHVuaXF1ZSA/XG4gICAgICAgICAgICBcInByZXZ1bmlxdWVcIiA6XG4gICAgICAgICAgICBcInByZXZcIiA6XG4gICAgICAgICAgdW5pcXVlID9cbiAgICAgICAgICAgIFwibmV4dHVuaXF1ZVwiIDpcbiAgICAgICAgICAgIFwibmV4dFwiO1xuICAgICAgICAvLyByZXF1ZXN0XG4gICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICBzb3VyY2Uub3BlbkN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pIDpcbiAgICAgICAgICBzb3VyY2Uub3BlbktleUN1cnNvcihtYWtlSURCS2V5UmFuZ2UocmFuZ2UpLCBkaXJlY3Rpb24pO1xuICAgICAgICAgIFxuICAgICAgICAvLyBpdGVyYXRpb25cbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgcmVxLm9uc3VjY2VzcyA9IHdyYXAoZXYgPT4ge1xuXG4gICAgICAgICAgY29uc3QgY3Vyc29yID0gcmVxLnJlc3VsdCBhcyB1bmtub3duIGFzIERCQ29yZUN1cnNvcjtcbiAgICAgICAgICBpZiAoIWN1cnNvcikge1xuICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgKGN1cnNvciBhcyBhbnkpLl9fX2lkID0gKytfaWRfY291bnRlcjtcbiAgICAgICAgICAoY3Vyc29yIGFzIGFueSkuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IF9jdXJzb3JDb250aW51ZSA9IGN1cnNvci5jb250aW51ZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgbGV0IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuY29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgIGlmIChfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5KSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5ID0gX2N1cnNvckNvbnRpbnVlUHJpbWFyeUtleS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgY29uc3QgX2N1cnNvckFkdmFuY2UgPSBjdXJzb3IuYWR2YW5jZS5iaW5kKGN1cnNvcik7XG4gICAgICAgICAgY29uc3QgZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZCA9ICgpPT57dGhyb3cgbmV3IEVycm9yKFwiQ3Vyc29yIG5vdCBzdGFydGVkXCIpO31cbiAgICAgICAgICBjb25zdCBkb1Rocm93Q3Vyc29ySXNTdG9wcGVkID0gKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3Igbm90IHN0b3BwZWRcIik7fVxuICAgICAgICAgIChjdXJzb3IgYXMgYW55KS50cmFucyA9IHRyYW5zO1xuICAgICAgICAgIGN1cnNvci5zdG9wID0gY3Vyc29yLmNvbnRpbnVlID0gY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IGN1cnNvci5hZHZhbmNlID0gZG9UaHJvd0N1cnNvcklzTm90U3RhcnRlZDtcbiAgICAgICAgICBjdXJzb3IuZmFpbCA9IHdyYXAocmVqZWN0KTtcbiAgICAgICAgICBjdXJzb3IubmV4dCA9IGZ1bmN0aW9uICh0aGlzOiBEQkNvcmVDdXJzb3IpIHtcbiAgICAgICAgICAgIC8vIG5leHQoKSBtdXN0IHdvcmsgd2l0aCBcInRoaXNcIiBwb2ludGVyIGluIG9yZGVyIHRvIGZ1bmN0aW9uIGNvcnJlY3RseSBmb3IgUHJveHlDdXJzb3JzIChkZXJpdmVkIG9iamVjdHMpXG4gICAgICAgICAgICAvLyB3aXRob3V0IGhhdmluZyB0byByZS1kZWZpbmUgbmV4dCgpIG9uIGVhY2ggY2hpbGQuXG4gICAgICAgICAgICBsZXQgZ290T25lID0gMTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnN0YXJ0KCgpID0+IGdvdE9uZS0tID8gdGhpcy5jb250aW51ZSgpIDogdGhpcy5zdG9wKCkpLnRoZW4oKCkgPT4gdGhpcyk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjdXJzb3Iuc3RhcnQgPSAoY2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIC8vY29uc29sZS5sb2coXCJTdGFydGluZyBjdXJzb3JcIiwgKGN1cnNvciBhcyBhbnkpLl9fX2lkKTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZXJhdGlvblByb21pc2UgPSBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZUl0ZXJhdGlvbiwgcmVqZWN0SXRlcmF0aW9uKSA9PntcbiAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbiA9IHdyYXAocmVzb2x2ZUl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXZlbnRSZWplY3RIYW5kbGVyKHJlamVjdEl0ZXJhdGlvbik7XG4gICAgICAgICAgICAgIGN1cnNvci5mYWlsID0gcmVqZWN0SXRlcmF0aW9uO1xuICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IHZhbHVlID0+IHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ3Vyc29yIHN0b3BcIiwgY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBjdXJzb3Iuc3RvcCA9IGN1cnNvci5jb250aW51ZSA9IGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBjdXJzb3IuYWR2YW5jZSA9IGRvVGhyb3dDdXJzb3JJc1N0b3BwZWQ7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZUl0ZXJhdGlvbih2YWx1ZSk7XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIE5vdyBjaGFuZ2UgcmVxLm9uc3VjY2VzcyB0byBhIGNhbGxiYWNrIHRoYXQgZG9lc24ndCBjYWxsIGluaXRDdXJzb3IgYnV0IGp1c3Qgb2JzZXJ2ZXIubmV4dCgpXG4gICAgICAgICAgICBjb25zdCBndWFyZGVkQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgIGlmIChyZXEucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIk5leHQgcmVzdWx0XCIsIGN1cnNvcik7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICBjdXJzb3IuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAoY3Vyc29yIGFzIGFueSkuZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgY3Vyc29yLnN0YXJ0ID0gKCk9Pnt0aHJvdyBuZXcgRXJyb3IoXCJDdXJzb3IgYmVoaW5kIGxhc3QgZW50cnlcIik7fVxuICAgICAgICAgICAgICAgIGN1cnNvci5zdG9wKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSB3cmFwKGV2ID0+IHtcbiAgICAgICAgICAgICAgLy9jdXJzb3IuY29udGludWUgPSBfY3Vyc29yQ29udGludWU7XG4gICAgICAgICAgICAgIC8vY3Vyc29yLmNvbnRpbnVlUHJpbWFyeUtleSA9IF9jdXJzb3JDb250aW51ZVByaW1hcnlLZXk7XG4gICAgICAgICAgICAgIC8vY3Vyc29yLmFkdmFuY2UgPSBfY3Vyc29yQWR2YW5jZTtcbiAgICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGd1YXJkZWRDYWxsYmFjaztcbiAgICAgICAgICAgICAgZ3VhcmRlZENhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSA9IF9jdXJzb3JDb250aW51ZTtcbiAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkgPSBfY3Vyc29yQ29udGludWVQcmltYXJ5S2V5O1xuICAgICAgICAgICAgY3Vyc29yLmFkdmFuY2UgPSBfY3Vyc29yQWR2YW5jZTtcbiAgICAgICAgICAgIGd1YXJkZWRDYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZXJhdGlvblByb21pc2U7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKGN1cnNvcik7XG4gICAgICAgIH0sIHJlamVjdCk7IFxuICAgICAgfSk7XG4gICAgfVxuICBcbiAgICBmdW5jdGlvbiBxdWVyeSAoaGFzR2V0QWxsOiBib29sZWFuKSB7XG4gICAgICByZXR1cm4gKHJlcXVlc3Q6IERCQ29yZVF1ZXJ5UmVxdWVzdCkgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8REJDb3JlUXVlcnlSZXNwb25zZT4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHJlc29sdmUgPSB3cmFwKHJlc29sdmUpO1xuICAgICAgICAgIGNvbnN0IHt0cmFucywgdmFsdWVzLCBsaW1pdCwgcXVlcnl9ID0gcmVxdWVzdDtcbiAgICAgICAgICBjb25zdCBub25JbmZpbml0TGltaXQgPSBsaW1pdCA9PT0gSW5maW5pdHkgPyB1bmRlZmluZWQgOiBsaW1pdDtcbiAgICAgICAgICBjb25zdCB7aW5kZXgsIHJhbmdlfSA9IHF1ZXJ5O1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gKHRyYW5zIGFzIElEQlRyYW5zYWN0aW9uKS5vYmplY3RTdG9yZSh0YWJsZU5hbWUpO1xuICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IGluZGV4LmlzUHJpbWFyeUtleSA/IHN0b3JlIDogc3RvcmUuaW5kZXgoaW5kZXgubmFtZSk7XG4gICAgICAgICAgY29uc3QgaWRiS2V5UmFuZ2UgPSBtYWtlSURCS2V5UmFuZ2UocmFuZ2UpO1xuICAgICAgICAgIGlmIChsaW1pdCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoe3Jlc3VsdDogW119KTtcbiAgICAgICAgICBpZiAoaGFzR2V0QWxsKSB7XG4gICAgICAgICAgICBjb25zdCByZXEgPSB2YWx1ZXMgP1xuICAgICAgICAgICAgICAgIChzb3VyY2UgYXMgYW55KS5nZXRBbGwoaWRiS2V5UmFuZ2UsIG5vbkluZmluaXRMaW1pdCkgOlxuICAgICAgICAgICAgICAgIChzb3VyY2UgYXMgYW55KS5nZXRBbGxLZXlzKGlkYktleVJhbmdlLCBub25JbmZpbml0TGltaXQpO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoe3Jlc3VsdDogZXZlbnQudGFyZ2V0LnJlc3VsdH0pO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IHZhbHVlcyB8fCAhKCdvcGVuS2V5Q3Vyc29yJyBpbiBzb3VyY2UpID9cbiAgICAgICAgICAgICAgc291cmNlLm9wZW5DdXJzb3IoaWRiS2V5UmFuZ2UpIDpcbiAgICAgICAgICAgICAgc291cmNlLm9wZW5LZXlDdXJzb3IoaWRiS2V5UmFuZ2UpXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldmVudCA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IHJlcS5yZXN1bHQgYXMgSURCQ3Vyc29yV2l0aFZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIWN1cnNvcikgcmV0dXJuIHJlc29sdmUoe3Jlc3VsdH0pO1xuICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZXMgPyBjdXJzb3IudmFsdWUgOiBjdXJzb3IucHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBsaW1pdCkgcmV0dXJuIHJlc29sdmUoe3Jlc3VsdH0pO1xuICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXEub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgXG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRhYmxlTmFtZSxcbiAgICAgIHNjaGVtYTogdGFibGVTY2hlbWEsXG4gICAgICBcbiAgICAgIG11dGF0ZSxcblxuICAgICAgZ2V0TWFueSAoe3RyYW5zLCBrZXlzfSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2U8YW55W10+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZXNvbHZlID0gd3JhcChyZXNvbHZlKTtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICBjb25zdCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICBsZXQga2V5Q291bnQgPSAwO1xuICAgICAgICAgIGxldCBjYWxsYmFja0NvdW50ID0gMDtcbiAgICAgICAgICBsZXQgdmFsdWVDb3VudCA9IDA7XG4gICAgICAgICAgbGV0IHJlcTogSURCUmVxdWVzdCAmIHtfcG9zPzogbnVtYmVyfTtcbiAgICBcbiAgICAgICAgICBjb25zdCBzdWNjZXNzSGFuZGxlciA9IGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGlmICgocmVzdWx0W3JlcS5fcG9zXSA9IHJlcS5yZXN1bHQpICE9IG51bGwpICsrdmFsdWVDb3VudDtcbiAgICAgICAgICAgIGlmICgrK2NhbGxiYWNrQ291bnQgPT09IGtleUNvdW50KSByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBlcnJvckhhbmRsZXIgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICBcbiAgICAgICAgICBmb3IgKGxldCBpPTA7IGk8bGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGtleXNbaV07XG4gICAgICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVxID0gc3RvcmUuZ2V0KGtleXNbaV0pO1xuICAgICAgICAgICAgICByZXEuX3BvcyA9IGk7XG4gICAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBzdWNjZXNzSGFuZGxlcjtcbiAgICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBlcnJvckhhbmRsZXI7XG4gICAgICAgICAgICAgICsra2V5Q291bnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChrZXlDb3VudCA9PT0gMCkgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sXG5cbiAgICAgIGdldCAoe3RyYW5zLCBrZXl9KSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxhbnk+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICByZXNvbHZlID0gd3JhcCAocmVzb2x2ZSk7XG4gICAgICAgICAgY29uc3Qgc3RvcmUgPSAodHJhbnMgYXMgSURCVHJhbnNhY3Rpb24pLm9iamVjdFN0b3JlKHRhYmxlTmFtZSk7XG4gICAgICAgICAgY29uc3QgcmVxID0gc3RvcmUuZ2V0KGtleSk7XG4gICAgICAgICAgcmVxLm9uc3VjY2VzcyA9IGV2ZW50ID0+IHJlc29sdmUoKGV2ZW50LnRhcmdldCBhcyBhbnkpLnJlc3VsdCk7XG4gICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9LFxuXG4gICAgICBxdWVyeTogcXVlcnkoaGFzR2V0QWxsKSxcbiAgICAgIFxuICAgICAgb3BlbkN1cnNvcixcblxuICAgICAgY291bnQgKHtxdWVyeSwgdHJhbnN9KSB7XG4gICAgICAgIGNvbnN0IHtpbmRleCwgcmFuZ2V9ID0gcXVlcnk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZTxudW1iZXI+KChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICBjb25zdCBzdG9yZSA9ICh0cmFucyBhcyBJREJUcmFuc2FjdGlvbikub2JqZWN0U3RvcmUodGFibGVOYW1lKTtcbiAgICAgICAgICBjb25zdCBzb3VyY2UgPSBpbmRleC5pc1ByaW1hcnlLZXkgPyBzdG9yZSA6IHN0b3JlLmluZGV4KGluZGV4Lm5hbWUpO1xuICAgICAgICAgIGNvbnN0IGlkYktleVJhbmdlID0gbWFrZUlEQktleVJhbmdlKHJhbmdlKTtcbiAgICAgICAgICBjb25zdCByZXEgPSBpZGJLZXlSYW5nZSA/IHNvdXJjZS5jb3VudChpZGJLZXlSYW5nZSkgOiBzb3VyY2UuY291bnQoKTtcbiAgICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcChldiA9PiByZXNvbHZlKChldi50YXJnZXQgYXMgSURCUmVxdWVzdCkucmVzdWx0KSk7XG4gICAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtzY2hlbWEsIGhhc0dldEFsbH0gPSBleHRyYWN0U2NoZW1hKGRiLCB0bXBUcmFucyk7XG4gIGNvbnN0IHRhYmxlcyA9IHNjaGVtYS50YWJsZXMubWFwKHRhYmxlU2NoZW1hID0+IGNyZWF0ZURiQ29yZVRhYmxlKHRhYmxlU2NoZW1hKSk7XG4gIGNvbnN0IHRhYmxlTWFwOiB7W25hbWU6IHN0cmluZ106IERCQ29yZVRhYmxlfSA9IHt9O1xuICB0YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB0YWJsZU1hcFt0YWJsZS5uYW1lXSA9IHRhYmxlKTtcbiAgcmV0dXJuIHtcbiAgICBzdGFjazogXCJkYmNvcmVcIixcbiAgICBcbiAgICB0cmFuc2FjdGlvbjogZGIudHJhbnNhY3Rpb24uYmluZChkYiksXG5cbiAgICB0YWJsZShuYW1lOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRhYmxlTWFwW25hbWVdO1xuICAgICAgaWYgKCFyZXN1bHQpIHRocm93IG5ldyBFcnJvcihgVGFibGUgJyR7bmFtZX0nIG5vdCBmb3VuZGApO1xuICAgICAgcmV0dXJuIHRhYmxlTWFwW25hbWVdO1xuICAgIH0sXG5cbiAgICBNSU5fS0VZOiAtSW5maW5pdHksXG5cbiAgICBNQVhfS0VZOiBnZXRNYXhLZXkoSWRiS2V5UmFuZ2UpLFxuXG4gICAgc2NoZW1hXG5cbiAgfTtcbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4vJztcbmltcG9ydCB7IGNyZWF0ZURCQ29yZSB9IGZyb20gJy4uLy4uL2RiY29yZS9kYmNvcmUtaW5kZXhlZGRiJztcbmltcG9ydCB7IERCQ29yZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgRGV4aWVET01EZXBlbmRlbmNpZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtZG9tLWRlcGVuZGVuY2llcyc7XG5pbXBvcnQgeyBEZXhpZVN0YWNrcywgTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuXG5mdW5jdGlvbiBjcmVhdGVNaWRkbGV3YXJlU3RhY2s8VFN0YWNrIGV4dGVuZHMge3N0YWNrOiBzdHJpbmd9PihcbiAgc3RhY2tJbXBsOiB7c3RhY2s6IHN0cmluZ30sXG4gIG1pZGRsZXdhcmVzOiBNaWRkbGV3YXJlPHtzdGFjazogc3RyaW5nfT5bXSk6IFRTdGFjayB7XG4gIHJldHVybiBtaWRkbGV3YXJlcy5yZWR1Y2UoKGRvd24sIHtjcmVhdGV9KSA9PiAoey4uLmRvd24sIC4uLmNyZWF0ZShkb3duKX0pLCBzdGFja0ltcGwpIGFzIFRTdGFjaztcbn0gXG5cbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoXG4gIG1pZGRsZXdhcmVzOiB7W1N0YWNrTmFtZSBpbiBrZXlvZiBEZXhpZVN0YWNrc10/OiBNaWRkbGV3YXJlPERleGllU3RhY2tzW1N0YWNrTmFtZV0+W119LFxuICBpZGJkYjogSURCRGF0YWJhc2UsXG4gIHtJREJLZXlSYW5nZSwgaW5kZXhlZERCfTogRGV4aWVET01EZXBlbmRlbmNpZXMsXG4gIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvbik6IHtbU3RhY2tOYW1lIGluIGtleW9mIERleGllU3RhY2tzXT86IERleGllU3RhY2tzW1N0YWNrTmFtZV19XG57XG4gIGNvbnN0IGRiY29yZSA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFjazxEQkNvcmU+KFxuICAgIGNyZWF0ZURCQ29yZShpZGJkYiwgSURCS2V5UmFuZ2UsIHRtcFRyYW5zKSxcbiAgICBtaWRkbGV3YXJlcy5kYmNvcmUpO1xuICBcbiAgLy8gVE9ETzogQ3JlYXRlIG90aGVyIHN0YWNrcyB0aGUgc2FtZSB3YXkgYXMgYWJvdmUuIFRoZXkgbWlnaHQgYmUgZGVwZW5kYW50IG9uIHRoZSByZXN1bHRcbiAgLy8gb2YgY3JlYXRpbmcgZGJjb3JlIHN0YWNrLlxuXG4gIHJldHVybiB7XG4gICAgZGJjb3JlXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3Moe19ub3ZpcDogZGJ9OiBEZXhpZSwgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKSB7XG4gIGNvbnN0IGlkYmRiID0gdG1wVHJhbnMuZGI7XG4gIGNvbnN0IHN0YWNrcyA9IGNyZWF0ZU1pZGRsZXdhcmVTdGFja3MoZGIuX21pZGRsZXdhcmVzLCBpZGJkYiwgZGIuX2RlcHMsIHRtcFRyYW5zKTtcbiAgZGIuY29yZSA9IHN0YWNrcy5kYmNvcmUhO1xuICBkYi50YWJsZXMuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgY29uc3QgdGFibGVOYW1lID0gdGFibGUubmFtZTtcbiAgICBpZiAoZGIuY29yZS5zY2hlbWEudGFibGVzLnNvbWUodGJsID0+IHRibC5uYW1lID09PSB0YWJsZU5hbWUpKSB7XG4gICAgICB0YWJsZS5jb3JlID0gZGIuY29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgaWYgKGRiW3RhYmxlTmFtZV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkge1xuICAgICAgICAgIGRiW3RhYmxlTmFtZV0uY29yZSA9IHRhYmxlLmNvcmU7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gJy4uL2RleGllJztcbmltcG9ydCB7IERiU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RiLXNjaGVtYSc7XG5pbXBvcnQgeyBfZ2xvYmFsIH0gZnJvbSBcIi4uLy4uL2dsb2JhbHMvZ2xvYmFsXCI7XG5pbXBvcnQgeyBzZXRQcm9wLCBrZXlzLCBzbGljZSwgaXNBcnJheSwgc2hhbGxvd0Nsb25lLCBpc0FzeW5jRnVuY3Rpb24sIGRlZmluZVByb3BlcnR5LCBnZXRQcm9wZXJ0eURlc2NyaXB0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyBWZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcbmltcG9ydCBQcm9taXNlLCB7IFBTRCwgbmV3U2NvcGUsIE5hdGl2ZVByb21pc2UsIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLCBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IFRhYmxlU2NoZW1hIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBJbmRleFNwZWMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvaW5kZXgtc3BlYyc7XG5pbXBvcnQgeyBoYXNJRURlbGV0ZU9iamVjdFN0b3JlQnVnLCBpc0lFT3JFZGdlIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgc2FmYXJpTXVsdGlTdG9yZUZpeCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9xdWlya3MnO1xuaW1wb3J0IHsgY3JlYXRlSW5kZXhTcGVjLCBuYW1lRnJvbUtleVBhdGggfSBmcm9tICcuLi8uLi9oZWxwZXJzL2luZGV4LXNwZWMnO1xuaW1wb3J0IHsgY3JlYXRlVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBnZW5lcmF0ZU1pZGRsZXdhcmVTdGFja3MgfSBmcm9tICcuLi9kZXhpZS9nZW5lcmF0ZS1taWRkbGV3YXJlLXN0YWNrcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRBcGlPblBsYWNlKHtfbm92aXA6IGRifTogRGV4aWUsIG9ianM6IE9iamVjdFtdLCB0YWJsZU5hbWVzOiBzdHJpbmdbXSwgZGJzY2hlbWE6IERiU2NoZW1hKSB7XG4gIHRhYmxlTmFtZXMuZm9yRWFjaCh0YWJsZU5hbWUgPT4ge1xuICAgIGNvbnN0IHNjaGVtYSA9IGRic2NoZW1hW3RhYmxlTmFtZV07XG4gICAgb2Jqcy5mb3JFYWNoKG9iaiA9PiB7XG4gICAgICBjb25zdCBwcm9wRGVzYyA9IGdldFByb3BlcnR5RGVzY3JpcHRvcihvYmosIHRhYmxlTmFtZSk7XG4gICAgICBpZiAoIXByb3BEZXNjIHx8IChcInZhbHVlXCIgaW4gcHJvcERlc2MgJiYgcHJvcERlc2MudmFsdWUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgLy8gRWl0aGVyIHRoZSBwcm9wIGlzIG5vdCBkZWNsYXJlZCwgb3IgaXQgaXMgaW5pdGlhbGl6ZWQgdG8gdW5kZWZpbmVkLlxuICAgICAgICBpZiAob2JqID09PSBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUgfHwgb2JqIGluc3RhbmNlb2YgZGIuVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAvLyBvYmogaXMgYSBUcmFuc2FjdGlvbiBwcm90b3R5cGUgKG9yIHByb3RvdHlwZSBvZiBhIHN1YmNsYXNzIHRvIFRyYW5zYWN0aW9uKVxuICAgICAgICAgIC8vIE1ha2UgdGhlIEFQSSBhIGdldHRlciB0aGF0IHJldHVybnMgdGhpcy50YWJsZSh0YWJsZU5hbWUpXG4gICAgICAgICAgc2V0UHJvcChvYmosIHRhYmxlTmFtZSwge1xuICAgICAgICAgICAgZ2V0KHRoaXM6IFRyYW5zYWN0aW9uKSB7IHJldHVybiB0aGlzLnRhYmxlKHRhYmxlTmFtZSk7IH0sXG4gICAgICAgICAgICBzZXQodmFsdWU6IGFueSkge1xuICAgICAgICAgICAgICAvLyBJc3N1ZSAjMTAzOVxuICAgICAgICAgICAgICAvLyBMZXQgXCJ0aGlzLnNjaGVtYSA9IGRic2NoZW1hO1wiIGFuZCBvdGhlciBwcm9wcyBpbiB0cmFuc2FjdGlvbiBjb25zdHJ1Y3RvciB3b3JrIGV2ZW4gaWYgdGhlcmUncyBhIG5hbWUgY29sbGlzaW9uIHdpdGggdGhlIHRhYmxlIG5hbWUuXG4gICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHRoaXMsIHRhYmxlTmFtZSwge3ZhbHVlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVGFibGUgd2lsbCBub3QgYmUgYm91bmQgdG8gYSB0cmFuc2FjdGlvbiAod2lsbCB1c2UgRGV4aWUuY3VycmVudFRyYW5zYWN0aW9uKVxuICAgICAgICAgIG9ialt0YWJsZU5hbWVdID0gbmV3IGRiLlRhYmxlKHRhYmxlTmFtZSwgc2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZVRhYmxlc0FwaSh7X25vdmlwOiBkYn06IERleGllLCBvYmpzOiBPYmplY3RbXSkge1xuICBvYmpzLmZvckVhY2gob2JqID0+IHtcbiAgICBmb3IgKGxldCBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAob2JqW2tleV0gaW5zdGFuY2VvZiBkYi5UYWJsZSkgZGVsZXRlIG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb3dlclZlcnNpb25GaXJzdChhOiBWZXJzaW9uLCBiOiBWZXJzaW9uKSB7XG4gIHJldHVybiBhLl9jZmcudmVyc2lvbiAtIGIuX2NmZy52ZXJzaW9uO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcnVuVXBncmFkZXJzKGRiOiBEZXhpZSwgb2xkVmVyc2lvbjogbnVtYmVyLCBpZGJVcGdyYWRlVHJhbnM6IElEQlRyYW5zYWN0aW9uLCByZWplY3QpIHtcbiAgY29uc3QgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICBjb25zdCB0cmFucyA9IGRiLl9jcmVhdGVUcmFuc2FjdGlvbigncmVhZHdyaXRlJywgZGIuX3N0b3JlTmFtZXMsIGdsb2JhbFNjaGVtYSk7XG4gIHRyYW5zLmNyZWF0ZShpZGJVcGdyYWRlVHJhbnMpO1xuICB0cmFucy5fY29tcGxldGlvbi5jYXRjaChyZWplY3QpO1xuICBjb25zdCByZWplY3RUcmFuc2FjdGlvbiA9IHRyYW5zLl9yZWplY3QuYmluZCh0cmFucyk7XG4gIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICBuZXdTY29wZSgoKSA9PiB7XG4gICAgUFNELnRyYW5zID0gdHJhbnM7XG4gICAgUFNELnRyYW5zbGVzcyA9IHRyYW5zbGVzcztcbiAgICBpZiAob2xkVmVyc2lvbiA9PT0gMCkge1xuICAgICAgLy8gQ3JlYXRlIHRhYmxlczpcbiAgICAgIGtleXMoZ2xvYmFsU2NoZW1hKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICAgIGNyZWF0ZVRhYmxlKGlkYlVwZ3JhZGVUcmFucywgdGFibGVOYW1lLCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5wcmltS2V5LCBnbG9iYWxTY2hlbWFbdGFibGVOYW1lXS5pbmRleGVzKTtcbiAgICAgIH0pO1xuICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgUHJvbWlzZS5mb2xsb3coKCkgPT4gZGIub24ucG9wdWxhdGUuZmlyZSh0cmFucykpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgICB9IGVsc2VcbiAgICAgIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoZGIsIG9sZFZlcnNpb24sIHRyYW5zLCBpZGJVcGdyYWRlVHJhbnMpLmNhdGNoKHJlamVjdFRyYW5zYWN0aW9uKTtcbiAgfSk7XG59XG5cbmV4cG9ydCB0eXBlIFVwZ3JhZGVRdWV1ZUl0ZW0gPSAoaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uKSA9PiBQcm9taXNlTGlrZTxhbnk+IHwgdm9pZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZVRhYmxlc0FuZEluZGV4ZXMoXG4gIHtfbm92aXA6IGRifTogRGV4aWUsXG4gIG9sZFZlcnNpb246IG51bWJlcixcbiAgdHJhbnM6IFRyYW5zYWN0aW9uLFxuICBpZGJVcGdyYWRlVHJhbnM6IElEQlRyYW5zYWN0aW9uKVxue1xuICAvLyBVcGdyYWRlIHZlcnNpb24gdG8gdmVyc2lvbiwgc3RlcC1ieS1zdGVwIGZyb20gb2xkZXN0IHRvIG5ld2VzdCB2ZXJzaW9uLlxuICAvLyBFYWNoIHRyYW5zYWN0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIHRhYmxlIHNldCB0aGF0IHdhcyBjdXJyZW50IGluIHRoYXQgdmVyc2lvbiAoYnV0IGFsc28gbm90LXlldC1kZWxldGVkIHRhYmxlcyBmcm9tIGl0cyBwcmV2aW91cyB2ZXJzaW9uKVxuICBjb25zdCBxdWV1ZTogVXBncmFkZVF1ZXVlSXRlbVtdID0gW107XG4gIGNvbnN0IHZlcnNpb25zID0gZGIuX3ZlcnNpb25zO1xuICBsZXQgZ2xvYmFsU2NoZW1hID0gZGIuX2RiU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICBsZXQgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gZmFsc2U7XG5cbiAgY29uc3QgdmVyc1RvUnVuID0gdmVyc2lvbnMuZmlsdGVyKHYgPT4gdi5fY2ZnLnZlcnNpb24gPj0gb2xkVmVyc2lvbik7XG4gIHZlcnNUb1J1bi5mb3JFYWNoKHZlcnNpb24gPT4ge1xuICAgIHF1ZXVlLnB1c2goKCkgPT4ge1xuICAgICAgY29uc3Qgb2xkU2NoZW1hID0gZ2xvYmFsU2NoZW1hO1xuICAgICAgY29uc3QgbmV3U2NoZW1hID0gdmVyc2lvbi5fY2ZnLmRic2NoZW1hO1xuICAgICAgYWRqdXN0VG9FeGlzdGluZ0luZGV4TmFtZXMoZGIsIG9sZFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTtcbiAgICAgIGFkanVzdFRvRXhpc3RpbmdJbmRleE5hbWVzKGRiLCBuZXdTY2hlbWEsIGlkYlVwZ3JhZGVUcmFucyk7XG5cbiAgICAgIGdsb2JhbFNjaGVtYSA9IGRiLl9kYlNjaGVtYSA9IG5ld1NjaGVtYTtcblxuICAgICAgY29uc3QgZGlmZiA9IGdldFNjaGVtYURpZmYob2xkU2NoZW1hLCBuZXdTY2hlbWEpO1xuICAgICAgLy8gQWRkIHRhYmxlcyAgICAgICAgICAgXG4gICAgICBkaWZmLmFkZC5mb3JFYWNoKHR1cGxlID0+IHtcbiAgICAgICAgY3JlYXRlVGFibGUoaWRiVXBncmFkZVRyYW5zLCB0dXBsZVswXSwgdHVwbGVbMV0ucHJpbUtleSwgdHVwbGVbMV0uaW5kZXhlcyk7XG4gICAgICB9KTtcbiAgICAgIC8vIENoYW5nZSB0YWJsZXNcbiAgICAgIGRpZmYuY2hhbmdlLmZvckVhY2goY2hhbmdlID0+IHtcbiAgICAgICAgaWYgKGNoYW5nZS5yZWNyZWF0ZSkge1xuICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLlVwZ3JhZGUoXCJOb3QgeWV0IHN1cHBvcnQgZm9yIGNoYW5naW5nIHByaW1hcnkga2V5XCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnN0IHN0b3JlID0gaWRiVXBncmFkZVRyYW5zLm9iamVjdFN0b3JlKGNoYW5nZS5uYW1lKTtcbiAgICAgICAgICAvLyBBZGQgaW5kZXhlc1xuICAgICAgICAgIGNoYW5nZS5hZGQuZm9yRWFjaChpZHggPT4gYWRkSW5kZXgoc3RvcmUsIGlkeCkpO1xuICAgICAgICAgIC8vIFVwZGF0ZSBpbmRleGVzXG4gICAgICAgICAgY2hhbmdlLmNoYW5nZS5mb3JFYWNoKGlkeCA9PiB7XG4gICAgICAgICAgICBzdG9yZS5kZWxldGVJbmRleChpZHgubmFtZSk7XG4gICAgICAgICAgICBhZGRJbmRleChzdG9yZSwgaWR4KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICAvLyBEZWxldGUgaW5kZXhlc1xuICAgICAgICAgIGNoYW5nZS5kZWwuZm9yRWFjaChpZHhOYW1lID0+IHN0b3JlLmRlbGV0ZUluZGV4KGlkeE5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IGNvbnRlbnRVcGdyYWRlID0gdmVyc2lvbi5fY2ZnLmNvbnRlbnRVcGdyYWRlO1xuXG4gICAgICBpZiAoY29udGVudFVwZ3JhZGUgJiYgdmVyc2lvbi5fY2ZnLnZlcnNpb24gPiBvbGRWZXJzaW9uKSB7XG4gICAgICAgIC8vIFVwZGF0ZSBkYi5jb3JlIHdpdGggbmV3IHRhYmxlcyBhbmQgaW5kZXhlczpcbiAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCBpZGJVcGdyYWRlVHJhbnMpO1xuICAgICAgICB0cmFucy5fbWVtb2l6ZWRUYWJsZXMgPSB7fTsgLy8gSW52YWxpZGF0ZSBtZW1vaXphdGlvbiBhcyB0cmFuc2FjdGlvbiBzaGFwZSBtYXkgY2hhbmdlIGJldHdlZW4gdmVyc2lvbnMuXG5cbiAgICAgICAgYW55Q29udGVudFVwZ3JhZGVySGFzUnVuID0gdHJ1ZTtcblxuICAgICAgICAvLyBBZGQgdG8tYmUtZGVsZXRlZCB0YWJsZXMgdG8gY29udGVudFVwZ3JhZGUgdHJhbnNhY3Rpb25cbiAgICAgICAgbGV0IHVwZ3JhZGVTY2hlbWEgPSBzaGFsbG93Q2xvbmUobmV3U2NoZW1hKTtcbiAgICAgICAgZGlmZi5kZWwuZm9yRWFjaCh0YWJsZSA9PiB7XG4gICAgICAgICAgdXBncmFkZVNjaGVtYVt0YWJsZV0gPSBvbGRTY2hlbWFbdGFibGVdO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBTYWZlIHRvIGFmZmVjdCBUcmFuc2FjdGlvbi5wcm90b3R5cGUgZ2xvYmFsbHkgaW4gdGhpcyBtb21lbnQsXG4gICAgICAgIC8vIGJlY2F1c2Ugd2hlbiB0aGlzIGNvZGUgcnVucywgdGhlcmUgbWF5IG5vdCBiZSBhbnkgb3RoZXIgY29kZVxuICAgICAgICAvLyB0aGF0IGNhbiBhY2Nlc3MgYW55IHRyYW5zYWN0aW9uIGluc3RhbmNlLCBlbHNlIHRoYW4gdGhpcyBwYXJ0aWN1bGFyXG4gICAgICAgIC8vIHVwZ3JhZGVyIGZ1bmN0aW9uLlxuICAgICAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGVdKTtcbiAgICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGtleXModXBncmFkZVNjaGVtYSksIHVwZ3JhZGVTY2hlbWEpO1xuICAgICAgICB0cmFucy5zY2hlbWEgPSB1cGdyYWRlU2NoZW1hO1xuXG4gICAgICAgIC8vIFN1cHBvcnQgZm9yIG5hdGl2ZSBhc3luYyBhd2FpdC5cbiAgICAgICAgY29uc3QgY29udGVudFVwZ3JhZGVJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKGNvbnRlbnRVcGdyYWRlKTtcbiAgICAgICAgaWYgKGNvbnRlbnRVcGdyYWRlSXNBc3luYykge1xuICAgICAgICAgIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxldCByZXR1cm5WYWx1ZTogYW55O1xuICAgICAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAgICAgLy8gRmluYWxseSwgY2FsbCB0aGUgc2NvcGUgZnVuY3Rpb24gd2l0aCBvdXIgdGFibGUgYW5kIHRyYW5zYWN0aW9uIGFyZ3VtZW50cy5cbiAgICAgICAgICByZXR1cm5WYWx1ZSA9IGNvbnRlbnRVcGdyYWRlKHRyYW5zKTtcbiAgICAgICAgICBpZiAocmV0dXJuVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChjb250ZW50VXBncmFkZUlzQXN5bmMpIHtcbiAgICAgICAgICAgICAgLy8gY29udGVudFVwZ3JhZGUgaXMgYSBuYXRpdmUgYXN5bmMgZnVuY3Rpb24gLSB3ZSBrbm93IGZvciBzdXJlIHJldHVyblZhbHVlIGlzIG5hdGl2ZSBwcm9taXNlLlxuICAgICAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgICByZXR1cm5WYWx1ZS50aGVuKGRlY3JlbWVudG9yLCBkZWNyZW1lbnRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldHVyblZhbHVlKSA6IHByb21pc2VGb2xsb3dlZC50aGVuKCgpPT5yZXR1cm5WYWx1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHF1ZXVlLnB1c2goaWRidHJhbnMgPT4ge1xuICAgICAgaWYgKCFhbnlDb250ZW50VXBncmFkZXJIYXNSdW4gfHwgIWhhc0lFRGVsZXRlT2JqZWN0U3RvcmVCdWcpIHsgLy8gRG9udCBkZWxldGUgb2xkIHRhYmxlcyBpZiBpZUJ1ZyBpcyBwcmVzZW50IGFuZCBhIGNvbnRlbnQgdXBncmFkZXIgaGFzIHJ1bi4gTGV0IHRhYmxlcyBiZSBsZWZ0IGluIERCIHNvIGZhci4gVGhpcyBuZWVkcyB0byBiZSB0YWtlbiBjYXJlIG9mLlxuICAgICAgICBjb25zdCBuZXdTY2hlbWEgPSB2ZXJzaW9uLl9jZmcuZGJzY2hlbWE7XG4gICAgICAgIC8vIERlbGV0ZSBvbGQgdGFibGVzXG4gICAgICAgIGRlbGV0ZVJlbW92ZWRUYWJsZXMobmV3U2NoZW1hLCBpZGJ0cmFucyk7XG4gICAgICB9XG4gICAgICAvLyBSZXN0b3JlIHRoZSBmaW5hbCBBUElcbiAgICAgIHJlbW92ZVRhYmxlc0FwaShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0pO1xuICAgICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLlRyYW5zYWN0aW9uLnByb3RvdHlwZV0sIGRiLl9zdG9yZU5hbWVzLCBkYi5fZGJTY2hlbWEpO1xuICAgICAgdHJhbnMuc2NoZW1hID0gZGIuX2RiU2NoZW1hO1xuICAgIH0pO1xuICB9KTtcblxuICAvLyBOb3csIGNyZWF0ZSBhIHF1ZXVlIGV4ZWN1dGlvbiBlbmdpbmVcbiAgZnVuY3Rpb24gcnVuUXVldWUoKSB7XG4gICAgcmV0dXJuIHF1ZXVlLmxlbmd0aCA/IFByb21pc2UucmVzb2x2ZShxdWV1ZS5zaGlmdCgpKHRyYW5zLmlkYnRyYW5zKSkudGhlbihydW5RdWV1ZSkgOlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH1cblxuICByZXR1cm4gcnVuUXVldWUoKS50aGVuKCgpID0+IHtcbiAgICBjcmVhdGVNaXNzaW5nVGFibGVzKGdsb2JhbFNjaGVtYSwgaWRiVXBncmFkZVRyYW5zKTsgLy8gQXQgbGFzdCwgbWFrZSBzdXJlIHRvIGNyZWF0ZSBhbnkgbWlzc2luZyB0YWJsZXMuIChOZWVkZWQgYnkgYWRkb25zIHRoYXQgYWRkIHN0b3JlcyB0byBEQiB3aXRob3V0IHNwZWNpZnlpbmcgdmVyc2lvbilcbiAgfSk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2NoZW1hRGlmZiB7XG4gIGRlbDogc3RyaW5nW10sXG4gIGFkZDogW3N0cmluZywgVGFibGVTY2hlbWFdW107XG4gIGNoYW5nZTogVGFibGVTY2hlbWFEaWZmW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFibGVTY2hlbWFEaWZmIHtcbiAgbmFtZTogc3RyaW5nLFxuICByZWNyZWF0ZTogYm9vbGVhbixcbiAgZGVsOiBzdHJpbmdbXSxcbiAgYWRkOiBJbmRleFNwZWNbXSxcbiAgY2hhbmdlOiBJbmRleFNwZWNbXVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U2NoZW1hRGlmZihvbGRTY2hlbWE6IERiU2NoZW1hLCBuZXdTY2hlbWE6IERiU2NoZW1hKTogU2NoZW1hRGlmZiB7XG4gIGNvbnN0IGRpZmY6IFNjaGVtYURpZmYgPSB7XG4gICAgZGVsOiBbXSwgLy8gQXJyYXkgb2YgdGFibGUgbmFtZXNcbiAgICBhZGQ6IFtdLCAvLyBBcnJheSBvZiBbdGFibGVOYW1lLCBuZXdEZWZpbml0aW9uXVxuICAgIGNoYW5nZTogW10gLy8gQXJyYXkgb2Yge25hbWU6IHRhYmxlTmFtZSwgcmVjcmVhdGU6IG5ld0RlZmluaXRpb24sIGRlbDogZGVsSW5kZXhOYW1lcywgYWRkOiBuZXdJbmRleERlZnMsIGNoYW5nZTogY2hhbmdlZEluZGV4RGVmc31cbiAgfTtcbiAgbGV0IHRhYmxlOiBzdHJpbmc7XG4gIGZvciAodGFibGUgaW4gb2xkU2NoZW1hKSB7XG4gICAgaWYgKCFuZXdTY2hlbWFbdGFibGVdKSBkaWZmLmRlbC5wdXNoKHRhYmxlKTtcbiAgfVxuICBmb3IgKHRhYmxlIGluIG5ld1NjaGVtYSkge1xuICAgIGNvbnN0IG9sZERlZiA9IG9sZFNjaGVtYVt0YWJsZV0sXG4gICAgICBuZXdEZWYgPSBuZXdTY2hlbWFbdGFibGVdO1xuICAgIGlmICghb2xkRGVmKSB7XG4gICAgICBkaWZmLmFkZC5wdXNoKFt0YWJsZSwgbmV3RGVmXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgbmFtZTogdGFibGUsXG4gICAgICAgIGRlZjogbmV3RGVmLFxuICAgICAgICByZWNyZWF0ZTogZmFsc2UsXG4gICAgICAgIGRlbDogW10sXG4gICAgICAgIGFkZDogW10sXG4gICAgICAgIGNoYW5nZTogW11cbiAgICAgIH07XG4gICAgICBpZiAoXG4gICAgICAgICAgKFxuICAgICAgICAgICAgIC8vIGNvbXBhcmUga2V5UGF0aHMgbm8gbWF0dGVyIGlmIHN0cmluZyBvciBzdHJpbmdbXVxuICAgICAgICAgICAgIC8vIGNvbXBhcmUgZmFsc3kga2V5cGF0aHMgc2FtZSBubyBtYXR0ZXIgaWYgdGhleSBhcmUgbnVsbCBvciBlbXB0eSBzdHJpbmcuXG4gICAgICAgICAgICAnJysob2xkRGVmLnByaW1LZXkua2V5UGF0aHx8JycpXG4gICAgICAgICAgKSAhPT0gKFxuICAgICAgICAgICAgJycrKG5ld0RlZi5wcmltS2V5LmtleVBhdGh8fCcnKVxuICAgICAgICAgICkgfHxcbiAgICAgICAgICAgIC8vIENvbXBhcmUgdGhlIGF1dG9JbmNyZW1lbnQgZmxhZyBhbHNvXG4gICAgICAgICAgKG9sZERlZi5wcmltS2V5LmF1dG8gIT09IG5ld0RlZi5wcmltS2V5LmF1dG8gJiYgIWlzSUVPckVkZ2UpKSAvLyBJRSBoYXMgYnVnIHJlYWRpbmcgYXV0b0luY3JlbWVudCBwcm9wLlxuICAgICAge1xuICAgICAgICAvLyBQcmltYXJ5IGtleSBoYXMgY2hhbmdlZC4gUmVtb3ZlIGFuZCByZS1hZGQgdGFibGUuXG4gICAgICAgIGNoYW5nZS5yZWNyZWF0ZSA9IHRydWU7XG4gICAgICAgIGRpZmYuY2hhbmdlLnB1c2goY2hhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNhbWUgcHJpbWFyeSBrZXkuIEp1c3QgZmluZCBvdXQgd2hhdCBkaWZmZXJzOlxuICAgICAgICBjb25zdCBvbGRJbmRleGVzID0gb2xkRGVmLmlkeEJ5TmFtZTtcbiAgICAgICAgY29uc3QgbmV3SW5kZXhlcyA9IG5ld0RlZi5pZHhCeU5hbWU7XG4gICAgICAgIGxldCBpZHhOYW1lOiBzdHJpbmc7XG4gICAgICAgIGZvciAoaWR4TmFtZSBpbiBvbGRJbmRleGVzKSB7XG4gICAgICAgICAgaWYgKCFuZXdJbmRleGVzW2lkeE5hbWVdKSBjaGFuZ2UuZGVsLnB1c2goaWR4TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpZHhOYW1lIGluIG5ld0luZGV4ZXMpIHtcbiAgICAgICAgICBjb25zdCBvbGRJZHggPSBvbGRJbmRleGVzW2lkeE5hbWVdLFxuICAgICAgICAgICAgbmV3SWR4ID0gbmV3SW5kZXhlc1tpZHhOYW1lXTtcbiAgICAgICAgICBpZiAoIW9sZElkeCkgY2hhbmdlLmFkZC5wdXNoKG5ld0lkeCk7XG4gICAgICAgICAgZWxzZSBpZiAob2xkSWR4LnNyYyAhPT0gbmV3SWR4LnNyYykgY2hhbmdlLmNoYW5nZS5wdXNoKG5ld0lkeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoYW5nZS5kZWwubGVuZ3RoID4gMCB8fCBjaGFuZ2UuYWRkLmxlbmd0aCA+IDAgfHwgY2hhbmdlLmNoYW5nZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgZGlmZi5jaGFuZ2UucHVzaChjaGFuZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlVGFibGUoXG4gIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbixcbiAgdGFibGVOYW1lOiBzdHJpbmcsXG4gIHByaW1LZXk6IEluZGV4U3BlYyxcbiAgaW5kZXhlczogSW5kZXhTcGVjW11cbikge1xuICBjb25zdCBzdG9yZSA9IGlkYnRyYW5zLmRiLmNyZWF0ZU9iamVjdFN0b3JlKFxuICAgIHRhYmxlTmFtZSxcbiAgICBwcmltS2V5LmtleVBhdGggP1xuICAgICAgeyBrZXlQYXRoOiBwcmltS2V5LmtleVBhdGgsIGF1dG9JbmNyZW1lbnQ6IHByaW1LZXkuYXV0byB9IDpcbiAgICAgIHsgYXV0b0luY3JlbWVudDogcHJpbUtleS5hdXRvIH1cbiAgKTtcbiAgaW5kZXhlcy5mb3JFYWNoKGlkeCA9PiBhZGRJbmRleChzdG9yZSwgaWR4KSk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZU1pc3NpbmdUYWJsZXMobmV3U2NoZW1hOiBEYlNjaGVtYSwgaWRidHJhbnM6IElEQlRyYW5zYWN0aW9uKSB7XG4gIGtleXMobmV3U2NoZW1hKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgaWYgKCFpZGJ0cmFucy5kYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKHRhYmxlTmFtZSkpIHtcbiAgICAgIGNyZWF0ZVRhYmxlKGlkYnRyYW5zLCB0YWJsZU5hbWUsIG5ld1NjaGVtYVt0YWJsZU5hbWVdLnByaW1LZXksIG5ld1NjaGVtYVt0YWJsZU5hbWVdLmluZGV4ZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWxldGVSZW1vdmVkVGFibGVzKG5ld1NjaGVtYTogRGJTY2hlbWEsIGlkYnRyYW5zOiBJREJUcmFuc2FjdGlvbikge1xuICBbXS5zbGljZS5jYWxsKGlkYnRyYW5zLmRiLm9iamVjdFN0b3JlTmFtZXMpLmZvckVhY2goc3RvcmVOYW1lID0+XG4gICAgbmV3U2NoZW1hW3N0b3JlTmFtZV0gPT0gbnVsbCAmJiBpZGJ0cmFucy5kYi5kZWxldGVPYmplY3RTdG9yZShzdG9yZU5hbWUpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZEluZGV4KHN0b3JlOiBJREJPYmplY3RTdG9yZSwgaWR4OiBJbmRleFNwZWMpIHtcbiAgc3RvcmUuY3JlYXRlSW5kZXgoaWR4Lm5hbWUsIGlkeC5rZXlQYXRoLCB7IHVuaXF1ZTogaWR4LnVuaXF1ZSwgbXVsdGlFbnRyeTogaWR4Lm11bHRpIH0pO1xufVxuXG5mdW5jdGlvbiBidWlsZEdsb2JhbFNjaGVtYShcbiAgZGI6IERleGllLFxuICBpZGJkYjogSURCRGF0YWJhc2UsXG4gIHRtcFRyYW5zOiBJREJUcmFuc2FjdGlvblxuKSB7XG4gIGNvbnN0IGdsb2JhbFNjaGVtYSA9IHt9O1xuICBjb25zdCBkYlN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgZGJTdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICBjb25zdCBzdG9yZSA9IHRtcFRyYW5zLm9iamVjdFN0b3JlKHN0b3JlTmFtZSk7XG4gICAgbGV0IGtleVBhdGggPSBzdG9yZS5rZXlQYXRoO1xuICAgIGNvbnN0IHByaW1LZXkgPSBjcmVhdGVJbmRleFNwZWMoXG4gICAgICBuYW1lRnJvbUtleVBhdGgoa2V5UGF0aCksXG4gICAgICBrZXlQYXRoIHx8IFwiXCIsXG4gICAgICBmYWxzZSxcbiAgICAgIGZhbHNlLFxuICAgICAgISFzdG9yZS5hdXRvSW5jcmVtZW50LFxuICAgICAga2V5UGF0aCAmJiB0eXBlb2Yga2V5UGF0aCAhPT0gXCJzdHJpbmdcIixcbiAgICAgIHRydWVcbiAgICApO1xuICAgIGNvbnN0IGluZGV4ZXM6IEluZGV4U3BlY1tdID0gW107XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdG9yZS5pbmRleE5hbWVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBjb25zdCBpZGJpbmRleCA9IHN0b3JlLmluZGV4KHN0b3JlLmluZGV4TmFtZXNbal0pO1xuICAgICAga2V5UGF0aCA9IGlkYmluZGV4LmtleVBhdGg7XG4gICAgICB2YXIgaW5kZXggPSBjcmVhdGVJbmRleFNwZWMoXG4gICAgICAgIGlkYmluZGV4Lm5hbWUsXG4gICAgICAgIGtleVBhdGgsXG4gICAgICAgICEhaWRiaW5kZXgudW5pcXVlLFxuICAgICAgICAhIWlkYmluZGV4Lm11bHRpRW50cnksXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBrZXlQYXRoICYmIHR5cGVvZiBrZXlQYXRoICE9PSBcInN0cmluZ1wiLFxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICAgIGluZGV4ZXMucHVzaChpbmRleCk7XG4gICAgfVxuICAgIGdsb2JhbFNjaGVtYVtzdG9yZU5hbWVdID0gY3JlYXRlVGFibGVTY2hlbWEoc3RvcmVOYW1lLCBwcmltS2V5LCBpbmRleGVzKTtcbiAgfSk7XG4gIHJldHVybiBnbG9iYWxTY2hlbWE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZWFkR2xvYmFsU2NoZW1hKHtfbm92aXA6IGRifTogRGV4aWUsIGlkYmRiOiBJREJEYXRhYmFzZSwgdG1wVHJhbnM6IElEQlRyYW5zYWN0aW9uKSB7XG4gIGRiLnZlcm5vID0gaWRiZGIudmVyc2lvbiAvIDEwO1xuICBjb25zdCBnbG9iYWxTY2hlbWEgPSBkYi5fZGJTY2hlbWEgPSBidWlsZEdsb2JhbFNjaGVtYShkYiwgaWRiZGIsIHRtcFRyYW5zKTtcbiAgZGIuX3N0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzLCAwKTtcbiAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXNdLCBrZXlzKGdsb2JhbFNjaGVtYSksIGdsb2JhbFNjaGVtYSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB2ZXJpZnlJbnN0YWxsZWRTY2hlbWEoZGI6IERleGllLCB0bXBUcmFuczogSURCVHJhbnNhY3Rpb24pOiBib29sZWFuIHtcbiAgY29uc3QgaW5zdGFsbGVkU2NoZW1hID0gYnVpbGRHbG9iYWxTY2hlbWEoZGIsIGRiLmlkYmRiLCB0bXBUcmFucyk7XG4gIGNvbnN0IGRpZmYgPSBnZXRTY2hlbWFEaWZmKGluc3RhbGxlZFNjaGVtYSwgZGIuX2RiU2NoZW1hKTtcbiAgcmV0dXJuICEoZGlmZi5hZGQubGVuZ3RoIHx8IGRpZmYuY2hhbmdlLnNvbWUoY2ggPT4gY2guYWRkLmxlbmd0aCB8fCBjaC5jaGFuZ2UubGVuZ3RoKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyh7X25vdmlwOiBkYn06IERleGllLCBzY2hlbWE6IERiU2NoZW1hLCBpZGJ0cmFuczogSURCVHJhbnNhY3Rpb24pIHtcbiAgLy8gSXNzdWUgIzMwIFByb2JsZW0gd2l0aCBleGlzdGluZyBkYiAtIGFkanVzdCB0byBleGlzdGluZyBpbmRleCBuYW1lcyB3aGVuIG1pZ3JhdGluZyBmcm9tIG5vbi1kZXhpZSBkYlxuICBjb25zdCBzdG9yZU5hbWVzID0gaWRidHJhbnMuZGIub2JqZWN0U3RvcmVOYW1lcztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlTmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBzdG9yZU5hbWUgPSBzdG9yZU5hbWVzW2ldO1xuICAgIGNvbnN0IHN0b3JlID0gaWRidHJhbnMub2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcbiAgICBkYi5faGFzR2V0QWxsID0gJ2dldEFsbCcgaW4gc3RvcmU7XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0b3JlLmluZGV4TmFtZXMubGVuZ3RoOyArK2opIHtcbiAgICAgIGNvbnN0IGluZGV4TmFtZSA9IHN0b3JlLmluZGV4TmFtZXNbal07XG4gICAgICBjb25zdCBrZXlQYXRoID0gc3RvcmUuaW5kZXgoaW5kZXhOYW1lKS5rZXlQYXRoO1xuICAgICAgY29uc3QgZGV4aWVOYW1lID0gdHlwZW9mIGtleVBhdGggPT09ICdzdHJpbmcnID8ga2V5UGF0aCA6IFwiW1wiICsgc2xpY2Uoa2V5UGF0aCkuam9pbignKycpICsgXCJdXCI7XG4gICAgICBpZiAoc2NoZW1hW3N0b3JlTmFtZV0pIHtcbiAgICAgICAgY29uc3QgaW5kZXhTcGVjID0gc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgIGlmIChpbmRleFNwZWMpIHtcbiAgICAgICAgICBpbmRleFNwZWMubmFtZSA9IGluZGV4TmFtZTtcbiAgICAgICAgICBkZWxldGUgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2RleGllTmFtZV07XG4gICAgICAgICAgc2NoZW1hW3N0b3JlTmFtZV0uaWR4QnlOYW1lW2luZGV4TmFtZV0gPSBpbmRleFNwZWM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCdWcgd2l0aCBnZXRBbGwoKSBvbiBTYWZhcmkgdmVyPDYwNCBvbiBXb3JrZXJzIG9ubHksIHNlZSBkaXNjdXNzaW9uIGZvbGxvd2luZyBQUiAjNTc5XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAvU2FmYXJpLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgIS8oQ2hyb21lXFwvfEVkZ2VcXC8pLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmXG4gICAgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJiBfZ2xvYmFsIGluc3RhbmNlb2YgX2dsb2JhbC5Xb3JrZXJHbG9iYWxTY29wZSAmJlxuICAgIFtdLmNvbmNhdChuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKC9TYWZhcmlcXC8oXFxkKikvKSlbMV0gPCA2MDQpXG4gIHtcbiAgICBkYi5faGFzR2V0QWxsID0gZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlSW5kZXhTeW50YXgocHJpbUtleUFuZEluZGV4ZXM6IHN0cmluZyk6IEluZGV4U3BlY1tdIHtcbiAgcmV0dXJuIHByaW1LZXlBbmRJbmRleGVzLnNwbGl0KCcsJykubWFwKChpbmRleCwgaW5kZXhOdW0pID0+IHtcbiAgICBpbmRleCA9IGluZGV4LnRyaW0oKTtcbiAgICBjb25zdCBuYW1lID0gaW5kZXgucmVwbGFjZSgvKFsmKl18XFwrXFwrKS9nLCBcIlwiKTsgLy8gUmVtb3ZlIFwiJlwiLCBcIisrXCIgYW5kIFwiKlwiXG4gICAgLy8gTGV0IGtleVBhdGggb2YgXCJbYStiXVwiIGJlIFtcImFcIixcImJcIl06XG4gICAgY29uc3Qga2V5UGF0aCA9IC9eXFxbLy50ZXN0KG5hbWUpID8gbmFtZS5tYXRjaCgvXlxcWyguKilcXF0kLylbMV0uc3BsaXQoJysnKSA6IG5hbWU7XG5cbiAgICByZXR1cm4gY3JlYXRlSW5kZXhTcGVjKFxuICAgICAgbmFtZSxcbiAgICAgIGtleVBhdGggfHwgbnVsbCxcbiAgICAgIC9cXCYvLnRlc3QoaW5kZXgpLFxuICAgICAgL1xcKi8udGVzdChpbmRleCksXG4gICAgICAvXFwrXFwrLy50ZXN0KGluZGV4KSxcbiAgICAgIGlzQXJyYXkoa2V5UGF0aCksXG4gICAgICBpbmRleE51bSA9PT0gMFxuICAgICk7XG4gIH0pO1xufVxuIiwgImltcG9ydCB7IFZlcnNpb24gYXMgSVZlcnNpb24gfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdmVyc2lvbic7XG5pbXBvcnQgeyBEYlNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1zY2hlbWEnO1xuaW1wb3J0IHsgZXh0ZW5kLCBrZXlzIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi90cmFuc2FjdGlvbic7XG5pbXBvcnQgeyByZW1vdmVUYWJsZXNBcGksIHNldEFwaU9uUGxhY2UsIHBhcnNlSW5kZXhTeW50YXggfSBmcm9tICcuL3NjaGVtYS1oZWxwZXJzJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgY3JlYXRlVGFibGVTY2hlbWEgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3RhYmxlLXNjaGVtYSc7XG5pbXBvcnQgeyBub3AsIHByb21pc2FibGVDaGFpbiB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9jaGFpbmluZy1mdW5jdGlvbnMnO1xuXG4vKiogY2xhc3MgVmVyc2lvblxuICpcbiAqIGh0dHBzOi8vZGV4aWUub3JnL2RvY3MvVmVyc2lvbi9WZXJzaW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBWZXJzaW9uIGltcGxlbWVudHMgSVZlcnNpb24ge1xuICBkYjogRGV4aWU7XG4gIF9jZmc6IHtcbiAgICB2ZXJzaW9uOiBudW1iZXIsXG4gICAgc3RvcmVzU291cmNlOiB7IFt0YWJsZU5hbWU6IHN0cmluZ106IHN0cmluZyB8IG51bGwgfSxcbiAgICBkYnNjaGVtYTogRGJTY2hlbWEsXG4gICAgdGFibGVzOiB7fSxcbiAgICBjb250ZW50VXBncmFkZTogRnVuY3Rpb24gfCBudWxsXG4gIH1cblxuICBfcGFyc2VTdG9yZXNTcGVjKHN0b3JlczogeyBbdGFibGVOYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBudWxsIH0sIG91dFNjaGVtYTogRGJTY2hlbWEpOiBhbnkge1xuICAgIGtleXMoc3RvcmVzKS5mb3JFYWNoKHRhYmxlTmFtZSA9PiB7XG4gICAgICBpZiAoc3RvcmVzW3RhYmxlTmFtZV0gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5kZXhlcyA9IHBhcnNlSW5kZXhTeW50YXgoc3RvcmVzW3RhYmxlTmFtZV0pO1xuICAgICAgICAgIHZhciBwcmltS2V5ID0gaW5kZXhlcy5zaGlmdCgpO1xuICAgICAgICAgIGlmIChwcmltS2V5Lm11bHRpKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJQcmltYXJ5IGtleSBjYW5ub3QgYmUgbXVsdGktdmFsdWVkXCIpO1xuICAgICAgICAgIGluZGV4ZXMuZm9yRWFjaChpZHggPT4ge1xuICAgICAgICAgICAgICBpZiAoaWR4LmF1dG8pIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIk9ubHkgcHJpbWFyeSBrZXkgY2FuIGJlIG1hcmtlZCBhcyBhdXRvSW5jcmVtZW50ICgrKylcIik7XG4gICAgICAgICAgICAgIGlmICghaWR4LmtleVBhdGgpIHRocm93IG5ldyBleGNlcHRpb25zLlNjaGVtYShcIkluZGV4IG11c3QgaGF2ZSBhIG5hbWUgYW5kIGNhbm5vdCBiZSBhbiBlbXB0eSBzdHJpbmdcIik7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgb3V0U2NoZW1hW3RhYmxlTmFtZV0gPSBjcmVhdGVUYWJsZVNjaGVtYSh0YWJsZU5hbWUsIHByaW1LZXksIGluZGV4ZXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgc3RvcmVzKHN0b3JlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfCBudWxsOyB9KTogSVZlcnNpb24ge1xuICAgIGNvbnN0IGRiID0gdGhpcy5kYjtcbiAgICB0aGlzLl9jZmcuc3RvcmVzU291cmNlID0gdGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSA/XG4gICAgICBleHRlbmQodGhpcy5fY2ZnLnN0b3Jlc1NvdXJjZSwgc3RvcmVzKSA6XG4gICAgICBzdG9yZXM7XG4gICAgY29uc3QgdmVyc2lvbnMgPSBkYi5fdmVyc2lvbnM7XG5cbiAgICAvLyBEZXJpdmUgc3RvcmVzIGZyb20gZWFybGllciB2ZXJzaW9ucyBpZiB0aGV5IGFyZSBub3QgZXhwbGljaXRlbHkgc3BlY2lmaWVkIGFzIG51bGwgb3IgYSBuZXcgc3ludGF4LlxuICAgIGNvbnN0IHN0b3Jlc1NwZWM6IHsgW2tleTogc3RyaW5nXTogc3RyaW5nOyB9ID0ge307XG4gICAgbGV0IGRic2NoZW1hID0ge307XG4gICAgdmVyc2lvbnMuZm9yRWFjaCh2ZXJzaW9uID0+IHsgLy8gJ3ZlcnNpb25zJyBpcyBhbHdheXMgc29ydGVkIGJ5IGxvd2VzdCB2ZXJzaW9uIGZpcnN0LlxuICAgICAgZXh0ZW5kKHN0b3Jlc1NwZWMsIHZlcnNpb24uX2NmZy5zdG9yZXNTb3VyY2UpO1xuICAgICAgZGJzY2hlbWEgPSAodmVyc2lvbi5fY2ZnLmRic2NoZW1hID0ge30pO1xuICAgICAgdmVyc2lvbi5fcGFyc2VTdG9yZXNTcGVjKHN0b3Jlc1NwZWMsIGRic2NoZW1hKTtcbiAgICB9KTtcbiAgICAvLyBVcGRhdGUgdGhlIGxhdGVzdCBzY2hlbWEgdG8gdGhpcyB2ZXJzaW9uXG4gICAgZGIuX2RiU2NoZW1hID0gZGJzY2hlbWE7XG4gICAgLy8gVXBkYXRlIEFQSXNcbiAgICByZW1vdmVUYWJsZXNBcGkoZGIsIFtkYi5fYWxsVGFibGVzLCBkYiwgZGIuVHJhbnNhY3Rpb24ucHJvdG90eXBlXSk7XG4gICAgc2V0QXBpT25QbGFjZShkYiwgW2RiLl9hbGxUYWJsZXMsIGRiLCBkYi5UcmFuc2FjdGlvbi5wcm90b3R5cGUsIHRoaXMuX2NmZy50YWJsZXNdLCBrZXlzKGRic2NoZW1hKSwgZGJzY2hlbWEpO1xuICAgIGRiLl9zdG9yZU5hbWVzID0ga2V5cyhkYnNjaGVtYSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB1cGdyYWRlKHVwZ3JhZGVGdW5jdGlvbjogKHRyYW5zOiBUcmFuc2FjdGlvbikgPT4gUHJvbWlzZUxpa2U8YW55PiB8IHZvaWQpOiBWZXJzaW9uIHtcbiAgICB0aGlzLl9jZmcuY29udGVudFVwZ3JhZGUgPSBwcm9taXNhYmxlQ2hhaW4odGhpcy5fY2ZnLmNvbnRlbnRVcGdyYWRlIHx8IG5vcCwgdXBncmFkZUZ1bmN0aW9uKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi4vZGV4aWUnO1xuaW1wb3J0IHsgbWFrZUNsYXNzQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvbWFrZS1jbGFzcy1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBWZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uJztcblxuZXhwb3J0IGludGVyZmFjZSBWZXJzaW9uQ29uc3RydWN0b3Ige1xuICBuZXcodmVyc2lvbk51bWJlcjogbnVtYmVyKTogVmVyc2lvbjtcbiAgcHJvdG90eXBlOiBWZXJzaW9uO1xufVxuXG4vKiogR2VuZXJhdGVzIGEgVmVyc2lvbiBjb25zdHJ1Y3RvciBib3VuZCB0byBnaXZlbiBEZXhpZSBpbnN0YW5jZS5cbiAqIFxuICogVGhlIHB1cnBvc2Ugb2YgaGF2aW5nIGR5bmFtaWNhbGx5IGNyZWF0ZWQgY29uc3RydWN0b3JzLCBpcyB0byBhbGxvd1xuICogYWRkb25zIHRvIGV4dGVuZCBjbGFzc2VzIGZvciBhIGNlcnRhaW4gRGV4aWUgaW5zdGFuY2Ugd2l0aG91dCBhZmZlY3RpbmdcbiAqIG90aGVyIGRiIGluc3RhbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZlcnNpb25Db25zdHJ1Y3RvcihkYjogRGV4aWUpIHtcbiAgcmV0dXJuIG1ha2VDbGFzc0NvbnN0cnVjdG9yPFZlcnNpb25Db25zdHJ1Y3Rvcj4oXG4gICAgVmVyc2lvbi5wcm90b3R5cGUsXG5cbiAgICBmdW5jdGlvbiBWZXJzaW9uKHRoaXM6IFZlcnNpb24sIHZlcnNpb25OdW1iZXI6IG51bWJlcikge1xuICAgICAgdGhpcy5kYiA9IGRiO1xuICAgICAgdGhpcy5fY2ZnID0ge1xuICAgICAgICB2ZXJzaW9uOiB2ZXJzaW9uTnVtYmVyLFxuICAgICAgICBzdG9yZXNTb3VyY2U6IG51bGwsXG4gICAgICAgIGRic2NoZW1hOiB7fSxcbiAgICAgICAgdGFibGVzOiB7fSxcbiAgICAgICAgY29udGVudFVwZ3JhZGU6IG51bGxcbiAgICAgIH07XG4gICAgfSk7XG5cbn1cbiIsICJpbXBvcnQgeyBEZXhpZSB9IGZyb20gXCIuLi9jbGFzc2VzL2RleGllL2RleGllXCI7XG5pbXBvcnQgeyBUYWJsZSB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvdGFibGVcIjtcbmltcG9ydCB7IERCTkFNRVNfREIgfSBmcm9tIFwiLi4vZ2xvYmFscy9jb25zdGFudHNcIjtcbmltcG9ydCB7IERleGllRE9NRGVwZW5kZW5jaWVzIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kZXhpZS1kb20tZGVwZW5kZW5jaWVzXCI7XG5pbXBvcnQgeyBub3AgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL2NoYWluaW5nLWZ1bmN0aW9uc1wiO1xuXG50eXBlIElEQktleU5hbWVzVmFyID0gdHlwZW9mIElEQktleVJhbmdlO1xuXG5mdW5jdGlvbiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCOiBJREJGYWN0b3J5LCBJREJLZXlSYW5nZTogSURCS2V5TmFtZXNWYXIpIHtcbiAgbGV0IGRiTmFtZXNEQiA9IGluZGV4ZWREQltcIl9kYk5hbWVzREJcIl07XG4gIGlmICghZGJOYW1lc0RCKSB7XG4gICAgZGJOYW1lc0RCID0gaW5kZXhlZERCW1wiX2RiTmFtZXNEQlwiXSA9IG5ldyBEZXhpZShEQk5BTUVTX0RCLCB7XG4gICAgICBhZGRvbnM6IFtdLFxuICAgICAgaW5kZXhlZERCLFxuICAgICAgSURCS2V5UmFuZ2UsXG4gICAgfSk7XG4gICAgZGJOYW1lc0RCLnZlcnNpb24oMSkuc3RvcmVzKHsgZGJuYW1lczogXCJuYW1lXCIgfSk7XG4gIH1cbiAgcmV0dXJuIGRiTmFtZXNEQi50YWJsZShcImRibmFtZXNcIikgYXMgVGFibGU8eyBuYW1lOiBzdHJpbmcgfSwgc3RyaW5nPjtcbn1cblxuZnVuY3Rpb24gaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQjogSURCRmFjdG9yeSkge1xuICByZXR1cm4gaW5kZXhlZERCICYmIHR5cGVvZiBpbmRleGVkREIuZGF0YWJhc2VzID09PSBcImZ1bmN0aW9uXCI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREYXRhYmFzZU5hbWVzKHtcbiAgaW5kZXhlZERCLFxuICBJREJLZXlSYW5nZSxcbn06IERleGllRE9NRGVwZW5kZW5jaWVzKSB7XG4gIHJldHVybiBoYXNEYXRhYmFzZXNOYXRpdmUoaW5kZXhlZERCKVxuICAgID8gUHJvbWlzZS5yZXNvbHZlKGluZGV4ZWREQi5kYXRhYmFzZXMoKSkudGhlbigoaW5mb3MpID0+XG4gICAgICAgIGluZm9zXG4gICAgICAgICAgLy8gU2VsZWN0IG5hbWUgcHJvcCBvZiBpbmZvczpcbiAgICAgICAgICAubWFwKChpbmZvKSA9PiBpbmZvLm5hbWUpXG4gICAgICAgICAgLy8gRmlsdGVyIG91dCBEQk5BTUVTX0RCIGFzIHByZXZpb3VzIERleGllIG9yIGJyb3dzZXIgdmVyc2lvbiB3b3VsZCBub3QgaGF2ZSBpbmNsdWRlZCBpdCBpbiB0aGUgcmVzdWx0LlxuICAgICAgICAgIC5maWx0ZXIoKG5hbWUpID0+IG5hbWUgIT09IERCTkFNRVNfREIpXG4gICAgICApXG4gICAgOiBnZXREYk5hbWVzVGFibGUoaW5kZXhlZERCLCBJREJLZXlSYW5nZSkudG9Db2xsZWN0aW9uKCkucHJpbWFyeUtleXMoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIF9vbkRhdGFiYXNlQ3JlYXRlZChcbiAgeyBpbmRleGVkREIsIElEQktleVJhbmdlIH06IERleGllRE9NRGVwZW5kZW5jaWVzLFxuICBuYW1lOiBzdHJpbmdcbikge1xuICAhaGFzRGF0YWJhc2VzTmF0aXZlKGluZGV4ZWREQikgJiZcbiAgICBuYW1lICE9PSBEQk5BTUVTX0RCICYmXG4gICAgZ2V0RGJOYW1lc1RhYmxlKGluZGV4ZWREQiwgSURCS2V5UmFuZ2UpLnB1dCh7bmFtZX0pLmNhdGNoKG5vcCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBfb25EYXRhYmFzZURlbGV0ZWQoXG4gIHsgaW5kZXhlZERCLCBJREJLZXlSYW5nZSB9OiBEZXhpZURPTURlcGVuZGVuY2llcyxcbiAgbmFtZTogc3RyaW5nXG4pIHtcbiAgIWhhc0RhdGFiYXNlc05hdGl2ZShpbmRleGVkREIpICYmXG4gICAgbmFtZSAhPT0gREJOQU1FU19EQiAmJlxuICAgIGdldERiTmFtZXNUYWJsZShpbmRleGVkREIsIElEQktleVJhbmdlKS5kZWxldGUobmFtZSkuY2F0Y2gobm9wKTtcbn1cbiIsICJpbXBvcnQgeyBuZXdTY29wZSB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuXG5leHBvcnQgZnVuY3Rpb24gdmlwIChmbikge1xuICAvLyBUbyBiZSB1c2VkIGJ5IHN1YnNjcmliZXJzIHRvIHRoZSBvbigncmVhZHknKSBldmVudC5cbiAgLy8gVGhpcyB3aWxsIGxldCBjYWxsZXIgdGhyb3VnaCB0byBhY2Nlc3MgREIgZXZlbiB3aGVuIGl0IGlzIGJsb2NrZWQgd2hpbGUgdGhlIGRiLnJlYWR5KCkgc3Vic2NyaWJlcnMgYXJlIGZpcmluZy5cbiAgLy8gVGhpcyB3b3VsZCBoYXZlIHdvcmtlZCBhdXRvbWF0aWNhbGx5IGlmIHdlIHdlcmUgY2VydGFpbiB0aGF0IHRoZSBQcm92aWRlciB3YXMgdXNpbmcgRGV4aWUuUHJvbWlzZSBmb3IgYWxsIGFzeW5jcm9uaWMgb3BlcmF0aW9ucy4gVGhlIHByb21pc2UgUFNEXG4gIC8vIGZyb20gdGhlIHByb3ZpZGVyLmNvbm5lY3QoKSBjYWxsIHdvdWxkIHRoZW4gYmUgZGVyaXZlZCBhbGwgdGhlIHdheSB0byB3aGVuIHByb3ZpZGVyIHdvdWxkIGNhbGwgbG9jYWxEYXRhYmFzZS5hcHBseUNoYW5nZXMoKS4gQnV0IHNpbmNlXG4gIC8vIHRoZSBwcm92aWRlciBtb3JlIGxpa2VseSBpcyB1c2luZyBub24tcHJvbWlzZSBhc3luYyBBUElzIG9yIG90aGVyIHRoZW5hYmxlIGltcGxlbWVudGF0aW9ucywgd2UgY2Fubm90IGFzc3VtZSB0aGF0LlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtZXRob2QgaXMgb25seSB1c2VmdWwgZm9yIG9uKCdyZWFkeScpIHN1YnNjcmliZXJzIHRoYXQgaXMgcmV0dXJuaW5nIGEgUHJvbWlzZSBmcm9tIHRoZSBldmVudC4gSWYgbm90IHVzaW5nIHZpcCgpXG4gIC8vIHRoZSBkYXRhYmFzZSBjb3VsZCBkZWFkbG9jayBzaW5jZSBpdCB3b250IG9wZW4gdW50aWwgdGhlIHJldHVybmVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGFuZCBhbnkgbm9uLVZJUGVkIG9wZXJhdGlvbiBzdGFydGVkIGJ5XG4gIC8vIHRoZSBjYWxsZXIgd2lsbCBub3QgcmVzb2x2ZSB1bnRpbCBkYXRhYmFzZSBpcyBvcGVuZWQuXG4gIHJldHVybiBuZXdTY29wZShmdW5jdGlvbiAoKSB7XG4gICAgUFNELmxldFRocm91Z2ggPSB0cnVlOyAvLyBNYWtlIHN1cmUgd2UgYXJlIGxldCB0aHJvdWdoIGlmIHN0aWxsIGJsb2NraW5nIGRiIGR1ZSB0byBvbnJlYWR5IGlzIGZpcmluZy5cbiAgICByZXR1cm4gZm4oKTtcbiAgfSk7XG59XG5cbiIsICIvKipcbiAqIFdvcmsgYXJvdW5kIFNhZmFyaSAxNCBJbmRleGVkREIgb3BlbiBidWcuXG4gKlxuICogU2FmYXJpIGhhcyBhIGhvcnJpYmxlIGJ1ZyB3aGVyZSBJREIgcmVxdWVzdHMgY2FuIGhhbmcgd2hpbGUgdGhlIGJyb3dzZXIgaXMgc3RhcnRpbmcgdXAuIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yMjY1NDdcbiAqIFRoZSBvbmx5IHNvbHV0aW9uIGlzIHRvIGtlZXAgbnVkZ2luZyBpdCB1bnRpbCBpdCdzIGF3YWtlLlxuICovXG5mdW5jdGlvbiBpZGJSZWFkeSgpIHtcbiAgICB2YXIgaXNTYWZhcmkgPSAhbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEgJiZcbiAgICAgICAgL1NhZmFyaVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJlxuICAgICAgICAhL0Nocm9tKGV8aXVtKVxcLy8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICAvLyBObyBwb2ludCBwdXR0aW5nIG90aGVyIGJyb3dzZXJzIG9yIG9sZGVyIHZlcnNpb25zIG9mIFNhZmFyaSB0aHJvdWdoIHRoaXMgbWVzcy5cbiAgICBpZiAoIWlzU2FmYXJpIHx8ICFpbmRleGVkREIuZGF0YWJhc2VzKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgdmFyIGludGVydmFsSWQ7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIHZhciB0cnlJZGIgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBpbmRleGVkREIuZGF0YWJhc2VzKCkuZmluYWxseShyZXNvbHZlKTsgfTtcbiAgICAgICAgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKHRyeUlkYiwgMTAwKTtcbiAgICAgICAgdHJ5SWRiKCk7XG4gICAgfSkuZmluYWxseShmdW5jdGlvbiAoKSB7IHJldHVybiBjbGVhckludGVydmFsKGludGVydmFsSWQpOyB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaWRiUmVhZHk7XG4iLCAiaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuL2RleGllJztcbmltcG9ydCAqIGFzIERlYnVnIGZyb20gJy4uLy4uL2hlbHBlcnMvZGVidWcnO1xuaW1wb3J0IHsgcmVqZWN0aW9uIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGV4Y2VwdGlvbnMgfSBmcm9tICcuLi8uLi9lcnJvcnMnO1xuaW1wb3J0IHsgZXZlbnRSZWplY3RIYW5kbGVyLCBwcmV2ZW50RGVmYXVsdCB9IGZyb20gJy4uLy4uL2Z1bmN0aW9ucy9ldmVudC13cmFwcGVycyc7XG5pbXBvcnQgUHJvbWlzZSwgeyB3cmFwIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IGNvbm5lY3Rpb25zIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgcnVuVXBncmFkZXJzLCByZWFkR2xvYmFsU2NoZW1hLCBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcywgdmVyaWZ5SW5zdGFsbGVkU2NoZW1hIH0gZnJvbSAnLi4vdmVyc2lvbi9zY2hlbWEtaGVscGVycyc7XG5pbXBvcnQgeyBzYWZhcmlNdWx0aVN0b3JlRml4IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBfb25EYXRhYmFzZUNyZWF0ZWQgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2RhdGFiYXNlLWVudW1lcmF0b3InO1xuaW1wb3J0IHsgdmlwIH0gZnJvbSAnLi92aXAnO1xuaW1wb3J0IHsgcHJvbWlzYWJsZUNoYWluLCBub3AgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7IGdlbmVyYXRlTWlkZGxld2FyZVN0YWNrcyB9IGZyb20gJy4vZ2VuZXJhdGUtbWlkZGxld2FyZS1zdGFja3MnO1xuaW1wb3J0IHsgc2xpY2UgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHNhZmFyaTE0V29ya2Fyb3VuZCBmcm9tICdzYWZhcmktMTQtaWRiLWZpeCc7XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXhpZU9wZW4gKGRiOiBEZXhpZSkge1xuICBjb25zdCBzdGF0ZSA9IGRiLl9zdGF0ZTtcbiAgY29uc3Qge2luZGV4ZWREQn0gPSBkYi5fZGVwcztcbiAgaWYgKHN0YXRlLmlzQmVpbmdPcGVuZWQgfHwgZGIuaWRiZGIpXG4gICAgICByZXR1cm4gc3RhdGUuZGJSZWFkeVByb21pc2UudGhlbjxEZXhpZT4oKCkgPT4gc3RhdGUuZGJPcGVuRXJyb3IgP1xuICAgICAgICByZWplY3Rpb24gKHN0YXRlLmRiT3BlbkVycm9yKSA6XG4gICAgICAgIGRiKTtcbiAgRGVidWcuZGVidWcgJiYgKHN0YXRlLm9wZW5DYW5jZWxsZXIuX3N0YWNrSG9sZGVyID0gRGVidWcuZ2V0RXJyb3JXaXRoU3RhY2soKSk7IC8vIExldCBzdGFja3MgcG9pbnQgdG8gd2hlbiBvcGVuKCkgd2FzIGNhbGxlZCByYXRoZXIgdGhhbiB3aGVyZSBuZXcgRGV4aWUoKSB3YXMgY2FsbGVkLlxuICBzdGF0ZS5pc0JlaW5nT3BlbmVkID0gdHJ1ZTtcbiAgc3RhdGUuZGJPcGVuRXJyb3IgPSBudWxsO1xuICBzdGF0ZS5vcGVuQ29tcGxldGUgPSBmYWxzZTtcbiAgY29uc3Qgb3BlbkNhbmNlbGxlciA9IHN0YXRlLm9wZW5DYW5jZWxsZXI7XG5cbiAgZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxlZCgpIHtcbiAgICAvLyBJZiBzdGF0ZS5vcGVuQ2FuY2VsbGVyIG9iamVjdCByZWZlcmVuY2UgaXMgcmVwbGFjZWQsIGl0IG1lYW5zIGRiLmNsb3NlKCkgaGFzIGJlZW4gY2FsbGVkLFxuICAgIC8vIG1lYW5pbmcgdGhpcyBvcGVuIGZsb3cgc2hvdWxkIGJlIGNhbmNlbGxlZC5cbiAgICBpZiAoc3RhdGUub3BlbkNhbmNlbGxlciAhPT0gb3BlbkNhbmNlbGxlcikgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoJ2RiLm9wZW4oKSB3YXMgY2FuY2VsbGVkJyk7XG4gIH1cbiAgXG4gIC8vIEZ1bmN0aW9uIHBvaW50ZXJzIHRvIGNhbGwgd2hlbiB0aGUgY29yZSBvcGVuaW5nIHByb2Nlc3MgY29tcGxldGVzLlxuICBsZXQgcmVzb2x2ZURiUmVhZHkgPSBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSxcbiAgICAgIC8vIHVwZ3JhZGVUcmFuc2FjdGlvbiB0byBhYm9ydCBvbiBmYWlsdXJlLlxuICAgICAgdXBncmFkZVRyYW5zYWN0aW9uOiAoSURCVHJhbnNhY3Rpb24gfCBudWxsKSA9IG51bGwsXG4gICAgICB3YXNDcmVhdGVkID0gZmFsc2U7XG5cbiAgY29uc3QgdHJ5T3BlbkRCID0gKCkgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIC8vIE11bHRpcGx5IGRiLnZlcm5vIHdpdGggMTAgd2lsbCBiZSBuZWVkZWQgdG8gd29ya2Fyb3VuZCB1cGdyYWRpbmcgYnVnIGluIElFOlxuICAgIC8vIElFIGZhaWxzIHdoZW4gZGVsZXRpbmcgb2JqZWN0U3RvcmUgYWZ0ZXIgcmVhZGluZyBmcm9tIGl0LlxuICAgIC8vIEEgZnV0dXJlIHZlcnNpb24gb2YgRGV4aWUuanMgd2lsbCBzdG9wb3ZlciBhbiBpbnRlcm1lZGlhdGUgdmVyc2lvbiB0byB3b3JrYXJvdW5kIHRoaXMuXG4gICAgLy8gQXQgdGhhdCBwb2ludCwgd2Ugd2FudCB0byBiZSBiYWNrd2FyZCBjb21wYXRpYmxlLiBDb3VsZCBoYXZlIGJlZW4gbXVsdGlwbGllZCB3aXRoIDIsIGJ1dCBieSB1c2luZyAxMCwgaXQgaXMgZWFzaWVyIHRvIG1hcCB0aGUgbnVtYmVyIHRvIHRoZSByZWFsIHZlcnNpb24gbnVtYmVyLlxuICAgIFxuICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAvLyBJZiBubyBBUEksIHRocm93IVxuICAgIGlmICghaW5kZXhlZERCKSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5NaXNzaW5nQVBJKCk7XG4gICAgY29uc3QgZGJOYW1lID0gZGIubmFtZTtcbiAgICBcbiAgICBjb25zdCByZXEgPSBzdGF0ZS5hdXRvU2NoZW1hID9cbiAgICAgIGluZGV4ZWREQi5vcGVuKGRiTmFtZSkgOlxuICAgICAgaW5kZXhlZERCLm9wZW4oZGJOYW1lLCBNYXRoLnJvdW5kKGRiLnZlcm5vICogMTApKTtcbiAgICBpZiAoIXJlcSkgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuTWlzc2luZ0FQSSgpOyAvLyBNYXkgaGFwcGVuIGluIFNhZmFyaSBwcml2YXRlIG1vZGUsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZGZhaGxhbmRlci9EZXhpZS5qcy9pc3N1ZXMvMTM0XG4gICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICByZXEub25ibG9ja2VkID0gd3JhcChkYi5fZmlyZU9uQmxvY2tlZCk7XG4gICAgcmVxLm9udXBncmFkZW5lZWRlZCA9IHdyYXAgKGUgPT4ge1xuICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24gPSByZXEudHJhbnNhY3Rpb247XG4gICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hICYmICFkYi5fb3B0aW9ucy5hbGxvd0VtcHR5REIpIHsgLy8gVW5sZXNzIGFuIGFkZG9uIGhhcyBzcGVjaWZpZWQgZGIuX2FsbG93RW1wdHlEQiwgbGV0cyBtYWtlIHRoZSBjYWxsIGZhaWwuXG4gICAgICAgICAgICAvLyBDYWxsZXIgZGlkIG5vdCBzcGVjaWZ5IGEgdmVyc2lvbiBvciBzY2hlbWEuIERvaW5nIHRoYXQgaXMgb25seSBhY2NlcHRhYmxlIGZvciBvcGVuaW5nIGFscmVhZCBleGlzdGluZyBkYXRhYmFzZXMuXG4gICAgICAgICAgICAvLyBJZiBvbnVwZ3JhZGVuZWVkZWQgaXMgY2FsbGVkIGl0IG1lYW5zIGRhdGFiYXNlIGRpZCBub3QgZXhpc3QuIFJlamVjdCB0aGUgb3BlbigpIHByb21pc2UgYW5kIG1ha2Ugc3VyZSB0aGF0IHdlXG4gICAgICAgICAgICAvLyBkbyBub3QgY3JlYXRlIGEgbmV3IGRhdGFiYXNlIGJ5IGFjY2lkZW50IGhlcmUuXG4gICAgICAgICAgICByZXEub25lcnJvciA9IHByZXZlbnREZWZhdWx0OyAvLyBQcm9oaWJpdCBvbmFib3J0IGVycm9yIGZyb20gZmlyaW5nIGJlZm9yZSB3ZSdyZSBkb25lIVxuICAgICAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uLmFib3J0KCk7IC8vIEFib3J0IHRyYW5zYWN0aW9uICh3b3VsZCBob3BlIHRoYXQgdGhpcyB3b3VsZCBtYWtlIERCIGRpc2FwcGVhciBidXQgaXQgZG9lc250LilcbiAgICAgICAgICAgIC8vIENsb3NlIGRhdGFiYXNlIGFuZCBkZWxldGUgaXQuXG4gICAgICAgICAgICByZXEucmVzdWx0LmNsb3NlKCk7XG4gICAgICAgICAgICBjb25zdCBkZWxyZXEgPSBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoZGJOYW1lKTsgLy8gVGhlIHVwZ3JhZGUgdHJhbnNhY3Rpb24gaXMgYXRvbWljLCBhbmQgamF2YXNjcmlwdCBpcyBzaW5nbGUgdGhyZWFkZWQgLSBtZWFuaW5nIHRoYXQgdGhlcmUgaXMgbm8gcmlzayB0aGF0IHdlIGRlbGV0ZSBzb21lb25lIGVsc2VzIGRhdGFiYXNlIGhlcmUhXG4gICAgICAgICAgICBkZWxyZXEub25zdWNjZXNzID0gZGVscmVxLm9uZXJyb3IgPSB3cmFwKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QgKG5ldyBleGNlcHRpb25zLk5vU3VjaERhdGFiYXNlKGBEYXRhYmFzZSAke2RiTmFtZX0gZG9lc250IGV4aXN0YCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB1cGdyYWRlVHJhbnNhY3Rpb24ub25lcnJvciA9IGV2ZW50UmVqZWN0SGFuZGxlcihyZWplY3QpO1xuICAgICAgICAgICAgdmFyIG9sZFZlciA9IGUub2xkVmVyc2lvbiA+IE1hdGgucG93KDIsIDYyKSA/IDAgOiBlLm9sZFZlcnNpb247IC8vIFNhZmFyaSA4IGZpeC5cbiAgICAgICAgICAgIHdhc0NyZWF0ZWQgPSBvbGRWZXIgPCAxO1xuICAgICAgICAgICAgZGIuX25vdmlwLmlkYmRiID0gcmVxLnJlc3VsdDsvLyBkYi5fbm92aXAgaXMgYmVjYXVzZSBkYiBjYW4gYmUgYW4gT2JqZWN0LmNyZWF0ZShvcmlnRGIpLlxuICAgICAgICAgICAgcnVuVXBncmFkZXJzKGRiLCBvbGRWZXIgLyAxMCwgdXBncmFkZVRyYW5zYWN0aW9uLCByZWplY3QpO1xuICAgICAgICB9XG4gICAgfSwgcmVqZWN0KTtcbiAgICBcbiAgICByZXEub25zdWNjZXNzID0gd3JhcCAoKCkgPT4ge1xuICAgICAgICAvLyBDb3JlIG9wZW5pbmcgcHJvY2VkdXJlIGNvbXBsZXRlLiBOb3cgbGV0J3MganVzdCByZWNvcmQgc29tZSBzdHVmZi5cbiAgICAgICAgdXBncmFkZVRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICAgICAgY29uc3QgaWRiZGIgPSBkYi5fbm92aXAuaWRiZGIgPSByZXEucmVzdWx0OyAvLyBkYi5fbm92aXAgaXMgYmVjYXVzZSBkYiBjYW4gYmUgYW4gT2JqZWN0LmNyZWF0ZShvcmlnRGIpLlxuXG4gICAgICAgIGNvbnN0IG9iamVjdFN0b3JlTmFtZXMgPSBzbGljZShpZGJkYi5vYmplY3RTdG9yZU5hbWVzKTtcbiAgICAgICAgaWYgKG9iamVjdFN0b3JlTmFtZXMubGVuZ3RoID4gMCkgdHJ5IHtcbiAgICAgICAgICBjb25zdCB0bXBUcmFucyA9IGlkYmRiLnRyYW5zYWN0aW9uKHNhZmFyaU11bHRpU3RvcmVGaXgob2JqZWN0U3RvcmVOYW1lcyksICdyZWFkb25seScpO1xuICAgICAgICAgIGlmIChzdGF0ZS5hdXRvU2NoZW1hKSByZWFkR2xvYmFsU2NoZW1hKGRiLCBpZGJkYiwgdG1wVHJhbnMpO1xuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICBhZGp1c3RUb0V4aXN0aW5nSW5kZXhOYW1lcyhkYiwgZGIuX2RiU2NoZW1hLCB0bXBUcmFucyk7XG4gICAgICAgICAgICAgIGlmICghdmVyaWZ5SW5zdGFsbGVkU2NoZW1hKGRiLCB0bXBUcmFucykpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUgU2NoZW1hRGlmZjogU2NoZW1hIHdhcyBleHRlbmRlZCB3aXRob3V0IGluY3JlYXNpbmcgdGhlIG51bWJlciBwYXNzZWQgdG8gZGIudmVyc2lvbigpLiBTb21lIHF1ZXJpZXMgbWF5IGZhaWwuYCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZ2VuZXJhdGVNaWRkbGV3YXJlU3RhY2tzKGRiLCB0bXBUcmFucyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBTYWZhcmkgOCBtYXkgYmFpbCBvdXQgaWYgPiAxIHN0b3JlIG5hbWVzLiBIb3dldmVyLCB0aGlzIHNob3VsZG50IGJlIGEgc2hvd3N0b3BwZXIuIElzc3VlICMxMjAuXG4gICAgICAgICAgLy8gQlVHQlVHOiBJdCB3aWxsIGJhaWwgb3V0IGFueXdheSBhcyBvZiBEZXhpZSAzLlxuICAgICAgICAgIC8vIFNob3VsZCB3ZSBzdXBwb3J0IFNhZmFyaSA4IGFueW1vcmU/IEJlbGlldmUgYWxsXG4gICAgICAgICAgLy8gRGV4aWUgdXNlcnMgdXNlIHRoZSBzaGltIGZvciB0aGF0IHBsYXRmb3JtIGFueXdheT8hXG4gICAgICAgICAgLy8gSWYgcmVtb3ZpbmcgU2FmYXJpIDggc3VwcG9ydCwgZ28gYWhlYWQgYW5kIHJlbW92ZSB0aGUgc2FmYXJpTXVsdGlTdG9yZUZpeCgpIGZ1bmN0aW9uXG4gICAgICAgICAgLy8gYXMgd2VsbCBhcyBhYnN1cmQgdXBncmFkZSB2ZXJzaW9uIHF1aXJrIGZvciBTYWZhcmkuXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbm5lY3Rpb25zLnB1c2goZGIpOyAvLyBVc2VkIGZvciBlbXVsYXRpbmcgdmVyc2lvbmNoYW5nZSBldmVudCBvbiBJRS9FZGdlL1NhZmFyaS5cbiAgICAgICAgXG4gICAgICAgIGlkYmRiLm9udmVyc2lvbmNoYW5nZSA9IHdyYXAoZXYgPT4ge1xuICAgICAgICAgICAgc3RhdGUudmNGaXJlZCA9IHRydWU7IC8vIGRldGVjdCBpbXBsZW1lbnRhdGlvbnMgdGhhdCBub3Qgc3VwcG9ydCB2ZXJzaW9uY2hhbmdlIChJRS9FZGdlL1NhZmFyaSlcbiAgICAgICAgICAgIGRiLm9uKFwidmVyc2lvbmNoYW5nZVwiKS5maXJlKGV2KTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBpZGJkYi5vbmNsb3NlID0gd3JhcChldiA9PiB7XG4gICAgICAgICAgICBkYi5vbihcImNsb3NlXCIpLmZpcmUoZXYpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAod2FzQ3JlYXRlZCkgX29uRGF0YWJhc2VDcmVhdGVkKGRiLl9kZXBzLCBkYk5hbWUpO1xuXG4gICAgICAgIHJlc29sdmUoKTtcblxuICAgIH0sIHJlamVjdCk7XG4gIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgaWYgKGVyciAmJiBlcnIubmFtZSA9PT0gJ1Vua25vd25FcnJvcicgJiYgc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAvLyBCdWcgaW4gQ2hyb21lIGFmdGVyIGNsZWFyaW5nIHNpdGUgZGF0YVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RleGllL0RleGllLmpzL2lzc3Vlcy81NDMjaXNzdWVjb21tZW50LTE3OTU3MzY2OTVcbiAgICAgIHN0YXRlLlBSMTM5OF9tYXhMb29wLS07XG4gICAgICBjb25zb2xlLndhcm4oJ0RleGllOiBXb3JrYXJvdW5kIGZvciBDaHJvbWUgVW5rbm93bkVycm9yIG9uIG9wZW4oKScpO1xuICAgICAgcmV0dXJuIHRyeU9wZW5EQigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gIH0pO1xuICBcbiAgLy8gc2FmYXJpMTRXb3JrYXJvdW5kID0gV29ya2Fyb3VuZCBieSBqYWtlYXJjaGliYWxkIGZvciBuZXcgbmFzdHkgYnVnIGluIHNhZmFyaSAxNC5cbiAgcmV0dXJuIFByb21pc2UucmFjZShbXG4gICAgb3BlbkNhbmNlbGxlcixcbiAgICAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgPyBQcm9taXNlLnJlc29sdmUoKSA6IHNhZmFyaTE0V29ya2Fyb3VuZCgpKS50aGVuKHRyeU9wZW5EQilcbiAgXSkudGhlbigoKSA9PiB7XG4gICAgICAvLyBCZWZvcmUgZmluYWxseSByZXNvbHZpbmcgdGhlIGRiUmVhZHlQcm9taXNlIGFuZCB0aGlzIHByb21pc2UsXG4gICAgICAvLyBjYWxsIGFuZCBhd2FpdCBhbGwgb24oJ3JlYWR5Jykgc3Vic2NyaWJlcnM6XG4gICAgICAvLyBEZXhpZS52aXAoKSBtYWtlcyBzdWJzY3JpYmVycyBhYmxlIHRvIHVzZSB0aGUgZGF0YWJhc2Ugd2hpbGUgYmVpbmcgb3BlbmVkLlxuICAgICAgLy8gVGhpcyBpcyBhIG11c3Qgc2luY2UgdGhlc2Ugc3Vic2NyaWJlcnMgdGFrZSBwYXJ0IG9mIHRoZSBvcGVuaW5nIHByb2NlZHVyZS5cbiAgICAgIHRocm93SWZDYW5jZWxsZWQoKTtcbiAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gW107XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHZpcCgoKT0+ZGIub24ucmVhZHkuZmlyZShkYi52aXApKSkudGhlbihmdW5jdGlvbiBmaXJlUmVtYWluZGVycygpIHtcbiAgICAgICAgICBpZiAoc3RhdGUub25SZWFkeUJlaW5nRmlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAvLyBJbiBjYXNlIGFkZGl0aW9uYWwgc3Vic2NyaWJlcnMgdG8gZGIub24oJ3JlYWR5Jykgd2VyZSBhZGRlZCBkdXJpbmcgdGhlIHRpbWUgZGIub24ucmVhZHkuZmlyZSB3YXMgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgIGxldCByZW1haW5kZXJzID0gc3RhdGUub25SZWFkeUJlaW5nRmlyZWQucmVkdWNlKHByb21pc2FibGVDaGFpbiwgbm9wKTtcbiAgICAgICAgICAgICAgc3RhdGUub25SZWFkeUJlaW5nRmlyZWQgPSBbXTtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2aXAoKCk9PnJlbWFpbmRlcnMoZGIudmlwKSkpLnRoZW4oZmlyZVJlbWFpbmRlcnMpXG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gIH0pLmZpbmFsbHkoKCk9PntcbiAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkID0gbnVsbDtcbiAgICAgIHN0YXRlLmlzQmVpbmdPcGVuZWQgPSBmYWxzZTtcbiAgfSkudGhlbigoKT0+e1xuICAgICAgLy8gUmVzb2x2ZSB0aGUgZGIub3BlbigpIHdpdGggdGhlIGRiIGluc3RhbmNlLlxuICAgICAgcmV0dXJuIGRiO1xuICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgc3RhdGUuZGJPcGVuRXJyb3IgPSBlcnI7IC8vIFJlY29yZCB0aGUgZXJyb3IuIEl0IHdpbGwgYmUgdXNlZCB0byByZWplY3QgZnVydGhlciBwcm9taXNlcyBvZiBkYiBvcGVyYXRpb25zLlxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gRGlkIHdlIGZhaWwgd2l0aGluIG9udXBncmFkZW5lZWRlZD8gTWFrZSBzdXJlIHRvIGFib3J0IHRoZSB1cGdyYWRlIHRyYW5zYWN0aW9uIHNvIGl0IGRvZXNudCBjb21taXQuXG4gICAgICAgIHVwZ3JhZGVUcmFuc2FjdGlvbiAmJiB1cGdyYWRlVHJhbnNhY3Rpb24uYWJvcnQoKTtcbiAgICAgIH0gY2F0Y2ggeyB9XG4gICAgICBpZiAob3BlbkNhbmNlbGxlciA9PT0gc3RhdGUub3BlbkNhbmNlbGxlcikge1xuICAgICAgICAvLyBTdGlsbCBpbiB0aGUgc2FtZSBvcGVuIGZsb3cgLSBUaGUgZXJyb3IgcmVhc29uIHdhcyBub3QgZHVlIHRvIGV4dGVybmFsIGNhbGwgdG8gZGIuY2xvc2UoKS5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRvIGNhbGwgZGIuY2xvc2UoKSB0byBmaW5hbGl6ZSByZXNvdXJjZXMuXG4gICAgICAgIGRiLl9jbG9zZSgpOyAvLyBDbG9zZXMgYW5kIHJlc2V0cyBpZGJkYiwgcmVtb3ZlcyBjb25uZWN0aW9ucywgcmVzZXRzIGRiUmVhZHlQcm9taXNlIGFuZCBvcGVuQ2FuY2VsbGVyIHNvIHRoYXQgYSBsYXRlciBkYi5vcGVuKCkgaXMgZnJlc2guXG4gICAgICB9XG4gICAgICByZXR1cm4gcmVqZWN0aW9uIChlcnIpO1xuICB9KS5maW5hbGx5KCgpPT57XG4gICAgICBzdGF0ZS5vcGVuQ29tcGxldGUgPSB0cnVlO1xuICAgICAgcmVzb2x2ZURiUmVhZHkoKTsgLy8gZGJSZWFkeVByb21pc2UgaXMgcmVzb2x2ZWQgbm8gbWF0dGVyIGlmIG9wZW4oKSByZWplY3RzIG9yIHJlc29sdmVkLiBJdCdzIGp1c3QgdG8gd2FrZSB1cCB3YWl0ZXJzLlxuICB9KTtcbn1cbiIsICJpbXBvcnQgeyBpc0FycmF5IH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGF3YWl0SXRlcmF0b3IgKGl0ZXJhdG9yOiBJdGVyYXRvcjxhbnk+KSB7XG4gIHZhciBjYWxsTmV4dCA9IHJlc3VsdCA9PiBpdGVyYXRvci5uZXh0KHJlc3VsdCksXG4gICAgICBkb1Rocm93ID0gZXJyb3IgPT4gaXRlcmF0b3IudGhyb3coZXJyb3IpLFxuICAgICAgb25TdWNjZXNzID0gc3RlcChjYWxsTmV4dCksXG4gICAgICBvbkVycm9yID0gc3RlcChkb1Rocm93KTtcblxuICBmdW5jdGlvbiBzdGVwKGdldE5leHQ6IChhbnkpPT5hbnkpIHtcbiAgICAgIHJldHVybiAodmFsPykgPT4ge1xuICAgICAgICAgIHZhciBuZXh0ID0gZ2V0TmV4dCh2YWwpLFxuICAgICAgICAgICAgICB2YWx1ZSA9IG5leHQudmFsdWU7XG5cbiAgICAgICAgICByZXR1cm4gbmV4dC5kb25lID8gdmFsdWUgOlxuICAgICAgICAgICAgICAoIXZhbHVlIHx8IHR5cGVvZiB2YWx1ZS50aGVuICE9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgICAgICAgICAgIGlzQXJyYXkodmFsdWUpID8gUHJvbWlzZS5hbGwodmFsdWUpLnRoZW4ob25TdWNjZXNzLCBvbkVycm9yKSA6IG9uU3VjY2Vzcyh2YWx1ZSkgOlxuICAgICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpKTtcbiAgICAgIH07XG4gIH1cblxuICByZXR1cm4gc3RlcChjYWxsTmV4dCkoKTtcbn1cbiIsICJpbXBvcnQgeyBUcmFuc2FjdGlvbk1vZGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdHJhbnNhY3Rpb24tbW9kZSc7XG5pbXBvcnQgeyBlcnJuYW1lcywgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBmbGF0dGVuLCBpc0FzeW5jRnVuY3Rpb24gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgRGV4aWUgfSBmcm9tICcuL2RleGllJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uIH0gZnJvbSAnLi4vdHJhbnNhY3Rpb24nO1xuaW1wb3J0IHsgYXdhaXRJdGVyYXRvciB9IGZyb20gJy4uLy4uL2hlbHBlcnMveWllbGQtc3VwcG9ydCc7XG5pbXBvcnQgUHJvbWlzZSwge1xuICBQU0QsXG4gIE5hdGl2ZVByb21pc2UsXG4gIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLFxuICByZWplY3Rpb24sXG4gIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzXG59IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBleHRyYWN0VHJhbnNhY3Rpb25BcmdzKG1vZGU6IFRyYW5zYWN0aW9uTW9kZSwgX3RhYmxlQXJnc18sIHNjb3BlRnVuYykge1xuICAvLyBMZXQgdGFibGUgYXJndW1lbnRzIGJlIGFsbCBhcmd1bWVudHMgYmV0d2VlbiBtb2RlIGFuZCBsYXN0IGFyZ3VtZW50LlxuICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChpIDwgMikgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZEFyZ3VtZW50KFwiVG9vIGZldyBhcmd1bWVudHNcIik7XG4gIC8vIFByZXZlbnQgb3B0aW16YXRpb24ga2lsbGVyIChodHRwczovL2dpdGh1Yi5jb20vcGV0a2FhbnRvbm92L2JsdWViaXJkL3dpa2kvT3B0aW1pemF0aW9uLWtpbGxlcnMjMzItbGVha2luZy1hcmd1bWVudHMpXG4gIC8vIGFuZCBjbG9uZSBhcmd1bWVudHMgZXhjZXB0IHRoZSBmaXJzdCBvbmUgaW50byBsb2NhbCB2YXIgJ2FyZ3MnLlxuICB2YXIgYXJncyA9IG5ldyBBcnJheShpIC0gMSk7XG4gIHdoaWxlICgtLWkpIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAvLyBMZXQgc2NvcGVGdW5jIGJlIHRoZSBsYXN0IGFyZ3VtZW50IGFuZCBwb3AgaXQgc28gdGhhdCBhcmdzIG5vdyBvbmx5IGNvbnRhaW4gdGhlIHRhYmxlIGFyZ3VtZW50cy5cbiAgc2NvcGVGdW5jID0gYXJncy5wb3AoKTtcbiAgdmFyIHRhYmxlcyA9IGZsYXR0ZW4oYXJncyk7IC8vIFN1cHBvcnQgdXNpbmcgYXJyYXkgYXMgbWlkZGxlIGFyZ3VtZW50LCBvciBhIG1peCBvZiBhcnJheXMgYW5kIG5vbi1hcnJheXMuXG4gIHJldHVybiBbbW9kZSwgdGFibGVzLCBzY29wZUZ1bmNdO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZW50ZXJUcmFuc2FjdGlvblNjb3BlKFxuICBkYjogRGV4aWUsXG4gIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgc3RvcmVOYW1lczogc3RyaW5nW10sXG4gIHBhcmVudFRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbiB8IHVuZGVmaW5lZCxcbiAgc2NvcGVGdW5jOiAoKT0+UHJvbWlzZUxpa2U8YW55PiB8IGFueVxuKSB7XG4gIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHtcbiAgICAvLyBLZWVwIGEgcG9pbnRlciB0byBsYXN0IG5vbi10cmFuc2FjdGlvbmFsIFBTRCB0byB1c2UgaWYgc29tZW9uZSBjYWxscyBEZXhpZS5pZ25vcmVUcmFuc2FjdGlvbigpLlxuICAgIGNvbnN0IHRyYW5zbGVzcyA9IFBTRC50cmFuc2xlc3MgfHwgUFNEO1xuICAgIC8vIE91ciB0cmFuc2FjdGlvbi5cbiAgICAvL3JldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgdHJhbnMgPSBkYi5fY3JlYXRlVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGIuX2RiU2NoZW1hLCBwYXJlbnRUcmFuc2FjdGlvbik7XG4gICAgLy8gTGV0IHRoZSB0cmFuc2FjdGlvbiBpbnN0YW5jZSBiZSBwYXJ0IG9mIGEgUHJvbWlzZS1zcGVjaWZpYyBkYXRhIChQU0QpIHZhbHVlLlxuICAgIGNvbnN0IHpvbmVQcm9wcyA9IHtcbiAgICAgIHRyYW5zOiB0cmFucyxcbiAgICAgIHRyYW5zbGVzczogdHJhbnNsZXNzXG4gICAgfTtcblxuICAgIGlmIChwYXJlbnRUcmFuc2FjdGlvbikge1xuICAgICAgLy8gRW11bGF0ZSB0cmFuc2FjdGlvbiBjb21taXQgYXdhcmVuZXNzIGZvciBpbm5lciB0cmFuc2FjdGlvbiAobXVzdCAnY29tbWl0JyB3aGVuIHRoZSBpbm5lciB0cmFuc2FjdGlvbiBoYXMgbm8gbW9yZSBvcGVyYXRpb25zIG9uZ29pbmcpXG4gICAgICB0cmFucy5pZGJ0cmFucyA9IHBhcmVudFRyYW5zYWN0aW9uLmlkYnRyYW5zO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0cmFucy5jcmVhdGUoKTsgLy8gQ3JlYXRlIHRoZSBuYXRpdmUgdHJhbnNhY3Rpb24gc28gdGhhdCBjb21wbGV0ZSgpIG9yIGVycm9yKCkgd2lsbCB0cmlnZ2VyIGV2ZW4gaWYgbm8gb3BlcmF0aW9uIGlzIG1hZGUgdXBvbiBpdC5cbiAgICAgICAgZGIuX3N0YXRlLlBSMTM5OF9tYXhMb29wID0gMztcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGlmIChleC5uYW1lID09PSBlcnJuYW1lcy5JbnZhbGlkU3RhdGUgJiYgZGIuaXNPcGVuKCkgJiYgLS1kYi5fc3RhdGUuUFIxMzk4X21heExvb3AgPiAwKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdEZXhpZTogTmVlZCB0byByZW9wZW4gZGInKTtcbiAgICAgICAgICBkYi5fY2xvc2UoKTtcbiAgICAgICAgICByZXR1cm4gZGIub3BlbigpLnRoZW4oKCkgPT4gZW50ZXJUcmFuc2FjdGlvblNjb3BlKFxuICAgICAgICAgICAgZGIsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgc3RvcmVOYW1lcyxcbiAgICAgICAgICAgIG51bGwsXG4gICAgICAgICAgICBzY29wZUZ1bmNcbiAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVqZWN0aW9uKGV4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBTdXBwb3J0IGZvciBuYXRpdmUgYXN5bmMgYXdhaXQuXG4gICAgY29uc3Qgc2NvcGVGdW5jSXNBc3luYyA9IGlzQXN5bmNGdW5jdGlvbihzY29wZUZ1bmMpO1xuICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgIH1cblxuICAgIGxldCByZXR1cm5WYWx1ZTtcbiAgICBjb25zdCBwcm9taXNlRm9sbG93ZWQgPSBQcm9taXNlLmZvbGxvdygoKSA9PiB7XG4gICAgICAvLyBGaW5hbGx5LCBjYWxsIHRoZSBzY29wZSBmdW5jdGlvbiB3aXRoIG91ciB0YWJsZSBhbmQgdHJhbnNhY3Rpb24gYXJndW1lbnRzLlxuICAgICAgcmV0dXJuVmFsdWUgPSBzY29wZUZ1bmMuY2FsbCh0cmFucywgdHJhbnMpO1xuICAgICAgaWYgKHJldHVyblZhbHVlKSB7XG4gICAgICAgIGlmIChzY29wZUZ1bmNJc0FzeW5jKSB7XG4gICAgICAgICAgLy8gc2NvcGVGdW5jIGlzIGEgbmF0aXZlIGFzeW5jIGZ1bmN0aW9uIC0gd2Uga25vdyBmb3Igc3VyZSByZXR1cm5WYWx1ZSBpcyBuYXRpdmUgcHJvbWlzZS5cbiAgICAgICAgICB2YXIgZGVjcmVtZW50b3IgPSBkZWNyZW1lbnRFeHBlY3RlZEF3YWl0cy5iaW5kKG51bGwsIG51bGwpO1xuICAgICAgICAgIHJldHVyblZhbHVlLnRoZW4oZGVjcmVtZW50b3IsIGRlY3JlbWVudG9yKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUubmV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhyb3cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBzY29wZUZ1bmMgcmV0dXJuZWQgYW4gaXRlcmF0b3Igd2l0aCB0aHJvdy1zdXBwb3J0LiBIYW5kbGUgeWllbGQgYXMgYXdhaXQuXG4gICAgICAgICAgcmV0dXJuVmFsdWUgPSBhd2FpdEl0ZXJhdG9yKHJldHVyblZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHpvbmVQcm9wcyk7XG4gICAgcmV0dXJuIChyZXR1cm5WYWx1ZSAmJiB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAvLyBQcm9taXNlIHJldHVybmVkLiBVc2VyIHVzZXMgcHJvbWlzZS1zdHlsZSB0cmFuc2FjdGlvbnMuXG4gICAgICBQcm9taXNlLnJlc29sdmUocmV0dXJuVmFsdWUpLnRoZW4oeCA9PiB0cmFucy5hY3RpdmUgP1xuICAgICAgICB4IC8vIFRyYW5zYWN0aW9uIHN0aWxsIGFjdGl2ZS4gQ29udGludWUuXG4gICAgICAgIDogcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLlByZW1hdHVyZUNvbW1pdChcbiAgICAgICAgICBcIlRyYW5zYWN0aW9uIGNvbW1pdHRlZCB0b28gZWFybHkuIFNlZSBodHRwOi8vYml0Lmx5LzJrZGNrTW5cIikpKVxuICAgICAgLy8gTm8gcHJvbWlzZSByZXR1cm5lZC4gV2FpdCBmb3IgYWxsIG91dHN0YW5kaW5nIHByb21pc2VzIGJlZm9yZSBjb250aW51aW5nLiBcbiAgICAgIDogcHJvbWlzZUZvbGxvd2VkLnRoZW4oKCkgPT4gcmV0dXJuVmFsdWUpXG4gICAgKS50aGVuKHggPT4ge1xuICAgICAgLy8gc3ViIHRyYW5zYWN0aW9ucyBkb24ndCByZWFjdCB0byBpZGJ0cmFucy5vbmNvbXBsZXRlLiBXZSBtdXN0IHRyaWdnZXIgYSBjb21wbGV0aW9uOlxuICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uKSB0cmFucy5fcmVzb2x2ZSgpO1xuICAgICAgLy8gd2FpdCBmb3IgdHJhbnMuX2NvbXBsZXRpb25cbiAgICAgIC8vIChpZiByb290IHRyYW5zYWN0aW9uLCB0aGlzIG1lYW5zICdjb21wbGV0ZScgZXZlbnQuIElmIHN1Yi10cmFuc2FjdGlvbiwgd2UndmUganVzdCBmaXJlZCBpdCBvdXJzZWx2ZXMpXG4gICAgICByZXR1cm4gdHJhbnMuX2NvbXBsZXRpb24udGhlbigoKSA9PiB4KTtcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIHRyYW5zLl9yZWplY3QoZSk7IC8vIFllcywgYWJvdmUgdGhlbi1oYW5kbGVyIHdlcmUgbWF5YmUgbm90IGNhbGxlZCBiZWNhdXNlIG9mIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gaW4gc2NvcGVGdW5jIVxuICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICB9KTtcbiAgfSk7XG59XG4iLCAiaW1wb3J0IHtcbiAgREJDb3JlLFxuICBEQkNvcmVJbmRleCxcbiAgREJDb3JlS2V5UmFuZ2UsXG4gIERCQ29yZVF1ZXJ5UmVxdWVzdCxcbiAgREJDb3JlUmFuZ2VUeXBlLFxuICBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdCxcbiAgREJDb3JlQ291bnRSZXF1ZXN0LFxuICBEQkNvcmVDdXJzb3IsXG4gIERCQ29yZVRhYmxlLFxufSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiY29yZVwiO1xuaW1wb3J0IHsgaXNBcnJheSB9IGZyb20gJy4uL2Z1bmN0aW9ucy91dGlscyc7XG5pbXBvcnQgeyBnZXRLZXlFeHRyYWN0b3IgfSBmcm9tICcuL2dldC1rZXktZXh0cmFjdG9yJztcbmltcG9ydCB7IGdldEtleVBhdGhBbGlhcyB9IGZyb20gJy4vZGJjb3JlLWluZGV4ZWRkYic7XG5pbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmUnO1xuXG5pbnRlcmZhY2UgVmlydHVhbEluZGV4IGV4dGVuZHMgREJDb3JlSW5kZXgge1xuICAvKiogVHJ1ZSBpZiB0aGlzIGluZGV4IGlzIHZpcnR1YWwsIGkuZS4gcmVwcmVzZW50cyBhIGNvbXBvdW5kIGluZGV4IGludGVybmFsbHksXG4gICAqIGJ1dCBtYWtlcyBpdCBhY3QgYXMgYXMgaGF2aW5nIGEgc3Vic2V0IG9mIGl0cyBrZXlQYXRocy5cbiAgICovXG4gIGlzVmlydHVhbDogYm9vbGVhbjtcblxuICAvKiogTnVtYmVyIG9mIGtleXBhdGhzIHRoYXQgdGhpcyBpbmRleCBjb21wcmlzZXMuIENhbiBiZSAwLi5OLlxuICAgKiBOb3RlOiBUaGlzIGlzIHRoZSBsZW5ndGggb2YgdGhlICp2aXJ0dWFsIGluZGV4Kiwgbm90IHRoZSByZWFsIGluZGV4LlxuICAgKi9cbiAga2V5TGVuZ3RoOiBudW1iZXI7XG5cbiAgLyoqIE51bWJlciBvZiBwb3BwZWQga2V5cGF0aHMgZnJvbSB0aGUgcmVhbCBpbmRleC5cbiAgICovXG4gIGtleVRhaWw6IG51bWJlcjtcbn1cblxuLy8gTW92ZSBpbnRvIHNvbWUgdXRpbDpcbmV4cG9ydCBmdW5jdGlvbiBwYWQgKGE6IGFueSB8IGFueVtdLCB2YWx1ZTogYW55LCBjb3VudDogbnVtYmVyKSB7XG4gIGNvbnN0IHJlc3VsdCA9IGlzQXJyYXkoYSkgPyBhLnNsaWNlKCkgOiBbYV07XG4gIGZvciAobGV0IGk9MDsgaTxjb3VudDsgKytpKSByZXN1bHQucHVzaCh2YWx1ZSk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmUgKGRvd246IERCQ29yZSkgOiBEQkNvcmUge1xuICByZXR1cm4ge1xuICAgIC4uLmRvd24sXG4gICAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpIHtcbiAgICAgIGNvbnN0IHRhYmxlID0gZG93bi50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgY29uc3Qge3NjaGVtYX0gPSB0YWJsZTtcbiAgICAgIGNvbnN0IGluZGV4TG9va3VwOiB7W2luZGV4QWxpYXM6IHN0cmluZ106IFZpcnR1YWxJbmRleFtdfSA9IHt9O1xuICAgICAgY29uc3QgYWxsVmlydHVhbEluZGV4ZXM6IFZpcnR1YWxJbmRleFtdID0gW107XG5cbiAgICAgIGZ1bmN0aW9uIGFkZFZpcnR1YWxJbmRleGVzIChrZXlQYXRoOiBudWxsIHwgc3RyaW5nIHwgc3RyaW5nW10sIGtleVRhaWw6IG51bWJlciwgbG93TGV2ZWxJbmRleDogREJDb3JlSW5kZXgpOiBWaXJ0dWFsSW5kZXgge1xuICAgICAgICBjb25zdCBrZXlQYXRoQWxpYXMgPSBnZXRLZXlQYXRoQWxpYXMoa2V5UGF0aCk7XG4gICAgICAgIGNvbnN0IGluZGV4TGlzdCA9IChpbmRleExvb2t1cFtrZXlQYXRoQWxpYXNdID0gaW5kZXhMb29rdXBba2V5UGF0aEFsaWFzXSB8fCBbXSk7XG4gICAgICAgIGNvbnN0IGtleUxlbmd0aCA9IGtleVBhdGggPT0gbnVsbCA/IDA6IHR5cGVvZiBrZXlQYXRoID09PSAnc3RyaW5nJyA/IDEgOiBrZXlQYXRoLmxlbmd0aDtcbiAgICAgICAgY29uc3QgaXNWaXJ0dWFsID0ga2V5VGFpbCA+IDA7XG4gICAgICAgIGNvbnN0IHZpcnR1YWxJbmRleCA9IHtcbiAgICAgICAgICAuLi5sb3dMZXZlbEluZGV4LFxuICAgICAgICAgIGlzVmlydHVhbCxcbiAgICAgICAgICBrZXlUYWlsLFxuICAgICAgICAgIGtleUxlbmd0aCxcbiAgICAgICAgICBleHRyYWN0S2V5OiBnZXRLZXlFeHRyYWN0b3Ioa2V5UGF0aCksXG4gICAgICAgICAgdW5pcXVlOiAhaXNWaXJ0dWFsICYmIGxvd0xldmVsSW5kZXgudW5pcXVlXG4gICAgICAgIH07XG4gICAgICAgIGluZGV4TGlzdC5wdXNoKHZpcnR1YWxJbmRleCk7XG4gICAgICAgIGlmICghdmlydHVhbEluZGV4LmlzUHJpbWFyeUtleSkge1xuICAgICAgICAgIGFsbFZpcnR1YWxJbmRleGVzLnB1c2godmlydHVhbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5TGVuZ3RoID4gMSkge1xuICAgICAgICAgIGNvbnN0IHZpcnR1YWxLZXlQYXRoID0ga2V5TGVuZ3RoID09PSAyID9cbiAgICAgICAgICAgIGtleVBhdGhbMF0gOiAvLyBUaGlzIGlzIGEgY29tcG91bmQgW2EsIGJdLiBBZGQgYSB2aXJ0dWFsIG5vcm1hbCBpbmRleCBhLlxuICAgICAgICAgICAga2V5UGF0aC5zbGljZSgwLCBrZXlMZW5ndGggLSAxKTsgLy8gVGhpcyBpcyBjb21wb3VuZCBbYSxiLGNdLiBBZGQgdmlydHVhbCBjb21wb3VuZCBbYSxiXS5cbiAgICAgICAgICBhZGRWaXJ0dWFsSW5kZXhlcyh2aXJ0dWFsS2V5UGF0aCwga2V5VGFpbCArIDEsIGxvd0xldmVsSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4TGlzdC5zb3J0KChhLGIpID0+IGEua2V5VGFpbCAtIGIua2V5VGFpbCk7IC8vIFNob3J0ZXN0IGtleVRhaWwgaXMgdGhlIGJlc3Qgb25lIChyZXByZXNlbnRzIHJlYWwgaW5kZXgpXG4gICAgICAgIHJldHVybiB2aXJ0dWFsSW5kZXg7XG4gICAgICB9XG4gICAgXG4gICAgICBjb25zdCBwcmltYXJ5S2V5ID0gYWRkVmlydHVhbEluZGV4ZXMoc2NoZW1hLnByaW1hcnlLZXkua2V5UGF0aCwgMCwgc2NoZW1hLnByaW1hcnlLZXkpO1xuICAgICAgaW5kZXhMb29rdXBbXCI6aWRcIl0gPSBbcHJpbWFyeUtleV07XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHNjaGVtYS5pbmRleGVzKSB7XG4gICAgICAgIGFkZFZpcnR1YWxJbmRleGVzKGluZGV4LmtleVBhdGgsIDAsIGluZGV4KTtcbiAgICAgIH1cbiAgICBcbiAgICAgIGZ1bmN0aW9uIGZpbmRCZXN0SW5kZXgoa2V5UGF0aDogbnVsbCB8IHN0cmluZyB8IHN0cmluZ1tdKTogVmlydHVhbEluZGV4IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5kZXhMb29rdXBbZ2V0S2V5UGF0aEFsaWFzKGtleVBhdGgpXTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCAmJiByZXN1bHRbMF07XG4gICAgICB9XG4gICAgXG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSYW5nZSAocmFuZ2U6IERCQ29yZUtleVJhbmdlLCBrZXlUYWlsOiBudW1iZXIpOiBEQkNvcmVLZXlSYW5nZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdHlwZTogcmFuZ2UudHlwZSA9PT0gREJDb3JlUmFuZ2VUeXBlLkVxdWFsID9cbiAgICAgICAgICAgIERCQ29yZVJhbmdlVHlwZS5SYW5nZSA6XG4gICAgICAgICAgICByYW5nZS50eXBlLFxuICAgICAgICAgIGxvd2VyOiBwYWQocmFuZ2UubG93ZXIsIHJhbmdlLmxvd2VyT3BlbiA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCksXG4gICAgICAgICAgbG93ZXJPcGVuOiB0cnVlLCAvLyBkb2Vzbid0IG1hdHRlciB0cnVlIG9yIGZhbHNlXG4gICAgICAgICAgdXBwZXI6IHBhZChyYW5nZS51cHBlciwgcmFuZ2UudXBwZXJPcGVuID8gZG93bi5NSU5fS0VZIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKSxcbiAgICAgICAgICB1cHBlck9wZW46IHRydWUgLy8gZG9lc24ndCBtYXR0ZXIgdHJ1ZSBvciBmYWxzZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIFxuICAgICAgZnVuY3Rpb24gdHJhbnNsYXRlUmVxdWVzdCAocmVxOiBEQkNvcmVRdWVyeVJlcXVlc3QpOiBEQkNvcmVRdWVyeVJlcXVlc3Q7XG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0IChyZXE6IERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0KTogREJDb3JlT3BlbkN1cnNvclJlcXVlc3Q7XG4gICAgICBmdW5jdGlvbiB0cmFuc2xhdGVSZXF1ZXN0IChyZXE6IERCQ29yZUNvdW50UmVxdWVzdCk6IERCQ29yZUNvdW50UmVxdWVzdCB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcmVxLnF1ZXJ5LmluZGV4IGFzIFZpcnR1YWxJbmRleDtcbiAgICAgICAgcmV0dXJuIGluZGV4LmlzVmlydHVhbCA/IHtcbiAgICAgICAgICAuLi5yZXEsXG4gICAgICAgICAgcXVlcnk6IHtcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgcmFuZ2U6IHRyYW5zbGF0ZVJhbmdlKHJlcS5xdWVyeS5yYW5nZSwgaW5kZXgua2V5VGFpbClcbiAgICAgICAgICB9XG4gICAgICAgIH0gOiByZXE7XG4gICAgICB9XG4gICAgXG4gICAgICBjb25zdCByZXN1bHQ6IERCQ29yZVRhYmxlID0ge1xuICAgICAgICAuLi50YWJsZSxcbiAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgLi4uc2NoZW1hLFxuICAgICAgICAgIHByaW1hcnlLZXksXG4gICAgICAgICAgaW5kZXhlczogYWxsVmlydHVhbEluZGV4ZXMsXG4gICAgICAgICAgZ2V0SW5kZXhCeUtleVBhdGg6IGZpbmRCZXN0SW5kZXhcbiAgICAgICAgfSxcblxuICAgICAgICBjb3VudChyZXEpIHtcbiAgICAgICAgICByZXR1cm4gdGFibGUuY291bnQodHJhbnNsYXRlUmVxdWVzdChyZXEpKTtcbiAgICAgICAgfSwgICAgXG4gICAgXG4gICAgICAgIHF1ZXJ5KHJlcSkge1xuICAgICAgICAgIHJldHVybiB0YWJsZS5xdWVyeSh0cmFuc2xhdGVSZXF1ZXN0KHJlcSkpO1xuICAgICAgICB9LFxuICAgIFxuICAgICAgICBvcGVuQ3Vyc29yKHJlcSkge1xuICAgICAgICAgIGNvbnN0IHtrZXlUYWlsLCBpc1ZpcnR1YWwsIGtleUxlbmd0aH0gPSAocmVxLnF1ZXJ5LmluZGV4IGFzIFZpcnR1YWxJbmRleCk7XG4gICAgICAgICAgaWYgKCFpc1ZpcnR1YWwpIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHJlcSk7XG4gICAgXG4gICAgICAgICAgZnVuY3Rpb24gY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3I6IERCQ29yZUN1cnNvcikgOiBEQkNvcmVDdXJzb3Ige1xuICAgICAgICAgICAgZnVuY3Rpb24gX2NvbnRpbnVlIChrZXk/OiBhbnkpIHtcbiAgICAgICAgICAgICAga2V5ICE9IG51bGwgP1xuICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShwYWQoa2V5LCByZXEucmV2ZXJzZSA/IGRvd24uTUFYX0tFWSA6IGRvd24uTUlOX0tFWSwga2V5VGFpbCkpIDpcbiAgICAgICAgICAgICAgICByZXEudW5pcXVlID9cbiAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZShcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yLmtleS5zbGljZSgwLCBrZXlMZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgLmNvbmNhdChyZXEucmV2ZXJzZVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBkb3duLk1JTl9LRVlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZG93bi5NQVhfS0VZLCBrZXlUYWlsKVxuICAgICAgICAgICAgICAgICAgKSA6XG4gICAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmlydHVhbEN1cnNvciA9IE9iamVjdC5jcmVhdGUoY3Vyc29yLCB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlOiB7dmFsdWU6IF9jb250aW51ZX0sXG4gICAgICAgICAgICAgIGNvbnRpbnVlUHJpbWFyeUtleToge1xuICAgICAgICAgICAgICAgIHZhbHVlKGtleTogYW55LCBwcmltYXJ5S2V5OiBhbnkpIHtcbiAgICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZVByaW1hcnlLZXkocGFkKGtleSwgZG93bi5NQVhfS0VZLCBrZXlUYWlsKSwgcHJpbWFyeUtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBwcmltYXJ5S2V5OiB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci5wcmltYXJ5S2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAga2V5OiB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgY29uc3Qga2V5ID0gY3Vyc29yLmtleSBhcyBhbnlbXTsgLy8gQSB2aXJ0dWFsIGN1cnNvciBhbHdheXMgb3BlcmF0ZXMgb24gY29tcG91bmQga2V5XG4gICAgICAgICAgICAgICAgICByZXR1cm4ga2V5TGVuZ3RoID09PSAxID9cbiAgICAgICAgICAgICAgICAgICAga2V5WzBdIDogLy8gQ3Vyc29yLmtleSBzaG91bGQgbm90IGJlIGFuIGFycmF5LlxuICAgICAgICAgICAgICAgICAgICBrZXkuc2xpY2UoMCwga2V5TGVuZ3RoKTsgLy8gQ3Vyc29yLmtleSBzaG91bGQgYmUgZmlyc3QgcGFydCBvZiBhcnJheS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHZpcnR1YWxDdXJzb3I7XG4gICAgICAgICAgfVxuICAgIFxuICAgICAgICAgIHJldHVybiB0YWJsZS5vcGVuQ3Vyc29yKHRyYW5zbGF0ZVJlcXVlc3QocmVxKSlcbiAgICAgICAgICAgIC50aGVuKGN1cnNvciA9PiBjdXJzb3IgJiYgY3JlYXRlVmlydHVhbEN1cnNvcihjdXJzb3IpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlIDogTWlkZGxld2FyZTxEQkNvcmU+ID0ge1xuICBzdGFjazogXCJkYmNvcmVcIixcbiAgbmFtZTogXCJWaXJ0dWFsSW5kZXhNaWRkbGV3YXJlXCIsXG4gIGxldmVsOiAxLFxuICBjcmVhdGU6IGNyZWF0ZVZpcnR1YWxJbmRleE1pZGRsZXdhcmVcbn07XG5cbiIsICJpbXBvcnQgeyBrZXlzLCBoYXNPd24sIHRvU3RyaW5nVGFnIH0gZnJvbSAnLi91dGlscyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRPYmplY3REaWZmKGE6IGFueSwgYjogYW55LCBydj86IGFueSwgcHJmeD86IHN0cmluZykge1xuICAvLyBDb21wYXJlcyBvYmplY3RzIGEgYW5kIGIgYW5kIHByb2R1Y2VzIGEgZGlmZiBvYmplY3QuXG4gIHJ2ID0gcnYgfHwge307XG4gIHByZnggPSBwcmZ4IHx8ICcnO1xuICBrZXlzKGEpLmZvckVhY2goKHByb3ApID0+IHtcbiAgICBpZiAoIWhhc093bihiLCBwcm9wKSkge1xuICAgICAgLy8gUHJvcGVydHkgcmVtb3ZlZFxuICAgICAgcnZbcHJmeCArIHByb3BdID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXAgPSBhW3Byb3BdLFxuICAgICAgICBicCA9IGJbcHJvcF07XG4gICAgICBpZiAodHlwZW9mIGFwID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYnAgPT09ICdvYmplY3QnICYmIGFwICYmIGJwKSB7XG4gICAgICAgIGNvbnN0IGFwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhhcCk7XG4gICAgICAgIGNvbnN0IGJwVHlwZU5hbWUgPSB0b1N0cmluZ1RhZyhicCk7XG5cbiAgICAgICAgaWYgKGFwVHlwZU5hbWUgIT09IGJwVHlwZU5hbWUpIHtcbiAgICAgICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdOyAvLyBQcm9wZXJ0eSBjaGFuZ2VkIHRvIG90aGVyIHR5cGVcbiAgICAgICAgfSBlbHNlIGlmIChhcFR5cGVOYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIC8vIFBvam8gb2JqZWN0cyAobm90IERhdGUsIEFycmF5QnVmZmVyLCBBcnJheSBldGMpLiBHbyBkZWVwLlxuICAgICAgICAgIGdldE9iamVjdERpZmYoYXAsIGJwLCBydiwgcHJmeCArIHByb3AgKyAnLicpO1xuICAgICAgICB9IGVsc2UgaWYgKGFwICE9PSBicCkge1xuICAgICAgICAgIC8vIFZhbHVlcyBkaWZmZXIuXG4gICAgICAgICAgLy8gQ291bGQgaGF2ZSBjaGVja2VkIGlmIERhdGUsIGFycmF5cyBvciBiaW5hcnkgdHlwZXMgaGF2ZSBzYW1lXG4gICAgICAgICAgLy8gY29udGVudCBoZXJlIGJ1dCBJIHRoaW5rIHRoYXQgd291bGQgYmUgYSBzdWJvcHRpbWF0aW9uLlxuICAgICAgICAgIC8vIFByZWZlciBzaW1wbGljaXR5LlxuICAgICAgICAgIHJ2W3ByZnggKyBwcm9wXSA9IGJbcHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXAgIT09IGJwKSBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdOyAvLyBQcmltaXRpdmUgdmFsdWUgY2hhbmdlZFxuICAgIH1cbiAgfSk7XG4gIGtleXMoYikuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIGlmICghaGFzT3duKGEsIHByb3ApKSB7XG4gICAgICBydltwcmZ4ICsgcHJvcF0gPSBiW3Byb3BdOyAvLyBQcm9wZXJ0eSBhZGRlZFxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBydjtcbn1cbiIsICJpbXBvcnQge1xuICBEQkNvcmVBZGRSZXF1ZXN0LFxuICBEQkNvcmVQdXRSZXF1ZXN0LFxuICBEQkNvcmVEZWxldGVSZXF1ZXN0LFxuICBEQkNvcmVJbmRleCxcbiAgREJDb3JlVGFibGUsXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRFZmZlY3RpdmVLZXlzIChcbiAgcHJpbWFyeUtleTogREJDb3JlSW5kZXgsXG4gIHJlcTogKFBpY2s8REJDb3JlQWRkUmVxdWVzdCB8IERCQ29yZVB1dFJlcXVlc3QsIFwidHlwZVwiIHwgXCJ2YWx1ZXNcIj4gJiB7a2V5cz86IGFueVtdfSkgfCBQaWNrPERCQ29yZURlbGV0ZVJlcXVlc3QsIFwia2V5c1wiIHwgXCJ0eXBlXCI+KVxue1xuICAvL2NvbnN0IHtvdXRib3VuZH0gPSBwcmltYXJ5S2V5O1xuICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSByZXR1cm4gcmVxLmtleXM7XG4gIHJldHVybiByZXEua2V5cyB8fCByZXEudmFsdWVzLm1hcChwcmltYXJ5S2V5LmV4dHJhY3RLZXkpXG59XG4iLCAiaW1wb3J0IHtcbiAgREJDb3JlLFxuICBEQkNvcmVUYWJsZSxcbiAgREJDb3JlTXV0YXRlUmVzcG9uc2UsXG4gIERCQ29yZURlbGV0ZVJhbmdlUmVxdWVzdCxcbiAgREJDb3JlQWRkUmVxdWVzdCxcbiAgREJDb3JlUHV0UmVxdWVzdCxcbiAgREJDb3JlRGVsZXRlUmVxdWVzdCxcbiAgREJDb3JlVHJhbnNhY3Rpb24sXG4gIERCQ29yZUtleVJhbmdlXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5pbXBvcnQgeyBub3AgfSBmcm9tICcuLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCB7IGhhc093biwgc2V0QnlLZXlQYXRoIH0gZnJvbSAnLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldE9iamVjdERpZmYgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL2dldC1vYmplY3QtZGlmZlwiO1xuaW1wb3J0IHsgUFNEIH0gZnJvbSAnLi4vaGVscGVycy9wcm9taXNlJztcbi8vaW1wb3J0IHsgTG9ja2FibGVUYWJsZU1pZGRsZXdhcmUgfSBmcm9tICcuLi9kYmNvcmUvbG9ja2FibGUtdGFibGUtbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBnZXRFZmZlY3RpdmVLZXlzIH0gZnJvbSAnLi4vZGJjb3JlL2dldC1lZmZlY3RpdmUta2V5cyc7XG5pbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSAnLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmUnO1xuaW1wb3J0IHsgVHJhbnNhY3Rpb24gfSBmcm9tICcuLi9jbGFzc2VzL3RyYW5zYWN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGhvb2tzTWlkZGxld2FyZTogTWlkZGxld2FyZTxEQkNvcmU+ICA9IHtcbiAgc3RhY2s6IFwiZGJjb3JlXCIsXG4gIG5hbWU6IFwiSG9va3NNaWRkbGV3YXJlXCIsXG4gIGxldmVsOiAyLFxuICBjcmVhdGU6IChkb3duQ29yZTogREJDb3JlKSA9PiAoe1xuICAgIC4uLmRvd25Db3JlLFxuICAgIHRhYmxlKHRhYmxlTmFtZTogc3RyaW5nKSB7XG4gICAgICBjb25zdCBkb3duVGFibGUgPSBkb3duQ29yZS50YWJsZSh0YWJsZU5hbWUpO1xuICAgICAgY29uc3Qge3ByaW1hcnlLZXl9ID0gZG93blRhYmxlLnNjaGVtYTtcbiAgXG4gICAgICBjb25zdCB0YWJsZU1pZGRsZXdhcmU6IERCQ29yZVRhYmxlID0ge1xuICAgICAgICAuLi5kb3duVGFibGUsXG4gICAgICAgIG11dGF0ZShyZXEpOlByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+IHtcbiAgICAgICAgICBjb25zdCBkeFRyYW5zID0gUFNELnRyYW5zIGFzIFRyYW5zYWN0aW9uO1xuICAgICAgICAgIC8vIEhvb2tzIGNhbiBiZSB0cmFuc2FjdGlvbi1ib3VuZC4gTmVlZCB0byBncmFiIHRoZW0gZnJvbSB0cmFuc2FjdGlvbi50YWJsZSBhbmQgbm90XG4gICAgICAgICAgLy8gZGIudGFibGUhXG4gICAgICAgICAgY29uc3Qge2RlbGV0aW5nLCBjcmVhdGluZywgdXBkYXRpbmd9ID0gZHhUcmFucy50YWJsZSh0YWJsZU5hbWUpLmhvb2s7XG4gICAgICAgICAgc3dpdGNoIChyZXEudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYWRkJzpcbiAgICAgICAgICAgICAgaWYgKGNyZWF0aW5nLmZpcmUgPT09IG5vcCkgYnJlYWs7XG4gICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKT0+YWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlICdwdXQnOlxuICAgICAgICAgICAgICBpZiAoY3JlYXRpbmcuZmlyZSA9PT0gbm9wICYmIHVwZGF0aW5nLmZpcmUgPT09IG5vcCkgYnJlYWs7XG4gICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKT0+YWRkUHV0T3JEZWxldGUocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgICBjYXNlICdkZWxldGUnOlxuICAgICAgICAgICAgICBpZiAoZGVsZXRpbmcuZmlyZSA9PT0gbm9wKSBicmVhaztcbiAgICAgICAgICAgICAgcmV0dXJuIGR4VHJhbnMuX3Byb21pc2UoJ3JlYWR3cml0ZScsICgpPT5hZGRQdXRPckRlbGV0ZShyZXEpLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgJ2RlbGV0ZVJhbmdlJzpcbiAgICAgICAgICAgICAgaWYgKGRlbGV0aW5nLmZpcmUgPT09IG5vcCkgYnJlYWs7XG4gICAgICAgICAgICAgIHJldHVybiBkeFRyYW5zLl9wcm9taXNlKCdyZWFkd3JpdGUnLCAoKT0+ZGVsZXRlUmFuZ2UocmVxKSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFueSBvZiB0aGUgYnJlYWtzIGFib3ZlIGhhcHBlbmVkIChubyBob29rcykgLSBkbyB0aGUgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpO1xuXG5cbiAgICAgICAgICBmdW5jdGlvbiBhZGRQdXRPckRlbGV0ZShyZXE6IERCQ29yZUFkZFJlcXVlc3QgfCBEQkNvcmVQdXRSZXF1ZXN0IHwgREJDb3JlRGVsZXRlUmVxdWVzdCk6IFByb21pc2U8REJDb3JlTXV0YXRlUmVzcG9uc2U+IHtcbiAgICAgICAgICAgIGNvbnN0IGR4VHJhbnMgPSBQU0QudHJhbnM7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gcmVxLmtleXMgfHwgZ2V0RWZmZWN0aXZlS2V5cyhwcmltYXJ5S2V5LCByZXEpO1xuICAgICAgICAgICAgaWYgKCFrZXlzKSB0aHJvdyBuZXcgRXJyb3IoXCJLZXlzIG1pc3NpbmdcIik7XG4gICAgICAgICAgICAvLyBDbG9uZSBSZXF1ZXN0IGFuZCBzZXQga2V5cyBhcmdcbiAgICAgICAgICAgIHJlcSA9IHJlcS50eXBlID09PSAnYWRkJyB8fCByZXEudHlwZSA9PT0gJ3B1dCcgP1xuICAgICAgICAgICAgICB7Li4ucmVxLCBrZXlzfSA6XG4gICAgICAgICAgICAgIHsuLi5yZXF9O1xuICAgICAgICAgICAgaWYgKHJlcS50eXBlICE9PSAnZGVsZXRlJykgcmVxLnZhbHVlcyA9IFsuLi5yZXEudmFsdWVzXTtcbiAgICAgICAgICAgIGlmIChyZXEua2V5cykgcmVxLmtleXMgPSBbLi4ucmVxLmtleXNdO1xuICBcbiAgICAgICAgICAgIHJldHVybiBnZXRFeGlzdGluZ1ZhbHVlcyhkb3duVGFibGUsIHJlcSwga2V5cykudGhlbiAoZXhpc3RpbmdWYWx1ZXMgPT4ge1xuICAgICAgICAgICAgICBjb25zdCBjb250ZXh0cyA9IGtleXMubWFwKChrZXksIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZXhpc3RpbmdWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3R4ID0geyBvbmVycm9yOiBudWxsLCBvbnN1Y2Nlc3M6IG51bGwgfTtcbiAgICAgICAgICAgICAgICBpZiAocmVxLnR5cGUgPT09ICdkZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAvLyBkZWxldGUgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICBkZWxldGluZy5maXJlLmNhbGwoY3R4LCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocmVxLnR5cGUgPT09ICdhZGQnIHx8IGV4aXN0aW5nVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIGFkZCgpIG9yIHB1dCgpIHJlc3VsdGVkIGluIGEgY3JlYXRlXG4gICAgICAgICAgICAgICAgICBjb25zdCBnZW5lcmF0ZWRQcmltYXJ5S2V5ID0gY3JlYXRpbmcuZmlyZS5jYWxsKGN0eCwga2V5LCByZXEudmFsdWVzW2ldLCBkeFRyYW5zKTtcbiAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gbnVsbCAmJiBnZW5lcmF0ZWRQcmltYXJ5S2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0gZ2VuZXJhdGVkUHJpbWFyeUtleTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmtleXNbaV0gPSBrZXk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcHJpbWFyeUtleS5vdXRib3VuZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXEudmFsdWVzW2ldLCBwcmltYXJ5S2V5LmtleVBhdGgsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gVGhlIHB1dCgpIG9wZXJhdGlvbiByZXN1bHRlZCBpbiBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG9iamVjdERpZmYgPSBnZXRPYmplY3REaWZmKGV4aXN0aW5nVmFsdWUsIHJlcS52YWx1ZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbENoYW5nZXMgPSB1cGRhdGluZy5maXJlLmNhbGwoY3R4LCBvYmplY3REaWZmLCBrZXksIGV4aXN0aW5nVmFsdWUsIGR4VHJhbnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGFkZGl0aW9uYWxDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RlZFZhbHVlID0gcmVxLnZhbHVlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbENoYW5nZXMpLmZvckVhY2goa2V5UGF0aCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc093bihyZXF1ZXN0ZWRWYWx1ZSwga2V5UGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtleVBhdGggaXMgYWxyZWFkeSBwcmVzZW50IGFzIGEgbGl0ZXJhbCBwcm9wZXJ0eSBvZiB0aGUgb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0ZWRWYWx1ZVtrZXlQYXRoXSA9IGFkZGl0aW9uYWxDaGFuZ2VzW2tleVBhdGhdO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBrZXlQYXRoIHJlcHJlc2VudHMgYSBuZXcgb3IgZXhpc3RpbmcgcGF0aCBpbnRvIHRoZSBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEJ5S2V5UGF0aChyZXF1ZXN0ZWRWYWx1ZSwga2V5UGF0aCwgYWRkaXRpb25hbENoYW5nZXNba2V5UGF0aF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjdHg7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICByZXR1cm4gZG93blRhYmxlLm11dGF0ZShyZXEpLnRoZW4oKHtmYWlsdXJlcywgcmVzdWx0cywgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHR9KSA9PiB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IHByaW1LZXkgPSByZXN1bHRzID8gcmVzdWx0c1tpXSA6IGtleXNbaV07XG4gICAgICAgICAgICAgICAgICBjb25zdCBjdHggPSBjb250ZXh0c1tpXTtcbiAgICAgICAgICAgICAgICAgIGlmIChwcmltS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZmFpbHVyZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY3R4Lm9uc3VjY2VzcyAmJiBjdHgub25zdWNjZXNzKFxuICAgICAgICAgICAgICAgICAgICAgIHJlcS50eXBlID09PSAncHV0JyAmJiBleGlzdGluZ1ZhbHVlc1tpXSA/IC8vIHRoZSBwdXQgcmVzdWx0ZWQgaW4gYW4gdXBkYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXEudmFsdWVzW2ldIDogLy8gdXBkYXRlIGhvb2tzIGV4cGVjdHMgZXhpc3RpbmcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW1LZXkgLy8gY3JlYXRlIGhvb2tzIGV4cGVjdHMgcHJpbWFyeSBrZXlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtmYWlsdXJlcywgcmVzdWx0cywgbnVtRmFpbHVyZXMsIGxhc3RSZXN1bHR9O1xuICAgICAgICAgICAgICB9KS5jYXRjaChlcnJvciA9PiB7XG4gICAgICAgICAgICAgICAgY29udGV4dHMuZm9yRWFjaChjdHggPT4gY3R4Lm9uZXJyb3IgJiYgY3R4Lm9uZXJyb3IoZXJyb3IpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgXG4gICAgICAgICAgZnVuY3Rpb24gZGVsZXRlUmFuZ2UocmVxOiBEQkNvcmVEZWxldGVSYW5nZVJlcXVlc3QpOiBQcm9taXNlPERCQ29yZU11dGF0ZVJlc3BvbnNlPiB7XG4gICAgICAgICAgICByZXR1cm4gZGVsZXRlTmV4dENodW5rKHJlcS50cmFucywgcmVxLnJhbmdlLCAxMDAwMCk7XG4gICAgICAgICAgfVxuICBcbiAgICAgICAgICBmdW5jdGlvbiBkZWxldGVOZXh0Q2h1bmsodHJhbnM6IERCQ29yZVRyYW5zYWN0aW9uLCByYW5nZTogREJDb3JlS2V5UmFuZ2UsIGxpbWl0OiBudW1iZXIpIHtcbiAgICAgICAgICAgIC8vIFF1ZXJ5IHdoYXQga2V5cyBpbiB0aGUgREIgd2l0aGluIHRoZSBnaXZlbiByYW5nZVxuICAgICAgICAgICAgcmV0dXJuIGRvd25UYWJsZS5xdWVyeSh7dHJhbnMsIHZhbHVlczogZmFsc2UsIHF1ZXJ5OiB7aW5kZXg6IHByaW1hcnlLZXksIHJhbmdlfSwgbGltaXR9KVxuICAgICAgICAgICAgLnRoZW4oKHtyZXN1bHR9KSA9PiB7XG4gICAgICAgICAgICAgIC8vIEdpdmVuIGEgc2V0IG9mIGtleXMsIGJ1bGsgZGVsZXRlIHRob3NlIHVzaW5nIHRoZSBzYW1lIHByb2NlZHVyZSBhcyBpbiBhZGRQdXRPckRlbGV0ZSgpLlxuICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgbWFrZSBzdXJlIHRoYXQgZGVsZXRpbmcgaG9vayBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgIHJldHVybiBhZGRQdXRPckRlbGV0ZSh7dHlwZTogJ2RlbGV0ZScsIGtleXM6IHJlc3VsdCwgdHJhbnN9KS50aGVuKHJlcyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcy5udW1GYWlsdXJlcyA+IDApIHJldHVybiBQcm9taXNlLnJlamVjdChyZXMuZmFpbHVyZXNbMF0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQubGVuZ3RoIDwgbGltaXQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7ZmFpbHVyZXM6IFtdLCBudW1GYWlsdXJlczogMCwgbGFzdFJlc3VsdDogdW5kZWZpbmVkfSBhcyBEQkNvcmVNdXRhdGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGV0ZU5leHRDaHVuayh0cmFucywgey4uLnJhbmdlLCBsb3dlcjogcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXSwgbG93ZXJPcGVuOiB0cnVlfSwgbGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIC8vY29uc3Qge2xvY2ssIGxvY2thYmxlTWlkZGxld2FyZX0gPSBMb2NrYWJsZVRhYmxlTWlkZGxld2FyZSh0YWJsZU1pZGRsZXdhcmUpO1xuXG4gICAgICByZXR1cm4gdGFibGVNaWRkbGV3YXJlO1xuICAgIH0sXG4gIH0pIGFzIERCQ29yZVxufTtcblxuZnVuY3Rpb24gZ2V0RXhpc3RpbmdWYWx1ZXMoXG4gIHRhYmxlOiBEQkNvcmVUYWJsZSxcbiAgcmVxOiBEQkNvcmVBZGRSZXF1ZXN0IHwgREJDb3JlUHV0UmVxdWVzdCB8IERCQ29yZURlbGV0ZVJlcXVlc3QsXG4gIGVmZmVjdGl2ZUtleXM6IGFueVtdXG4pIHtcbiAgcmV0dXJuIHJlcS50eXBlID09PSBcImFkZFwiXG4gICAgPyBQcm9taXNlLnJlc29sdmUoW10pXG4gICAgOiB0YWJsZS5nZXRNYW55KHsgdHJhbnM6IHJlcS50cmFucywga2V5czogZWZmZWN0aXZlS2V5cywgY2FjaGU6IFwiaW1tdXRhYmxlXCIgfSk7XG59XG4iLCAiaW1wb3J0IHsgZGVlcENsb25lIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgREJDb3JlIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9kYmNvcmVcIjtcbmltcG9ydCB7IE1pZGRsZXdhcmUgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL21pZGRsZXdhcmVcIjtcbmltcG9ydCBQcm9taXNlIGZyb20gXCIuLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IGNtcCB9IGZyb20gJy4uL2Z1bmN0aW9ucy9jbXAnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RnJvbVRyYW5zYWN0aW9uQ2FjaGUoXG4gIGtleXM6IGFueVtdLFxuICBjYWNoZTogeyBrZXlzOiBhbnlbXTsgdmFsdWVzOiBhbnlbXSB9IHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgY2xvbmU/OiBib29sZWFuXG4pIHtcbiAgdHJ5IHtcbiAgICBpZiAoIWNhY2hlKSByZXR1cm4gbnVsbDtcbiAgICBpZiAoY2FjaGUua2V5cy5sZW5ndGggPCBrZXlzLmxlbmd0aCkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgcmVzdWx0OiBhbnlbXSA9IFtdO1xuICAgIC8vIENvbXBhcmUgaWYgdGhlIGV4YWN0IHNhbWUgb3JkZXIgb2Yga2V5cyB3YXMgcmV0cmlldmVkIGluIHNhbWUgdHJhbnNhY3Rpb246XG4gICAgLy8gQWxsb3cgc29tZSBjYWNoZWQga2V5cyB0byBiZSBvbWl0dGVkIGZyb20gcHJvdmlkZWQgc2V0IG9mIGtleXNcbiAgICAvLyBVc2UgY2FzZTogMS4gZ2V0TWFueShrZXlzKSAyLiB1cGRhdGUgYSBzdWJzZXQgb2YgdGhvc2UgMy4gY2FsbCBwdXQgd2l0aCB0aGUgdXBkYXRlZCBvbmVzID09PiBtaWRkbGV3YXJlcyBzaG91bGQgYmUgYWJsZSB0byBmaW5kIG9sZCB2YWx1ZXNcbiAgICBmb3IgKGxldCBpID0gMCwgaiA9IDA7IGkgPCBjYWNoZS5rZXlzLmxlbmd0aCAmJiBqIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGNtcChjYWNoZS5rZXlzW2ldLCBrZXlzW2pdKSAhPT0gMCkgY29udGludWU7XG4gICAgICByZXN1bHQucHVzaChjbG9uZSA/IGRlZXBDbG9uZShjYWNoZS52YWx1ZXNbaV0pIDogY2FjaGUudmFsdWVzW2ldKTtcbiAgICAgICsrajtcbiAgICB9XG4gICAgLy8gSWYgZ290IGFsbCBrZXlzIGNhbGxlciB3YXMgbG9va2luZyBmb3IsIHJldHVybiByZXN1bHQuXG4gICAgcmV0dXJuIHJlc3VsdC5sZW5ndGggPT09IGtleXMubGVuZ3RoID8gcmVzdWx0IDogbnVsbDtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlOiBNaWRkbGV3YXJlPERCQ29yZT4gPSB7XG4gIHN0YWNrOiBcImRiY29yZVwiLFxuICBsZXZlbDogLTEsXG4gIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFibGU6ICh0YWJsZU5hbWUpID0+IHtcbiAgICAgICAgY29uc3QgdGFibGUgPSBjb3JlLnRhYmxlKHRhYmxlTmFtZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgZ2V0TWFueTogKHJlcSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXEuY2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFJlc3VsdCA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKFxuICAgICAgICAgICAgICByZXEua2V5cyxcbiAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdLFxuICAgICAgICAgICAgICByZXEuY2FjaGUgPT09IFwiY2xvbmVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlmIChjYWNoZWRSZXN1bHQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjYWNoZWRSZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhYmxlLmdldE1hbnkocmVxKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0ge1xuICAgICAgICAgICAgICAgIGtleXM6IHJlcS5rZXlzLFxuICAgICAgICAgICAgICAgIHZhbHVlczogcmVxLmNhY2hlID09PSBcImNsb25lXCIgPyBkZWVwQ2xvbmUocmVzKSA6IHJlcyxcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICAvLyBJbnZhbGlkYXRlIGNhY2hlIG9uIGFueSBtdXRhdGUgZXhjZXB0IFwiYWRkXCIgd2hpY2ggY2FuJ3QgY2hhbmdlIGV4aXN0aW5nIHZhbHVlczpcbiAgICAgICAgICAgIGlmIChyZXEudHlwZSAhPT0gXCJhZGRcIikgcmVxLnRyYW5zW1wiX2NhY2hlXCJdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZS5tdXRhdGUocmVxKTtcbiAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9LFxufTtcbiIsICJpbXBvcnQgeyBjbXAgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL2NtcFwiO1xuaW1wb3J0IHsgZXh0ZW5kLCBpdGVyYXRvclN5bWJvbCwgcHJvcHMgfSBmcm9tICcuLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IHsgSW5kZXhhYmxlVHlwZSB9IGZyb20gJy4uL3B1YmxpYyc7XG5pbXBvcnQge1xuICBFbXB0eVJhbmdlLFxuICBJbnRlcnZhbFRyZWUsXG4gIEludGVydmFsVHJlZU5vZGUsXG4gIFJhbmdlU2V0Q29uc3RydWN0b3IsXG4gIFJhbmdlU2V0UHJvdG90eXBlLFxufSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL3Jhbmdlc2V0XCI7XG5cbi8qIEFuIGludGVydmFsIHRyZWUgaW1wbGVtZW50YXRpb24gdG8gZWZmaWNpZW50bHkgZGV0ZWN0IG92ZXJsYXBwaW5nIHJhbmdlcyBvZiBxdWVyaWVkIGluZGV4ZXMuXG4gKlxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJ2YWxfdHJlZVxuICogXG4gKi9cblxuZnVuY3Rpb24gaXNFbXB0eVJhbmdlKG5vZGU6IEludGVydmFsVHJlZSB8IHtmcm9tOiBJbmRleGFibGVUeXBlLCB0bzogSW5kZXhhYmxlVHlwZX0pOiBub2RlIGlzIEVtcHR5UmFuZ2Uge1xuICByZXR1cm4gIShcImZyb21cIiBpbiBub2RlKTtcbn1cblxuZXhwb3J0IHR5cGUgUmFuZ2VTZXQgPSBSYW5nZVNldFByb3RvdHlwZSAmIEludGVydmFsVHJlZTtcblxuZXhwb3J0IGNvbnN0IFJhbmdlU2V0ID0gZnVuY3Rpb24oZnJvbU9yVHJlZTogYW55LCB0bz86IGFueSkge1xuICBpZiAodGhpcykge1xuICAgIC8vIENhbGxlZCB3aXRoIG5ldygpXG4gICAgZXh0ZW5kKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyB7ZDoxLCBmcm9tOiBmcm9tT3JUcmVlLCB0bzogYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB0byA6IGZyb21PclRyZWV9IDoge2Q6MH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIENhbGxlZCB3aXRob3V0IG5ldygpXG4gICAgY29uc3QgcnYgPSBuZXcgUmFuZ2VTZXQoKTtcbiAgICBpZiAoZnJvbU9yVHJlZSAmJiAoXCJkXCIgaW4gZnJvbU9yVHJlZSkpIHtcbiAgICAgIGV4dGVuZChydiwgZnJvbU9yVHJlZSk7XG4gICAgfVxuICAgIHJldHVybiBydjtcbiAgfVxufSBhcyBSYW5nZVNldENvbnN0cnVjdG9yO1xuXG5wcm9wcyhSYW5nZVNldC5wcm90b3R5cGUsIHtcbiAgYWRkKHJhbmdlU2V0OiBJbnRlcnZhbFRyZWUgfCB7ZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGV9KSB7XG4gICAgbWVyZ2VSYW5nZXModGhpcywgcmFuZ2VTZXQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRLZXkoa2V5OiBJbmRleGFibGVUeXBlKSB7XG4gICAgYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRLZXlzKGtleXM6IEluZGV4YWJsZVR5cGVbXSkge1xuICAgIGtleXMuZm9yRWFjaChrZXkgPT4gYWRkUmFuZ2UodGhpcywga2V5LCBrZXkpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBbaXRlcmF0b3JTeW1ib2xdKCk6IEl0ZXJhdG9yPEludGVydmFsVHJlZU5vZGUsIHVuZGVmaW5lZCwgSW5kZXhhYmxlVHlwZSB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBnZXRSYW5nZVNldEl0ZXJhdG9yKHRoaXMpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gYWRkUmFuZ2UodGFyZ2V0OiBJbnRlcnZhbFRyZWUsIGZyb206IEluZGV4YWJsZVR5cGUsIHRvOiBJbmRleGFibGVUeXBlKSB7XG4gIGNvbnN0IGRpZmYgPSBjbXAoZnJvbSwgdG8pO1xuICAvLyBjbXAoKSByZXR1cm5zIE5hTiBpZiBvbmUgb2YgdGhlIGFyZ3MgYXJlIElEQi1pbnZhbGlkIGtleXMuXG4gIC8vIEF2b2lkIHN0b3JpbmcgaW52YWxpZCBrZXlzIGluIHJhbmdlc2V0OlxuICBpZiAoaXNOYU4oZGlmZikpIHJldHVybjtcblxuICAvLyBDYWxsZXIgaXMgdHJ5aW5nIHRvIGFkZCBhIHJhbmdlIHdoZXJlIGZyb20gaXMgZ3JlYXRlciB0aGFuIHRvOlxuICBpZiAoZGlmZiA+IDApIHRocm93IFJhbmdlRXJyb3IoKTtcbiAgXG4gIGlmIChpc0VtcHR5UmFuZ2UodGFyZ2V0KSkgcmV0dXJuIGV4dGVuZCh0YXJnZXQsIHsgZnJvbSwgdG8sIGQ6IDEgfSk7XG4gIGNvbnN0IGxlZnQgPSB0YXJnZXQubDtcbiAgY29uc3QgcmlnaHQgPSB0YXJnZXQucjtcbiAgaWYgKGNtcCh0bywgdGFyZ2V0LmZyb20pIDwgMCkge1xuICAgIGxlZnRcbiAgICAgID8gYWRkUmFuZ2UobGVmdCwgZnJvbSwgdG8pXG4gICAgICA6ICh0YXJnZXQubCA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICB9XG4gIGlmIChjbXAoZnJvbSwgdGFyZ2V0LnRvKSA+IDApIHtcbiAgICByaWdodFxuICAgICAgPyBhZGRSYW5nZShyaWdodCwgZnJvbSwgdG8pXG4gICAgICA6ICh0YXJnZXQuciA9IHsgZnJvbSwgdG8sIGQ6IDEsIGw6IG51bGwsIHI6IG51bGwgfSk7XG4gICAgcmV0dXJuIHJlYmFsYW5jZSh0YXJnZXQpO1xuICB9XG4gIC8vIE5vdyB3ZSBoYXZlIHNvbWUga2luZCBvZiBvdmVybGFwLiBXZSB3aWxsIGJlIGFibGUgdG8gbWVyZ2UgdGhlIG5ldyByYW5nZSBpbnRvIHRoZSBub2RlIG9yIGxldCBpdCBiZSBzd2FsbG93ZWQuXG5cbiAgLy8gR3JvdyBsZWZ0P1xuICBpZiAoY21wKGZyb20sIHRhcmdldC5mcm9tKSA8IDApIHtcbiAgICB0YXJnZXQuZnJvbSA9IGZyb207XG4gICAgdGFyZ2V0LmwgPSBudWxsOyAvLyBDdXQgb2ZmIGZvciBub3cuIFJlLWFkZCBsYXRlci5cbiAgICB0YXJnZXQuZCA9IHJpZ2h0ID8gcmlnaHQuZCArIDEgOiAxO1xuICB9XG4gIC8vIEdyb3cgcmlnaHQ/XG4gIGlmIChjbXAodG8sIHRhcmdldC50bykgPiAwKSB7XG4gICAgdGFyZ2V0LnRvID0gdG87XG4gICAgdGFyZ2V0LnIgPSBudWxsOyAvLyBDdXQgb2ZmIGZvciBub3cuIFJlLWFkZCBsYXRlci5cbiAgICB0YXJnZXQuZCA9IHRhcmdldC5sID8gdGFyZ2V0LmwuZCArIDEgOiAxO1xuICB9XG4gIGNvbnN0IHJpZ2h0V2FzQ3V0T2ZmID0gIXRhcmdldC5yO1xuICAvLyBSZS1hZGQgbGVmdD9cbiAgaWYgKGxlZnQgJiYgIXRhcmdldC5sKSB7XG4gICAgLy9SYW5nZXMgdG8gdGhlIGxlZnQgbWF5IGJlIHN3YWxsb3dlZC4gQ3V0IGl0IG9mIGFuZCByZS1hZGQgYWxsLlxuICAgIC8vQ291bGQgcHJvYmFibHkgYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IVxuICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgbGVmdCk7XG4gIH1cbiAgLy8gUmUtYWRkIHJpZ2h0P1xuICBpZiAocmlnaHQgJiYgcmlnaHRXYXNDdXRPZmYpIHtcbiAgICAvL1JhbmdlcyB0byB0aGUgcmlnaHQgbWF5IGJlIHN3YWxsb3dlZC4gQ3V0IGl0IG9mIGFuZCByZS1hZGQgYWxsLlxuICAgIC8vQ291bGQgcHJvYmFibHkgYmUgZG9uZSBtb3JlIGVmZmljaWVudGx5IVxuICAgIG1lcmdlUmFuZ2VzKHRhcmdldCwgcmlnaHQpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZVJhbmdlcyh0YXJnZXQ6IEludGVydmFsVHJlZSwgbmV3U2V0OiBJbnRlcnZhbFRyZWUgfCB7ZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGV9KSB7XG4gIGZ1bmN0aW9uIF9hZGRSYW5nZVNldChcbiAgICB0YXJnZXQ6IEludGVydmFsVHJlZSxcbiAgICB7IGZyb20sIHRvLCBsLCByIH06IEludGVydmFsVHJlZU5vZGUgfCB7ZnJvbTogSW5kZXhhYmxlVHlwZSwgdG86IEluZGV4YWJsZVR5cGUsIGw/OiB1bmRlZmluZWQsIHI/OiB1bmRlZmluZWR9XG4gICkge1xuICAgIGFkZFJhbmdlKHRhcmdldCwgZnJvbSwgdG8pO1xuICAgIGlmIChsKSBfYWRkUmFuZ2VTZXQodGFyZ2V0LCBsKTtcbiAgICBpZiAocikgX2FkZFJhbmdlU2V0KHRhcmdldCwgcik7XG4gIH1cblxuICBpZighaXNFbXB0eVJhbmdlKG5ld1NldCkpIF9hZGRSYW5nZVNldCh0YXJnZXQsIG5ld1NldCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByYW5nZXNPdmVybGFwKFxuICByYW5nZVNldDE6IEludGVydmFsVHJlZSxcbiAgcmFuZ2VTZXQyOiBJbnRlcnZhbFRyZWVcbik6IGJvb2xlYW4ge1xuICAgIC8vIFN0YXJ0IGl0ZXJhdGluZyBvdGhlciBmcm9tIHNjcmF0Y2guXG4gICAgY29uc3QgaTEgPSBnZXRSYW5nZVNldEl0ZXJhdG9yKHJhbmdlU2V0Mik7XG4gICAgbGV0IG5leHRSZXN1bHQxID0gaTEubmV4dCgpO1xuICAgIGlmIChuZXh0UmVzdWx0MS5kb25lKSByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGEgPSBuZXh0UmVzdWx0MS52YWx1ZTtcblxuICAgIC8vIFN0YXJ0IGl0ZXJhdGluZyB0aGlzIGZyb20gc3RhcnQgb2Ygb3RoZXJcbiAgICBjb25zdCBpMiA9IGdldFJhbmdlU2V0SXRlcmF0b3IocmFuZ2VTZXQxKTtcbiAgICBsZXQgbmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSk7IC8vIFN0YXJ0IGZyb20gYmVnaW5uaW5nIG9mIG90aGVyIHJhbmdlXG4gICAgbGV0IGIgPSBuZXh0UmVzdWx0Mi52YWx1ZTtcblxuICAgIHdoaWxlICghbmV4dFJlc3VsdDEuZG9uZSAmJiAhbmV4dFJlc3VsdDIuZG9uZSkge1xuICAgICAgaWYgKGNtcChiIS5mcm9tLCBhLnRvKSA8PSAwICYmIGNtcChiIS50bywgYS5mcm9tKSA+PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGNtcChhLmZyb20sIGIhLmZyb20pIDwgMFxuICAgICAgICA/IChhID0gKG5leHRSZXN1bHQxID0gaTEubmV4dChiIS5mcm9tKSkudmFsdWUhKSAvLyBhIGlzIGJlaGluZC4gZm9yd2FyZCBpdCB0byBiZWdpbm5pbmcgb2YgbmV4dCBiLXJhbmdlXG4gICAgICAgIDogKGIgPSAobmV4dFJlc3VsdDIgPSBpMi5uZXh0KGEuZnJvbSkpLnZhbHVlKTsgLy8gYiBpcyBiZWhpbmQuIGZvcndhcmQgaXQgdG8gYmVnaW5uaW5nIG9mIG5leHQgYS1yYW5nZVxuICAgIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG50eXBlIFJhbmdlU2V0SXRlcmF0b3JTdGF0ZSA9XG4gIHwge1xuICAgICAgdXA/OiBSYW5nZVNldEl0ZXJhdG9yU3RhdGU7XG4gICAgICBuOiBJbnRlcnZhbFRyZWVOb2RlO1xuICAgICAgczogMCB8IDEgfCAyIHwgMztcbiAgICB9XG4gIHwgdW5kZWZpbmVkXG4gIHwgbnVsbDtcbmV4cG9ydCBmdW5jdGlvbiBnZXRSYW5nZVNldEl0ZXJhdG9yKFxuICBub2RlOiBFbXB0eVJhbmdlIHwgSW50ZXJ2YWxUcmVlTm9kZVxuKTogR2VuZXJhdG9yPEludGVydmFsVHJlZU5vZGUsIHVuZGVmaW5lZCwgSW5kZXhhYmxlVHlwZSB8IHVuZGVmaW5lZD4ge1xuICBsZXQgc3RhdGU6IFJhbmdlU2V0SXRlcmF0b3JTdGF0ZSA9IGlzRW1wdHlSYW5nZShub2RlKSA/IG51bGwgOiB7IHM6IDAsIG46IG5vZGUgfTtcblxuICByZXR1cm4ge1xuICAgIG5leHQoa2V5Pykge1xuICAgICAgY29uc3Qga2V5UHJvdmlkZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMDtcbiAgICAgIHdoaWxlIChzdGF0ZSkge1xuICAgICAgICBzd2l0Y2ggKHN0YXRlLnMpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAvLyBJbml0aWFsIHN0YXRlIGZvciBub2RlLlxuICAgICAgICAgICAgLy8gRmFzdCBmb3J3YXJkIHRvIGxlZnRtb3N0IG5vZGUuXG4gICAgICAgICAgICBzdGF0ZS5zID0gMTtcbiAgICAgICAgICAgIGlmIChrZXlQcm92aWRlZCkge1xuICAgICAgICAgICAgICB3aGlsZSAoc3RhdGUubi5sICYmIGNtcChrZXksIHN0YXRlLm4uZnJvbSkgPCAwKVxuICAgICAgICAgICAgICAgIHN0YXRlID0geyB1cDogc3RhdGUsIG46IHN0YXRlLm4ubCwgczogMSB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd2hpbGUgKHN0YXRlLm4ubCkgc3RhdGUgPSB7IHVwOiBzdGF0ZSwgbjogc3RhdGUubi5sLCBzOiAxIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgLy8gaW50ZW50aW9uYWxseSBmYWxsIGludG8gY2FzZSAxOlxuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIC8vIFdlJ3JlIG9uIGEgbm9kZSB3aGVyZSBpdCdzIGxlZnQgcGFydCBpcyBhbHJlYWR5IGhhbmRsZWQgb3IgZG9lcyBub3QgZXhpc3QuXG4gICAgICAgICAgICBzdGF0ZS5zID0gMjtcbiAgICAgICAgICAgIGlmICgha2V5UHJvdmlkZWQgfHwgY21wKGtleSwgc3RhdGUubi50bykgPD0gMClcbiAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHN0YXRlLm4sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgLy8gV2UndmUgZW1pdHRlZCBvdXIgbm9kZSBhbmQgc2hvdWxkIGNvbnRpbnVlIHdpdGggdGhlIHJpZ2h0IHBhcnQgb3IgbGV0IHBhcmVudCB0YWtlIG92ZXIgZnJvbSBpdCdzIHN0YXRlIDFcbiAgICAgICAgICAgIGlmIChzdGF0ZS5uLnIpIHtcbiAgICAgICAgICAgICAgc3RhdGUucyA9IDM7IC8vIFNvIHdoZW4gY2hpbGQgaXMgZG9uZSwgd2Uga25vdyB3ZSdyZSBkb25lLlxuICAgICAgICAgICAgICBzdGF0ZSA9IHsgdXA6IHN0YXRlLCBuOiBzdGF0ZS5uLnIsIHM6IDAgfTtcbiAgICAgICAgICAgICAgY29udGludWU7IC8vIFdpbGwgZmFsbCBpbiB0byBjYXNlIDAgd2l0aCBmYXN0IGZvcndhcmQgdG8gbGVmdCBsZWFmIG9mIHRoaXMgc3VidHJlZS5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbnRlbnRpb25hbGx5IGZhbGwgaW50byBjYXNlIDM6XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RhdGUgPSBzdGF0ZS51cDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9O1xuICAgIH0sXG4gIH0gYXMgR2VuZXJhdG9yPEludGVydmFsVHJlZU5vZGUsIHVuZGVmaW5lZCwgSW5kZXhhYmxlVHlwZT47XG59XG5cbmZ1bmN0aW9uIHJlYmFsYW5jZSh0YXJnZXQ6IEludGVydmFsVHJlZU5vZGUpIHtcbiAgY29uc3QgZGlmZiA9ICh0YXJnZXQucj8uZCB8fCAwKSAtICh0YXJnZXQubD8uZCB8fCAwKTtcbiAgY29uc3QgciA9IGRpZmYgPiAxID8gXCJyXCIgOiBkaWZmIDwgLTEgPyBcImxcIiA6IFwiXCI7XG4gIGlmIChyKSB7XG5cbiAgICAvLyBSb3RhdGUgKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RyZWVfcm90YXRpb24pXG4gICAgLy9cbiAgICAvLyBcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgW09MRFJPT1RdXG4gICAgLy8gICAgICAgW09MRFJPT1QuTF0gICAgICAgICAgICBbTkVXUk9PVF1cbiAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIFtORVdST09ULkxdIFtORVdST09ULlJdXG4gICAgLy9cbiAgICAvLyBJcyBnb2luZyB0byBiZWNvbWU6XG4gICAgLy9cbiAgICAvLyBcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgW05FV1JPT1RdXG4gICAgLy8gICAgICAgIFtPTERST09UXSAgICAgICAgICAgICBbTkVXUk9PVC5SXVxuICAgIC8vIFtPTERST09ULkxdIFtORVdST09ULkxdICBcblxuICAgIC8vICogY2xvbmUgbm93IGhhcyB0aGUgcHJvcHMgb2YgT0xEUk9PVFxuICAgIC8vIFBsYW46XG4gICAgLy8gKiB0YXJnZXQgbXVzdCBiZSBnaXZlbiB0aGUgcHJvcHMgb2YgTkVXUk9PVFxuICAgIC8vICogdGFyZ2V0W2xdIG11c3QgcG9pbnQgdG8gYSBuZXcgT0xEUk9PVFxuICAgIC8vICogdGFyZ2V0W3JdIG11c3QgcG9pbnQgdG8gTkVXUk9PVC5SXG4gICAgLy8gKiBPTERST09UW3JdIG11c3QgcG9pbnQgdG8gTkVXUk9PVC5MXG4gICAgY29uc3QgbCA9IHIgPT09IFwiclwiID8gXCJsXCIgOiBcInJcIjsgLy8gU3VwcG9ydCBib3RoIGxlZnQvcmlnaHQgcm90YXRpb25cbiAgICBjb25zdCByb290Q2xvbmUgPSB7IC4uLnRhcmdldCB9O1xuICAgIC8vIFdlJ3JlIGdvbm5hIGNvcHkgcHJvcHMgZnJvbSB0YXJnZXQncyByaWdodCBub2RlIGludG8gdGFyZ2V0IHNvIHRoYXQgdGFyZ2V0IHdpbGxcbiAgICAvLyBoYXZlIHNhbWUgcmFuZ2UgYXMgb2xkIHRhcmdldFtyXSAoaW5zdGVhZCBvZiBjaGFuZ2luZyBwb2ludGVycywgd2UgY29weSB2YWx1ZXMuXG4gICAgLy8gdGhhdCB3YXkgd2UgZG8gbm90IG5lZWQgdG8gYWRqdXN0IHBvaW50ZXJzIGluIHBhcmVudHMpLlxuICAgIGNvbnN0IG9sZFJvb3RSaWdodCA9IHRhcmdldFtyXTsgXG4gICAgdGFyZ2V0LmZyb20gPSBvbGRSb290UmlnaHQuZnJvbTtcbiAgICB0YXJnZXQudG8gPSBvbGRSb290UmlnaHQudG87XG4gICAgdGFyZ2V0W3JdID0gb2xkUm9vdFJpZ2h0W3JdO1xuICAgIHJvb3RDbG9uZVtyXSA9IG9sZFJvb3RSaWdodFtsXTtcbiAgICB0YXJnZXRbbF0gPSByb290Q2xvbmU7XG4gICAgcm9vdENsb25lLmQgPSBjb21wdXRlRGVwdGgocm9vdENsb25lKTtcbiAgfVxuICB0YXJnZXQuZCA9IGNvbXB1dGVEZXB0aCh0YXJnZXQpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRGVwdGgoeyByLCBsIH06IFBpY2s8SW50ZXJ2YWxUcmVlTm9kZSwgXCJsXCIgfCBcInJcIj4pIHtcbiAgcmV0dXJuIChyID8gKGwgPyBNYXRoLm1heChyLmQsIGwuZCkgOiByLmQpIDogbCA/IGwuZCA6IDApICsgMTtcbn1cbiIsICJpbXBvcnQgeyBnZXRGcm9tVHJhbnNhY3Rpb25DYWNoZSB9IGZyb20gXCIuLi9kYmNvcmUvY2FjaGUtZXhpc3RpbmctdmFsdWVzLW1pZGRsZXdhcmVcIjtcbmltcG9ydCB7IGNtcCB9IGZyb20gXCIuLi9mdW5jdGlvbnMvY21wXCI7XG5pbXBvcnQgeyBpc0FycmF5LCBrZXlzIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgUFNEIH0gZnJvbSBcIi4uL2hlbHBlcnMvcHJvbWlzZVwiO1xuaW1wb3J0IHsgUmFuZ2VTZXQgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZXNldFwiO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5pbXBvcnQge1xuICBEQkNvcmUsXG4gIERCQ29yZUNvdW50UmVxdWVzdCxcbiAgREJDb3JlQ3Vyc29yLFxuICBEQkNvcmVHZXRNYW55UmVxdWVzdCxcbiAgREJDb3JlR2V0UmVxdWVzdCxcbiAgREJDb3JlSW5kZXgsXG4gIERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0LFxuICBEQkNvcmVRdWVyeVJlcXVlc3QsXG4gIERCQ29yZVF1ZXJ5UmVzcG9uc2UsXG4gIERCQ29yZVRhYmxlLFxuICBEQkNvcmVUYWJsZVNjaGVtYSxcbiAgREJDb3JlVHJhbnNhY3Rpb24sXG59IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGJjb3JlXCI7XG5pbXBvcnQgeyBNaWRkbGV3YXJlIH0gZnJvbSBcIi4uL3B1YmxpYy90eXBlcy9taWRkbGV3YXJlXCI7XG5cbmV4cG9ydCBjb25zdCBvYnNlcnZhYmlsaXR5TWlkZGxld2FyZTogTWlkZGxld2FyZTxEQkNvcmU+ID0ge1xuICBzdGFjazogXCJkYmNvcmVcIixcbiAgbGV2ZWw6IDAsXG4gIGNyZWF0ZTogKGNvcmUpID0+IHtcbiAgICBjb25zdCBkYk5hbWUgPSBjb3JlLnNjaGVtYS5uYW1lO1xuICAgIGNvbnN0IEZVTExfUkFOR0UgPSBuZXcgUmFuZ2VTZXQoY29yZS5NSU5fS0VZLCBjb3JlLk1BWF9LRVkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLmNvcmUsXG4gICAgICB0YWJsZTogKHRhYmxlTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCB0YWJsZSA9IGNvcmUudGFibGUodGFibGVOYW1lKTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHRhYmxlO1xuICAgICAgICBjb25zdCB7IHByaW1hcnlLZXkgfSA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgeyBleHRyYWN0S2V5LCBvdXRib3VuZCB9ID0gcHJpbWFyeUtleTtcbiAgICAgICAgY29uc3QgdGFibGVDbG9uZTogREJDb3JlVGFibGUgPSB7XG4gICAgICAgICAgLi4udGFibGUsXG4gICAgICAgICAgbXV0YXRlOiAocmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFucyA9IHJlcS50cmFucyBhcyBEQkNvcmVUcmFuc2FjdGlvbiAmIHtcbiAgICAgICAgICAgICAgbXV0YXRlZFBhcnRzPzogT2JzZXJ2YWJpbGl0eVNldDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBtdXRhdGVkUGFydHMgPVxuICAgICAgICAgICAgICB0cmFucy5tdXRhdGVkUGFydHMgfHwgKHRyYW5zLm11dGF0ZWRQYXJ0cyA9IHt9KTtcbiAgICAgICAgICAgIGNvbnN0IGdldFJhbmdlU2V0ID0gKGluZGV4TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICByZXR1cm4gKG11dGF0ZWRQYXJ0c1twYXJ0XSB8fFxuICAgICAgICAgICAgICAgIChtdXRhdGVkUGFydHNbcGFydF0gPSBuZXcgUmFuZ2VTZXQoKSkpIGFzIFJhbmdlU2V0O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHBrUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlbHNSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiOmRlbHNcIik7XG5cbiAgICAgICAgICAgIGNvbnN0IHsgdHlwZSB9ID0gcmVxO1xuICAgICAgICAgICAgbGV0IFtrZXlzLCBuZXdPYmpzXSA9XG4gICAgICAgICAgICAgIHJlcS50eXBlID09PSBcImRlbGV0ZVJhbmdlXCJcbiAgICAgICAgICAgICAgICA/IFtyZXEucmFuZ2VdIC8vIGtleXMgd2lsbCBiZSBhbiBEQkNvcmVLZXlSYW5nZSBvYmplY3QgLSB0cmFuc2Zvcm1lZCBsYXRlciBvbiB0byBhIFtmcm9tLHRvXS1zdHlsZSByYW5nZS5cbiAgICAgICAgICAgICAgICA6IHJlcS50eXBlID09PSBcImRlbGV0ZVwiXG4gICAgICAgICAgICAgICAgPyBbcmVxLmtleXNdIC8vIGtleXMga25vd24gYWxyZWFkeSBoZXJlLiBuZXdPYmpzIHdpbGwgYmUgdW5kZWZpbmVkLlxuICAgICAgICAgICAgICAgIDogcmVxLnZhbHVlcy5sZW5ndGggPCA1MFxuICAgICAgICAgICAgICAgID8gW1tdLCByZXEudmFsdWVzXSAvLyBrZXlzID0gZW1wdHkgYXJyYXkgLSB3aWxsIGJlIHJlc29sdmVkIGluIG11dGF0ZSgpLnRoZW4oLi4uKS5cbiAgICAgICAgICAgICAgICA6IFtdOyAvLyBrZXlzIGFuZCBuZXdPYmpzIHdpbGwgYm90aCBiZSB1bmRlZmluZWQgLSBjaGFuZ2VTcGVjIHdpbGwgYmVjb21lIHRydWUgKGNoYW5nZWQgZm9yIGVudGlyZSB0YWJsZSlcbiAgICAgICAgICAgIGNvbnN0IG9sZENhY2hlID0gcmVxLnRyYW5zW1wiX2NhY2hlXCJdO1xuICAgICAgICAgICAgcmV0dXJuIHRhYmxlLm11dGF0ZShyZXEpLnRoZW4oKHJlcykgPT4ge1xuICAgICAgICAgICAgICAvLyBBZGQgdGhlIG11dGF0ZWQgdGFibGUgYW5kIG9wdGlvbmFsbHkga2V5cyB0byB0aGUgbXV0YXRlZFRhYmxlcyBzZXQgb24gdGhlIHRyYW5zYWN0aW9uLlxuICAgICAgICAgICAgICAvLyBVc2VkIGJ5IHN1YnNjcmliZXJzIHRvIHR4Y29tbWl0IGV2ZW50IGFuZCBmb3IgQ29sbGVjdGlvbi5wcm90b3R5cGUuc3Vic2NyaWJlKCkuXG4gICAgICAgICAgICAgIGlmIChpc0FycmF5KGtleXMpKSB7XG4gICAgICAgICAgICAgICAgLy8ga2V5cyBpcyBhbiBhcnJheSAtIGRlbGV0ZSwgYWRkIG9yIHB1dCBvZiBsZXNzIHRoYW4gNTAgcm93cy5cbiAgICAgICAgICAgICAgICBpZiAodHlwZSAhPT0gXCJkZWxldGVcIikga2V5cyA9IHJlcy5yZXN1bHRzO1xuICAgICAgICAgICAgICAgIC8vIGluZGl2aWR1YWwga2V5cyAoYWRkIHB1dCBvciBkZWxldGUpXG4gICAgICAgICAgICAgICAgcGtSYW5nZVNldC5hZGRLZXlzKGtleXMpO1xuICAgICAgICAgICAgICAgIC8vIE9ubHkgZ2V0IG9sZE9ianMgaWYgdGhleSBoYXZlIGJlZW4gY2FjaGVkIHJlY2VudGx5XG4gICAgICAgICAgICAgICAgLy8gKFRoaXMgYXBwbGllcyB0byBDb2xsZWN0aW9uLm1vZGlmeSgpIG9ubHksIGJ1dCBhbHNvIGlmIHVwZGF0aW5nL2RlbGV0aW5nIGhvb2tzIGhhdmUgc3Vic2NyaWJlcnMpXG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkT2JqcyA9IGdldEZyb21UcmFuc2FjdGlvbkNhY2hlKGtleXMsIG9sZENhY2hlKTtcblxuICAgICAgICAgICAgICAgIC8vIFN1cHBseSBkZXRhaWxlZCB2YWx1ZXMgcGVyIGluZGV4IGZvciBib3RoIG9sZCBhbmQgbmV3IG9iamVjdHM6XG4gICAgICAgICAgICAgICAgaWYgKCFvbGRPYmpzICYmIHR5cGUgIT09IFwiYWRkXCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIGRlbGV0ZSBvciBwdXQgYW5kIHdlIGRvbid0IGtub3cgb2xkIHZhbHVlcy5cbiAgICAgICAgICAgICAgICAgIC8vIEluZGljYXRlIHRoaXMgaW4gdGhlIFwiOmRlbHNcIiBwYXJ0LCBmb3IgdGhlIHNha2Ugb2YgY291bnQoKSBxdWVyaWVzIG9ubHkhXG4gICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5cyhrZXlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9sZE9ianMgfHwgbmV3T2Jqcykge1xuICAgICAgICAgICAgICAgICAgLy8gTm8gbWF0dGVyIGlmIGtub3duaW5nIG9sZE9ianMgb3Igbm90LCB0cmFjayB0aGUgaW5kaWNlcyBpZiBpdCdzIGEgcHV0LCBhZGQgb3IgZGVsZXRlLlxuICAgICAgICAgICAgICAgICAgdHJhY2tBZmZlY3RlZEluZGV4ZXMoZ2V0UmFuZ2VTZXQsIHNjaGVtYSwgb2xkT2JqcywgbmV3T2Jqcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgICAgICAvLyBBcyB3ZSBjYW4ndCBrbm93IGRlbGV0ZWQgaW5kZXggcmFuZ2VzLCBtYXJrIGluZGV4LWJhc2VkIHN1YnNjcmlwdGlvbnMgbXVzdCB0cmlnZ2VyLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0geyBmcm9tOiBrZXlzLmxvd2VyLCB0bzoga2V5cy51cHBlciB9O1xuICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQocmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vIGRlbGV0ZVJhbmdlLiBrZXlzIGlzIGEgREJDb3JlS2V5UmFuZ2Ugb2JqZWN0cy4gVHJhbnNmb3JtIGl0IHRvIFtmcm9tLHRvXS1zdHlsZSByYW5nZS5cbiAgICAgICAgICAgICAgICBwa1JhbmdlU2V0LmFkZChyYW5nZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVG9vIG1hbnkgcmVxdWVzdHMgdG8gcmVjb3JkIHRoZSBkZXRhaWxzIHdpdGhvdXQgc2xvd2luZyBkb3duIHdyaXRlIHBlcmZvcm1hbmNlLlxuICAgICAgICAgICAgICAgIC8vIExldCdzIGp1c3QgcmVjb3JkIGEgZ2VuZXJpYyBsYXJnZSByYW5nZSBvbiBwcmltYXJ5IGtleSwgdGhlIHZpcnR1YWwgOmRlbHMgaW5kZXggYW5kXG4gICAgICAgICAgICAgICAgLy8gYWxsIHNlY29uZGFyeSBpbmRpY2VzOlxuICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgIGRlbHNSYW5nZVNldC5hZGQoRlVMTF9SQU5HRSk7XG4gICAgICAgICAgICAgICAgc2NoZW1hLmluZGV4ZXMuZm9yRWFjaChpZHggPT4gZ2V0UmFuZ2VTZXQoaWR4Lm5hbWUpLmFkZChGVUxMX1JBTkdFKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgZ2V0UmFuZ2U6IChyZXE6IGFueSkgPT4gW0RCQ29yZUluZGV4LCBSYW5nZVNldF0gPSAoe1xuICAgICAgICAgIHF1ZXJ5OiB7IGluZGV4LCByYW5nZSB9LFxuICAgICAgICB9OlxuICAgICAgICAgIHwgREJDb3JlUXVlcnlSZXF1ZXN0XG4gICAgICAgICAgfCBEQkNvcmVDb3VudFJlcXVlc3RcbiAgICAgICAgICB8IERCQ29yZU9wZW5DdXJzb3JSZXF1ZXN0KSA9PiBbXG4gICAgICAgICAgaW5kZXgsXG4gICAgICAgICAgbmV3IFJhbmdlU2V0KHJhbmdlLmxvd2VyID8/IGNvcmUuTUlOX0tFWSwgcmFuZ2UudXBwZXIgPz8gY29yZS5NQVhfS0VZKSxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCByZWFkU3Vic2NyaWJlcnM6IHtbbWV0aG9kIGluXG4gICAgICAgICAgRXhjbHVkZTxrZXlvZiBEQkNvcmVUYWJsZSwgXCJuYW1lXCIgfCBcInNjaGVtYVwiIHwgXCJtdXRhdGVcIj5dOiBcbiAgICAgICAgICAocmVxOiBhbnkpID0+IFtEQkNvcmVJbmRleCwgUmFuZ2VTZXRdXG4gICAgICAgIH0gPSB7XG4gICAgICAgICAgZ2V0OiAocmVxKSA9PiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KHJlcS5rZXkpXSxcbiAgICAgICAgICBnZXRNYW55OiAocmVxKSA9PiBbcHJpbWFyeUtleSwgbmV3IFJhbmdlU2V0KCkuYWRkS2V5cyhyZXEua2V5cyldLFxuICAgICAgICAgIGNvdW50OiBnZXRSYW5nZSxcbiAgICAgICAgICBxdWVyeTogZ2V0UmFuZ2UsXG4gICAgICAgICAgb3BlbkN1cnNvcjogZ2V0UmFuZ2UsXG4gICAgICAgIH1cblxuICAgICAgICBrZXlzKHJlYWRTdWJzY3JpYmVycykuZm9yRWFjaChtZXRob2QgPT4ge1xuICAgICAgICAgIHRhYmxlQ2xvbmVbbWV0aG9kXSA9IGZ1bmN0aW9uIChcbiAgICAgICAgICAgIHJlcTpcbiAgICAgICAgICAgICAgfCBEQkNvcmVHZXRSZXF1ZXN0XG4gICAgICAgICAgICAgIHwgREJDb3JlR2V0TWFueVJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVRdWVyeVJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVDb3VudFJlcXVlc3RcbiAgICAgICAgICAgICAgfCBEQkNvcmVPcGVuQ3Vyc29yUmVxdWVzdFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgY29uc3QgeyBzdWJzY3IgfSA9IFBTRDtcbiAgICAgICAgICAgIGlmIChzdWJzY3IpIHtcbiAgICAgICAgICAgICAgLy8gQ3VycmVudCB6b25lIHdhbnQncyB0byB0cmFjayBhbGwgcXVlcmllcyBzbyB0aGV5IGNhbiBiZSBzdWJzY3JpYmVkIHRvLlxuICAgICAgICAgICAgICAvLyAoVGhlIHF1ZXJ5IGlzIGV4ZWN1dGVkIHdpdGhpbiBhIFwibGl2ZVF1ZXJ5XCIgem9uZSlcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGUgcXVlcnkgYXBwbGllcyB0byBhIGNlcnRhaW4gc2V0IG9mIHJhbmdlczpcbiAgICAgICAgICAgICAgLy8gVHJhY2sgd2hhdCB3ZSBzaG91bGQgYmUgb2JzZXJ2aW5nOlxuICAgICAgICAgICAgICBjb25zdCBnZXRSYW5nZVNldCA9IChpbmRleE5hbWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnQgPSBgaWRiOi8vJHtkYk5hbWV9LyR7dGFibGVOYW1lfS8ke2luZGV4TmFtZX1gO1xuICAgICAgICAgICAgICAgIHJldHVybiAoc3Vic2NyW3BhcnRdIHx8XG4gICAgICAgICAgICAgICAgICAoc3Vic2NyW3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpKSBhcyBSYW5nZVNldDtcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgY29uc3QgcGtSYW5nZVNldCA9IGdldFJhbmdlU2V0KFwiXCIpO1xuICAgICAgICAgICAgICBjb25zdCBkZWxzUmFuZ2VTZXQgPSBnZXRSYW5nZVNldChcIjpkZWxzXCIpO1xuICAgICAgICAgICAgICBjb25zdCBbcXVlcmllZEluZGV4LCBxdWVyaWVkUmFuZ2VzXSA9IHJlYWRTdWJzY3JpYmVyc1ttZXRob2RdKHJlcSk7XG4gICAgICAgICAgICAgIC8vIEEgZ2VuZXJpYyBydWxlIGhlcmU6IHF1ZXJpZWQgcmFuZ2VzIHNob3VsZCBhbHdheXMgYmUgc3Vic2NyaWJlZCB0by5cbiAgICAgICAgICAgICAgZ2V0UmFuZ2VTZXQocXVlcmllZEluZGV4Lm5hbWUgfHwgXCJcIikuYWRkKHF1ZXJpZWRSYW5nZXMpO1xuICAgICAgICAgICAgICBpZiAoIXF1ZXJpZWRJbmRleC5pc1ByaW1hcnlLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGNvdW50KCksIHF1ZXJ5KCkgYW5kIG9wZW5DdXJzb3IoKSBvcGVyYXRlcyBvbiBzZWNvbmRhcnkgaW5kaWNlcy5cbiAgICAgICAgICAgICAgICAvLyBTaW5jZSBwdXQoKSwgZGVsZXRlKCkgYW5kIGRlbGV0ZVJhbmdlKCkgbXV0YXRpb25zIG1heSBoYXBwZW4gd2l0aG91dCBrbm93aW5nIG9sZE9ianMsXG4gICAgICAgICAgICAgICAgLy8gdGhlIG11dGF0ZSgpIG1ldGhvZCB3aWxsIGJlIG1pc3Npbmcgd2hhdCBzZWNvbmRhcnkgaW5kaWNlcyB0aGF0IGFyZSBiZWluZyBkZWxldGVkIGZyb21cbiAgICAgICAgICAgICAgICAvLyB0aGUgc3Vic2NyaWJlZCByYW5nZS4gV2UgYXJlIHdvcmtpbmcgYXJvdW5kIHRoaXMgaXNzdWUgYnkgcmVjb3JkaW5nIGFsbCB0aGUgcmVzdWx0aW5nXG4gICAgICAgICAgICAgICAgLy8gcHJpbWFyeSBrZXlzIGZyb20gdGhlIHF1ZXJpZXMuIFRoaXMgb25seSB3b3JrcyBmb3IgdGhvc2Uga2luZHMgb2YgcXVlcmllcyB3aGVyZSB3ZSBjYW5cbiAgICAgICAgICAgICAgICAvLyBkZXJpdmUgdGhlIHByaW1hcnkga2V5IGZyb20gdGhlIHJlc3VsdC5cbiAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGJsb2NrIHdlIGFyZSBhY2NvbXBsaXNoaW5nIHRoaXMgdXNpbmcgdmFyaW91cyBzdHJhdGVnaWVzIGRlcGVuZGluZyBvbiB0aGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgIC8vIG9mIHRoZSBxdWVyeSByZXN1bHQuXG5cbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImNvdW50XCIpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3ZlIGdvdCBhIHByb2JsZW0hIERlbGV0ZSBhbmQgcHV0IG11dGF0aW9ucyBoYXBwZW4gd2l0aG91dCBrbm93biB0aGUgb2xkT2Jqcy5cbiAgICAgICAgICAgICAgICAgIC8vIFRob3NlIG11dGF0aW9uIGNvdWxkIGNoYW5nZSB0aGUgY291bnQuXG4gICAgICAgICAgICAgICAgICAvLyBTb2x1dGlvbjogRGVkaWNhdGVkIFwiOmRlbHNcIiB1cmwgcmVwcmVzZW5kcyBhIHN1YnNjcmlwdGlvbiB0byBhbGwgbXV0YXRpb25zIHdpdGhvdXQgb2xkT2Jqc1xuICAgICAgICAgICAgICAgICAgLy8gKHNwZWNpYWxseSB0cmlnZ2VyZWQgaW4gdGhlIG11dGF0b3JzIHB1dCgpLCBkZWxldGUoKSBhbmQgZGVsZXRlUmFuZ2UoKSB3aGVuIHRoZXkgZG9uJ3Qga25vdyBvbGRPYmplY3QpXG4gICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkKEZVTExfUkFOR0UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAvLyBvcGVuQ3Vyc29yKCkgb3IgcXVlcnkoKVxuXG4gICAgICAgICAgICAgICAgICAvLyBQcmVwYXJlIGEga2V5c1Byb21pc2UgaW4gY2FzZSB0aGUgd2UncmUgZG9pbmcgYW4gSURCSW5kZXguZ2V0QWxsKCkgb24gYSBzdG9yZSB3aXRoIG91dGJvdW5kIGtleXMuXG4gICAgICAgICAgICAgICAgICBjb25zdCBrZXlzUHJvbWlzZSA9XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCA9PT0gXCJxdWVyeVwiICYmXG4gICAgICAgICAgICAgICAgICAgIG91dGJvdW5kICYmXG4gICAgICAgICAgICAgICAgICAgIChyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFibGUucXVlcnkoe1xuICAgICAgICAgICAgICAgICAgICAgIC4uLihyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKS50aGVuKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJxdWVyeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG91dGJvdW5kICYmIChyZXEgYXMgREJDb3JlUXVlcnlSZXF1ZXN0KS52YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGtleXMgYXJlIG91dGJvdW5kLCB3ZSBjYW4ndCB1c2UgZXh0cmFjdEtleSB0byBtYXAgd2hhdCBrZXlzIHRvIG9ic2VydmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSd2ZSBxdWVyaWVkIGFuIGluZGV4IChsaWtlICdkYXRlVGltZScpIG9uIGFuIG91dGJvdW5kIHRhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0cmlldmUgYSBsaXN0IG9mIG9iamVjdHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGZyb20gd2hvIHdlIGNhbm5vdCBrbm93IHRoZWlyIHByaW1hcnkga2V5cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFwiTHVja2lseVwiIHRob3VnaCwgd2UndmUgcHJlcGFyZWQgdGhlIGtleXNQcm9taXNlIHRvIGFzc2lzdCB1cyBpbiBleGFjdCB0aGlzIGNvbmRpdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZXlzUHJvbWlzZS50aGVuKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAoeyByZXN1bHQ6IHJlc3VsdGluZ0tleXMgfTogREJDb3JlUXVlcnlSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhyZXN1bHRpbmdLZXlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAvLyBxdWVyeSgpIGluYm91bmQgdmFsdWVzLCBrZXlzIG9yIG91dGJvdW5kIGtleXMuIFNlY29uZGFyeSBpbmRleGVzIG9ubHkgc2luY2VcbiAgICAgICAgICAgICAgICAgICAgICAvLyBmb3IgcHJpbWFyeSBrZXlzIHdlIHdvdWxkIG9ubHkgYWRkIHJlc3VsdHMgd2l0aGluIHRoZSBhbHJlYWR5IHJlZ2lzdGVyZWQgcmFuZ2UuXG4gICAgICAgICAgICAgICAgICAgICAgY29uc3QgcEtleXMgPSAocmVxIGFzIERCQ29yZVF1ZXJ5UmVxdWVzdCkudmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IChyZXMgYXMgREJDb3JlUXVlcnlSZXNwb25zZSkucmVzdWx0Lm1hcChleHRyYWN0S2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiAocmVzIGFzIERCQ29yZVF1ZXJ5UmVzcG9uc2UpLnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoKHJlcSBhcyBEQkNvcmVRdWVyeVJlcXVlc3QpLnZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGFueSBtdXRhdGlvbiBtYWRlIG9uIHRoZSByZXR1cm5lZCBrZXlzLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gdGhhdCB3ZSBkZXRlY3QgYm90aCBkZWxldGlvbnMgYW5kIHVwZGF0ZWQgcHJvcGVydGllcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHBrUmFuZ2VTZXQuYWRkS2V5cyhwS2V5cyk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YnNjcmliZSBvbmx5IHRvIG11dGF0aW9ucyBvbiB0aGUgcmV0dXJuZWQga2V5c1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW4gY2FzZSB0aGUgbXV0YXRvciB3YXMgdW5hYmxlIHRvIGtub3cgb2xkT2Jqcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGl0IGhhcyBvbGRPYmosIHRoZSBtdXRhdG9yIHdvbid0IHB1dCBhbnl0aGluZyBpbiBcIjpkZWxzXCIgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgY2FuIG1vcmUgZmluZS1ncmFpbmVkIHB1dCB0aGUgZXhhY3QgcmVtb3ZlZCBhbmQgYWRkZWQgaW5kZXggdmFsdWUgaW4gdGhlIGNvcnJlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IHJhbmdlIHRoYXQgd2Ugc3Vic2NyaWJlIHRvIGluIHRoZSBxdWVyaWVkIHJhbmdlIHNldHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCBsb2FkIHZhbHVlcyBzbyBhIGNoYW5nZSBvbiBhIHByb3BlcnR5IG91dHNpZGUgb3VyIGluZGV4IHdpbGwgbm90XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXF1aXJlIHVzIHRvIHJlLWV4ZWN1dGUgdGhlIHF1ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsc1JhbmdlU2V0LmFkZEtleXMocEtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtZXRob2QgPT09IFwib3BlbkN1cnNvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGVyIHJlcXVlc3RzIGEgY3Vyc29yLlxuICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgc2FtZSByZWFzb24gYXMgd2hlbiBtZXRob2Q9PT1cInF1ZXJ5XCIsIHdlIG9ubHkgbmVlZCB0byBvYnNlcnZlXG4gICAgICAgICAgICAgICAgICAgICAgLy8gdGhvc2Uga2V5cyB3aG9zZSB2YWx1ZXMgYXJlIHBvc3NpYmx5IHVzZWQgb3IgcmVuZGVyZWQgLSB3aGljaCBjb3VsZFxuICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgaGFwcGVuIG9uIGtleXMgd2hlcmUgdGhleSBnZXQgdGhlIGN1cnNvcidzIGtleSwgcHJpbWFyeUtleSBvciB2YWx1ZS5cbiAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3I6IERCQ29yZUN1cnNvciB8IG51bGwgPSByZXM7XG4gICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd2FudFZhbHVlcyA9IChyZXEgYXMgREJDb3JlT3BlbkN1cnNvclJlcXVlc3QpLnZhbHVlcztcbiAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgICAgICAgICAgY3Vyc29yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuY3JlYXRlKGN1cnNvciwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3Iua2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByaW1hcnlLZXk6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2V5ID0gY3Vyc29yLnByaW1hcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxzUmFuZ2VTZXQuYWRkS2V5KHBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YW50VmFsdWVzICYmIHBrUmFuZ2VTZXQuYWRkS2V5KGN1cnNvci5wcmltYXJ5S2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJzb3IudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGFibGVbbWV0aG9kXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGFibGVDbG9uZTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfSxcbn07XG5cbmZ1bmN0aW9uIHRyYWNrQWZmZWN0ZWRJbmRleGVzKFxuICBnZXRSYW5nZVNldDogKGluZGV4OiBzdHJpbmcpID0+IFJhbmdlU2V0LFxuICBzY2hlbWE6IERCQ29yZVRhYmxlU2NoZW1hLFxuICBvbGRPYmpzOiBhbnlbXSB8IHVuZGVmaW5lZCxcbiAgbmV3T2JqczogYW55W10gfCB1bmRlZmluZWRcbikge1xuICBmdW5jdGlvbiBhZGRBZmZlY3RlZEluZGV4KGl4OiBEQkNvcmVJbmRleCkge1xuICAgIGNvbnN0IHJhbmdlU2V0ID0gZ2V0UmFuZ2VTZXQoaXgubmFtZSB8fCBcIlwiKTtcbiAgICBmdW5jdGlvbiBleHRyYWN0S2V5KG9iajogYW55KSB7XG4gICAgICByZXR1cm4gb2JqICE9IG51bGwgPyBpeC5leHRyYWN0S2V5KG9iaikgOiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBhZGRLZXlPcktleXMgPSAoa2V5OiBhbnkpID0+IGl4Lm11bHRpRW50cnkgJiYgaXNBcnJheShrZXkpXG4gICAgICAvLyBtdWx0aUVudHJ5IGFuZCB0aGUgb2xkIHByb3BlcnR5IHdhcyBhbiBhcnJheSAtIGFkZCBlYWNoIGFycmF5IGVudHJ5IHRvIHRoZSByYW5nZVNldDpcbiAgICAgID8ga2V5LmZvckVhY2goa2V5ID0+IHJhbmdlU2V0LmFkZEtleShrZXkpKVxuICAgICAgLy8gTm90IG11bHRpRW50cnkgb3IgdGhlIG9sZCBwcm9wZXJ0eSB3YXMgbm90IGFuIGFycmF5IC0gYWRkIGVhY2ggYXJyYXkgZW50cnkgdG8gdGhlIHJhbmdlU2V0OlxuICAgICAgOiByYW5nZVNldC5hZGRLZXkoa2V5KTtcblxuICAgIChvbGRPYmpzIHx8IG5ld09ianMpLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIGNvbnN0IG9sZEtleSA9IG9sZE9ianMgJiYgZXh0cmFjdEtleShvbGRPYmpzW2ldKTtcbiAgICAgIGNvbnN0IG5ld0tleSA9IG5ld09ianMgJiYgZXh0cmFjdEtleShuZXdPYmpzW2ldKTtcbiAgICAgIGlmIChjbXAob2xkS2V5LCBuZXdLZXkpICE9PSAwKSB7XG4gICAgICAgIC8vIFRoZSBpbmRleCBoYXMgY2hhbmdlZC4gQWRkIGJvdGggb2xkIGFuZCBuZXcgdmFsdWUgb2YgdGhlIGluZGV4LlxuICAgICAgICBpZiAob2xkS2V5ICE9IG51bGwpIGFkZEtleU9yS2V5cyhvbGRLZXkpOyAvLyBJZiBvbGRLZXkgaXMgaW52YWxpZCBrZXksIGFkZEtleSgpIHdpbGwgYmUgYSBub29wLlxuICAgICAgICBpZiAobmV3S2V5ICE9IG51bGwpIGFkZEtleU9yS2V5cyhuZXdLZXkpOyAvLyBJZiBuZXdLZXkgaXMgaW52YWxpZCBrZXksIGFkZEtleSgpIHdpbGwgYmUgYSBub29wLlxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNjaGVtYS5pbmRleGVzLmZvckVhY2goYWRkQWZmZWN0ZWRJbmRleCk7XG59XG4iLCAiLy8gSW1wb3J0IHR5cGVzIGZyb20gdGhlIHB1YmxpYyBBUElcbmltcG9ydCB7IERleGllIGFzIElEZXhpZSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWVcIjtcbmltcG9ydCB7IERleGllT3B0aW9ucywgRGV4aWVDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3JcIjtcbmltcG9ydCB7IERiRXZlbnRzIH0gZnJvbSBcIi4uLy4uL3B1YmxpYy90eXBlcy9kYi1ldmVudHNcIjtcbi8vaW1wb3J0IHsgUHJvbWlzZUV4dGVuZGVkLCBQcm9taXNlRXh0ZW5kZWRDb25zdHJ1Y3RvciB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9wcm9taXNlLWV4dGVuZGVkJztcbmltcG9ydCB7IFRhYmxlIGFzIElUYWJsZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy90YWJsZSc7XG5pbXBvcnQgeyBUYWJsZVNjaGVtYSB9IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvdGFibGUtc2NoZW1hXCI7XG5pbXBvcnQgeyBEYlNjaGVtYSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYi1zY2hlbWEnO1xuXG4vLyBJbnRlcm5hbCBpbXBvcnRzXG5pbXBvcnQgeyBUYWJsZSwgVGFibGVDb25zdHJ1Y3RvciwgY3JlYXRlVGFibGVDb25zdHJ1Y3RvciB9IGZyb20gXCIuLi90YWJsZVwiO1xuaW1wb3J0IHsgQ29sbGVjdGlvbiwgQ29sbGVjdGlvbkNvbnN0cnVjdG9yLCBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi9jb2xsZWN0aW9uJztcbmltcG9ydCB7IFdoZXJlQ2xhdXNlIH0gZnJvbSAnLi4vd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZSc7XG5pbXBvcnQgeyBXaGVyZUNsYXVzZUNvbnN0cnVjdG9yLCBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yIH0gZnJvbSAnLi4vd2hlcmUtY2xhdXNlL3doZXJlLWNsYXVzZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbiB9IGZyb20gJy4uL3RyYW5zYWN0aW9uJztcbmltcG9ydCB7IFRyYW5zYWN0aW9uQ29uc3RydWN0b3IsIGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi90cmFuc2FjdGlvbi90cmFuc2FjdGlvbi1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBWZXJzaW9uIH0gZnJvbSBcIi4uL3ZlcnNpb24vdmVyc2lvblwiO1xuaW1wb3J0IHsgVmVyc2lvbkNvbnN0cnVjdG9yLCBjcmVhdGVWZXJzaW9uQ29uc3RydWN0b3IgfSBmcm9tICcuLi92ZXJzaW9uL3ZlcnNpb24tY29uc3RydWN0b3InO1xuXG4vLyBPdGhlciBpbXBvcnRzLi4uXG5pbXBvcnQgeyBEZXhpZUV2ZW50U2V0IH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RleGllLWV2ZW50LXNldCc7XG5pbXBvcnQgeyBEZXhpZUV4Y2VwdGlvbkNsYXNzZXMgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZXJyb3JzJztcbmltcG9ydCB7IERleGllRE9NRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RleGllLWRvbS1kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgbm9wLCBwcm9taXNhYmxlQ2hhaW4gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvY2hhaW5pbmctZnVuY3Rpb25zJztcbmltcG9ydCBQcm9taXNlLCB7IFBTRCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBleHRlbmQsIG92ZXJyaWRlLCBrZXlzLCBoYXNPd24gfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvdXRpbHMnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuLi8uLi9oZWxwZXJzL0V2ZW50cyc7XG5pbXBvcnQgeyBtYXhTdHJpbmcsIGNvbm5lY3Rpb25zLCBSRUFET05MWSwgUkVBRFdSSVRFIH0gZnJvbSAnLi4vLi4vZ2xvYmFscy9jb25zdGFudHMnO1xuaW1wb3J0IHsgZ2V0TWF4S2V5IH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3F1aXJrcyc7XG5pbXBvcnQgeyBleGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IGxvd2VyVmVyc2lvbkZpcnN0IH0gZnJvbSAnLi4vdmVyc2lvbi9zY2hlbWEtaGVscGVycyc7XG5pbXBvcnQgeyBkZXhpZU9wZW4gfSBmcm9tICcuL2RleGllLW9wZW4nO1xuaW1wb3J0IHsgd3JhcCB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBfb25EYXRhYmFzZURlbGV0ZWQgfSBmcm9tICcuLi8uLi9oZWxwZXJzL2RhdGFiYXNlLWVudW1lcmF0b3InO1xuaW1wb3J0IHsgZXZlbnRSZWplY3RIYW5kbGVyIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2V2ZW50LXdyYXBwZXJzJztcbmltcG9ydCB7IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MsIGVudGVyVHJhbnNhY3Rpb25TY29wZSB9IGZyb20gJy4vdHJhbnNhY3Rpb24taGVscGVycyc7XG5pbXBvcnQgeyBUcmFuc2FjdGlvbk1vZGUgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvdHJhbnNhY3Rpb24tbW9kZSc7XG5pbXBvcnQgeyByZWplY3Rpb24gfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgdXNlUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IERCQ29yZSB9IGZyb20gJy4uLy4uL3B1YmxpYy90eXBlcy9kYmNvcmUnO1xuaW1wb3J0IHsgTWlkZGxld2FyZSwgRGV4aWVTdGFja3MgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvbWlkZGxld2FyZSc7XG5pbXBvcnQgeyB2aXJ0dWFsSW5kZXhNaWRkbGV3YXJlIH0gZnJvbSAnLi4vLi4vZGJjb3JlL3ZpcnR1YWwtaW5kZXgtbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBob29rc01pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9ob29rcy9ob29rcy1taWRkbGV3YXJlJztcbmltcG9ydCB7IEluZGV4YWJsZVR5cGUgfSBmcm9tICcuLi8uLi9wdWJsaWMnO1xuaW1wb3J0IHsgb2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUgfSBmcm9tICcuLi8uLi9saXZlLXF1ZXJ5L29ic2VydmFiaWxpdHktbWlkZGxld2FyZSc7XG5pbXBvcnQgeyBjYWNoZUV4aXN0aW5nVmFsdWVzTWlkZGxld2FyZSB9IGZyb20gJy4uLy4uL2RiY29yZS9jYWNoZS1leGlzdGluZy12YWx1ZXMtbWlkZGxld2FyZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGJSZWFkeVN0YXRlIHtcbiAgZGJPcGVuRXJyb3I6IGFueTtcbiAgaXNCZWluZ09wZW5lZDogYm9vbGVhbjtcbiAgb25SZWFkeUJlaW5nRmlyZWQ6IHVuZGVmaW5lZCB8IEZ1bmN0aW9uW107XG4gIG9wZW5Db21wbGV0ZTogYm9vbGVhbjtcbiAgZGJSZWFkeVJlc29sdmU6ICgpID0+IHZvaWQ7XG4gIGRiUmVhZHlQcm9taXNlOiBQcm9taXNlPGFueT47XG4gIGNhbmNlbE9wZW46IChyZWFzb24/OiBFcnJvcikgPT4gdm9pZDtcbiAgb3BlbkNhbmNlbGxlcjogUHJvbWlzZTxhbnk+ICYgeyBfc3RhY2tIb2xkZXI/OiBFcnJvciB9O1xuICBhdXRvU2NoZW1hOiBib29sZWFuO1xuICB2Y0ZpcmVkPzogYm9vbGVhbjtcbiAgUFIxMzk4X21heExvb3A/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBEZXhpZSBpbXBsZW1lbnRzIElEZXhpZSB7XG4gIF9vcHRpb25zOiBEZXhpZU9wdGlvbnM7XG4gIF9zdGF0ZTogRGJSZWFkeVN0YXRlO1xuICBfdmVyc2lvbnM6IFZlcnNpb25bXTtcbiAgX3N0b3JlTmFtZXM6IHN0cmluZ1tdO1xuICBfZGVwczogRGV4aWVET01EZXBlbmRlbmNpZXM7XG4gIF9hbGxUYWJsZXM6IHsgW25hbWU6IHN0cmluZ106IFRhYmxlOyB9O1xuICBfY3JlYXRlVHJhbnNhY3Rpb246ICh0aGlzOiBEZXhpZSwgbW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLCBzdG9yZU5hbWVzOiBBcnJheUxpa2U8c3RyaW5nPiwgZGJzY2hlbWE6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogVGFibGVTY2hlbWE7IH0sIHBhcmVudFRyYW5zYWN0aW9uPzogVHJhbnNhY3Rpb24pID0+IFRyYW5zYWN0aW9uO1xuICBfZGJTY2hlbWE6IHsgW3RhYmxlTmFtZTogc3RyaW5nXTogVGFibGVTY2hlbWE7IH07XG4gIF9oYXNHZXRBbGw/OiBib29sZWFuO1xuICBfbWF4S2V5OiBJbmRleGFibGVUeXBlO1xuICBfZmlyZU9uQmxvY2tlZDogKGV2OiBFdmVudCkgPT4gdm9pZDtcbiAgX21pZGRsZXdhcmVzOiB7W1N0YWNrTmFtZSBpbiBrZXlvZiBEZXhpZVN0YWNrc10/OiBNaWRkbGV3YXJlPERleGllU3RhY2tzW1N0YWNrTmFtZV0+W119ID0ge307XG4gIF92aXA/OiBib29sZWFuO1xuICBfbm92aXA/OiBEZXhpZTsvLyBkYi5fbm92aXAgaXMgdG8gZXNjYXBlIHRvIG9yaWcgZGIgZnJvbSBkYi52aXAuXG4gIGNvcmU6IERCQ29yZTtcblxuICBuYW1lOiBzdHJpbmc7XG4gIHZlcm5vOiBudW1iZXIgPSAwO1xuICBpZGJkYjogSURCRGF0YWJhc2UgfCBudWxsO1xuICB2aXA6IERleGllO1xuICBvbjogRGJFdmVudHM7XG5cbiAgVGFibGU6IFRhYmxlQ29uc3RydWN0b3I7XG4gIFdoZXJlQ2xhdXNlOiBXaGVyZUNsYXVzZUNvbnN0cnVjdG9yO1xuICBDb2xsZWN0aW9uOiBDb2xsZWN0aW9uQ29uc3RydWN0b3I7XG4gIFZlcnNpb246IFZlcnNpb25Db25zdHJ1Y3RvcjtcbiAgVHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uQ29uc3RydWN0b3I7XG5cbiAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCBvcHRpb25zPzogRGV4aWVPcHRpb25zKSB7XG4gICAgY29uc3QgZGVwcyA9IChEZXhpZSBhcyBhbnkgYXMgRGV4aWVDb25zdHJ1Y3RvcikuZGVwZW5kZW5jaWVzO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zID0ge1xuICAgICAgLy8gRGVmYXVsdCBPcHRpb25zXG4gICAgICBhZGRvbnM6IChEZXhpZSBhcyBhbnkgYXMgRGV4aWVDb25zdHJ1Y3RvcikuYWRkb25zLCAvLyBQaWNrIHN0YXRpY2FsbHkgcmVnaXN0ZXJlZCBhZGRvbnMgYnkgZGVmYXVsdFxuICAgICAgYXV0b09wZW46IHRydWUsICAgICAgICAgICAgICAgICAvLyBEb24ndCByZXF1aXJlIGRiLm9wZW4oKSBleHBsaWNpdGVseS5cbiAgICAgIC8vIERlZmF1bHQgRE9NIGRlcGVuZGVuY3kgaW1wbGVtZW50YXRpb25zIGZyb20gc3RhdGljIHByb3AuXG4gICAgICBpbmRleGVkREI6IGRlcHMuaW5kZXhlZERCLCAgICAgIC8vIEJhY2tlbmQgSW5kZXhlZERCIGFwaS4gRGVmYXVsdCB0byBicm93c2VyIGVudi5cbiAgICAgIElEQktleVJhbmdlOiBkZXBzLklEQktleVJhbmdlLCAgLy8gQmFja2VuZCBJREJLZXlSYW5nZSBhcGkuIERlZmF1bHQgdG8gYnJvd3NlciBlbnYuXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLl9kZXBzID0ge1xuICAgICAgaW5kZXhlZERCOiBvcHRpb25zLmluZGV4ZWREQiBhcyBJREJGYWN0b3J5LFxuICAgICAgSURCS2V5UmFuZ2U6IG9wdGlvbnMuSURCS2V5UmFuZ2UgYXMgdHlwZW9mIElEQktleVJhbmdlXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhZGRvbnMsXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdGhpcy5fZGJTY2hlbWEgPSB7fTtcbiAgICB0aGlzLl92ZXJzaW9ucyA9IFtdO1xuICAgIHRoaXMuX3N0b3JlTmFtZXMgPSBbXTtcbiAgICB0aGlzLl9hbGxUYWJsZXMgPSB7fTtcbiAgICB0aGlzLmlkYmRiID0gbnVsbDtcbiAgICB0aGlzLl9ub3ZpcCA9IHRoaXM7XG4gICAgY29uc3Qgc3RhdGU6IERiUmVhZHlTdGF0ZSA9IHtcbiAgICAgIGRiT3BlbkVycm9yOiBudWxsLFxuICAgICAgaXNCZWluZ09wZW5lZDogZmFsc2UsXG4gICAgICBvblJlYWR5QmVpbmdGaXJlZDogbnVsbCxcbiAgICAgIG9wZW5Db21wbGV0ZTogZmFsc2UsXG4gICAgICBkYlJlYWR5UmVzb2x2ZTogbm9wLFxuICAgICAgZGJSZWFkeVByb21pc2U6IG51bGwgYXMgUHJvbWlzZSxcbiAgICAgIGNhbmNlbE9wZW46IG5vcCxcbiAgICAgIG9wZW5DYW5jZWxsZXI6IG51bGwgYXMgUHJvbWlzZSxcbiAgICAgIGF1dG9TY2hlbWE6IHRydWUsXG4gICAgICBQUjEzOThfbWF4TG9vcDogM1xuICAgIH07XG4gICAgc3RhdGUuZGJSZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHN0YXRlLmRiUmVhZHlSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICB9KTtcbiAgICBzdGF0ZS5vcGVuQ2FuY2VsbGVyID0gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgc3RhdGUuY2FuY2VsT3BlbiA9IHJlamVjdDtcbiAgICB9KTtcbiAgICB0aGlzLl9zdGF0ZSA9IHN0YXRlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5vbiA9IEV2ZW50cyh0aGlzLCBcInBvcHVsYXRlXCIsIFwiYmxvY2tlZFwiLCBcInZlcnNpb25jaGFuZ2VcIiwgXCJjbG9zZVwiLCB7IHJlYWR5OiBbcHJvbWlzYWJsZUNoYWluLCBub3BdIH0pIGFzIERiRXZlbnRzO1xuICAgIHRoaXMub24ucmVhZHkuc3Vic2NyaWJlID0gb3ZlcnJpZGUodGhpcy5vbi5yZWFkeS5zdWJzY3JpYmUsIHN1YnNjcmliZSA9PiB7XG4gICAgICByZXR1cm4gKHN1YnNjcmliZXIsIGJTdGlja3kpID0+IHtcbiAgICAgICAgKERleGllIGFzIGFueSBhcyBEZXhpZUNvbnN0cnVjdG9yKS52aXAoKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgaWYgKHN0YXRlLm9wZW5Db21wbGV0ZSkge1xuICAgICAgICAgICAgLy8gRGF0YWJhc2UgYWxyZWFkeSBvcGVuLiBDYWxsIHN1YnNjcmliZXIgYXNhcC5cbiAgICAgICAgICAgIGlmICghc3RhdGUuZGJPcGVuRXJyb3IpIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oc3Vic2NyaWJlcik7XG4gICAgICAgICAgICAvLyBiU3RpY2t5OiBBbHNvIHN1YnNjcmliZSB0byBmdXR1cmUgb3BlbiBzdWNlc3NlcyAoYWZ0ZXIgY2xvc2UgLyByZW9wZW4pIFxuICAgICAgICAgICAgaWYgKGJTdGlja3kpIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkKSB7XG4gICAgICAgICAgICAvLyBkYi5vbigncmVhZHknKSBzdWJzY3JpYmVycyBhcmUgY3VycmVudGx5IGJlaW5nIGV4ZWN1dGVkIGFuZCBoYXZlIG5vdCB5ZXQgcmVzb2x2ZWQgb3IgcmVqZWN0ZWRcbiAgICAgICAgICAgIHN0YXRlLm9uUmVhZHlCZWluZ0ZpcmVkLnB1c2goc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBpZiAoYlN0aWNreSkgc3Vic2NyaWJlKHN1YnNjcmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEYXRhYmFzZSBub3QgeWV0IG9wZW4uIFN1YnNjcmliZSB0byBpdC5cbiAgICAgICAgICAgIHN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgIC8vIElmIGJTdGlja3kgaXMgZmFsc3ksIG1ha2Ugc3VyZSB0byB1bnN1YnNjcmliZSBzdWJzY3JpYmVyIHdoZW4gZmlyZWQgb25jZS5cbiAgICAgICAgICAgIGNvbnN0IGRiID0gdGhpcztcbiAgICAgICAgICAgIGlmICghYlN0aWNreSkgc3Vic2NyaWJlKGZ1bmN0aW9uIHVuc3Vic2NyaWJlKCkge1xuICAgICAgICAgICAgICBkYi5vbi5yZWFkeS51bnN1YnNjcmliZShzdWJzY3JpYmVyKTtcbiAgICAgICAgICAgICAgZGIub24ucmVhZHkudW5zdWJzY3JpYmUodW5zdWJzY3JpYmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIENyZWF0ZSBkZXJpdmVkIGNsYXNzZXMgYm91bmQgdG8gdGhpcyBpbnN0YW5jZSBvZiBEZXhpZTpcbiAgICB0aGlzLkNvbGxlY3Rpb24gPSBjcmVhdGVDb2xsZWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5UYWJsZSA9IGNyZWF0ZVRhYmxlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5UcmFuc2FjdGlvbiA9IGNyZWF0ZVRyYW5zYWN0aW9uQ29uc3RydWN0b3IodGhpcyk7XG4gICAgdGhpcy5WZXJzaW9uID0gY3JlYXRlVmVyc2lvbkNvbnN0cnVjdG9yKHRoaXMpO1xuICAgIHRoaXMuV2hlcmVDbGF1c2UgPSBjcmVhdGVXaGVyZUNsYXVzZUNvbnN0cnVjdG9yKHRoaXMpO1xuXG4gICAgLy8gRGVmYXVsdCBzdWJzY3JpYmVycyB0byBcInZlcnNpb25jaGFuZ2VcIiBhbmQgXCJibG9ja2VkXCIuXG4gICAgLy8gQ2FuIGJlIG92ZXJyaWRkZW4gYnkgY3VzdG9tIGhhbmRsZXJzLiBJZiBjdXN0b20gaGFuZGxlcnMgcmV0dXJuIGZhbHNlLCB0aGVzZSBkZWZhdWx0XG4gICAgLy8gYmVoYXZpb3VycyB3aWxsIGJlIHByZXZlbnRlZC5cbiAgICB0aGlzLm9uKFwidmVyc2lvbmNoYW5nZVwiLCBldiA9PiB7XG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIGZvciB2ZXJzaW9uY2hhbmdlIGV2ZW50IGlzIHRvIGNsb3NlIGRhdGFiYXNlIGNvbm5lY3Rpb24uXG4gICAgICAvLyBDYWxsZXIgY2FuIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IgYnkgZG9pbmcgZGIub24oXCJ2ZXJzaW9uY2hhbmdlXCIsIGZ1bmN0aW9uKCl7IHJldHVybiBmYWxzZTsgfSk7XG4gICAgICAvLyBMZXQncyBub3QgYmxvY2sgdGhlIG90aGVyIHdpbmRvdyBmcm9tIG1ha2luZyBpdCdzIGRlbGV0ZSgpIG9yIG9wZW4oKSBjYWxsLlxuICAgICAgLy8gTk9URSEgVGhpcyBldmVudCBpcyBuZXZlciBmaXJlZCBpbiBJRSxFZGdlIG9yIFNhZmFyaS5cbiAgICAgIGlmIChldi5uZXdWZXJzaW9uID4gMClcbiAgICAgICAgY29uc29sZS53YXJuKGBBbm90aGVyIGNvbm5lY3Rpb24gd2FudHMgdG8gdXBncmFkZSBkYXRhYmFzZSAnJHt0aGlzLm5hbWV9Jy4gQ2xvc2luZyBkYiBub3cgdG8gcmVzdW1lIHRoZSB1cGdyYWRlLmApO1xuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLndhcm4oYEFub3RoZXIgY29ubmVjdGlvbiB3YW50cyB0byBkZWxldGUgZGF0YWJhc2UgJyR7dGhpcy5uYW1lfScuIENsb3NpbmcgZGIgbm93IHRvIHJlc3VtZSB0aGUgZGVsZXRlIHJlcXVlc3QuYCk7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAvLyBJbiBtYW55IHdlYiBhcHBsaWNhdGlvbnMsIGl0IHdvdWxkIGJlIHJlY29tbWVuZGVkIHRvIGZvcmNlIHdpbmRvdy5yZWxvYWQoKVxuICAgICAgLy8gd2hlbiB0aGlzIGV2ZW50IG9jY3Vycy4gVG8gZG8gdGhhdCwgc3Vic2NyaWJlIHRvIHRoZSB2ZXJzaW9uY2hhbmdlIGV2ZW50XG4gICAgICAvLyBhbmQgY2FsbCB3aW5kb3cubG9jYXRpb24ucmVsb2FkKHRydWUpIGlmIGV2Lm5ld1ZlcnNpb24gPiAwIChub3QgYSBkZWxldGlvbilcbiAgICAgIC8vIFRoZSByZWFzb24gZm9yIHRoaXMgaXMgdGhhdCB5b3VyIGN1cnJlbnQgd2ViIGFwcCBvYnZpb3VzbHkgaGFzIG9sZCBzY2hlbWEgY29kZSB0aGF0IG5lZWRzXG4gICAgICAvLyB0byBiZSB1cGRhdGVkLiBBbm90aGVyIHdpbmRvdyBnb3QgYSBuZXdlciB2ZXJzaW9uIG9mIHRoZSBhcHAgYW5kIG5lZWRzIHRvIHVwZ3JhZGUgREIgYnV0XG4gICAgICAvLyB5b3VyIHdpbmRvdyBpcyBibG9ja2luZyBpdCB1bmxlc3Mgd2UgY2xvc2UgaXQgaGVyZS5cbiAgICB9KTtcbiAgICB0aGlzLm9uKFwiYmxvY2tlZFwiLCBldiA9PiB7XG4gICAgICBpZiAoIWV2Lm5ld1ZlcnNpb24gfHwgZXYubmV3VmVyc2lvbiA8IGV2Lm9sZFZlcnNpb24pXG4gICAgICAgIGNvbnNvbGUud2FybihgRGV4aWUuZGVsZXRlKCcke3RoaXMubmFtZX0nKSB3YXMgYmxvY2tlZGApO1xuICAgICAgZWxzZVxuICAgICAgICBjb25zb2xlLndhcm4oYFVwZ3JhZGUgJyR7dGhpcy5uYW1lfScgYmxvY2tlZCBieSBvdGhlciBjb25uZWN0aW9uIGhvbGRpbmcgdmVyc2lvbiAke2V2Lm9sZFZlcnNpb24gLyAxMH1gKTtcbiAgICB9KTtcblxuICAgIHRoaXMuX21heEtleSA9IGdldE1heEtleShvcHRpb25zLklEQktleVJhbmdlIGFzIHR5cGVvZiBJREJLZXlSYW5nZSk7XG5cbiAgICB0aGlzLl9jcmVhdGVUcmFuc2FjdGlvbiA9IChcbiAgICAgIG1vZGU6IElEQlRyYW5zYWN0aW9uTW9kZSxcbiAgICAgIHN0b3JlTmFtZXM6IHN0cmluZ1tdLFxuICAgICAgZGJzY2hlbWE6IERiU2NoZW1hLFxuICAgICAgcGFyZW50VHJhbnNhY3Rpb24/OiBUcmFuc2FjdGlvbikgPT4gbmV3IHRoaXMuVHJhbnNhY3Rpb24obW9kZSwgc3RvcmVOYW1lcywgZGJzY2hlbWEsIHRoaXMuX29wdGlvbnMuY2hyb21lVHJhbnNhY3Rpb25EdXJhYmlsaXR5LCBwYXJlbnRUcmFuc2FjdGlvbik7XG5cbiAgICB0aGlzLl9maXJlT25CbG9ja2VkID0gZXYgPT4ge1xuICAgICAgdGhpcy5vbihcImJsb2NrZWRcIikuZmlyZShldik7XG4gICAgICAvLyBXb3JrYXJvdW5kIChub3QgZnVsbHkqKSBmb3IgbWlzc2luZyBcInZlcnNpb25jaGFuZ2VcIiBldmVudCBpbiBJRSxFZGdlIGFuZCBTYWZhcmk6XG4gICAgICBjb25uZWN0aW9uc1xuICAgICAgICAuZmlsdGVyKGMgPT4gYy5uYW1lID09PSB0aGlzLm5hbWUgJiYgYyAhPT0gdGhpcyAmJiAhYy5fc3RhdGUudmNGaXJlZClcbiAgICAgICAgLm1hcChjID0+IGMub24oXCJ2ZXJzaW9uY2hhbmdlXCIpLmZpcmUoZXYpKTtcbiAgICB9XG5cbiAgICAvLyBEZWZhdWx0IG1pZGRsZXdhcmVzOlxuICAgIHRoaXMudXNlKHZpcnR1YWxJbmRleE1pZGRsZXdhcmUpO1xuICAgIHRoaXMudXNlKGhvb2tzTWlkZGxld2FyZSk7XG4gICAgdGhpcy51c2Uob2JzZXJ2YWJpbGl0eU1pZGRsZXdhcmUpO1xuICAgIHRoaXMudXNlKGNhY2hlRXhpc3RpbmdWYWx1ZXNNaWRkbGV3YXJlKTtcblxuICAgIHRoaXMudmlwID0gT2JqZWN0LmNyZWF0ZSh0aGlzLCB7X3ZpcDoge3ZhbHVlOiB0cnVlfX0pIGFzIERleGllO1xuXG4gICAgLy8gQ2FsbCBlYWNoIGFkZG9uOlxuICAgIGFkZG9ucy5mb3JFYWNoKGFkZG9uID0+IGFkZG9uKHRoaXMpKTtcbiAgfVxuXG4gIHZlcnNpb24odmVyc2lvbk51bWJlcjogbnVtYmVyKTogVmVyc2lvbiB7XG4gICAgaWYgKGlzTmFOKHZlcnNpb25OdW1iZXIpIHx8IHZlcnNpb25OdW1iZXIgPCAwLjEpIHRocm93IG5ldyBleGNlcHRpb25zLlR5cGUoYEdpdmVuIHZlcnNpb24gaXMgbm90IGEgcG9zaXRpdmUgbnVtYmVyYCk7XG4gICAgdmVyc2lvbk51bWJlciA9IE1hdGgucm91bmQodmVyc2lvbk51bWJlciAqIDEwKSAvIDEwO1xuICAgIGlmICh0aGlzLmlkYmRiIHx8IHRoaXMuX3N0YXRlLmlzQmVpbmdPcGVuZWQpXG4gICAgICB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TY2hlbWEoXCJDYW5ub3QgYWRkIHZlcnNpb24gd2hlbiBkYXRhYmFzZSBpcyBvcGVuXCIpO1xuICAgIHRoaXMudmVybm8gPSBNYXRoLm1heCh0aGlzLnZlcm5vLCB2ZXJzaW9uTnVtYmVyKTtcbiAgICBjb25zdCB2ZXJzaW9ucyA9IHRoaXMuX3ZlcnNpb25zO1xuICAgIHZhciB2ZXJzaW9uSW5zdGFuY2UgPSB2ZXJzaW9ucy5maWx0ZXIoXG4gICAgICB2ID0+IHYuX2NmZy52ZXJzaW9uID09PSB2ZXJzaW9uTnVtYmVyKVswXTtcbiAgICBpZiAodmVyc2lvbkluc3RhbmNlKSByZXR1cm4gdmVyc2lvbkluc3RhbmNlO1xuICAgIHZlcnNpb25JbnN0YW5jZSA9IG5ldyB0aGlzLlZlcnNpb24odmVyc2lvbk51bWJlcik7XG4gICAgdmVyc2lvbnMucHVzaCh2ZXJzaW9uSW5zdGFuY2UpO1xuICAgIHZlcnNpb25zLnNvcnQobG93ZXJWZXJzaW9uRmlyc3QpO1xuICAgIHZlcnNpb25JbnN0YW5jZS5zdG9yZXMoe30pOyAvLyBEZXJpdmUgZWFybGllciBzY2hlbWFzIGJ5IGRlZmF1bHQuXG4gICAgLy8gRGlzYWJsZSBhdXRvc2NoZW1hIG1vZGUsIGFzIGF0IGxlYXN0IG9uZSB2ZXJzaW9uIGlzIHNwZWNpZmllZC5cbiAgICB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hID0gZmFsc2U7XG4gICAgcmV0dXJuIHZlcnNpb25JbnN0YW5jZTtcbiAgfVxuXG4gIF93aGVuUmVhZHk8VD4oZm46ICgpID0+IFByb21pc2U8VD4pOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gKHRoaXMuaWRiZGIgJiYgKHRoaXMuX3N0YXRlLm9wZW5Db21wbGV0ZSB8fCBQU0QubGV0VGhyb3VnaCB8fCB0aGlzLl92aXApKSA/IGZuKCkgOiBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5fc3RhdGUub3BlbkNvbXBsZXRlKSB7XG4gICAgICAgIC8vIGlkYmRiIGlzIGZhbHN5IGJ1dCBvcGVuQ29tcGxldGUgaXMgdHJ1ZS4gTXVzdCBoYXZlIGJlZW4gYW4gZXhjZXB0aW9uIGR1cmluIG9wZW4uXG4gICAgICAgIC8vIERvbid0IHdhaXQgZm9yIG9wZW5Db21wbGV0ZSBhcyBpdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIGxvb3AuXG4gICAgICAgIHJldHVybiByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQodGhpcy5fc3RhdGUuZGJPcGVuRXJyb3IpKTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fc3RhdGUuaXNCZWluZ09wZW5lZCkge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuYXV0b09wZW4pIHtcbiAgICAgICAgICByZWplY3QobmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlbigpLmNhdGNoKG5vcCk7IC8vIE9wZW4gaW4gYmFja2dyb3VuZC4gSWYgaWYgZmFpbHMsIGl0IHdpbGwgYmUgY2F0Y2hlZCBieSB0aGUgZmluYWwgcHJvbWlzZSBhbnl3YXkuXG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0ZS5kYlJlYWR5UHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSkudGhlbihmbik7XG4gIH1cblxuICB1c2Uoe3N0YWNrLCBjcmVhdGUsIGxldmVsLCBuYW1lfTogTWlkZGxld2FyZTxEQkNvcmU+KTogdGhpcyB7XG4gICAgaWYgKG5hbWUpIHRoaXMudW51c2Uoe3N0YWNrLCBuYW1lfSk7IC8vIEJlIGFibGUgdG8gcmVwbGFjZSBleGlzdGluZyBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IG1pZGRsZXdhcmVzID0gdGhpcy5fbWlkZGxld2FyZXNbc3RhY2tdIHx8ICh0aGlzLl9taWRkbGV3YXJlc1tzdGFja10gPSBbXSk7XG4gICAgbWlkZGxld2FyZXMucHVzaCh7c3RhY2ssIGNyZWF0ZSwgbGV2ZWw6IGxldmVsID09IG51bGwgPyAxMCA6IGxldmVsLCBuYW1lfSk7XG4gICAgbWlkZGxld2FyZXMuc29ydCgoYSwgYikgPT4gYS5sZXZlbCAtIGIubGV2ZWwpO1xuICAgIC8vIFRvZG8gdXBkYXRlIGRiLmNvcmUgYW5kIGRiLnRhYmxlcy4uLmNvcmUgPyBPciBzaG91bGQgYmUgZXhwZWN0IHRoaXMgdG8gaGF2ZSBlZmZlY3RcbiAgICAvLyBvbmx5IGFmdGVyIG5leHQgb3BlbigpP1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdW51c2Uoe3N0YWNrLCBjcmVhdGV9OiBNaWRkbGV3YXJlPHtzdGFjazoga2V5b2YgRGV4aWVTdGFja3N9Pik6IHRoaXM7XG4gIHVudXNlKHtzdGFjaywgbmFtZX06IHtzdGFjazoga2V5b2YgRGV4aWVTdGFja3MsIG5hbWU6IHN0cmluZ30pOiB0aGlzO1xuICB1bnVzZSh7c3RhY2ssIG5hbWUsIGNyZWF0ZX06IHtzdGFjazoga2V5b2YgRGV4aWVTdGFja3MsIG5hbWU/OiBzdHJpbmcsIGNyZWF0ZT86IEZ1bmN0aW9ufSkge1xuICAgIGlmIChzdGFjayAmJiB0aGlzLl9taWRkbGV3YXJlc1tzdGFja10pIHtcbiAgICAgIHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXSA9IHRoaXMuX21pZGRsZXdhcmVzW3N0YWNrXS5maWx0ZXIobXcgPT5cbiAgICAgICAgY3JlYXRlID8gbXcuY3JlYXRlICE9PSBjcmVhdGUgOiAvLyBHaXZlbiBtaWRkbGV3YXJlIGhhcyBhIGNyZWF0ZSBtZXRob2QuIE1hdGNoIHRoYXQgZXhhY3RseS5cbiAgICAgICAgbmFtZSA/IG13Lm5hbWUgIT09IG5hbWUgOiAvLyBHaXZlbiBtaWRkbGV3YXJlIHNwZWMgXG4gICAgICAgIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHJldHVybiBkZXhpZU9wZW4odGhpcyk7XG4gIH1cblxuICBfY2xvc2UoKTogdm9pZCB7XG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICBjb25zdCBpZHggPSBjb25uZWN0aW9ucy5pbmRleE9mKHRoaXMpO1xuICAgIGlmIChpZHggPj0gMCkgY29ubmVjdGlvbnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgaWYgKHRoaXMuaWRiZGIpIHtcbiAgICAgIHRyeSB7IHRoaXMuaWRiZGIuY2xvc2UoKTsgfSBjYXRjaCAoZSkgeyB9XG4gICAgICB0aGlzLl9ub3ZpcC5pZGJkYiA9IG51bGw7IC8vIGRiLl9ub3ZpcCBpcyBiZWNhdXNlIGRiIGNhbiBiZSBhbiBPYmplY3QuY3JlYXRlKG9yaWdEYikuXG4gICAgfSAgICBcbiAgICAvLyBSZXNldCBkYlJlYWR5UHJvbWlzZSBwcm9taXNlOlxuICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBzdGF0ZS5kYlJlYWR5UmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSk7XG4gICAgc3RhdGUub3BlbkNhbmNlbGxlciA9IG5ldyBQcm9taXNlKChfLCByZWplY3QpID0+IHtcbiAgICAgIHN0YXRlLmNhbmNlbE9wZW4gPSByZWplY3Q7XG4gICAgfSk7XG4gIH1cblxuICBjbG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLl9jbG9zZSgpO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgdGhpcy5fb3B0aW9ucy5hdXRvT3BlbiA9IGZhbHNlO1xuICAgIHN0YXRlLmRiT3BlbkVycm9yID0gbmV3IGV4Y2VwdGlvbnMuRGF0YWJhc2VDbG9zZWQoKTtcbiAgICBpZiAoc3RhdGUuaXNCZWluZ09wZW5lZClcbiAgICAgIHN0YXRlLmNhbmNlbE9wZW4oc3RhdGUuZGJPcGVuRXJyb3IpO1xuICB9XG5cbiAgZGVsZXRlKCk6IFByb21pc2U8dm9pZD4ge1xuICAgIGNvbnN0IGhhc0FyZ3VtZW50cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwO1xuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNvbnN0IGRvRGVsZXRlID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgIHZhciByZXEgPSB0aGlzLl9kZXBzLmluZGV4ZWREQi5kZWxldGVEYXRhYmFzZSh0aGlzLm5hbWUpO1xuICAgICAgICByZXEub25zdWNjZXNzID0gd3JhcCgoKSA9PiB7XG4gICAgICAgICAgX29uRGF0YWJhc2VEZWxldGVkKHRoaXMuX2RlcHMsIHRoaXMubmFtZSk7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSBldmVudFJlamVjdEhhbmRsZXIocmVqZWN0KTtcbiAgICAgICAgcmVxLm9uYmxvY2tlZCA9IHRoaXMuX2ZpcmVPbkJsb2NrZWQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChoYXNBcmd1bWVudHMpIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkFyZ3VtZW50cyBub3QgYWxsb3dlZCBpbiBkYi5kZWxldGUoKVwiKTtcbiAgICAgIGlmIChzdGF0ZS5pc0JlaW5nT3BlbmVkKSB7XG4gICAgICAgIHN0YXRlLmRiUmVhZHlQcm9taXNlLnRoZW4oZG9EZWxldGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZG9EZWxldGUoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGJhY2tlbmREQigpIHtcbiAgICByZXR1cm4gdGhpcy5pZGJkYjtcbiAgfVxuXG4gIGlzT3BlbigpIHtcbiAgICByZXR1cm4gdGhpcy5pZGJkYiAhPT0gbnVsbDtcbiAgfVxuXG4gIGhhc0JlZW5DbG9zZWQoKSB7XG4gICAgY29uc3QgZGJPcGVuRXJyb3IgPSB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvcjtcbiAgICByZXR1cm4gZGJPcGVuRXJyb3IgJiYgKGRiT3BlbkVycm9yLm5hbWUgPT09ICdEYXRhYmFzZUNsb3NlZCcpO1xuICB9XG5cbiAgaGFzRmFpbGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5kYk9wZW5FcnJvciAhPT0gbnVsbDtcbiAgfVxuXG4gIGR5bmFtaWNhbGx5T3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZS5hdXRvU2NoZW1hO1xuICB9XG5cbiAgZ2V0IHRhYmxlcyAoKSB7XG4gICAgcmV0dXJuIGtleXModGhpcy5fYWxsVGFibGVzKS5tYXAobmFtZSA9PiB0aGlzLl9hbGxUYWJsZXNbbmFtZV0pO1xuICB9XG5cbiAgdHJhbnNhY3Rpb24oKTogUHJvbWlzZSB7XG4gICAgY29uc3QgYXJncyA9IGV4dHJhY3RUcmFuc2FjdGlvbkFyZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICBfdHJhbnNhY3Rpb24obW9kZTogVHJhbnNhY3Rpb25Nb2RlLCB0YWJsZXM6IEFycmF5PElUYWJsZSB8IHN0cmluZz4sIHNjb3BlRnVuYzogRnVuY3Rpb24pIHtcbiAgICBsZXQgcGFyZW50VHJhbnNhY3Rpb24gPSBQU0QudHJhbnMgYXMgVHJhbnNhY3Rpb24gfCB1bmRlZmluZWQ7XG4gICAgLy8gQ2hlY2sgaWYgcGFyZW50IHRyYW5zYWN0aW9ucyBpcyBib3VuZCB0byB0aGlzIGRiIGluc3RhbmNlLCBhbmQgaWYgY2FsbGVyIHdhbnRzIHRvIHJldXNlIGl0XG4gICAgaWYgKCFwYXJlbnRUcmFuc2FjdGlvbiB8fCBwYXJlbnRUcmFuc2FjdGlvbi5kYiAhPT0gdGhpcyB8fCBtb2RlLmluZGV4T2YoJyEnKSAhPT0gLTEpIHBhcmVudFRyYW5zYWN0aW9uID0gbnVsbDtcbiAgICBjb25zdCBvbmx5SWZDb21wYXRpYmxlID0gbW9kZS5pbmRleE9mKCc/JykgIT09IC0xO1xuICAgIG1vZGUgPSBtb2RlLnJlcGxhY2UoJyEnLCAnJykucmVwbGFjZSgnPycsICcnKSBhcyBUcmFuc2FjdGlvbk1vZGU7IC8vIE9rLiBXaWxsIGNoYW5nZSBhcmd1bWVudHNbMF0gYXMgd2VsbCBidXQgd2Ugd29udCB0b3VjaCBhcmd1bWVudHMgaGVuY2Vmb3J0aC5cbiAgICBsZXQgaWRiTW9kZTogSURCVHJhbnNhY3Rpb25Nb2RlLFxuICAgICAgICBzdG9yZU5hbWVzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0IHN0b3JlTmFtZXMgZnJvbSBhcmd1bWVudHMuIEVpdGhlciB0aHJvdWdoIGdpdmVuIHRhYmxlIGluc3RhbmNlcywgb3IgdGhyb3VnaCBnaXZlbiB0YWJsZSBuYW1lcy5cbiAgICAgICAgLy9cbiAgICAgICAgc3RvcmVOYW1lcyA9IHRhYmxlcy5tYXAodGFibGUgPT4ge1xuICAgICAgICAgICAgdmFyIHN0b3JlTmFtZSA9IHRhYmxlIGluc3RhbmNlb2YgdGhpcy5UYWJsZSA/IHRhYmxlLm5hbWUgOiB0YWJsZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVOYW1lICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgdGFibGUgYXJndW1lbnQgdG8gRGV4aWUudHJhbnNhY3Rpb24oKS4gT25seSBUYWJsZSBvciBTdHJpbmcgYXJlIGFsbG93ZWRcIik7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmVOYW1lO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBSZXNvbHZlIG1vZGUuIEFsbG93IHNob3J0Y3V0cyBcInJcIiBhbmQgXCJyd1wiLlxuICAgICAgICAvL1xuICAgICAgICBpZiAobW9kZSA9PSBcInJcIiB8fCBtb2RlID09PSBSRUFET05MWSlcbiAgICAgICAgICBpZGJNb2RlID0gUkVBRE9OTFk7XG4gICAgICAgIGVsc2UgaWYgKG1vZGUgPT0gXCJyd1wiIHx8IG1vZGUgPT0gUkVBRFdSSVRFKVxuICAgICAgICAgIGlkYk1vZGUgPSBSRUFEV1JJVEU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRocm93IG5ldyBleGNlcHRpb25zLkludmFsaWRBcmd1bWVudChcIkludmFsaWQgdHJhbnNhY3Rpb24gbW9kZTogXCIgKyBtb2RlKTtcblxuICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIC8vIEJhc2ljIGNoZWNrc1xuICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uLm1vZGUgPT09IFJFQURPTkxZICYmIGlkYk1vZGUgPT09IFJFQURXUklURSkge1xuICAgICAgICAgICAgICAgIGlmIChvbmx5SWZDb21wYXRpYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNwYXduIG5ldyB0cmFuc2FjdGlvbiBpbnN0ZWFkLlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7IFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHRocm93IG5ldyBleGNlcHRpb25zLlN1YlRyYW5zYWN0aW9uKFwiQ2Fubm90IGVudGVyIGEgc3ViLXRyYW5zYWN0aW9uIHdpdGggUkVBRFdSSVRFIG1vZGUgd2hlbiBwYXJlbnQgdHJhbnNhY3Rpb24gaXMgUkVBRE9OTFlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyZW50VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBzdG9yZU5hbWVzLmZvckVhY2goc3RvcmVOYW1lID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFRyYW5zYWN0aW9uICYmIHBhcmVudFRyYW5zYWN0aW9uLnN0b3JlTmFtZXMuaW5kZXhPZihzdG9yZU5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBTcGF3biBuZXcgdHJhbnNhY3Rpb24gaW5zdGVhZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7IFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB0aHJvdyBuZXcgZXhjZXB0aW9ucy5TdWJUcmFuc2FjdGlvbihcIlRhYmxlIFwiICsgc3RvcmVOYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBub3QgaW5jbHVkZWQgaW4gcGFyZW50IHRyYW5zYWN0aW9uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9ubHlJZkNvbXBhdGlibGUgJiYgcGFyZW50VHJhbnNhY3Rpb24gJiYgIXBhcmVudFRyYW5zYWN0aW9uLmFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIC8vICc/JyBtb2RlIHNob3VsZCBub3Qga2VlcCB1c2luZyBhbiBpbmFjdGl2ZSB0cmFuc2FjdGlvbi5cbiAgICAgICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgICAgICBwYXJlbnRUcmFuc2FjdGlvbi5fcHJvbWlzZShudWxsLCAoXywgcmVqZWN0KSA9PiB7cmVqZWN0KGUpO30pIDpcbiAgICAgICAgICAgIHJlamVjdGlvbiAoZSk7XG4gICAgfVxuICAgIC8vIElmIHRoaXMgaXMgYSBzdWItdHJhbnNhY3Rpb24sIGxvY2sgdGhlIHBhcmVudCBhbmQgdGhlbiBsYXVuY2ggdGhlIHN1Yi10cmFuc2FjdGlvbi5cbiAgICBjb25zdCBlbnRlclRyYW5zYWN0aW9uID0gZW50ZXJUcmFuc2FjdGlvblNjb3BlLmJpbmQobnVsbCwgdGhpcywgaWRiTW9kZSwgc3RvcmVOYW1lcywgcGFyZW50VHJhbnNhY3Rpb24sIHNjb3BlRnVuYyk7XG4gICAgcmV0dXJuIChwYXJlbnRUcmFuc2FjdGlvbiA/XG4gICAgICAgIHBhcmVudFRyYW5zYWN0aW9uLl9wcm9taXNlKGlkYk1vZGUsIGVudGVyVHJhbnNhY3Rpb24sIFwibG9ja1wiKSA6XG4gICAgICAgIFBTRC50cmFucyA/XG4gICAgICAgICAgICAvLyBubyBwYXJlbnQgdHJhbnNhY3Rpb24gZGVzcGl0ZSBQU0QudHJhbnMgZXhpc3RzLiBNYWtlIHN1cmUgYWxzb1xuICAgICAgICAgICAgLy8gdGhhdCB0aGUgem9uZSB3ZSBjcmVhdGUgaXMgbm90IGEgc3ViLXpvbmUgb2YgY3VycmVudCwgYmVjYXVzZVxuICAgICAgICAgICAgLy8gUHJvbWlzZS5mb2xsb3coKSBzaG91bGQgbm90IHdhaXQgZm9yIGl0IGlmIHNvLlxuICAgICAgICAgICAgdXNlUFNEKFBTRC50cmFuc2xlc3MsICgpPT50aGlzLl93aGVuUmVhZHkoZW50ZXJUcmFuc2FjdGlvbikpIDpcbiAgICAgICAgICAgIHRoaXMuX3doZW5SZWFkeSAoZW50ZXJUcmFuc2FjdGlvbikpO1xuICB9XG5cbiAgdGFibGUodGFibGVOYW1lOiBzdHJpbmcpOiBUYWJsZTtcbiAgdGFibGU8VCwgVEtleSBleHRlbmRzIEluZGV4YWJsZVR5cGU9SW5kZXhhYmxlVHlwZT4odGFibGVOYW1lOiBzdHJpbmcpOiBJVGFibGU8VCwgVEtleT47XG4gIHRhYmxlKHRhYmxlTmFtZTogc3RyaW5nKTogVGFibGUge1xuICAgIGlmICghaGFzT3duKHRoaXMuX2FsbFRhYmxlcywgdGFibGVOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IGV4Y2VwdGlvbnMuSW52YWxpZFRhYmxlKGBUYWJsZSAke3RhYmxlTmFtZX0gZG9lcyBub3QgZXhpc3RgKTsgfVxuICAgIHJldHVybiB0aGlzLl9hbGxUYWJsZXNbdGFibGVOYW1lXTtcbiAgfVxufVxuIiwgImltcG9ydCB7XG4gIE9ic2VydmFibGUgYXMgSU9ic2VydmFibGUsXG4gIE9ic2VydmVyLFxuICBTdWJzY3JpcHRpb24sXG59IGZyb20gXCIuLi8uLi9wdWJsaWMvdHlwZXMvb2JzZXJ2YWJsZVwiO1xuXG5jb25zdCBzeW1ib2xPYnNlcnZhYmxlOiB0eXBlb2YgU3ltYm9sLm9ic2VydmFibGUgPVxuICB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIFwib2JzZXJ2YWJsZVwiIGluIFN5bWJvbFxuICAgID8gU3ltYm9sLm9ic2VydmFibGVcbiAgICA6IFwiQEBvYnNlcnZhYmxlXCIgYXMgYW55O1xuXG5leHBvcnQgY2xhc3MgT2JzZXJ2YWJsZTxUPiBpbXBsZW1lbnRzIElPYnNlcnZhYmxlPFQ+IHtcbiAgcHJpdmF0ZSBfc3Vic2NyaWJlOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiBTdWJzY3JpcHRpb247XG4gIGhhc1ZhbHVlPzogKCk9PmJvb2xlYW47XG4gIGdldFZhbHVlPzogKCk9PlQ7XG5cbiAgY29uc3RydWN0b3Ioc3Vic2NyaWJlOiAob2JzZXJ2ZXI6IE9ic2VydmVyPFQ+KSA9PiBTdWJzY3JpcHRpb24pIHtcbiAgICB0aGlzLl9zdWJzY3JpYmUgPSBzdWJzY3JpYmU7XG4gIH1cblxuICBzdWJzY3JpYmUoXG4gICAgb25OZXh0PzogKCh2YWx1ZTogVCkgPT4gdm9pZCkgfMKgbnVsbCxcbiAgICBvbkVycm9yPzogKChlcnJvcjogYW55KSA9PiB2b2lkKSB8IG51bGwsXG4gICAgb25Db21wbGV0ZT86ICgoKSA9PiB2b2lkKSB8IG51bGxcbiAgKTogU3Vic2NyaXB0aW9uO1xuICBzdWJzY3JpYmUob2JzZXJ2ZXI/OiBPYnNlcnZlcjxUPiB8IG51bGwpOiBTdWJzY3JpcHRpb247XG4gIHN1YnNjcmliZSh4PzogYW55LCBlcnJvcj86IGFueSwgY29tcGxldGU/OiBhbnkpOiBTdWJzY3JpcHRpb24ge1xuICAgIHJldHVybiB0aGlzLl9zdWJzY3JpYmUoXG4gICAgICAheCB8fCB0eXBlb2YgeCA9PT0gXCJmdW5jdGlvblwiID8geyBuZXh0OiB4LCBlcnJvciwgY29tcGxldGUgfSA6IHhcbiAgICApO1xuICB9XG5cbiAgW3N5bWJvbE9ic2VydmFibGVdKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59XG4iLCAiaW1wb3J0IHsgZGVlcENsb25lLCBrZXlzIH0gZnJvbSBcIi4uL2Z1bmN0aW9ucy91dGlsc1wiO1xuaW1wb3J0IHsgbWVyZ2VSYW5nZXMsIFJhbmdlU2V0IH0gZnJvbSBcIi4uL2hlbHBlcnMvcmFuZ2VzZXRcIjtcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChcbiAgdGFyZ2V0OiBPYnNlcnZhYmlsaXR5U2V0LFxuICBuZXdTZXQ6IE9ic2VydmFiaWxpdHlTZXRcbik6IE9ic2VydmFiaWxpdHlTZXQge1xuICBrZXlzKG5ld1NldCkuZm9yRWFjaChwYXJ0ID0+IHtcbiAgICBjb25zdCByYW5nZVNldCA9IHRhcmdldFtwYXJ0XSB8fCAodGFyZ2V0W3BhcnRdID0gbmV3IFJhbmdlU2V0KCkpO1xuICAgIG1lcmdlUmFuZ2VzKHJhbmdlU2V0LCBuZXdTZXRbcGFydF0pO1xuICB9KTtcbiAgcmV0dXJuIHRhcmdldDtcbn1cbiIsICJpbXBvcnQgeyBpc0FzeW5jRnVuY3Rpb24sIGtleXMgfSBmcm9tIFwiLi4vZnVuY3Rpb25zL3V0aWxzXCI7XG5pbXBvcnQgeyBnbG9iYWxFdmVudHMsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FIH0gZnJvbSBcIi4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50c1wiO1xuaW1wb3J0IHtcbiAgZGVjcmVtZW50RXhwZWN0ZWRBd2FpdHMsXG4gIGluY3JlbWVudEV4cGVjdGVkQXdhaXRzLFxuICBuZXdTY29wZSxcbiAgUFNELFxuICB1c2VQU0QsXG59IGZyb20gXCIuLi9oZWxwZXJzL3Byb21pc2VcIjtcbmltcG9ydCB7IE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL2RiLWV2ZW50c1wiO1xuaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZSBhcyBJT2JzZXJ2YWJsZSxcbiAgU3Vic2NyaXB0aW9uLFxufSBmcm9tIFwiLi4vcHVibGljL3R5cGVzL29ic2VydmFibGVcIjtcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tIFwiLi4vY2xhc3Nlcy9vYnNlcnZhYmxlL29ic2VydmFibGVcIjtcbmltcG9ydCB7IGV4dGVuZE9ic2VydmFiaWxpdHlTZXQgfSBmcm9tIFwiLi9leHRlbmQtb2JzZXJ2YWJpbGl0eS1zZXRcIjtcbmltcG9ydCB7IHJhbmdlc092ZXJsYXAgfSBmcm9tIFwiLi4vaGVscGVycy9yYW5nZXNldFwiO1xuXG5leHBvcnQgZnVuY3Rpb24gbGl2ZVF1ZXJ5PFQ+KHF1ZXJpZXI6ICgpID0+IFQgfCBQcm9taXNlPFQ+KTogSU9ic2VydmFibGU8VD4ge1xuICBsZXQgaGFzVmFsdWUgPSBmYWxzZTtcbiAgbGV0IGN1cnJlbnRWYWx1ZTogVCA9IHVuZGVmaW5lZCBhcyBhbnk7XG4gIGNvbnN0IG9ic2VydmFibGUgPSBuZXcgT2JzZXJ2YWJsZTxUPigob2JzZXJ2ZXIpID0+IHtcbiAgICBjb25zdCBzY29wZUZ1bmNJc0FzeW5jID0gaXNBc3luY0Z1bmN0aW9uKHF1ZXJpZXIpO1xuICAgIGZ1bmN0aW9uIGV4ZWN1dGUoc3Vic2NyOiBPYnNlcnZhYmlsaXR5U2V0KSB7XG4gICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICBpbmNyZW1lbnRFeHBlY3RlZEF3YWl0cygpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhlYyA9ICgpID0+IG5ld1Njb3BlKHF1ZXJpZXIsIHsgc3Vic2NyLCB0cmFuczogbnVsbCB9KTtcbiAgICAgIGNvbnN0IHJ2ID0gUFNELnRyYW5zXG4gICAgICAgID8gLy8gSWdub3JlIGN1cnJlbnQgdHJhbnNhY3Rpb24gaWYgYWN0aXZlIHdoZW4gY2FsbGluZyBzdWJzY3JpYmUoKS5cbiAgICAgICAgICB1c2VQU0QoUFNELnRyYW5zbGVzcywgZXhlYylcbiAgICAgICAgOiBleGVjKCk7XG4gICAgICBpZiAoc2NvcGVGdW5jSXNBc3luYykge1xuICAgICAgICAocnYgYXMgUHJvbWlzZTxhbnk+KS50aGVuKFxuICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzLFxuICAgICAgICAgIGRlY3JlbWVudEV4cGVjdGVkQXdhaXRzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcnY7XG4gICAgfVxuXG4gICAgbGV0IGNsb3NlZCA9IGZhbHNlO1xuXG4gICAgbGV0IGFjY3VtTXV0czogT2JzZXJ2YWJpbGl0eVNldCA9IHt9O1xuICAgIGxldCBjdXJyZW50T2JzOiBPYnNlcnZhYmlsaXR5U2V0ID0ge307XG5cbiAgICBjb25zdCBzdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbiA9IHtcbiAgICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiBjbG9zZWQ7XG4gICAgICB9LFxuICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgZ2xvYmFsRXZlbnRzLnN0b3JhZ2VtdXRhdGVkLnVuc3Vic2NyaWJlKG11dGF0aW9uTGlzdGVuZXIpO1xuICAgICAgfSxcbiAgICB9O1xuXG4gICAgb2JzZXJ2ZXIuc3RhcnQgJiYgb2JzZXJ2ZXIuc3RhcnQoc3Vic2NyaXB0aW9uKTsgLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JzZXJ2YWJsZVxuXG4gICAgbGV0IHF1ZXJ5aW5nID0gZmFsc2UsXG4gICAgICBzdGFydGVkTGlzdGVuaW5nID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBzaG91bGROb3RpZnkoKSB7XG4gICAgICByZXR1cm4ga2V5cyhjdXJyZW50T2JzKS5zb21lKFxuICAgICAgICAoa2V5KSA9PlxuICAgICAgICAgIGFjY3VtTXV0c1trZXldICYmIHJhbmdlc092ZXJsYXAoYWNjdW1NdXRzW2tleV0sIGN1cnJlbnRPYnNba2V5XSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3QgbXV0YXRpb25MaXN0ZW5lciA9IChwYXJ0czogT2JzZXJ2YWJpbGl0eVNldCkgPT4ge1xuICAgICAgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldChhY2N1bU11dHMsIHBhcnRzKTtcbiAgICAgIGlmIChzaG91bGROb3RpZnkoKSkge1xuICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIGNvbnN0IGRvUXVlcnkgPSAoKSA9PiB7XG4gICAgICBpZiAocXVlcnlpbmcgfHwgY2xvc2VkKSByZXR1cm47XG4gICAgICBhY2N1bU11dHMgPSB7fTtcbiAgICAgIGNvbnN0IHN1YnNjcjogT2JzZXJ2YWJpbGl0eVNldCA9IHt9O1xuICAgICAgY29uc3QgcmV0ID0gZXhlY3V0ZShzdWJzY3IpO1xuICAgICAgaWYgKCFzdGFydGVkTGlzdGVuaW5nKSB7XG4gICAgICAgIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgbXV0YXRpb25MaXN0ZW5lcik7XG4gICAgICAgIHN0YXJ0ZWRMaXN0ZW5pbmcgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcXVlcnlpbmcgPSB0cnVlO1xuICAgICAgUHJvbWlzZS5yZXNvbHZlKHJldCkudGhlbihcbiAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgIGhhc1ZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICBjdXJyZW50VmFsdWUgPSByZXN1bHQ7XG4gICAgICAgICAgcXVlcnlpbmcgPSBmYWxzZTtcbiAgICAgICAgICBpZiAoY2xvc2VkKSByZXR1cm47XG4gICAgICAgICAgaWYgKHNob3VsZE5vdGlmeSgpKSB7XG4gICAgICAgICAgICAvLyBNdXRhdGlvbnMgaGFzIGhhcHBlbmVkIHdoaWxlIHdlIHdlcmUgcXVlcnlpbmcuIFJlZG8gcXVlcnkuXG4gICAgICAgICAgICBkb1F1ZXJ5KCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFjY3VtTXV0cyA9IHt9O1xuICAgICAgICAgICAgLy8gVXBkYXRlIHdoYXQgd2UgYXJlIHN1YnNjcmliaW5nIGZvciBiYXNlZCBvbiB0aGlzIGxhc3QgcnVuOlxuICAgICAgICAgICAgY3VycmVudE9icyA9IHN1YnNjcjtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dChyZXN1bHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgIHF1ZXJ5aW5nID0gZmFsc2U7XG4gICAgICAgICAgaGFzVmFsdWUgPSBmYWxzZTtcbiAgICAgICAgICBvYnNlcnZlci5lcnJvciAmJiBvYnNlcnZlci5lcnJvcihlcnIpO1xuICAgICAgICAgIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICApO1xuICAgIH07XG5cbiAgICBkb1F1ZXJ5KCk7XG4gICAgcmV0dXJuIHN1YnNjcmlwdGlvbjtcbiAgfSk7XG4gIG9ic2VydmFibGUuaGFzVmFsdWUgPSAoKSA9PiBoYXNWYWx1ZTtcbiAgb2JzZXJ2YWJsZS5nZXRWYWx1ZSA9ICgpID0+IGN1cnJlbnRWYWx1ZTtcbiAgcmV0dXJuIG9ic2VydmFibGU7XG59XG4iLCAiaW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsJztcbmltcG9ydCB7IERleGllRE9NRGVwZW5kZW5jaWVzIH0gZnJvbSAnLi4vLi4vcHVibGljL3R5cGVzL2RleGllLWRvbS1kZXBlbmRlbmNpZXMnO1xuXG5leHBvcnQgbGV0IGRvbURlcHM6IERleGllRE9NRGVwZW5kZW5jaWVzXG5cbnRyeSB7XG4gIGRvbURlcHMgPSB7XG4gICAgLy8gUmVxdWlyZWQ6XG4gICAgaW5kZXhlZERCOiBfZ2xvYmFsLmluZGV4ZWREQiB8fCBfZ2xvYmFsLm1vekluZGV4ZWREQiB8fCBfZ2xvYmFsLndlYmtpdEluZGV4ZWREQiB8fCBfZ2xvYmFsLm1zSW5kZXhlZERCLFxuICAgIElEQktleVJhbmdlOiBfZ2xvYmFsLklEQktleVJhbmdlIHx8IF9nbG9iYWwud2Via2l0SURCS2V5UmFuZ2VcbiAgfTtcbn0gY2F0Y2ggKGUpIHtcbiAgZG9tRGVwcyA9IHsgaW5kZXhlZERCOiBudWxsLCBJREJLZXlSYW5nZTogbnVsbCB9O1xufVxuIiwgImltcG9ydCB7IERleGllIGFzIF9EZXhpZSB9IGZyb20gJy4vZGV4aWUnO1xuaW1wb3J0IHsgX2dsb2JhbCB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsJztcbmltcG9ydCB7IHByb3BzLCBkZXJpdmUsIGV4dGVuZCwgb3ZlcnJpZGUsIGdldEJ5S2V5UGF0aCwgc2V0QnlLZXlQYXRoLCBkZWxCeUtleVBhdGgsIHNoYWxsb3dDbG9uZSwgZGVlcENsb25lLCBhc2FwIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL3V0aWxzJztcbmltcG9ydCB7IGdldE9iamVjdERpZmYgfSBmcm9tIFwiLi4vLi4vZnVuY3Rpb25zL2dldC1vYmplY3QtZGlmZlwiO1xuaW1wb3J0IHsgZnVsbE5hbWVFeGNlcHRpb25zIH0gZnJvbSAnLi4vLi4vZXJyb3JzJztcbmltcG9ydCB7IERleGllQ29uc3RydWN0b3IgfSBmcm9tICcuLi8uLi9wdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3InO1xuaW1wb3J0IHsgZ2V0RGF0YWJhc2VOYW1lcyB9IGZyb20gJy4uLy4uL2hlbHBlcnMvZGF0YWJhc2UtZW51bWVyYXRvcic7XG5pbXBvcnQgeyBQU0QgfSBmcm9tICcuLi8uLi9oZWxwZXJzL3Byb21pc2UnO1xuaW1wb3J0IHsgdXNlUFNEIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IG5ld1Njb3BlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9wcm9taXNlJztcbmltcG9ydCB7IHJlamVjdGlvbiB9IGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBhd2FpdEl0ZXJhdG9yIH0gZnJvbSAnLi4vLi4vaGVscGVycy95aWVsZC1zdXBwb3J0JztcbmltcG9ydCBQcm9taXNlIGZyb20gJy4uLy4uL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgKiBhcyBEZWJ1ZyBmcm9tICcuLi8uLi9oZWxwZXJzL2RlYnVnJztcbmltcG9ydCB7IGRleGllU3RhY2tGcmFtZUZpbHRlciwgbWluS2V5LCBjb25uZWN0aW9ucywgREVYSUVfVkVSU0lPTiB9IGZyb20gJy4uLy4uL2dsb2JhbHMvY29uc3RhbnRzJztcbmltcG9ydCBFdmVudHMgZnJvbSAnLi4vLi4vaGVscGVycy9FdmVudHMnO1xuaW1wb3J0IHsgZXhjZXB0aW9ucyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBlcnJuYW1lcyB9IGZyb20gJy4uLy4uL2Vycm9ycyc7XG5pbXBvcnQgeyBnZXRNYXhLZXkgfSBmcm9tICcuLi8uLi9mdW5jdGlvbnMvcXVpcmtzJztcbmltcG9ydCB7IHZpcCB9IGZyb20gJy4vdmlwJztcbmltcG9ydCB7IGdsb2JhbEV2ZW50cyB9IGZyb20gJy4uLy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBsaXZlUXVlcnkgfSBmcm9tICcuLi8uLi9saXZlLXF1ZXJ5L2xpdmUtcXVlcnknO1xuaW1wb3J0IHsgZXh0ZW5kT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gJy4uLy4uL2xpdmUtcXVlcnkvZXh0ZW5kLW9ic2VydmFiaWxpdHktc2V0JztcbmltcG9ydCB7IGRvbURlcHMgfSBmcm9tICcuL2RleGllLWRvbS1kZXBlbmRlbmNpZXMnO1xuaW1wb3J0IHsgY21wIH0gZnJvbSAnLi4vLi4vZnVuY3Rpb25zL2NtcCc7XG5cbi8qIChEZXhpZSkgaXMgYW4gaW5zdGFuY2Ugb2YgRGV4aWVDb25zdHJ1Y3RvciwgYXMgZGVmaW5lZCBpbiBwdWJsaWMvdHlwZXMvZGV4aWUtY29uc3RydWN0b3IuZC50c1xuKiAgKG5ldyBEZXhpZSgpKSBpcyBhbiBpbnN0YW5jZSBvZiBEZXhpZSwgYXMgZGVmaW5lZCBpbiBwdWJsaWMvdHlwZXMvZGV4aWUuZC50c1xuKiBcbiogV2h5IHdlJ3JlIGRvaW5nIHRoaXM/XG5cbiogQmVjYXVzZSB3ZSd2ZSBjaG9vc2VuIHRvIGRlZmluZSB0aGUgcHVibGljIERleGllIEFQSSB1c2luZyBhIERleGllQ29uc3RydWN0b3IgaW50ZXJmYWNlXG4qIHJhdGhlciB0aGFuIGRlY2xhcmluZyBhIGNsYXNzLiBPbiB0aGF0IGludGVyZmFjZSwgYWxsIHN0YXRpYyBwcm9wcyBhcmUgZGVmaW5lZC5cbiogSW4gcHJhY3RpY2UsIGNsYXNzIERleGllJ3MgY29uc3RydWN0b3IgaW1wbGVtZW50cyBEZXhpZUNvbnN0cnVjdG9yIGFuZCBhbGwgbWVtYmVyIHByb3BzXG4qIGFyZSBkZWZpbmVkIGluIGludGVyZmFjZSBEZXhpZS4gV2UgY291bGQgc2F5LCBpdCdzIGEgdHlwZXNjcmlwdCBsaW1pdGF0aW9uIG9mIG5vdCBiZWluZ1xuKiBhYmxlIHRvIGRlZmluZSBhIHN0YXRpYyBpbnRlcmZhY2UgdGhhdCBmb3JjZXMgdXMgdG8gZG8gdGhlIGNhc3QgYmVsb3cuXG4qL1xuY29uc3QgRGV4aWUgPSBfRGV4aWUgYXMgYW55IGFzIERleGllQ29uc3RydWN0b3I7XG5cbi8vXG4vLyBTZXQgYWxsIHN0YXRpYyBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIG9udG8gRGV4aWU6XG4vLyBcbnByb3BzKERleGllLCB7XG5cbiAgLy8gRGV4aWUuQnVsa0Vycm9yID0gY2xhc3MgQnVsa0Vycm9yIHsuLi59O1xuICAvLyBEZXhpZS5YWFhFcnJvciA9IGNsYXNzIFhYWEVycm9yIHsuLi59O1xuICAuLi5mdWxsTmFtZUV4Y2VwdGlvbnMsXG5cbiAgLy9cbiAgLy8gU3RhdGljIGRlbGV0ZSgpIG1ldGhvZC5cbiAgLy9cbiAgZGVsZXRlKGRhdGFiYXNlTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgZGIgPSBuZXcgRGV4aWUoZGF0YWJhc2VOYW1lLCB7YWRkb25zOiBbXX0pO1xuICAgIHJldHVybiBkYi5kZWxldGUoKTtcbiAgfSxcblxuICAvL1xuICAvLyBTdGF0aWMgZXhpc3RzKCkgbWV0aG9kLlxuICAvL1xuICBleGlzdHMobmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBEZXhpZShuYW1lLCB7IGFkZG9uczogW10gfSkub3BlbigpLnRoZW4oZGIgPT4ge1xuICAgICAgZGIuY2xvc2UoKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pLmNhdGNoKCdOb1N1Y2hEYXRhYmFzZUVycm9yJywgKCkgPT4gZmFsc2UpO1xuICB9LFxuXG4gIC8vXG4gIC8vIFN0YXRpYyBtZXRob2QgZm9yIHJldHJpZXZpbmcgYSBsaXN0IG9mIGFsbCBleGlzdGluZyBkYXRhYmFzZXMgYXQgY3VycmVudCBob3N0LlxuICAvL1xuICBnZXREYXRhYmFzZU5hbWVzKGNiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBnZXREYXRhYmFzZU5hbWVzKERleGllLmRlcGVuZGVuY2llcykudGhlbihjYik7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gcmVqZWN0aW9uKG5ldyBleGNlcHRpb25zLk1pc3NpbmdBUEkoKSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKiBAZGVwcmVjYXRlZCAqL1xuICBkZWZpbmVDbGFzcygpIHtcbiAgICBmdW5jdGlvbiBDbGFzcyhjb250ZW50KSB7XG4gICAgICBleHRlbmQodGhpcywgY29udGVudCk7XG4gICAgfVxuICAgIHJldHVybiBDbGFzcztcbiAgfSxcblxuICBpZ25vcmVUcmFuc2FjdGlvbihzY29wZUZ1bmMpIHtcbiAgICAvLyBJbiBjYXNlIGNhbGxlciBpcyB3aXRoaW4gYSB0cmFuc2FjdGlvbiBidXQgbmVlZHMgdG8gY3JlYXRlIGEgc2VwYXJhdGUgdHJhbnNhY3Rpb24uXG4gICAgLy8gRXhhbXBsZSBvZiB1c2FnZTpcbiAgICAvL1xuICAgIC8vIExldCdzIHNheSB3ZSBoYXZlIGEgbG9nZ2VyIGZ1bmN0aW9uIGluIG91ciBhcHAuIE90aGVyIGFwcGxpY2F0aW9uLWxvZ2ljIHNob3VsZCBiZSB1bmF3YXJlIG9mIHRoZVxuICAgIC8vIGxvZ2dlciBmdW5jdGlvbiBhbmQgbm90IG5lZWQgdG8gaW5jbHVkZSB0aGUgJ2xvZ2VudHJpZXMnIHRhYmxlIGluIGFsbCB0cmFuc2FjdGlvbiBpdCBwZXJmb3Jtcy5cbiAgICAvLyBUaGUgbG9nZ2luZyBzaG91bGQgYWx3YXlzIGJlIGRvbmUgaW4gYSBzZXBhcmF0ZSB0cmFuc2FjdGlvbiBhbmQgbm90IGJlIGRlcGVuZGFudCBvbiB0aGUgY3VycmVudFxuICAgIC8vIHJ1bm5pbmcgdHJhbnNhY3Rpb24gY29udGV4dC4gVGhlbiB5b3UgY291bGQgdXNlIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgdG8gcnVuIGNvZGUgdGhhdCBzdGFydHMgYSBuZXcgdHJhbnNhY3Rpb24uXG4gICAgLy9cbiAgICAvLyAgICAgRGV4aWUuaWdub3JlVHJhbnNhY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgLy8gICAgICAgICBkYi5sb2dlbnRyaWVzLmFkZChuZXdMb2dFbnRyeSk7XG4gICAgLy8gICAgIH0pO1xuICAgIC8vXG4gICAgLy8gVW5sZXNzIHVzaW5nIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCksIHRoZSBhYm92ZSBleGFtcGxlIHdvdWxkIHRyeSB0byByZXVzZSB0aGUgY3VycmVudCB0cmFuc2FjdGlvblxuICAgIC8vIGluIGN1cnJlbnQgUHJvbWlzZS1zY29wZS5cbiAgICAvL1xuICAgIC8vIEFuIGFsdGVybmF0aXZlIHRvIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKCkgd291bGQgYmUgc2V0SW1tZWRpYXRlKCkgb3Igc2V0VGltZW91dCgpLiBUaGUgcmVhc29uIHdlIHN0aWxsIHByb3ZpZGUgYW5cbiAgICAvLyBBUEkgZm9yIHRoaXMgYmVjYXVzZVxuICAgIC8vICAxKSBUaGUgaW50ZW50aW9uIG9mIHdyaXRpbmcgdGhlIHN0YXRlbWVudCBjb3VsZCBiZSB1bmNsZWFyIGlmIHVzaW5nIHNldEltbWVkaWF0ZSgpIG9yIHNldFRpbWVvdXQoKS5cbiAgICAvLyAgMikgc2V0VGltZW91dCgpIHdvdWxkIHdhaXQgdW5uZXNjZXNzYXJ5IHVudGlsIGZpcmluZy4gVGhpcyBpcyBob3dldmVyIG5vdCB0aGUgY2FzZSB3aXRoIHNldEltbWVkaWF0ZSgpLlxuICAgIC8vICAzKSBzZXRJbW1lZGlhdGUoKSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoZSBFUyBzdGFuZGFyZC5cbiAgICAvLyAgNCkgWW91IG1pZ2h0IHdhbnQgdG8ga2VlcCBvdGhlciBQU0Qgc3RhdGUgdGhhdCB3YXMgc2V0IGluIGEgcGFyZW50IFBTRCwgc3VjaCBhcyBQU0QubGV0VGhyb3VnaC5cbiAgICByZXR1cm4gUFNELnRyYW5zID9cbiAgICAgIHVzZVBTRChQU0QudHJhbnNsZXNzLCBzY29wZUZ1bmMpIDogLy8gVXNlIHRoZSBjbG9zZXN0IHBhcmVudCB0aGF0IHdhcyBub24tdHJhbnNhY3Rpb25hbC5cbiAgICAgIHNjb3BlRnVuYygpOyAvLyBObyBuZWVkIHRvIGNoYW5nZSBzY29wZSBiZWNhdXNlIHRoZXJlIGlzIG5vIG9uZ29pbmcgdHJhbnNhY3Rpb24uXG4gIH0sXG5cbiAgdmlwLFxuXG4gIGFzeW5jOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm46IEZ1bmN0aW9uKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBydiA9IGF3YWl0SXRlcmF0b3IoZ2VuZXJhdG9yRm4uYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG4gICAgICAgIGlmICghcnYgfHwgdHlwZW9mIHJ2LnRoZW4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShydik7XG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIHJlamVjdGlvbihlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIHNwYXduOiBmdW5jdGlvbiAoZ2VuZXJhdG9yRm4sIGFyZ3MsIHRoaXopIHtcbiAgICB0cnkge1xuICAgICAgdmFyIHJ2ID0gYXdhaXRJdGVyYXRvcihnZW5lcmF0b3JGbi5hcHBseSh0aGl6LCBhcmdzIHx8IFtdKSk7XG4gICAgICBpZiAoIXJ2IHx8IHR5cGVvZiBydi50aGVuICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJ2KTtcbiAgICAgIHJldHVybiBydjtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gcmVqZWN0aW9uKGUpO1xuICAgIH1cbiAgfSxcblxuICAvLyBEZXhpZS5jdXJyZW50VHJhbnNhY3Rpb24gcHJvcGVydHlcbiAgY3VycmVudFRyYW5zYWN0aW9uOiB7XG4gICAgZ2V0OiAoKSA9PiBQU0QudHJhbnMgfHwgbnVsbFxuICB9LFxuXG4gIHdhaXRGb3I6IGZ1bmN0aW9uIChwcm9taXNlT3JGdW5jdGlvbiwgb3B0aW9uYWxUaW1lb3V0KSB7XG4gICAgLy8gSWYgYSBmdW5jdGlvbiBpcyBwcm92aWRlZCwgaW52b2tlIGl0IGFuZCBwYXNzIHRoZSByZXR1cm5pbmcgdmFsdWUgdG8gVHJhbnNhY3Rpb24ud2FpdEZvcigpXG4gICAgY29uc3QgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShcbiAgICAgIHR5cGVvZiBwcm9taXNlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/XG4gICAgICAgIERleGllLmlnbm9yZVRyYW5zYWN0aW9uKHByb21pc2VPckZ1bmN0aW9uKSA6XG4gICAgICAgIHByb21pc2VPckZ1bmN0aW9uKVxuICAgICAgLnRpbWVvdXQob3B0aW9uYWxUaW1lb3V0IHx8IDYwMDAwKTsgLy8gRGVmYXVsdCB0aGUgdGltZW91dCB0byBvbmUgbWludXRlLiBDYWxsZXIgbWF5IHNwZWNpZnkgSW5maW5pdHkgaWYgcmVxdWlyZWQuICAgICAgIFxuXG4gICAgLy8gUnVuIGdpdmVuIHByb21pc2Ugb24gY3VycmVudCB0cmFuc2FjdGlvbi4gSWYgbm8gY3VycmVudCB0cmFuc2FjdGlvbiwganVzdCByZXR1cm4gYSBEZXhpZSBwcm9taXNlIGJhc2VkXG4gICAgLy8gb24gZ2l2ZW4gdmFsdWUuXG4gICAgcmV0dXJuIFBTRC50cmFucyA/XG4gICAgICBQU0QudHJhbnMud2FpdEZvcihwcm9taXNlKSA6XG4gICAgICBwcm9taXNlO1xuICB9LFxuXG4gIC8vIEV4cG9ydCBvdXIgUHJvbWlzZSBpbXBsZW1lbnRhdGlvbiBzaW5jZSBpdCBjYW4gYmUgaGFuZHkgYXMgYSBzdGFuZGFsb25lIFByb21pc2UgaW1wbGVtZW50YXRpb25cbiAgUHJvbWlzZTogUHJvbWlzZSxcblxuICAvLyBEZXhpZS5kZWJ1ZyBwcm9wdGVyeTpcbiAgLy8gRGV4aWUuZGVidWcgPSBmYWxzZVxuICAvLyBEZXhpZS5kZWJ1ZyA9IHRydWVcbiAgLy8gRGV4aWUuZGVidWcgPSBcImRleGllXCIgLSBkb24ndCBoaWRlIGRleGllJ3Mgc3RhY2sgZnJhbWVzLlxuICBkZWJ1Zzoge1xuICAgIGdldDogKCkgPT4gRGVidWcuZGVidWcsXG4gICAgc2V0OiB2YWx1ZSA9PiB7XG4gICAgICBEZWJ1Zy5zZXREZWJ1Zyh2YWx1ZSwgdmFsdWUgPT09ICdkZXhpZScgPyAoKSA9PiB0cnVlIDogZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gRXhwb3J0IG91ciBkZXJpdmUvZXh0ZW5kL292ZXJyaWRlIG1ldGhvZG9sb2d5XG4gIGRlcml2ZTogZGVyaXZlLCAvLyBEZXByZWNhdGU/XG4gIGV4dGVuZDogZXh0ZW5kLCAvLyBEZXByZWNhdGU/XG4gIHByb3BzOiBwcm9wcyxcbiAgb3ZlcnJpZGU6IG92ZXJyaWRlLCAvLyBEZXByZWNhdGU/XG4gIC8vIEV4cG9ydCBvdXIgRXZlbnRzKCkgZnVuY3Rpb24gLSBjYW4gYmUgaGFuZHkgYXMgYSB0b29sa2l0XG4gIEV2ZW50czogRXZlbnRzLFxuICBvbjogZ2xvYmFsRXZlbnRzLFxuICBsaXZlUXVlcnksXG4gIGV4dGVuZE9ic2VydmFiaWxpdHlTZXQsXG4gIC8vIFV0aWxpdGllc1xuICBnZXRCeUtleVBhdGg6IGdldEJ5S2V5UGF0aCxcbiAgc2V0QnlLZXlQYXRoOiBzZXRCeUtleVBhdGgsXG4gIGRlbEJ5S2V5UGF0aDogZGVsQnlLZXlQYXRoLFxuICBzaGFsbG93Q2xvbmU6IHNoYWxsb3dDbG9uZSxcbiAgZGVlcENsb25lOiBkZWVwQ2xvbmUsXG4gIGdldE9iamVjdERpZmY6IGdldE9iamVjdERpZmYsXG4gIGNtcCxcbiAgYXNhcDogYXNhcCxcbiAgLy9tYXhLZXk6IG5ldyBEZXhpZSgnJyx7YWRkb25zOltdfSkuX21heEtleSxcbiAgbWluS2V5OiBtaW5LZXksXG4gIC8vIEFkZG9uIHJlZ2lzdHJ5XG4gIGFkZG9uczogW10sXG4gIC8vIEdsb2JhbCBEQiBjb25uZWN0aW9uIGxpc3RcbiAgY29ubmVjdGlvbnM6IGNvbm5lY3Rpb25zLFxuXG4gIC8vTXVsdGlNb2RpZnlFcnJvcjogZXhjZXB0aW9ucy5Nb2RpZnksIC8vIE9ic29sZXRlIVxuICBlcnJuYW1lczogZXJybmFtZXMsXG5cbiAgLy8gRXhwb3J0IG90aGVyIHN0YXRpYyBjbGFzc2VzXG4gIC8vSW5kZXhTcGVjOiBJbmRleFNwZWMsIE9ic29sZXRlIVxuICAvL1RhYmxlU2NoZW1hOiBUYWJsZVNjaGVtYSwgT2Jzb2xldGUhXG5cbiAgLy9cbiAgLy8gRGVwZW5kZW5jaWVzXG4gIC8vXG4gIC8vIFRoZXNlIHdpbGwgYXV0b21hdGljYWxseSB3b3JrIGluIGJyb3dzZXJzIHdpdGggaW5kZXhlZERCIHN1cHBvcnQsIG9yIHdoZXJlIGFuIGluZGV4ZWREQiBwb2x5ZmlsbCBoYXMgYmVlbiBpbmNsdWRlZC5cbiAgLy9cbiAgLy8gSW4gbm9kZS5qcywgaG93ZXZlciwgdGhlc2UgcHJvcGVydGllcyBtdXN0IGJlIHNldCBcIm1hbnVhbGx5XCIgYmVmb3JlIGluc3RhbnNpYXRpbmcgYSBuZXcgRGV4aWUoKS5cbiAgLy8gRm9yIG5vZGUuanMsIHlvdSBuZWVkIHRvIHJlcXVpcmUgaW5kZXhlZGRiLWpzIG9yIHNpbWlsYXIgYW5kIHRoZW4gc2V0IHRoZXNlIGRlcHMuXG4gIC8vXG4gIGRlcGVuZGVuY2llczogZG9tRGVwcyxcblxuICAvLyBBUEkgVmVyc2lvbiBOdW1iZXI6IFR5cGUgTnVtYmVyLCBtYWtlIHN1cmUgdG8gYWx3YXlzIHNldCBhIHZlcnNpb24gbnVtYmVyIHRoYXQgY2FuIGJlIGNvbXBhcmFibGUgY29ycmVjdGx5LiBFeGFtcGxlOiAwLjksIDAuOTEsIDAuOTIsIDEuMCwgMS4wMSwgMS4xLCAxLjIsIDEuMjEsIGV0Yy5cbiAgc2VtVmVyOiBERVhJRV9WRVJTSU9OLFxuICB2ZXJzaW9uOiBERVhJRV9WRVJTSU9OLnNwbGl0KCcuJylcbiAgICAubWFwKG4gPT4gcGFyc2VJbnQobikpXG4gICAgLnJlZHVjZSgocCwgYywgaSkgPT4gcCArIChjIC8gTWF0aC5wb3coMTAsIGkgKiAyKSkpLFxuXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9kZmFobGFuZGVyL0RleGllLmpzL2lzc3Vlcy8xODZcbiAgLy8gdHlwZXNjcmlwdCBjb21waWxlciB0c2MgaW4gbW9kZSB0cy0tPmVzNSAmIGNvbW1vbkpTLCB3aWxsIGV4cGVjdCByZXF1aXJlKCkgdG8gcmV0dXJuXG4gIC8vIHguZGVmYXVsdC4gV29ya2Fyb3VuZDogU2V0IERleGllLmRlZmF1bHQgPSBEZXhpZS5cbiAgLy8gZGVmYXVsdDogRGV4aWUsIC8vIENvbW1lbnRlZCBiZWNhdXNlIHNvbHZlZCBpbiBpbmRleC11bWQudHMgaW5zdGVhZC5cbiAgLy8gTWFrZSBpdCBwb3NzaWJsZSB0byBpbXBvcnQge0RleGllfSAobm9uLWRlZmF1bHQgaW1wb3J0KVxuICAvLyBSZWFzb24gMTogTWF5IHN3aXRjaCB0byB0aGF0IGluIGZ1dHVyZS5cbiAgLy8gUmVhc29uIDI6IFdlIGRlY2xhcmUgaXQgYm90aCBkZWZhdWx0IGFuZCBuYW1lZCBleHBvcnRlZCBpbiBkLnRzIHRvIG1ha2UgaXQgcG9zc2libGVcbiAgLy8gdG8gbGV0IGFkZG9ucyBleHRlbmQgdGhlIERleGllIGludGVyZmFjZSB3aXRoIFR5cGVzY3JpcHQgMi4xICh3b3JrcyBvbmx5IHdoZW4gZXhwbGljaXRlbHlcbiAgLy8gZXhwb3J0aW5nIHRoZSBzeW1ib2wsIG5vdCBqdXN0IGRlZmF1bHQgZXhwb3J0aW5nKVxuICAvLyBEZXhpZTogRGV4aWUgLy8gQ29tbWVudGVkIGJlY2F1c2Ugc29sdmVkIGluIGluZGV4LXVtZC50cyBpbnN0ZWFkLlxufSk7XG5cbkRleGllLm1heEtleSA9IGdldE1heEtleShEZXhpZS5kZXBlbmRlbmNpZXMuSURCS2V5UmFuZ2UpO1xuIiwgImltcG9ydCB7IGlzSUVPckVkZ2UgfSBmcm9tICcuLi9nbG9iYWxzL2NvbnN0YW50cyc7XG5pbXBvcnQgeyBnbG9iYWxFdmVudHMsIERFWElFX1NUT1JBR0VfTVVUQVRFRF9FVkVOVF9OQU1FLCBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUgfSBmcm9tICcuLi9nbG9iYWxzL2dsb2JhbC1ldmVudHMnO1xuaW1wb3J0IHsgT2JzZXJ2YWJpbGl0eVNldCB9IGZyb20gXCIuLi9wdWJsaWMvdHlwZXMvZGItZXZlbnRzXCI7XG5cbmlmICh0eXBlb2YgZGlzcGF0Y2hFdmVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gIGdsb2JhbEV2ZW50cyhERVhJRV9TVE9SQUdFX01VVEFURURfRVZFTlRfTkFNRSwgdXBkYXRlZFBhcnRzID0+IHtcbiAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgbGV0IGV2ZW50OiBDdXN0b21FdmVudDxPYnNlcnZhYmlsaXR5U2V0PjtcbiAgICAgIGlmIChpc0lFT3JFZGdlKSB7XG4gICAgICAgIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICAgIGV2ZW50LmluaXRDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHRydWUsIHRydWUsIHVwZGF0ZWRQYXJ0cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldmVudCA9IG5ldyBDdXN0b21FdmVudChTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUsIHtcbiAgICAgICAgICBkZXRhaWw6IHVwZGF0ZWRQYXJ0c1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IHRydWU7XG4gICAgICBkaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgIHByb3BhZ2F0aW5nTG9jYWxseSA9IGZhbHNlO1xuICAgIH1cbiAgfSk7XG4gIGFkZEV2ZW50TGlzdGVuZXIoU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLCAoe2RldGFpbH06IEN1c3RvbUV2ZW50PE9ic2VydmFiaWxpdHlTZXQ+KSA9PiB7XG4gICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgIHByb3BhZ2F0ZUxvY2FsbHkoZGV0YWlsKTtcbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcHJvcGFnYXRlTG9jYWxseSh1cGRhdGVQYXJ0czogT2JzZXJ2YWJpbGl0eVNldCkge1xuICBsZXQgd2FzTWUgPSBwcm9wYWdhdGluZ0xvY2FsbHk7XG4gIHRyeSB7XG4gICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gdHJ1ZTtcbiAgICBnbG9iYWxFdmVudHMuc3RvcmFnZW11dGF0ZWQuZmlyZSh1cGRhdGVQYXJ0cyk7XG4gIH0gZmluYWxseSB7XG4gICAgcHJvcGFnYXRpbmdMb2NhbGx5ID0gd2FzTWU7XG4gIH1cbn1cblxuZXhwb3J0IGxldCBwcm9wYWdhdGluZ0xvY2FsbHkgPSBmYWxzZTtcbiIsICJpbXBvcnQge1xuICBnbG9iYWxFdmVudHMsXG4gIFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSxcbiAgREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsXG59IGZyb20gJy4uL2dsb2JhbHMvZ2xvYmFsLWV2ZW50cyc7XG5pbXBvcnQgeyBwcm9wYWdhdGVMb2NhbGx5LCBwcm9wYWdhdGluZ0xvY2FsbHkgfSBmcm9tICcuL3Byb3BhZ2F0ZS1sb2NhbGx5JztcblxuaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsICE9PSAndW5kZWZpbmVkJykge1xuICBjb25zdCBiYyA9IG5ldyBCcm9hZGNhc3RDaGFubmVsKFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSk7XG5cbiAgLyoqXG4gICAgICogVGhlIE5vZGUuanMgQnJvYWRjYXN0Q2hhbm5lbCB3aWxsIHByZXZlbnQgdGhlIG5vZGUgcHJvY2VzcyBmcm9tIGV4aXRpbmdcbiAgICAgKiBpZiB0aGUgQnJvYWRjYXN0Q2hhbm5lbCBpcyBub3QgY2xvc2VkLlxuICAgICAqIFRoZXJlZm9yZSB3ZSBoYXZlIHRvIGNhbGwgdW5yZWYoKSB3aGljaCBhbGxvd3MgdGhlIHByb2Nlc3MgdG8gZmluaXNoXG4gICAgICogcHJvcGVybHkgZXZlbiB3aGVuIHRoZSBCcm9hZGNhc3RDaGFubmVsIGlzIG5ldmVyIGNsb3NlZC5cbiAgICAgKiBAbGluayBodHRwczovL25vZGVqcy5vcmcvYXBpL3dvcmtlcl90aHJlYWRzLmh0bWwjYnJvYWRjYXN0Y2hhbm5lbHVucmVmXG4gICAgICogQGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2RleGllL0RleGllLmpzL3B1bGwvMTU3NlxuICAgICAqL1xuICBpZiAodHlwZW9mIChiYyBhcyBhbnkpLnVucmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgKGJjIGFzIGFueSkudW5yZWYoKTtcbiAgfSBcbiAgIFxuICAvL1xuICAvLyBQcm9wYWdhdGUgbG9jYWwgY2hhbmdlcyB0byByZW1vdGUgdGFicywgd2luZG93cyBhbmQgd29ya2VycyB2aWEgQnJvYWRjYXN0Q2hhbm5lbFxuICAvL1xuICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIChjaGFuZ2VkUGFydHMpID0+IHtcbiAgICBpZiAoIXByb3BhZ2F0aW5nTG9jYWxseSkge1xuICAgICAgYmMucG9zdE1lc3NhZ2UoY2hhbmdlZFBhcnRzKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vXG4gIC8vIFByb3BhZ2F0ZSByZW1vdGUgY2hhbmdlcyBsb2NhbGx5IHZpYSBzdG9yYWdlIGV2ZW50OlxuICAvL1xuICBiYy5vbm1lc3NhZ2UgPSAoZXYpID0+IHtcbiAgICBpZiAoZXYuZGF0YSkgcHJvcGFnYXRlTG9jYWxseShldi5kYXRhKTtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSB2ZXJpZmllZCAtIHdoZW4gdHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIsIHdlIGFyZSBhIHdpbmRvdyBvciB3b3JrZXIuIE5vdCBhIE5vZGUgcHJvY2Vzcy5cblxuICAvL1xuICAvLyBQcm9wYWdhdGUgbG9jYWwgY2hhbmdlcyB0byByZW1vdGUgdGFicy93aW5kb3dzIHZpYSBzdG9yYWdlIGV2ZW50IGFuZCBzZXJ2aWNlIHdvcmtlclxuICAvLyB2aWEgbWVzc2FnZXMuIFdlIGhhdmUgdGhpcyBjb2RlIGhlcmUgYmVjYXVzZSBvZiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYxNDcyLlxuICAvL1xuICBnbG9iYWxFdmVudHMoREVYSUVfU1RPUkFHRV9NVVRBVEVEX0VWRU5UX05BTUUsIChjaGFuZ2VkUGFydHMpID0+IHtcbiAgICB0cnkge1xuICAgICAgaWYgKCFwcm9wYWdhdGluZ0xvY2FsbHkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbFN0b3JhZ2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gV2UncmUgYSBicm93c2luZyB3aW5kb3cgb3IgdGFiLiBQcm9wYWdhdGUgdG8gb3RoZXIgd2luZG93cy90YWJzIHZpYSBzdG9yYWdlIGV2ZW50OlxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFxuICAgICAgICAgICAgU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FLFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICB0cmlnOiBNYXRoLnJhbmRvbSgpLFxuICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmWydjbGllbnRzJ10gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgLy8gV2UncmUgYSBzZXJ2aWNlIHdvcmtlci4gUHJvcGFnYXRlIHRvIG91ciBicm93c2VyIGNsaWVudHMuXG4gICAgICAgICAgWy4uLnNlbGZbJ2NsaWVudHMnXS5tYXRjaEFsbCh7IGluY2x1ZGVVbmNvbnRyb2xsZWQ6IHRydWUgfSldLmZvckVhY2goXG4gICAgICAgICAgICAoY2xpZW50KSA9PlxuICAgICAgICAgICAgICBjbGllbnQucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFNUT1JBR0VfTVVUQVRFRF9ET01fRVZFTlRfTkFNRSxcbiAgICAgICAgICAgICAgICBjaGFuZ2VkUGFydHMsXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2gge31cbiAgfSk7XG5cbiAgLy9cbiAgLy8gUHJvcGFnYXRlIHJlbW90ZSBjaGFuZ2VzIGxvY2FsbHkgdmlhIHN0b3JhZ2UgZXZlbnQ6XG4gIC8vXG4gIGlmICh0eXBlb2YgYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ3N0b3JhZ2UnLCAoZXY6IFN0b3JhZ2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2LmtleSA9PT0gU1RPUkFHRV9NVVRBVEVEX0RPTV9FVkVOVF9OQU1FKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGV2Lm5ld1ZhbHVlKTtcbiAgICAgICAgaWYgKGRhdGEpIHByb3BhZ2F0ZUxvY2FsbHkoZGF0YS5jaGFuZ2VkUGFydHMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLy9cbiAgLy8gUHJvcGFnYXRlIG1lc3NhZ2VzIGZyb20gc2VydmljZSB3b3JrZXJcbiAgLy9cbiAgY29uc3Qgc3dDb250YWluZXIgPSBzZWxmLmRvY3VtZW50ICYmIG5hdmlnYXRvci5zZXJ2aWNlV29ya2VyOyAvLyBzZWxmLmRvY3VtZW50IGlzIHRvIHZlcmlmeSB3ZSdyZSBub3QgdGhlIFNXIG91cnNlbGZcbiAgaWYgKHN3Q29udGFpbmVyKSB7XG4gICAgLy8gV2UncmUgYSBicm93c2VyIHdpbmRvdyBhbmQgd2FudCB0byBwcm9wYWdhdGUgbWVzc2FnZSBmcm9tIHRoZSBTVzpcbiAgICBzd0NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgcHJvcGFnYXRlTWVzc2FnZUxvY2FsbHkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZU1lc3NhZ2VMb2NhbGx5KHsgZGF0YSB9OiBNZXNzYWdlRXZlbnQpIHtcbiAgaWYgKGRhdGEgJiYgZGF0YS50eXBlID09PSBTVE9SQUdFX01VVEFURURfRE9NX0VWRU5UX05BTUUpIHtcbiAgICBwcm9wYWdhdGVMb2NhbGx5KGRhdGEuY2hhbmdlZFBhcnRzKTtcbiAgfVxufVxuIiwgImltcG9ydCB7IERleGllIH0gZnJvbSAnLi9jbGFzc2VzL2RleGllJztcbmltcG9ydCB7IERleGllQ29uc3RydWN0b3IgfSBmcm9tICcuL3B1YmxpYy90eXBlcy9kZXhpZS1jb25zdHJ1Y3Rvcic7XG5pbXBvcnQgeyBEZXhpZVByb21pc2UgfSBmcm9tICcuL2hlbHBlcnMvcHJvbWlzZSc7XG5pbXBvcnQgeyBtYXBFcnJvciB9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCAqIGFzIERlYnVnIGZyb20gJy4vaGVscGVycy9kZWJ1Zyc7XG5pbXBvcnQgeyBkZXhpZVN0YWNrRnJhbWVGaWx0ZXIgfSBmcm9tICcuL2dsb2JhbHMvY29uc3RhbnRzJztcblxuLy8gR2VuZXJhdGUgYWxsIHN0YXRpYyBwcm9wZXJ0aWVzIHN1Y2ggYXMgRGV4aWUubWF4S2V5IGV0Y1xuLy8gKGltcGxlbWVudCBpbnRlcmZhY2UgRGV4aWVDb25zdHJ1Y3Rvcik6XG5pbXBvcnQgJy4vY2xhc3Nlcy9kZXhpZS9kZXhpZS1zdGF0aWMtcHJvcHMnO1xuaW1wb3J0ICcuL2xpdmUtcXVlcnkvZW5hYmxlLWJyb2FkY2FzdCc7XG5pbXBvcnQgeyBsaXZlUXVlcnkgfSBmcm9tICcuL2xpdmUtcXVlcnkvbGl2ZS1xdWVyeSc7XG5cbi8vIFNldCByZWplY3Rpb25NYXBwZXIgb2YgRGV4aWVQcm9taXNlIHNvIHRoYXQgaXQgZ2VuZXJhbGx5IHRyaWVzIHRvIG1hcFxuLy8gRE9NRXJyb3JzIGFuZCBET01FeGNlcHRpb25zIHRvIGEgRGV4aWVFcnJvciBpbnN0YW5jZSB3aXRoIHNhbWUgbmFtZSBidXQgd2l0aFxuLy8gYXN5bmMgc3RhY2sgc3VwcG9ydCBhbmQgd2l0aCBhIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgZnJvbSBEZXhpZUVycm9yIGFuZCBFcnJvci5cbi8vIG9mIE1hcCBET01FcnJvcnMgYW5kIERPTUV4Y2VwdGlvbnMgdG8gY29ycmVzcG9uZGluZyBEZXhpZSBlcnJvcnMuXG5EZXhpZVByb21pc2UucmVqZWN0aW9uTWFwcGVyID0gbWFwRXJyb3I7XG5cbi8vIExldCB0aGUgYXN5bmMgc3RhY2sgZmlsdGVyIGZvY3VzIG9uIGFwcCBjb2RlIGFuZCBmaWx0ZXIgYXdheSBmcmFtZXMgZnJvbSBkZXhpZS5taW4uanM6XG5EZWJ1Zy5zZXREZWJ1ZyhEZWJ1Zy5kZWJ1ZywgZGV4aWVTdGFja0ZyYW1lRmlsdGVyKTtcblxuZXhwb3J0IHsgUmFuZ2VTZXQsIG1lcmdlUmFuZ2VzLCByYW5nZXNPdmVybGFwIH0gZnJvbSBcIi4vaGVscGVycy9yYW5nZXNldFwiO1xuZXhwb3J0IHsgRGV4aWUsIGxpdmVRdWVyeSB9OyAvLyBDb21wbHkgd2l0aCBwdWJsaWMvaW5kZXguZC50cy5cbmV4cG9ydCBkZWZhdWx0IERleGllO1xuIiwgImltcG9ydCBEZXhpZSwgeyBUYWJsZSB9IGZyb20gXCJkZXhpZVwiXG5pbXBvcnQgeyBTaGFyZWREb2N1bWVudCB9IGZyb20gXCIuL3NoYXJlZEVudGl0aWVzL3NoYXJlZERvY3VtZW50XCJcbmltcG9ydCB7IGNyZWF0ZVJhbmRvbUlkIH0gZnJvbSBcIi4vdG9vbHNcIlxuaW1wb3J0IHsgU2hhcmVkRW50aXR5IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRW50aXR5XCJcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gXCIuL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlclwiXG5cblxuZXhwb3J0IGludGVyZmFjZSBQZXJtYW5lbnRTaGFyZURvY3VtZW50IHtcbiAgcGF0aDogc3RyaW5nLCBwZXJzaXN0ZW5jZUlkOiBzdHJpbmcsIHNoYXJlSWQ6IHN0cmluZyBcbn1cblxuZXhwb3J0IGludGVyZmFjZSBQZXJtYW5lbnRTaGFyZUZvbGRlciB7XG4gIHBhdGg6IHN0cmluZywgcGVyc2lzdGVuY2VJZDogc3RyaW5nLCBzaGFyZUlkOiBzdHJpbmcgXG59XG5cbmV4cG9ydCBjbGFzcyBQZXJtYW5lbnRTaGFyZVN0b3JlSW5kZXhlZERCIHtcblxuICBvaWQ6IHN0cmluZ1xuICBwcml2YXRlIGRvY3VtZW50VGFibGU6IFRhYmxlPFBlcm1hbmVudFNoYXJlRG9jdW1lbnQsIHN0cmluZz5cbiAgcHJpdmF0ZSBmb2xkZXJUYWJsZTogVGFibGU8UGVybWFuZW50U2hhcmVGb2xkZXIsIHN0cmluZz5cbiAgcHJpdmF0ZSBkYjogRGV4aWVcblxuICBrZWVwT3BlbjogYm9vbGVhbiA9IHRydWVcblxuICBjb25zdHJ1Y3RvcihvaWQ6IHN0cmluZykge1xuICAgIHRoaXMub2lkID0gb2lkXG4gICAgdGhpcy5kYiA9IG5ldyBEZXhpZSgncGVlcmRyYWZ0XycgKyB0aGlzLm9pZClcbiAgICB0aGlzLmRiLnZlcnNpb24oMikuc3RvcmVzKHtcbiAgICAgIHNoYXJlZERvY3M6IFwicGF0aCxwZXJzaXN0ZW5jZUlkLHNoYXJlSWRcIixcbiAgICAgIHNoYXJlZEZvbGRlcnM6IFwicGF0aCxwZXJzaXN0ZW5jZUlkLHNoYXJlSWRcIlxuICAgIH0pXG4gICAgdGhpcy5kYi5vbihcImNsb3NlXCIsICgpID0+IHtcbiAgICAgIGlmKHRoaXMua2VlcE9wZW4pIHtcbiAgICAgICAgdGhpcy5kYi5vcGVuKClcbiAgICAgIH1cbiAgICB9KVxuICAgIHRoaXMuZG9jdW1lbnRUYWJsZSA9IHRoaXMuZGIuX2FsbFRhYmxlc1tcInNoYXJlZERvY3NcIl0gYXMgVGFibGU8UGVybWFuZW50U2hhcmVEb2N1bWVudCwgc3RyaW5nPlxuICAgIHRoaXMuZm9sZGVyVGFibGUgPSB0aGlzLmRiLl9hbGxUYWJsZXNbXCJzaGFyZWRGb2xkZXJzXCJdIGFzIFRhYmxlPFBlcm1hbmVudFNoYXJlRm9sZGVyLCBzdHJpbmc+XG4gIH1cblxuICBjbG9zZSgpe1xuICAgIHRoaXMua2VlcE9wZW4gPSBmYWxzZVxuICAgIHRoaXMuZGIuY2xvc2UoKVxuICB9XG5cbiAgYWRkKGRvYzogU2hhcmVkRW50aXR5KSB7XG4gICAgaWYoZG9jIGluc3RhbmNlb2YgU2hhcmVkRG9jdW1lbnQpe1xuICAgICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUYWJsZS5hZGQoe1xuICAgICAgICBwYXRoOiBkb2MucGF0aCxcbiAgICAgICAgc2hhcmVJZDogZG9jLnNoYXJlSWQsXG4gICAgICAgIHBlcnNpc3RlbmNlSWQ6IGNyZWF0ZVJhbmRvbUlkKClcbiAgICAgIH0pXG4gICAgfVxuICAgIGlmKGRvYyBpbnN0YW5jZW9mIFNoYXJlZEZvbGRlcil7XG4gICAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS5hZGQoe1xuICAgICAgICBwYXRoOiBkb2MucGF0aCxcbiAgICAgICAgc2hhcmVJZDogZG9jLnNoYXJlSWQsXG4gICAgICAgIHBlcnNpc3RlbmNlSWQ6IGNyZWF0ZVJhbmRvbUlkKClcbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcmVtb3ZlRG9jKHBhdGg6IHN0cmluZykge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50VGFibGUuZGVsZXRlKHBhdGgpXG4gIH1cblxuICBhc3luYyBnZXREb2NCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUYWJsZS5nZXQocGF0aClcbiAgfVxuXG4gIGdldEFsbERvY3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnRUYWJsZS50b0FycmF5KClcbiAgfVxuXG4gIHJlbW92ZUZvbGRlcihwYXRoOiBzdHJpbmcpIHtcbiAgICByZXR1cm4gdGhpcy5mb2xkZXJUYWJsZS5kZWxldGUocGF0aClcbiAgfVxuXG4gIGdldEFsbEZvbGRlcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZGVyVGFibGUudG9BcnJheSgpXG4gIH1cblxuICBhc3luYyBnZXRGb2xkZXJCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9sZGVyVGFibGUuZ2V0KHBhdGgpXG4gIH1cblxuXG4gIGFzeW5jIGRlbGV0ZURCKCkge1xuICAgIHdpbmRvdy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5mb2xkZXJUYWJsZS5uYW1lKVxuICAgIHdpbmRvdy5pbmRleGVkREIuZGVsZXRlRGF0YWJhc2UodGhpcy5kb2N1bWVudFRhYmxlLm5hbWUpXG4gIH1cblxufSIsICJpbXBvcnQgeyByZXF1ZXN0VXJsIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vcGVlcmRyYWZ0UGx1Z2luXCJcbmltcG9ydCB7IHNob3dOb3RpY2UgfSBmcm9tIFwiLi91aVwiXG5cbmV4cG9ydCBjb25zdCByZXF1ZXN0TG9naW5Db2RlID0gYXN5bmMgKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luLCBlbWFpbDogc3RyaW5nKSA9PiB7XG5cbiAgY29uc3QgdXJsID0gbmV3IFVSTChcIi9ncm91cC9sb2dpbi9zZW5kLW1haWwtd2l0aC1jb2RlXCIsIHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCkudG9TdHJpbmcoKVxuXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGVtYWlsXG4gICAgfSlcbiAgfSkuanNvblxuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5vaykge1xuICAgIHJldHVyblxuICB9XG4gIHJldHVybiB0cnVlXG5cbn1cblxuXG5leHBvcnQgY29uc3QgcmVxdWVzdFdlYlRva2VuID0gYXN5bmMgKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luLCBlbWFpbDogc3RyaW5nLCB0b2tlbjogc3RyaW5nLCBsb25nTGl2ZWQ6IGJvb2xlYW4pID0+IHtcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKFwiL2dyb3VwL2xvZ2luL3ZlcmlmeS1jb2RlXCIsIHBsdWdpbi5zZXR0aW5ncy5iYXNlUGF0aCkudG9TdHJpbmcoKVxuXG4gIGNvbnN0IGRhdGEgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICB1cmwsXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgIGVtYWlsLCB0b2tlbiwgbG9uZ0xpdmVkXG4gICAgfSlcbiAgfSkuanNvblxuXG4gIGlmICghZGF0YSB8fCAhZGF0YS5qd3QpIHtcbiAgICByZXR1cm5cbiAgfVxuICByZXR1cm4gZGF0YS5qd3Rcbn1cblxuZXhwb3J0IGNvbnN0IHNhdmVKV1QgPSAob2lkOiBzdHJpbmcsIGp3dDogc3RyaW5nKSA9PiB7XG4gIGxvY2FsU3RvcmFnZS5zZXRJdGVtKG9pZCArIFwiLXBlZXJkcmFmdC1qd3RcIiwgand0KVxufVxuXG5leHBvcnQgY29uc3QgZ2V0SldUID0gKG9pZDogc3RyaW5nKSA9PiB7XG4gIHJldHVybiBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShvaWQgKyBcIi1wZWVyZHJhZnQtand0XCIpXG59XG5cbmV4cG9ydCBjb25zdCBjbGVhckpXVCA9IChvaWQ6IHN0cmluZykgPT4ge1xuICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShvaWQgKyBcIi1wZWVyZHJhZnQtand0XCIpXG59XG5cbmV4cG9ydCBjb25zdCBsb2dvdXQgPSAocGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcblxuICByZXR1cm4gbmV3IFByb21pc2U8dm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBjb25zdCBzZXJ2ZXIgPSBwbHVnaW4uc2VydmVyU3luY1xuICAgIGlmIChzZXJ2ZXIuYXV0aGVudGljYXRlZCkge1xuICAgICAgY29uc3QgaGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgY2xlYXJKV1QocGx1Z2luLnNldHRpbmdzLm9pZClcbiAgICAgICAgc2VydmVyLmp3dCA9IHVuZGVmaW5lZFxuICAgICAgICBzZXJ2ZXIub2ZmKCdjb25uZWN0aW9uLWNsb3NlJywgaGFuZGxlcilcbiAgICAgICAgc2hvd05vdGljZShcIkxvZ2dlZCBvdXQgb2YgUGVlcmRyYWZ0XCIpXG4gICAgICAgIHNlcnZlci5jb25uZWN0KClcbiAgICAgICAgcmVzb2x2ZSgpXG4gICAgICB9XG4gICAgICBzZXJ2ZXIub24oJ2Nvbm5lY3Rpb24tY2xvc2UnLCBoYW5kbGVyKVxuICAgICAgc2VydmVyLmRpc2Nvbm5lY3QoKVxuICAgIH1cbiAgfSlcbn0iLCAiaW1wb3J0IHsgTW9kYWwsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlcXVlc3RMb2dpbkNvZGUsIHJlcXVlc3RXZWJUb2tlbiwgc2F2ZUpXVCB9IGZyb20gXCJzcmMvbG9naW5cIjtcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcInNyYy9wZWVyZHJhZnRQbHVnaW5cIjtcbmltcG9ydCB7IHNhdmVTZXR0aW5ncyB9IGZyb20gXCJzcmMvc2V0dGluZ3NcIjtcbmltcG9ydCB7IHNob3dOb3RpY2UgfSBmcm9tIFwic3JjL3VpXCI7XG5cbmNsYXNzIExvZ2luTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cblxuICBwbHVnaW46IFBlZXJkcmFmdFBsdWdpblxuICBjYjogKHN1Y2Nlc3M6IGJvb2xlYW4pID0+IGFueVxuICBjYkNhbGxlZDogYm9vbGVhbiA9IGZhbHNlO1xuXG4gIHN0b3JlSldUID0gZmFsc2VcbiAgY29kZSA9ICcnXG4gIGVtYWlsID0gJydcblxuICBjb25zdHJ1Y3RvcihwbHVnaW46IFBlZXJkcmFmdFBsdWdpbiwgY2I6IChzdWNjZXNzOiBib29sZWFuKSA9PiBhbnkpIHtcbiAgICBzdXBlcihwbHVnaW4uYXBwKVxuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luXG4gICAgdGhpcy5jYiA9IGNiXG4gICAgdGhpcy5lbWFpbCA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnBsYW4uZW1haWwgPz8gJydcbiAgfVxuXG4gIGFzeW5jIG9uT3BlbigpIHtcbiAgICB0aGlzLmNvbnRlbnRFbC5lbXB0eSgpXG4gICAgY29uc3QgaGVhZGluZyA9IHRoaXMucGx1Z2luLnNldHRpbmdzLnBsYW4uZW1haWwgPyBcIkxvZyBpbiB0byB5b3VyIFBlZXJkcmFmdCBhY2NvdW50XCIgOiBcIkxvZyBpbiBvciByZWdpc3RlciB3aXRoIFBlZXJkcmFmdFwiXG4gICAgY29uc3QgaGVhZGVyU2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKS5zZXROYW1lKGhlYWRpbmcpIC8vLnNldEhlYWRpbmcoKS5zZXREZXNjKFwiXCIpXG5cbiAgICBjb25zdCBoZWFkZXJEaXYgPSBoZWFkZXJTZXR0aW5nLmRlc2NFbC5jcmVhdGVEaXYoKVxuXG4gICAgaGVhZGVyRGl2LmNyZWF0ZVNwYW4oeyB0ZXh0OiBcIlRvIGluaXRpYXRlIG5ldyBzaGFyZWQgZG9jdW1lbnRzIG9yIGZvbGRlcnMgeW91IG5lZWQgdG8gaGF2ZSBhIFBlZXJkcmFmdCBhY2NvdW50LiBDb2xsYWJvcmF0b3JzIGNhbiBqb2luIHdpdGhvdXQgcmVnaXN0cmF0aW9uLiBJZiB5b3UgbmVlZCBhbnkgaGVscCwgXCIgfSlcbiAgICBoZWFkZXJEaXYuY3JlYXRlRWwoXCJhXCIsIHtcbiAgICAgIHRleHQ6IFwiZ2V0IGluIHRvdWNoXCIsXG4gICAgICBhdHRyOiB7XG4gICAgICAgIGhyZWY6IFwibWFpbHRvOmRvbWluaWtAcGVlcmRyYWZ0LmFwcFwiXG4gICAgICB9XG4gICAgfSlcbiAgICBoZWFkZXJEaXYuY3JlYXRlU3Bhbih7IHRleHQ6ICcuJyB9KVxuXG4gICAgY29uc3QgZW1haWxTZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgZW1haWxTZXR0aW5nLnNldE5hbWUoXCJZb3VyIGUtbWFpbCBhZGRyZXNzXCIpXG4gICAgZW1haWxTZXR0aW5nLmRlc2NFbC5pbm5lckhUTUwgPSAnQnkgc2lnbmluZyB1cCBvciBsb2dnaW5nIGluLCB5b3UgYWdyZWUgdG8gPGEgaHJlZj1cImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHAvdGVybXNcIj50aGUgVGVybXMgb2YgU2VydmljZTwvYT4gYW5kIHRoZSA8YSBocmVmPVwiaHR0cHM6Ly93d3cucGVlcmRyYWZ0LmFwcC9wcml2YWN5XCI+UHJpdmFjeSBQb2xpY3k8L2E+LidcbiAgICBlbWFpbFNldHRpbmcuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgIHRleHQuaW5wdXRFbC5zZXRBdHRyKFwidHlwZVwiLCBcImVtYWlsXCIpXG4gICAgICB0ZXh0LnNldFZhbHVlKHRoaXMuZW1haWwpXG4gICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgdGhpcy5lbWFpbCA9IHZhbHVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBlbWFpbFNldHRpbmcuYWRkQnV0dG9uKGJ1dHRvbiA9PiB7XG4gICAgICBidXR0b24uc2V0QnV0dG9uVGV4dChcIlNlbmQgTG9naW4gQ29kZVwiKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoIXRoaXMuZW1haWwubWF0Y2goL15cXFMrQFxcUytcXC5cXFMrJC8pKSB7XG4gICAgICAgICAgc2hvd05vdGljZShcIlBsZWFzZSBlbnRlciBhIHZhbGlkIGVtYWlsIGFkZHJlc3MuXCIpXG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICBjb25zdCBjb2RlID0gYXdhaXQgcmVxdWVzdExvZ2luQ29kZSh0aGlzLnBsdWdpbiwgdGhpcy5lbWFpbClcblxuICAgICAgICAgIGlmIChjb2RlKSB7XG4gICAgICAgICAgICBzaG93Tm90aWNlKFwiQ29kZSBzZW50IHRvIFwiICsgdGhpcy5lbWFpbCArIFwiLlwiKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG93Tm90aWNlKFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4gb3IgZ2V0IGluIHRvdWNoIHdpdGggcGVlcmRyYWZ0IHN1cHBvcnQuXCIpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCByZW1lbWJlclNldHRpbmcgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICByZW1lbWJlclNldHRpbmcuc2V0TmFtZShcIlJlbWVtYmVyIG1lXCIpXG4gICAgcmVtZW1iZXJTZXR0aW5nLnNldERlc2MoXCJJZiBkaXNhYmxlZCwgeW91IHdpbGwgYmUgYXNrZWQgdG8gbG9nIGluIG9uIGV2ZXJ5IHJlc3RhcnQgb2YgT2JzaWRpYW4uXCIpXG4gICAgcmVtZW1iZXJTZXR0aW5nLmFkZFRvZ2dsZSgodG9nZ2wpID0+IHtcbiAgICAgIHRvZ2dsLnNldFZhbHVlKHRoaXMuc3RvcmVKV1QpXG4gICAgICB0b2dnbC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuc3RvcmVKV1QgPSB2YWx1ZVxuICAgICAgICB0aGlzLm9uT3BlbigpXG4gICAgICB9KVxuICAgIH0pXG5cblxuICAgIGNvbnN0IGNvZGVTZXR0aW5nID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgY29kZVNldHRpbmcuc2V0TmFtZShcIkxvZ2luIENvZGVcIilcbiAgICBjb2RlU2V0dGluZy5zZXREZXNjKFwiRW50ZXIgdGhlIGNvZGUgeW91IHJlY2VpdmVkIHZpYSBlbWFpbC5cIilcbiAgICBjb2RlU2V0dGluZy5hZGRUZXh0KHRleHQgPT4ge1xuICAgICAgdGV4dC5pbnB1dEVsLnNldEF0dHIoXCJ0eXBlXCIsIFwicGFzc3dvcmRcIilcbiAgICAgIHRleHQuc2V0VmFsdWUodGhpcy5jb2RlKVxuICAgICAgdGV4dC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMuY29kZSA9IHZhbHVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb2RlU2V0dGluZy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGNvbnN0IHRleHQgPSB0aGlzLnN0b3JlSldUID8gXCJMb2cgaW4gYW5kIHJlbWVtYmVyIG1lXCIgOiBcIkxvZyBpbiBmb3IgdGhpcyBzZXNzaW9uIG9ubHlcIlxuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQodGV4dClcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgaWYgKCF0aGlzLmVtYWlsLm1hdGNoKC9eXFxTK0BcXFMrXFwuXFxTKyQvKSkge1xuICAgICAgICAgIHNob3dOb3RpY2UoXCJQbGVhc2UgZW50ZXIgYSB2YWxpZCBlbWFpbCBhZGRyZXNzLlwiKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmNvZGUpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGp3dCA9IGF3YWl0IHJlcXVlc3RXZWJUb2tlbih0aGlzLnBsdWdpbiwgdGhpcy5lbWFpbCwgdGhpcy5jb2RlLCB0aGlzLnN0b3JlSldUKVxuXG5cbiAgICAgICAgaWYgKGp3dCkge1xuICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnBsYW4uZW1haWwgPSB0aGlzLmVtYWlsXG4gICAgICAgICAgc2F2ZVNldHRpbmdzKHRoaXMucGx1Z2luLnNldHRpbmdzLCB0aGlzLnBsdWdpbilcblxuICAgICAgICAgIGlmIChhd2FpdCB0aGlzLnBsdWdpbi5zZXJ2ZXJTeW5jLmF1dGhlbnRpY2F0ZShqd3QpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9yZUpXVCkge1xuICAgICAgICAgICAgICBzYXZlSldUKHRoaXMucGx1Z2luLnNldHRpbmdzLm9pZCwgand0KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jYih0cnVlKVxuICAgICAgICAgICAgdGhpcy5jYkNhbGxlZCA9IHRydWVcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaG93Tm90aWNlKFwiU29tZXRoaW5nIHdlbnQgd3JvbmcuIFBsZWFzZSB0cnkgYWdhaW4gb3IgZ2V0IGluIHRvdWNoIHdpdGggcGVlcmRyYWZ0IHN1cHBvcnQuXCIpXG4gICAgICAgIH1cbiAgICAgIH0pXG5cbiAgICB9KVxuXG4gIH1cblxuICBvbkNsb3NlID0gKCkgPT4ge1xuICAgIGlmICghdGhpcy5jYkNhbGxlZCkge1xuICAgICAgdGhpcy5jYihmYWxzZSlcbiAgICAgIHRoaXMuY2JDYWxsZWQgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBvcGVuTG9naW5Nb2RhbCA9IChwZWVyZHJhZnRQbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPigocmVzb2x2ZSkgPT4ge1xuICAgIG5ldyBMb2dpbk1vZGFsKHBlZXJkcmFmdFBsdWdpbiwgKGNiKSA9PiB7XG4gICAgICByZXNvbHZlKGNiKVxuICAgIH0pLm9wZW4oKVxuICB9KVxuXG59IiwgImltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRG9jdW1lbnRcIlxuaW1wb3J0IHsgY3JlYXRlUmFuZG9tSWQgfSBmcm9tIFwiLi90b29sc1wiXG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRFbnRpdHlcIlxuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSBcIi4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyXCJcbmltcG9ydCBQZWVyZHJhZnRQbHVnaW4gZnJvbSBcIi4vcGVlcmRyYWZ0UGx1Z2luXCJcbmltcG9ydCB7IHNhdmVTZXR0aW5ncyB9IGZyb20gXCIuL3NldHRpbmdzXCJcbmltcG9ydCB7IG5vcm1hbGl6ZVBhdGggfSBmcm9tIFwib2JzaWRpYW5cIlxuXG5leHBvcnQgaW50ZXJmYWNlIFBlcm1hbmVudFNoYXJlRG9jdW1lbnQge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUGVybWFuZW50U2hhcmVGb2xkZXIge1xuICBwYXRoOiBzdHJpbmcsIHBlcnNpc3RlbmNlSWQ6IHN0cmluZywgc2hhcmVJZDogc3RyaW5nXG59XG5cblxuZXhwb3J0IGNvbnN0IGFkZCA9IGFzeW5jIChkb2M6IFNoYXJlZEVudGl0eSwgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFNoYXJlZERvY3VtZW50KSB7XG4gICAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5zZXQoZG9jLnBhdGgsIHtcbiAgICAgIHNoYXJlSWQ6IGRvYy5zaGFyZUlkLFxuICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgIH0pXG4gIH1cbiAgaWYgKGRvYyBpbnN0YW5jZW9mIFNoYXJlZEZvbGRlcikge1xuICAgIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5zZXQoZG9jLnBhdGgsIHtcbiAgICAgIHNoYXJlSWQ6IGRvYy5zaGFyZUlkLFxuICAgICAgcGVyc2lzdGVuY2VJZDogY3JlYXRlUmFuZG9tSWQoKVxuICAgIH0pXG4gIH1cbiAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlRG9jID0gYXN5bmMgKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5maWxlcy5kZWxldGUobm9ybWFsaXplUGF0aChwYXRoKSlcbiAgc2F2ZVNldHRpbmdzKHBsdWdpbi5zZXR0aW5ncywgcGx1Z2luKVxufVxuXG5leHBvcnQgY29uc3QgZ2V0RG9jQnlQYXRoID0gKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXMuZ2V0KHBhdGgpXG59XG5cbmV4cG9ydCBjb25zdCBtb3ZlRG9jID0gYXN5bmMgKG9sZFBhdGg6IHN0cmluZywgbmV3UGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4ge1xuICBjb25zdCBmaWxlcyA9IHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZmlsZXNcbiAgY29uc3QgZW50cnkgPSBmaWxlcy5nZXQob2xkUGF0aClcbiAgaWYgKGVudHJ5KSB7XG4gICAgZmlsZXMuZGVsZXRlKG9sZFBhdGgpXG4gICAgZmlsZXMuc2V0KG5ld1BhdGgsIGVudHJ5KVxuICAgIHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVtb3ZlRm9sZGVyID0gYXN5bmMgKHBhdGg6IHN0cmluZywgcGx1Z2luOiBQZWVyZHJhZnRQbHVnaW4pID0+IHtcbiAgcGx1Z2luLnNldHRpbmdzLnNlcnZlclNoYXJlcy5mb2xkZXJzLmRlbGV0ZShwYXRoKVxuICBzYXZlU2V0dGluZ3MocGx1Z2luLnNldHRpbmdzLCBwbHVnaW4pXG59XG5cbmV4cG9ydCBjb25zdCBnZXRGb2xkZXJCeVBhdGggPSAocGF0aDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbikgPT4gIHtcbiAgcmV0dXJuIHBsdWdpbi5zZXR0aW5ncy5zZXJ2ZXJTaGFyZXMuZm9sZGVycy5nZXQocGF0aClcbn1cblxuZXhwb3J0IGNvbnN0IG1vdmVGb2xkZXIgPSBhc3luYyAob2xkUGF0aDogc3RyaW5nLCBuZXdQYXRoOiBzdHJpbmcsIHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG4gIGNvbnN0IG9sZFBhdGhOb3JtYWxpemVkID0gbm9ybWFsaXplUGF0aChvbGRQYXRoKVxuICBjb25zdCBuZXdQYXRoTm9ybWFsaXplZCA9IG5vcm1hbGl6ZVBhdGgobmV3UGF0aClcbiAgY29uc3QgZmlsZXMgPSBwbHVnaW4uc2V0dGluZ3Muc2VydmVyU2hhcmVzLmZvbGRlcnNcbiAgY29uc3QgZW50cnkgPSBmaWxlcy5nZXQob2xkUGF0aE5vcm1hbGl6ZWQpXG4gIGlmIChlbnRyeSkge1xuICAgIGZpbGVzLmRlbGV0ZShvbGRQYXRoTm9ybWFsaXplZClcbiAgICBmaWxlcy5zZXQobmV3UGF0aE5vcm1hbGl6ZWQsIGVudHJ5KVxuICAgIHNhdmVTZXR0aW5ncyhwbHVnaW4uc2V0dGluZ3MsIHBsdWdpbilcbiAgfVxufSIsICJpbXBvcnQgeyBBcHAsIE1vZGFsLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBTaGFyZWRGb2xkZXIgfSBmcm9tIFwic3JjL3NoYXJlZEVudGl0aWVzL3NoYXJlZEZvbGRlclwiO1xuaW1wb3J0IHsgc2hvd05vdGljZSB9IGZyb20gXCJzcmMvdWlcIjtcblxuY2xhc3MgU2hhcmVkRm9sZGVyT3B0aW9uc01vZGFsIGV4dGVuZHMgTW9kYWwge1xuXG4gIGZvbGRlcjogU2hhcmVkRm9sZGVyXG5cbiAgY29uc3RydWN0b3IoYXBwOiBBcHAsIGZvbGRlcjogU2hhcmVkRm9sZGVyKSB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuZm9sZGVyID0gZm9sZGVyXG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLnNldE5hbWUodGhpcy5mb2xkZXIuZ2V0T3JpZ2luYWxGb2xkZXJOYW1lKCkpLnNldEhlYWRpbmcoKVxuXG4gICAgLy8gRm9sZGVyIE5hbWVcbiAgICBjb25zdCBuYW1lU2V0dGluZyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuICAgIGxldCB0ZW1wTmFtZSA9IHRoaXMuZm9sZGVyLmdldE9yaWdpbmFsRm9sZGVyTmFtZSgpXG4gICAgbmFtZVNldHRpbmcuc2V0TmFtZShcIlBlZXJkcmFmdCBmb2xkZXIgbmFtZVwiKVxuICAgIG5hbWVTZXR0aW5nLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICB0ZXh0LnNldFZhbHVlKHRlbXBOYW1lKVxuICAgICAgdGV4dC5vbkNoYW5nZSh2YWx1ZSA9PiB7XG4gICAgICAgIHRlbXBOYW1lID0gdmFsdWVcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIG5hbWVTZXR0aW5nLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJVcGRhdGVcIilcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgaWYgKHRlbXBOYW1lICE9PSB0aGlzLmZvbGRlci5nZXRPcmlnaW5hbEZvbGRlck5hbWUoKSkge1xuICAgICAgICAgIHRoaXMuZm9sZGVyLnNldE9yaWdpbmFsRm9sZGVyTmFtZSh0ZW1wTmFtZSlcbiAgICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgICBvcGVuRm9sZGVyT3B0aW9ucyh0aGlzLmFwcCwgdGhpcy5mb2xkZXIpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIEFkZCBwZWVyZHJhZnQgcHJvcGVydHlcblxuICAgIGNvbnN0IHByb3AgPSBuZXcgU2V0dGluZyh0aGlzLmNvbnRlbnRFbClcbiAgICBwcm9wLnNldE5hbWUoXCJBdXRvIGFkZCBwcm9wZXJ0eSB3aXRoIFBlZXJkcmFmdCBVUkxcIilcbiAgICBwcm9wLnNldERlc2MoXCJMZWF2ZSBlbXB0eSBpZiBubyBwcm9wZXJ0eSBzaG91bGQgYmUgYWRkZWRcIilcbiAgICBsZXQgdGVtcFByb3AgPSB0aGlzLmZvbGRlci5nZXRBdXRvRmlsbFByb3BlcnR5KClcblxuICAgIHByb3AuYWRkVGV4dCh0ZXh0ID0+IHtcbiAgICAgIHRleHQuc2V0VmFsdWUodGVtcFByb3ApXG4gICAgICB0ZXh0Lm9uQ2hhbmdlKHZhbHVlID0+IHtcbiAgICAgICAgdGVtcFByb3AgPSB2YWx1ZVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgcHJvcC5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiVXBkYXRlICYgQXBwbHlcIilcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKGFzeW5jICgpID0+IHtcbiAgICAgICAgY29uc3Qgb2xkUHJvcGVydHkgPSB0aGlzLmZvbGRlci5nZXRBdXRvRmlsbFByb3BlcnR5KClcbiAgICAgICAgaWYgKHRlbXBQcm9wICE9PSBvbGRQcm9wZXJ0eSkge1xuICAgICAgICAgIHRoaXMuZm9sZGVyLnNldEF1dG9GaWxsUHJvcGVydHkodGVtcFByb3ApXG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm90aWNlID0gc2hvd05vdGljZShcIlVwZGF0aW5nIFVSTHMuLi5cIilcbiAgICAgICAgYXdhaXQgdGhpcy5mb2xkZXIudXBkYXRlUHJvcGVydGllc09mQWxsRG9jdW1lbnRzKG9sZFByb3BlcnR5KVxuICAgICAgICBub3RpY2UuaGlkZSgpXG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgICBvcGVuRm9sZGVyT3B0aW9ucyh0aGlzLmFwcCwgdGhpcy5mb2xkZXIpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCBsaW5rID0gbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpXG4gICAgbGluay5zZXROYW1lKFwiUGVlcmRyYWZ0IFVSTFwiKVxuICAgIGxpbmsuYWRkQnV0dG9uKGJ0biA9PiB7XG4gICAgICBidG4uc2V0QnV0dG9uVGV4dChcIkNvcHkgUGVlcmRyYWZ0IFVSTCB0byBjbGlwYm9hcmRcIilcbiAgICAgIGJ0bi5vbkNsaWNrKCgpPT4ge1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0aGlzLmZvbGRlci5nZXRTaGFyZVVSTCgpKVxuICAgICAgICBzaG93Tm90aWNlKFwiTGluayBjb3BpZWQgdG8gY2xpcGJvYXJkLlwiKVxuICAgICAgfSlcbiAgICB9KVxuXG5cbiAgfVxufVxuXG5leHBvcnQgY29uc3Qgb3BlbkZvbGRlck9wdGlvbnMgPSAoYXBwOiBBcHAsIGZvbGRlcjogU2hhcmVkRm9sZGVyKSA9PiB7XG4gIG5ldyBTaGFyZWRGb2xkZXJPcHRpb25zTW9kYWwoYXBwLCBmb2xkZXIpLm9wZW4oKVxufSIsICJjb25zdCBFX1RJTUVPVVQgPSBuZXcgRXJyb3IoJ3RpbWVvdXQgd2hpbGUgd2FpdGluZyBmb3IgbXV0ZXggdG8gYmVjb21lIGF2YWlsYWJsZScpO1xuY29uc3QgRV9BTFJFQURZX0xPQ0tFRCA9IG5ldyBFcnJvcignbXV0ZXggYWxyZWFkeSBsb2NrZWQnKTtcbmNvbnN0IEVfQ0FOQ0VMRUQgPSBuZXcgRXJyb3IoJ3JlcXVlc3QgZm9yIGxvY2sgY2FuY2VsZWQnKTtcblxudmFyIF9fYXdhaXRlciQyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5jbGFzcyBTZW1hcGhvcmUge1xuICAgIGNvbnN0cnVjdG9yKF92YWx1ZSwgX2NhbmNlbEVycm9yID0gRV9DQU5DRUxFRCkge1xuICAgICAgICB0aGlzLl92YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgdGhpcy5fY2FuY2VsRXJyb3IgPSBfY2FuY2VsRXJyb3I7XG4gICAgICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVycyA9IFtdO1xuICAgIH1cbiAgICBhY3F1aXJlKHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICBpZiAod2VpZ2h0IDw9IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgd2VpZ2h0ICR7d2VpZ2h0fTogbXVzdCBiZSBwb3NpdGl2ZWApO1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFzayA9IHsgcmVzb2x2ZSwgcmVqZWN0LCB3ZWlnaHQsIHByaW9yaXR5IH07XG4gICAgICAgICAgICBjb25zdCBpID0gZmluZEluZGV4RnJvbUVuZCh0aGlzLl9xdWV1ZSwgKG90aGVyKSA9PiBwcmlvcml0eSA8PSBvdGhlci5wcmlvcml0eSk7XG4gICAgICAgICAgICBpZiAoaSA9PT0gLTEgJiYgd2VpZ2h0IDw9IHRoaXMuX3ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gTmVlZHMgaW1tZWRpYXRlIGRpc3BhdGNoLCBza2lwIHRoZSBxdWV1ZVxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3F1ZXVlLnNwbGljZShpICsgMSwgMCwgdGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5FeGNsdXNpdmUoY2FsbGJhY2tfMSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyJDIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uKiAoY2FsbGJhY2ssIHdlaWdodCA9IDEsIHByaW9yaXR5ID0gMCkge1xuICAgICAgICAgICAgY29uc3QgW3ZhbHVlLCByZWxlYXNlXSA9IHlpZWxkIHRoaXMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRGb3JVbmxvY2sod2VpZ2h0ID0gMSwgcHJpb3JpdHkgPSAwKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIGlmICh0aGlzLl9jb3VsZExvY2tJbW1lZGlhdGVseSh3ZWlnaHQsIHByaW9yaXR5KSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgICAgIGluc2VydFNvcnRlZCh0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV0sIHsgcmVzb2x2ZSwgcHJpb3JpdHkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3ZhbHVlIDw9IDA7XG4gICAgfVxuICAgIGdldFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gICAgfVxuICAgIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3ZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoUXVldWUoKTtcbiAgICB9XG4gICAgcmVsZWFzZSh3ZWlnaHQgPSAxKSB7XG4gICAgICAgIGlmICh3ZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgIHRoaXMuX3ZhbHVlICs9IHdlaWdodDtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hRdWV1ZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHRoaXMuX3F1ZXVlLmZvckVhY2goKGVudHJ5KSA9PiBlbnRyeS5yZWplY3QodGhpcy5fY2FuY2VsRXJyb3IpKTtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICB9XG4gICAgX2Rpc3BhdGNoUXVldWUoKSB7XG4gICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB3aGlsZSAodGhpcy5fcXVldWUubGVuZ3RoID4gMCAmJiB0aGlzLl9xdWV1ZVswXS53ZWlnaHQgPD0gdGhpcy5fdmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoSXRlbSh0aGlzLl9xdWV1ZS5zaGlmdCgpKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYWluVW5sb2NrV2FpdGVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kaXNwYXRjaEl0ZW0oaXRlbSkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5fdmFsdWU7XG4gICAgICAgIHRoaXMuX3ZhbHVlIC09IGl0ZW0ud2VpZ2h0O1xuICAgICAgICBpdGVtLnJlc29sdmUoW3ByZXZpb3VzVmFsdWUsIHRoaXMuX25ld1JlbGVhc2VyKGl0ZW0ud2VpZ2h0KV0pO1xuICAgIH1cbiAgICBfbmV3UmVsZWFzZXIod2VpZ2h0KSB7XG4gICAgICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjYWxsZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucmVsZWFzZSh3ZWlnaHQpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBfZHJhaW5VbmxvY2tXYWl0ZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB3ZWlnaHQgPSB0aGlzLl92YWx1ZTsgd2VpZ2h0ID4gMDsgd2VpZ2h0LS0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB3YWl0ZXJzID0gdGhpcy5fd2VpZ2h0ZWRXYWl0ZXJzW3dlaWdodCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICghd2FpdGVycylcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgd2FpdGVycy5mb3JFYWNoKCh3YWl0ZXIpID0+IHdhaXRlci5yZXNvbHZlKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuX3dlaWdodGVkV2FpdGVyc1t3ZWlnaHQgLSAxXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcXVldWVkUHJpb3JpdHkgPSB0aGlzLl9xdWV1ZVswXS5wcmlvcml0eTtcbiAgICAgICAgICAgIGZvciAobGV0IHdlaWdodCA9IHRoaXMuX3ZhbHVlOyB3ZWlnaHQgPiAwOyB3ZWlnaHQtLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRlcnMgPSB0aGlzLl93ZWlnaHRlZFdhaXRlcnNbd2VpZ2h0IC0gMV07XG4gICAgICAgICAgICAgICAgaWYgKCF3YWl0ZXJzKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBpID0gd2FpdGVycy5maW5kSW5kZXgoKHdhaXRlcikgPT4gd2FpdGVyLnByaW9yaXR5IDw9IHF1ZXVlZFByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAoaSA9PT0gLTEgPyB3YWl0ZXJzIDogd2FpdGVycy5zcGxpY2UoMCwgaSkpXG4gICAgICAgICAgICAgICAgICAgIC5mb3JFYWNoKCh3YWl0ZXIgPT4gd2FpdGVyLnJlc29sdmUoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIF9jb3VsZExvY2tJbW1lZGlhdGVseSh3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwIHx8IHRoaXMuX3F1ZXVlWzBdLnByaW9yaXR5IDwgcHJpb3JpdHkpICYmXG4gICAgICAgICAgICB3ZWlnaHQgPD0gdGhpcy5fdmFsdWU7XG4gICAgfVxufVxuZnVuY3Rpb24gaW5zZXJ0U29ydGVkKGEsIHYpIHtcbiAgICBjb25zdCBpID0gZmluZEluZGV4RnJvbUVuZChhLCAob3RoZXIpID0+IHYucHJpb3JpdHkgPD0gb3RoZXIucHJpb3JpdHkpO1xuICAgIGEuc3BsaWNlKGkgKyAxLCAwLCB2KTtcbn1cbmZ1bmN0aW9uIGZpbmRJbmRleEZyb21FbmQoYSwgcHJlZGljYXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZShhW2ldKSkge1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG52YXIgX19hd2FpdGVyJDEgPSAodW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmNsYXNzIE11dGV4IHtcbiAgICBjb25zdHJ1Y3RvcihjYW5jZWxFcnJvcikge1xuICAgICAgICB0aGlzLl9zZW1hcGhvcmUgPSBuZXcgU2VtYXBob3JlKDEsIGNhbmNlbEVycm9yKTtcbiAgICB9XG4gICAgYWNxdWlyZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlciQxKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiogKHByaW9yaXR5ID0gMCkge1xuICAgICAgICAgICAgY29uc3QgWywgcmVsZWFzZXJdID0geWllbGQgdGhpcy5fc2VtYXBob3JlLmFjcXVpcmUoMSwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlbGVhc2VyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCBwcmlvcml0eSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5ydW5FeGNsdXNpdmUoKCkgPT4gY2FsbGJhY2soKSwgMSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICBpc0xvY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbWFwaG9yZS5pc0xvY2tlZCgpO1xuICAgIH1cbiAgICB3YWl0Rm9yVW5sb2NrKHByaW9yaXR5ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2VtYXBob3JlLndhaXRGb3JVbmxvY2soMSwgcHJpb3JpdHkpO1xuICAgIH1cbiAgICByZWxlYXNlKCkge1xuICAgICAgICBpZiAodGhpcy5fc2VtYXBob3JlLmlzTG9ja2VkKCkpXG4gICAgICAgICAgICB0aGlzLl9zZW1hcGhvcmUucmVsZWFzZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZW1hcGhvcmUuY2FuY2VsKCk7XG4gICAgfVxufVxuXG52YXIgX19hd2FpdGVyID0gKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiB3aXRoVGltZW91dChzeW5jLCB0aW1lb3V0LCB0aW1lb3V0RXJyb3IgPSBFX1RJTUVPVVQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3F1aXJlOiAod2VpZ2h0T3JQcmlvcml0eSwgcHJpb3JpdHkpID0+IHtcbiAgICAgICAgICAgIGxldCB3ZWlnaHQ7XG4gICAgICAgICAgICBpZiAoaXNTZW1hcGhvcmUoc3luYykpIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd2VpZ2h0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHByaW9yaXR5ID0gd2VpZ2h0T3JQcmlvcml0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh3ZWlnaHQgIT09IHVuZGVmaW5lZCAmJiB3ZWlnaHQgPD0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB3ZWlnaHQgJHt3ZWlnaHR9OiBtdXN0IGJlIHBvc2l0aXZlYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCBpc1RpbWVvdXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGUgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaXNUaW1lb3V0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRpbWVvdXRFcnJvcik7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGlja2V0ID0geWllbGQgKGlzU2VtYXBob3JlKHN5bmMpXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHN5bmMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBzeW5jLmFjcXVpcmUocHJpb3JpdHkpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsZWFzZSA9IEFycmF5LmlzQXJyYXkodGlja2V0KSA/IHRpY2tldFsxXSA6IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGVhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aWNrZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgcnVuRXhjbHVzaXZlKGNhbGxiYWNrLCB3ZWlnaHQsIHByaW9yaXR5KSB7XG4gICAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGxldCByZWxlYXNlID0gKCkgPT4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRpY2tldCA9IHlpZWxkIHRoaXMuYWNxdWlyZSh3ZWlnaHQsIHByaW9yaXR5KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGlja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjayh0aWNrZXRbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVsZWFzZSA9IHRpY2tldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICByZWxlYXNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbGVhc2Uod2VpZ2h0KSB7XG4gICAgICAgICAgICBzeW5jLnJlbGVhc2Uod2VpZ2h0KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsKCkge1xuICAgICAgICAgICAgcmV0dXJuIHN5bmMuY2FuY2VsKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdhaXRGb3JVbmxvY2s6ICh3ZWlnaHRPclByaW9yaXR5LCBwcmlvcml0eSkgPT4ge1xuICAgICAgICAgICAgbGV0IHdlaWdodDtcbiAgICAgICAgICAgIGlmIChpc1NlbWFwaG9yZShzeW5jKSkge1xuICAgICAgICAgICAgICAgIHdlaWdodCA9IHdlaWdodE9yUHJpb3JpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB3ZWlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcHJpb3JpdHkgPSB3ZWlnaHRPclByaW9yaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdlaWdodCAhPT0gdW5kZWZpbmVkICYmIHdlaWdodCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHdlaWdodCAke3dlaWdodH06IG11c3QgYmUgcG9zaXRpdmVgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiByZWplY3QodGltZW91dEVycm9yKSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgKGlzU2VtYXBob3JlKHN5bmMpXG4gICAgICAgICAgICAgICAgICAgID8gc3luYy53YWl0Rm9yVW5sb2NrKHdlaWdodCwgcHJpb3JpdHkpXG4gICAgICAgICAgICAgICAgICAgIDogc3luYy53YWl0Rm9yVW5sb2NrKHByaW9yaXR5KSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChoYW5kbGUpO1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgaXNMb2NrZWQ6ICgpID0+IHN5bmMuaXNMb2NrZWQoKSxcbiAgICAgICAgZ2V0VmFsdWU6ICgpID0+IHN5bmMuZ2V0VmFsdWUoKSxcbiAgICAgICAgc2V0VmFsdWU6ICh2YWx1ZSkgPT4gc3luYy5zZXRWYWx1ZSh2YWx1ZSksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGlzU2VtYXBob3JlKHN5bmMpIHtcbiAgICByZXR1cm4gc3luYy5nZXRWYWx1ZSAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpc25lIEB0eXBlc2NyaXB0LWVzbGludC9leHBsaWNpdC1tb2R1bGUtYm91bmRhcnktdHlwZXNcbmZ1bmN0aW9uIHRyeUFjcXVpcmUoc3luYywgYWxyZWFkeUFjcXVpcmVkRXJyb3IgPSBFX0FMUkVBRFlfTE9DS0VEKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gd2l0aFRpbWVvdXQoc3luYywgMCwgYWxyZWFkeUFjcXVpcmVkRXJyb3IpO1xufVxuXG5leHBvcnQgeyBFX0FMUkVBRFlfTE9DS0VELCBFX0NBTkNFTEVELCBFX1RJTUVPVVQsIE11dGV4LCBTZW1hcGhvcmUsIHRyeUFjcXVpcmUsIHdpdGhUaW1lb3V0IH07XG4iLCAiY29uc3QgZGVmYXVsdE9wdGlvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmZyZWV6ZSh7XG4gIGRpZmZUaW1lb3V0OiAxLFxuICBkaWZmRWRpdENvc3Q6IDQsXG4gIG1hdGNoVGhyZXNob2xkOiAwLjUsXG4gIG1hdGNoRGlzdGFuY2U6IDFlMyxcbiAgcGF0Y2hEZWxldGVUaHJlc2hvbGQ6IDAuNSxcbiAgcGF0Y2hNYXJnaW46IDQsXG4gIG1hdGNoTWF4Qml0czogMzJcbn0pO1xuZnVuY3Rpb24gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAob3B0aW9ucz8uX19yZXNvbHZlZClcbiAgICByZXR1cm4gb3B0aW9ucztcbiAgY29uc3QgcmVzb2x2ZWQgPSB7XG4gICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgLi4ub3B0aW9uc1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzb2x2ZWQsIFwiX19yZXNvbHZlZFwiLCB7IHZhbHVlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSB9KTtcbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5jb25zdCBESUZGX0RFTEVURSA9IC0xO1xuY29uc3QgRElGRl9JTlNFUlQgPSAxO1xuY29uc3QgRElGRl9FUVVBTCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVEaWZmKG9wLCB0ZXh0KSB7XG4gIHJldHVybiBbb3AsIHRleHRdO1xufVxuZnVuY3Rpb24gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBvcHRfY2hlY2tsaW5lcyA9IHRydWUsIG9wdF9kZWFkbGluZSkge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAodHlwZW9mIG9wdF9kZWFkbGluZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgaWYgKHJlc29sdmVkLmRpZmZUaW1lb3V0IDw9IDApXG4gICAgICBvcHRfZGVhZGxpbmUgPSBOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIGVsc2VcbiAgICAgIG9wdF9kZWFkbGluZSA9ICgvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSkuZ2V0VGltZSgpICsgcmVzb2x2ZWQuZGlmZlRpbWVvdXQgKiAxZTM7XG4gIH1cbiAgY29uc3QgZGVhZGxpbmUgPSBvcHRfZGVhZGxpbmU7XG4gIGlmICh0ZXh0MSA9PSBudWxsIHx8IHRleHQyID09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKGRpZmZfbWFpbilcIik7XG4gIGlmICh0ZXh0MSA9PT0gdGV4dDIpIHtcbiAgICBpZiAodGV4dDEpXG4gICAgICByZXR1cm4gW2NyZWF0ZURpZmYoRElGRl9FUVVBTCwgdGV4dDEpXTtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgY29uc3QgY2hlY2tsaW5lcyA9IG9wdF9jaGVja2xpbmVzO1xuICBsZXQgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblByZWZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25wcmVmaXggPSB0ZXh0MS5zdWJzdHJpbmcoMCwgY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoY29tbW9ubGVuZ3RoKTtcbiAgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblN1ZmZpeCh0ZXh0MSwgdGV4dDIpO1xuICBjb25zdCBjb21tb25zdWZmaXggPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcoMCwgdGV4dDEubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgdGV4dDIgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgdGV4dDIubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgY29uc3QgZGlmZnMgPSBkaWZmQ29tcHV0ZSh0ZXh0MSwgdGV4dDIsIHJlc29sdmVkLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gIGlmIChjb21tb25wcmVmaXgpXG4gICAgZGlmZnMudW5zaGlmdChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGNvbW1vbnByZWZpeCkpO1xuICBpZiAoY29tbW9uc3VmZml4KVxuICAgIGRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBjb21tb25zdWZmaXgpKTtcbiAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG4gIHJldHVybiBkaWZmcztcbn1cbmZ1bmN0aW9uIGRpZmZDb21wdXRlKHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgY2hlY2tsaW5lcywgZGVhZGxpbmUpIHtcbiAgbGV0IGRpZmZzO1xuICBpZiAoIXRleHQxKSB7XG4gICAgcmV0dXJuIFtjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG4gIGlmICghdGV4dDIpIHtcbiAgICByZXR1cm4gW2NyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHQxKV07XG4gIH1cbiAgY29uc3QgbG9uZ3RleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MSA6IHRleHQyO1xuICBjb25zdCBzaG9ydHRleHQgPSB0ZXh0MS5sZW5ndGggPiB0ZXh0Mi5sZW5ndGggPyB0ZXh0MiA6IHRleHQxO1xuICBjb25zdCBpID0gbG9uZ3RleHQuaW5kZXhPZihzaG9ydHRleHQpO1xuICBpZiAoaSAhPT0gLTEpIHtcbiAgICBkaWZmcyA9IFtjcmVhdGVEaWZmKERJRkZfSU5TRVJULCBsb25ndGV4dC5zdWJzdHJpbmcoMCwgaSkpLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHNob3J0dGV4dCksIGNyZWF0ZURpZmYoRElGRl9JTlNFUlQsIGxvbmd0ZXh0LnN1YnN0cmluZyhpICsgc2hvcnR0ZXh0Lmxlbmd0aCkpXTtcbiAgICBpZiAodGV4dDEubGVuZ3RoID4gdGV4dDIubGVuZ3RoKVxuICAgICAgZGlmZnNbMF1bMF0gPSBkaWZmc1syXVswXSA9IERJRkZfREVMRVRFO1xuICAgIHJldHVybiBkaWZmcztcbiAgfVxuICBpZiAoc2hvcnR0ZXh0Lmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dDEpLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xuICB9XG4gIGNvbnN0IGhtID0gZGlmZkhhbGZNYXRjaCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMpO1xuICBpZiAoaG0pIHtcbiAgICBjb25zdCB0ZXh0MV9hID0gaG1bMF07XG4gICAgY29uc3QgdGV4dDFfYiA9IGhtWzFdO1xuICAgIGNvbnN0IHRleHQyX2EgPSBobVsyXTtcbiAgICBjb25zdCB0ZXh0Ml9iID0gaG1bM107XG4gICAgY29uc3QgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICAgIGNvbnN0IGRpZmZzX2EgPSBkaWZmTWFpbih0ZXh0MV9hLCB0ZXh0Ml9hLCBvcHRpb25zLCBjaGVja2xpbmVzLCBkZWFkbGluZSk7XG4gICAgY29uc3QgZGlmZnNfYiA9IGRpZmZNYWluKHRleHQxX2IsIHRleHQyX2IsIG9wdGlvbnMsIGNoZWNrbGluZXMsIGRlYWRsaW5lKTtcbiAgICByZXR1cm4gZGlmZnNfYS5jb25jYXQoW2NyZWF0ZURpZmYoRElGRl9FUVVBTCwgbWlkX2NvbW1vbildLCBkaWZmc19iKTtcbiAgfVxuICBpZiAoY2hlY2tsaW5lcyAmJiB0ZXh0MS5sZW5ndGggPiAxMDAgJiYgdGV4dDIubGVuZ3RoID4gMTAwKVxuICAgIHJldHVybiBkaWZmTGluZU1vZGUodGV4dDEsIHRleHQyLCBvcHRpb25zLCBkZWFkbGluZSk7XG4gIHJldHVybiBkaWZmQmlzZWN0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgZGVhZGxpbmUpO1xufVxuZnVuY3Rpb24gZGlmZkxpbmVNb2RlKHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgZGVhZGxpbmUpIHtcbiAgY29uc3QgYSA9IGRpZmZMaW5lc1RvQ2hhcnModGV4dDEsIHRleHQyKTtcbiAgdGV4dDEgPSBhLmNoYXJzMTtcbiAgdGV4dDIgPSBhLmNoYXJzMjtcbiAgY29uc3QgbGluZWFycmF5ID0gYS5saW5lQXJyYXk7XG4gIGNvbnN0IGRpZmZzID0gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBmYWxzZSwgZGVhZGxpbmUpO1xuICBkaWZmQ2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lYXJyYXkpO1xuICBkaWZmQ2xlYW51cFNlbWFudGljKGRpZmZzKTtcbiAgZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIFwiXCIpKTtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgY291bnRfZGVsZXRlID0gMDtcbiAgbGV0IGNvdW50X2luc2VydCA9IDA7XG4gIGxldCB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gIGxldCB0ZXh0X2luc2VydCA9IFwiXCI7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgc3dpdGNoIChkaWZmc1twb2ludGVyXVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgY291bnRfaW5zZXJ0Kys7XG4gICAgICAgIHRleHRfaW5zZXJ0ICs9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChjb3VudF9kZWxldGUgPj0gMSAmJiBjb3VudF9pbnNlcnQgPj0gMSkge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0LCBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQpO1xuICAgICAgICAgIHBvaW50ZXIgPSBwb2ludGVyIC0gY291bnRfZGVsZXRlIC0gY291bnRfaW5zZXJ0O1xuICAgICAgICAgIGNvbnN0IHN1YkRpZmYgPSBkaWZmTWFpbih0ZXh0X2RlbGV0ZSwgdGV4dF9pbnNlcnQsIG9wdGlvbnMsIGZhbHNlLCBkZWFkbGluZSk7XG4gICAgICAgICAgZm9yIChsZXQgaiA9IHN1YkRpZmYubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG4gICAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgc3ViRGlmZltqXSk7XG4gICAgICAgICAgcG9pbnRlciA9IHBvaW50ZXIgKyBzdWJEaWZmLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxuICBkaWZmcy5wb3AoKTtcbiAgcmV0dXJuIGRpZmZzO1xufVxuZnVuY3Rpb24gZGlmZkJpc2VjdCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIGRlYWRsaW5lKSB7XG4gIGNvbnN0IHRleHQxX2xlbmd0aCA9IHRleHQxLmxlbmd0aDtcbiAgY29uc3QgdGV4dDJfbGVuZ3RoID0gdGV4dDIubGVuZ3RoO1xuICBjb25zdCBtYXhfZCA9IE1hdGguY2VpbCgodGV4dDFfbGVuZ3RoICsgdGV4dDJfbGVuZ3RoKSAvIDIpO1xuICBjb25zdCB2X29mZnNldCA9IG1heF9kO1xuICBjb25zdCB2X2xlbmd0aCA9IDIgKiBtYXhfZDtcbiAgY29uc3QgdjEgPSBuZXcgQXJyYXkodl9sZW5ndGgpO1xuICBjb25zdCB2MiA9IG5ldyBBcnJheSh2X2xlbmd0aCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgdl9sZW5ndGg7IHgrKykge1xuICAgIHYxW3hdID0gLTE7XG4gICAgdjJbeF0gPSAtMTtcbiAgfVxuICB2MVt2X29mZnNldCArIDFdID0gMDtcbiAgdjJbdl9vZmZzZXQgKyAxXSA9IDA7XG4gIGNvbnN0IGRlbHRhID0gdGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoO1xuICBjb25zdCBmcm9udCA9IGRlbHRhICUgMiAhPT0gMDtcbiAgbGV0IGsxc3RhcnQgPSAwO1xuICBsZXQgazFlbmQgPSAwO1xuICBsZXQgazJzdGFydCA9IDA7XG4gIGxldCBrMmVuZCA9IDA7XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgbWF4X2Q7IGQrKykge1xuICAgIGlmICgoLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCkpLmdldFRpbWUoKSA+IGRlYWRsaW5lKVxuICAgICAgYnJlYWs7XG4gICAgZm9yIChsZXQgazEgPSAtZCArIGsxc3RhcnQ7IGsxIDw9IGQgLSBrMWVuZDsgazEgKz0gMikge1xuICAgICAgY29uc3QgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBrMTtcbiAgICAgIGxldCB4MTtcbiAgICAgIGlmIChrMSA9PT0gLWQgfHwgazEgIT09IGQgJiYgdjFbazFfb2Zmc2V0IC0gMV0gPCB2MVtrMV9vZmZzZXQgKyAxXSlcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgKyAxXTtcbiAgICAgIGVsc2VcbiAgICAgICAgeDEgPSB2MVtrMV9vZmZzZXQgLSAxXSArIDE7XG4gICAgICBsZXQgeTEgPSB4MSAtIGsxO1xuICAgICAgd2hpbGUgKHgxIDwgdGV4dDFfbGVuZ3RoICYmIHkxIDwgdGV4dDJfbGVuZ3RoICYmIHRleHQxLmNoYXJBdCh4MSkgPT09IHRleHQyLmNoYXJBdCh5MSkpIHtcbiAgICAgICAgeDErKztcbiAgICAgICAgeTErKztcbiAgICAgIH1cbiAgICAgIHYxW2sxX29mZnNldF0gPSB4MTtcbiAgICAgIGlmICh4MSA+IHRleHQxX2xlbmd0aCkge1xuICAgICAgICBrMWVuZCArPSAyO1xuICAgICAgfSBlbHNlIGlmICh5MSA+IHRleHQyX2xlbmd0aCkge1xuICAgICAgICBrMXN0YXJ0ICs9IDI7XG4gICAgICB9IGVsc2UgaWYgKGZyb250KSB7XG4gICAgICAgIGNvbnN0IGsyX29mZnNldCA9IHZfb2Zmc2V0ICsgZGVsdGEgLSBrMTtcbiAgICAgICAgaWYgKGsyX29mZnNldCA+PSAwICYmIGsyX29mZnNldCA8IHZfbGVuZ3RoICYmIHYyW2syX29mZnNldF0gIT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgeDIgPSB0ZXh0MV9sZW5ndGggLSB2MltrMl9vZmZzZXRdO1xuICAgICAgICAgIGlmICh4MSA+PSB4Mikge1xuICAgICAgICAgICAgcmV0dXJuIGRpZmZCaXNlY3RTcGxpdCh0ZXh0MSwgdGV4dDIsIG9wdGlvbnMsIHgxLCB5MSwgZGVhZGxpbmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBrMiA9IC1kICsgazJzdGFydDsgazIgPD0gZCAtIGsyZW5kOyBrMiArPSAyKSB7XG4gICAgICBjb25zdCBrMl9vZmZzZXQgPSB2X29mZnNldCArIGsyO1xuICAgICAgbGV0IHgyO1xuICAgICAgaWYgKGsyID09PSAtZCB8fCBrMiAhPT0gZCAmJiB2MltrMl9vZmZzZXQgLSAxXSA8IHYyW2syX29mZnNldCArIDFdKVxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCArIDFdO1xuICAgICAgZWxzZVxuICAgICAgICB4MiA9IHYyW2syX29mZnNldCAtIDFdICsgMTtcbiAgICAgIGxldCB5MiA9IHgyIC0gazI7XG4gICAgICB3aGlsZSAoeDIgPCB0ZXh0MV9sZW5ndGggJiYgeTIgPCB0ZXh0Ml9sZW5ndGggJiYgdGV4dDEuY2hhckF0KHRleHQxX2xlbmd0aCAtIHgyIC0gMSkgPT09IHRleHQyLmNoYXJBdCh0ZXh0Ml9sZW5ndGggLSB5MiAtIDEpKSB7XG4gICAgICAgIHgyKys7XG4gICAgICAgIHkyKys7XG4gICAgICB9XG4gICAgICB2MltrMl9vZmZzZXRdID0geDI7XG4gICAgICBpZiAoeDIgPiB0ZXh0MV9sZW5ndGgpIHtcbiAgICAgICAgazJlbmQgKz0gMjtcbiAgICAgIH0gZWxzZSBpZiAoeTIgPiB0ZXh0Ml9sZW5ndGgpIHtcbiAgICAgICAgazJzdGFydCArPSAyO1xuICAgICAgfSBlbHNlIGlmICghZnJvbnQpIHtcbiAgICAgICAgY29uc3QgazFfb2Zmc2V0ID0gdl9vZmZzZXQgKyBkZWx0YSAtIGsyO1xuICAgICAgICBpZiAoazFfb2Zmc2V0ID49IDAgJiYgazFfb2Zmc2V0IDwgdl9sZW5ndGggJiYgdjFbazFfb2Zmc2V0XSAhPT0gLTEpIHtcbiAgICAgICAgICBjb25zdCB4MSA9IHYxW2sxX29mZnNldF07XG4gICAgICAgICAgY29uc3QgeTEgPSB2X29mZnNldCArIHgxIC0gazFfb2Zmc2V0O1xuICAgICAgICAgIHgyID0gdGV4dDFfbGVuZ3RoIC0geDI7XG4gICAgICAgICAgaWYgKHgxID49IHgyKSB7XG4gICAgICAgICAgICByZXR1cm4gZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgeDEsIHkxLCBkZWFkbGluZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBbY3JlYXRlRGlmZihESUZGX0RFTEVURSwgdGV4dDEpLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0MildO1xufVxuZnVuY3Rpb24gZGlmZkJpc2VjdFNwbGl0KHRleHQxLCB0ZXh0Miwgb3B0aW9ucywgeCwgeSwgZGVhZGxpbmUpIHtcbiAgY29uc3QgdGV4dDFhID0gdGV4dDEuc3Vic3RyaW5nKDAsIHgpO1xuICBjb25zdCB0ZXh0MmEgPSB0ZXh0Mi5zdWJzdHJpbmcoMCwgeSk7XG4gIGNvbnN0IHRleHQxYiA9IHRleHQxLnN1YnN0cmluZyh4KTtcbiAgY29uc3QgdGV4dDJiID0gdGV4dDIuc3Vic3RyaW5nKHkpO1xuICBjb25zdCBkaWZmcyA9IGRpZmZNYWluKHRleHQxYSwgdGV4dDJhLCBvcHRpb25zLCBmYWxzZSwgZGVhZGxpbmUpO1xuICBjb25zdCBkaWZmc2IgPSBkaWZmTWFpbih0ZXh0MWIsIHRleHQyYiwgb3B0aW9ucywgZmFsc2UsIGRlYWRsaW5lKTtcbiAgcmV0dXJuIGRpZmZzLmNvbmNhdChkaWZmc2IpO1xufVxuZnVuY3Rpb24gZGlmZkxpbmVzVG9DaGFycyh0ZXh0MSwgdGV4dDIpIHtcbiAgY29uc3QgbGluZUFycmF5ID0gW107XG4gIGNvbnN0IGxpbmVIYXNoID0ge307XG4gIGxldCBtYXhMaW5lcyA9IDRlNDtcbiAgbGluZUFycmF5WzBdID0gXCJcIjtcbiAgZnVuY3Rpb24gZGlmZkxpbmVzVG9DaGFyc011bmdlKHRleHQpIHtcbiAgICBsZXQgY2hhcnMgPSBcIlwiO1xuICAgIGxldCBsaW5lU3RhcnQgPSAwO1xuICAgIGxldCBsaW5lRW5kID0gLTE7XG4gICAgbGV0IGxpbmVBcnJheUxlbmd0aCA9IGxpbmVBcnJheS5sZW5ndGg7XG4gICAgd2hpbGUgKGxpbmVFbmQgPCB0ZXh0Lmxlbmd0aCAtIDEpIHtcbiAgICAgIGxpbmVFbmQgPSB0ZXh0LmluZGV4T2YoXCJcXG5cIiwgbGluZVN0YXJ0KTtcbiAgICAgIGlmIChsaW5lRW5kID09PSAtMSlcbiAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoIC0gMTtcbiAgICAgIGxldCBsaW5lID0gdGV4dC5zdWJzdHJpbmcobGluZVN0YXJ0LCBsaW5lRW5kICsgMSk7XG4gICAgICBpZiAobGluZUhhc2guaGFzT3duUHJvcGVydHkgPyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGluZUhhc2gsIGxpbmUpIDogbGluZUhhc2hbbGluZV0gIT09IHZvaWQgMCkge1xuICAgICAgICBjaGFycyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxpbmVIYXNoW2xpbmVdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChsaW5lQXJyYXlMZW5ndGggPT09IG1heExpbmVzKSB7XG4gICAgICAgICAgbGluZSA9IHRleHQuc3Vic3RyaW5nKGxpbmVTdGFydCk7XG4gICAgICAgICAgbGluZUVuZCA9IHRleHQubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNoYXJzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUobGluZUFycmF5TGVuZ3RoKTtcbiAgICAgICAgbGluZUhhc2hbbGluZV0gPSBsaW5lQXJyYXlMZW5ndGg7XG4gICAgICAgIGxpbmVBcnJheVtsaW5lQXJyYXlMZW5ndGgrK10gPSBsaW5lO1xuICAgICAgfVxuICAgICAgbGluZVN0YXJ0ID0gbGluZUVuZCArIDE7XG4gICAgfVxuICAgIHJldHVybiBjaGFycztcbiAgfVxuICBjb25zdCBjaGFyczEgPSBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dDEpO1xuICBtYXhMaW5lcyA9IDY1NTM1O1xuICBjb25zdCBjaGFyczIgPSBkaWZmTGluZXNUb0NoYXJzTXVuZ2UodGV4dDIpO1xuICByZXR1cm4geyBjaGFyczEsIGNoYXJzMiwgbGluZUFycmF5IH07XG59XG5mdW5jdGlvbiBkaWZmQ2hhcnNUb0xpbmVzKGRpZmZzLCBsaW5lQXJyYXkpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXJzID0gZGlmZnNbaV1bMV07XG4gICAgY29uc3QgdGV4dCA9IFtdO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgY2hhcnMubGVuZ3RoOyBqKyspXG4gICAgICB0ZXh0W2pdID0gbGluZUFycmF5W2NoYXJzLmNoYXJDb2RlQXQoaildO1xuICAgIGRpZmZzW2ldWzFdID0gdGV4dC5qb2luKFwiXCIpO1xuICB9XG59XG5mdW5jdGlvbiBkaWZmQ29tbW9uUHJlZml4KHRleHQxLCB0ZXh0Mikge1xuICBpZiAoIXRleHQxIHx8ICF0ZXh0MiB8fCB0ZXh0MS5jaGFyQXQoMCkgIT09IHRleHQyLmNoYXJBdCgwKSlcbiAgICByZXR1cm4gMDtcbiAgbGV0IHBvaW50ZXJtaW4gPSAwO1xuICBsZXQgcG9pbnRlcm1heCA9IE1hdGgubWluKHRleHQxLmxlbmd0aCwgdGV4dDIubGVuZ3RoKTtcbiAgbGV0IHBvaW50ZXJtaWQgPSBwb2ludGVybWF4O1xuICBsZXQgcG9pbnRlcnN0YXJ0ID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyhwb2ludGVyc3RhcnQsIHBvaW50ZXJtaWQpID09PSB0ZXh0Mi5zdWJzdHJpbmcocG9pbnRlcnN0YXJ0LCBwb2ludGVybWlkKSkge1xuICAgICAgcG9pbnRlcm1pbiA9IHBvaW50ZXJtaWQ7XG4gICAgICBwb2ludGVyc3RhcnQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn1cbmZ1bmN0aW9uIGRpZmZDb21tb25TdWZmaXgodGV4dDEsIHRleHQyKSB7XG4gIGlmICghdGV4dDEgfHwgIXRleHQyIHx8IHRleHQxLmNoYXJBdCh0ZXh0MS5sZW5ndGggLSAxKSAhPT0gdGV4dDIuY2hhckF0KHRleHQyLmxlbmd0aCAtIDEpKVxuICAgIHJldHVybiAwO1xuICBsZXQgcG9pbnRlcm1pbiA9IDA7XG4gIGxldCBwb2ludGVybWF4ID0gTWF0aC5taW4odGV4dDEubGVuZ3RoLCB0ZXh0Mi5sZW5ndGgpO1xuICBsZXQgcG9pbnRlcm1pZCA9IHBvaW50ZXJtYXg7XG4gIGxldCBwb2ludGVyZW5kID0gMDtcbiAgd2hpbGUgKHBvaW50ZXJtaW4gPCBwb2ludGVybWlkKSB7XG4gICAgaWYgKHRleHQxLnN1YnN0cmluZyh0ZXh0MS5sZW5ndGggLSBwb2ludGVybWlkLCB0ZXh0MS5sZW5ndGggLSBwb2ludGVyZW5kKSA9PT0gdGV4dDIuc3Vic3RyaW5nKHRleHQyLmxlbmd0aCAtIHBvaW50ZXJtaWQsIHRleHQyLmxlbmd0aCAtIHBvaW50ZXJlbmQpKSB7XG4gICAgICBwb2ludGVybWluID0gcG9pbnRlcm1pZDtcbiAgICAgIHBvaW50ZXJlbmQgPSBwb2ludGVybWluO1xuICAgIH0gZWxzZSB7XG4gICAgICBwb2ludGVybWF4ID0gcG9pbnRlcm1pZDtcbiAgICB9XG4gICAgcG9pbnRlcm1pZCA9IE1hdGguZmxvb3IoKHBvaW50ZXJtYXggLSBwb2ludGVybWluKSAvIDIgKyBwb2ludGVybWluKTtcbiAgfVxuICByZXR1cm4gcG9pbnRlcm1pZDtcbn1cbmZ1bmN0aW9uIGRpZmZDb21tb25PdmVybGFwKHRleHQxLCB0ZXh0Mikge1xuICBjb25zdCB0ZXh0MV9sZW5ndGggPSB0ZXh0MS5sZW5ndGg7XG4gIGNvbnN0IHRleHQyX2xlbmd0aCA9IHRleHQyLmxlbmd0aDtcbiAgaWYgKHRleHQxX2xlbmd0aCA9PT0gMCB8fCB0ZXh0Ml9sZW5ndGggPT09IDApXG4gICAgcmV0dXJuIDA7XG4gIGlmICh0ZXh0MV9sZW5ndGggPiB0ZXh0Ml9sZW5ndGgpXG4gICAgdGV4dDEgPSB0ZXh0MS5zdWJzdHJpbmcodGV4dDFfbGVuZ3RoIC0gdGV4dDJfbGVuZ3RoKTtcbiAgZWxzZSBpZiAodGV4dDFfbGVuZ3RoIDwgdGV4dDJfbGVuZ3RoKVxuICAgIHRleHQyID0gdGV4dDIuc3Vic3RyaW5nKDAsIHRleHQxX2xlbmd0aCk7XG4gIGNvbnN0IHRleHRfbGVuZ3RoID0gTWF0aC5taW4odGV4dDFfbGVuZ3RoLCB0ZXh0Ml9sZW5ndGgpO1xuICBpZiAodGV4dDEgPT09IHRleHQyKVxuICAgIHJldHVybiB0ZXh0X2xlbmd0aDtcbiAgbGV0IGJlc3QgPSAwO1xuICBsZXQgbGVuZ3RoID0gMTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKTtcbiAgICBjb25zdCBmb3VuZCA9IHRleHQyLmluZGV4T2YocGF0dGVybik7XG4gICAgaWYgKGZvdW5kID09PSAtMSlcbiAgICAgIHJldHVybiBiZXN0O1xuICAgIGxlbmd0aCArPSBmb3VuZDtcbiAgICBpZiAoZm91bmQgPT09IDAgfHwgdGV4dDEuc3Vic3RyaW5nKHRleHRfbGVuZ3RoIC0gbGVuZ3RoKSA9PT0gdGV4dDIuc3Vic3RyaW5nKDAsIGxlbmd0aCkpIHtcbiAgICAgIGJlc3QgPSBsZW5ndGg7XG4gICAgICBsZW5ndGgrKztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZmZIYWxmTWF0Y2godGV4dDEsIHRleHQyLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zLmRpZmZUaW1lb3V0IDw9IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBsb25ndGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQxIDogdGV4dDI7XG4gIGNvbnN0IHNob3J0dGV4dCA9IHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCA/IHRleHQyIDogdGV4dDE7XG4gIGlmIChsb25ndGV4dC5sZW5ndGggPCA0IHx8IHNob3J0dGV4dC5sZW5ndGggKiAyIDwgbG9uZ3RleHQubGVuZ3RoKVxuICAgIHJldHVybiBudWxsO1xuICBmdW5jdGlvbiBkaWZmSGFsZk1hdGNoSShsb25ndGV4dDIsIHNob3J0dGV4dDIsIGkpIHtcbiAgICBjb25zdCBzZWVkID0gbG9uZ3RleHQyLnN1YnN0cmluZyhpLCBpICsgTWF0aC5mbG9vcihsb25ndGV4dDIubGVuZ3RoIC8gNCkpO1xuICAgIGxldCBqID0gLTE7XG4gICAgbGV0IGJlc3RfY29tbW9uID0gXCJcIjtcbiAgICBsZXQgYmVzdF9sb25ndGV4dF9hLCBiZXN0X2xvbmd0ZXh0X2IsIGJlc3Rfc2hvcnR0ZXh0X2EsIGJlc3Rfc2hvcnR0ZXh0X2I7XG4gICAgd2hpbGUgKChqID0gc2hvcnR0ZXh0Mi5pbmRleE9mKHNlZWQsIGogKyAxKSkgIT09IC0xKSB7XG4gICAgICBjb25zdCBwcmVmaXhMZW5ndGggPSBkaWZmQ29tbW9uUHJlZml4KGxvbmd0ZXh0Mi5zdWJzdHJpbmcoaSksIHNob3J0dGV4dDIuc3Vic3RyaW5nKGopKTtcbiAgICAgIGNvbnN0IHN1ZmZpeExlbmd0aCA9IGRpZmZDb21tb25TdWZmaXgobG9uZ3RleHQyLnN1YnN0cmluZygwLCBpKSwgc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoMCwgaikpO1xuICAgICAgaWYgKGJlc3RfY29tbW9uLmxlbmd0aCA8IHN1ZmZpeExlbmd0aCArIHByZWZpeExlbmd0aCkge1xuICAgICAgICBiZXN0X2NvbW1vbiA9IHNob3J0dGV4dDIuc3Vic3RyaW5nKGogLSBzdWZmaXhMZW5ndGgsIGopICsgc2hvcnR0ZXh0Mi5zdWJzdHJpbmcoaiwgaiArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYSA9IGxvbmd0ZXh0Mi5zdWJzdHJpbmcoMCwgaSAtIHN1ZmZpeExlbmd0aCk7XG4gICAgICAgIGJlc3RfbG9uZ3RleHRfYiA9IGxvbmd0ZXh0Mi5zdWJzdHJpbmcoaSArIHByZWZpeExlbmd0aCk7XG4gICAgICAgIGJlc3Rfc2hvcnR0ZXh0X2EgPSBzaG9ydHRleHQyLnN1YnN0cmluZygwLCBqIC0gc3VmZml4TGVuZ3RoKTtcbiAgICAgICAgYmVzdF9zaG9ydHRleHRfYiA9IHNob3J0dGV4dDIuc3Vic3RyaW5nKGogKyBwcmVmaXhMZW5ndGgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYmVzdF9jb21tb24ubGVuZ3RoICogMiA+PSBsb25ndGV4dDIubGVuZ3RoKVxuICAgICAgcmV0dXJuIFtiZXN0X2xvbmd0ZXh0X2EsIGJlc3RfbG9uZ3RleHRfYiwgYmVzdF9zaG9ydHRleHRfYSwgYmVzdF9zaG9ydHRleHRfYiwgYmVzdF9jb21tb25dO1xuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IGhtMSA9IGRpZmZIYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyA0KSk7XG4gIGNvbnN0IGhtMiA9IGRpZmZIYWxmTWF0Y2hJKGxvbmd0ZXh0LCBzaG9ydHRleHQsIE1hdGguY2VpbChsb25ndGV4dC5sZW5ndGggLyAyKSk7XG4gIGxldCBobTtcbiAgaWYgKCFobTEgJiYgIWhtMikge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKCFobTIpIHtcbiAgICBobSA9IGhtMTtcbiAgfSBlbHNlIGlmICghaG0xKSB7XG4gICAgaG0gPSBobTI7XG4gIH0gZWxzZSB7XG4gICAgaG0gPSBobTFbNF0ubGVuZ3RoID4gaG0yWzRdLmxlbmd0aCA/IGhtMSA6IGhtMjtcbiAgfVxuICBsZXQgdGV4dDFfYSwgdGV4dDFfYiwgdGV4dDJfYSwgdGV4dDJfYjtcbiAgaWYgKHRleHQxLmxlbmd0aCA+IHRleHQyLmxlbmd0aCkge1xuICAgIHRleHQxX2EgPSBobVswXTtcbiAgICB0ZXh0MV9iID0gaG1bMV07XG4gICAgdGV4dDJfYSA9IGhtWzJdO1xuICAgIHRleHQyX2IgPSBobVszXTtcbiAgfSBlbHNlIHtcbiAgICB0ZXh0Ml9hID0gaG1bMF07XG4gICAgdGV4dDJfYiA9IGhtWzFdO1xuICAgIHRleHQxX2EgPSBobVsyXTtcbiAgICB0ZXh0MV9iID0gaG1bM107XG4gIH1cbiAgY29uc3QgbWlkX2NvbW1vbiA9IGhtWzRdO1xuICByZXR1cm4gW3RleHQxX2EsIHRleHQxX2IsIHRleHQyX2EsIHRleHQyX2IsIG1pZF9jb21tb25dO1xufVxuZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpYyhkaWZmcykge1xuICBsZXQgY2hhbmdlcyA9IGZhbHNlO1xuICBjb25zdCBlcXVhbGl0aWVzID0gW107XG4gIGxldCBlcXVhbGl0aWVzTGVuZ3RoID0gMDtcbiAgbGV0IGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgbGV0IGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7XG4gIGxldCBsZW5ndGhfZGVsZXRpb25zMSA9IDA7XG4gIGxldCBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICBsZXQgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IGxlbmd0aF9pbnNlcnRpb25zMjtcbiAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gbGVuZ3RoX2RlbGV0aW9uczI7XG4gICAgICBsZW5ndGhfaW5zZXJ0aW9uczIgPSAwO1xuICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICAgICAgbGFzdEVxdWFsaXR5ID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpXG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMiArPSBkaWZmc1twb2ludGVyXVsxXS5sZW5ndGg7XG4gICAgICBlbHNlXG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMyICs9IGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aDtcbiAgICAgIGlmIChsYXN0RXF1YWxpdHkgJiYgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8PSBNYXRoLm1heChsZW5ndGhfaW5zZXJ0aW9uczEsIGxlbmd0aF9kZWxldGlvbnMxKSAmJiBsYXN0RXF1YWxpdHkubGVuZ3RoIDw9IE1hdGgubWF4KGxlbmd0aF9pbnNlcnRpb25zMiwgbGVuZ3RoX2RlbGV0aW9uczIpKSB7XG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgY3JlYXRlRGlmZihESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5KSk7XG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBlcXVhbGl0aWVzTGVuZ3RoLS07XG4gICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgIGxlbmd0aF9pbnNlcnRpb25zMSA9IDA7XG4gICAgICAgIGxlbmd0aF9kZWxldGlvbnMxID0gMDtcbiAgICAgICAgbGVuZ3RoX2luc2VydGlvbnMyID0gMDtcbiAgICAgICAgbGVuZ3RoX2RlbGV0aW9uczIgPSAwO1xuICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKVxuICAgIGRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xuICBkaWZmQ2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpO1xuICBwb2ludGVyID0gMTtcbiAgd2hpbGUgKHBvaW50ZXIgPCBkaWZmcy5sZW5ndGgpIHtcbiAgICBpZiAoZGlmZnNbcG9pbnRlciAtIDFdWzBdID09PSBESUZGX0RFTEVURSAmJiBkaWZmc1twb2ludGVyXVswXSA9PT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNvbnN0IGRlbGV0aW9uID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgY29uc3QgaW5zZXJ0aW9uID0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICBjb25zdCBvdmVybGFwX2xlbmd0aDEgPSBkaWZmQ29tbW9uT3ZlcmxhcChkZWxldGlvbiwgaW5zZXJ0aW9uKTtcbiAgICAgIGNvbnN0IG92ZXJsYXBfbGVuZ3RoMiA9IGRpZmZDb21tb25PdmVybGFwKGluc2VydGlvbiwgZGVsZXRpb24pO1xuICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBvdmVybGFwX2xlbmd0aDIpIHtcbiAgICAgICAgaWYgKG92ZXJsYXBfbGVuZ3RoMSA+PSBkZWxldGlvbi5sZW5ndGggLyAyIHx8IG92ZXJsYXBfbGVuZ3RoMSA+PSBpbnNlcnRpb24ubGVuZ3RoIC8gMikge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIGluc2VydGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgxKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGRlbGV0aW9uLnN1YnN0cmluZygwLCBkZWxldGlvbi5sZW5ndGggLSBvdmVybGFwX2xlbmd0aDEpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcob3ZlcmxhcF9sZW5ndGgxKTtcbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChvdmVybGFwX2xlbmd0aDIgPj0gZGVsZXRpb24ubGVuZ3RoIC8gMiB8fCBvdmVybGFwX2xlbmd0aDIgPj0gaW5zZXJ0aW9uLmxlbmd0aCAvIDIpIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciwgMCwgY3JlYXRlRGlmZihESUZGX0VRVUFMLCBkZWxldGlvbi5zdWJzdHJpbmcoMCwgb3ZlcmxhcF9sZW5ndGgyKSkpO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVswXSA9IERJRkZfSU5TRVJUO1xuICAgICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSA9IGluc2VydGlvbi5zdWJzdHJpbmcoMCwgaW5zZXJ0aW9uLmxlbmd0aCAtIG92ZXJsYXBfbGVuZ3RoMik7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzBdID0gRElGRl9ERUxFVEU7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gZGVsZXRpb24uc3Vic3RyaW5nKG92ZXJsYXBfbGVuZ3RoMik7XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb2ludGVyKys7XG4gICAgfVxuICAgIHBvaW50ZXIrKztcbiAgfVxufVxuY29uc3Qgbm9uQWxwaGFOdW1lcmljUmVnZXhfID0gL1teYS16QS1aMC05XS87XG5jb25zdCB3aGl0ZXNwYWNlUmVnZXhfID0gL1xccy87XG5jb25zdCBsaW5lYnJlYWtSZWdleF8gPSAvW1xcclxcbl0vO1xuY29uc3QgYmxhbmtsaW5lRW5kUmVnZXhfID0gL1xcblxccj9cXG4kLztcbmNvbnN0IGJsYW5rbGluZVN0YXJ0UmVnZXhfID0gL15cXHI/XFxuXFxyP1xcbi87XG5mdW5jdGlvbiBkaWZmQ2xlYW51cFNlbWFudGljTG9zc2xlc3MoZGlmZnMpIHtcbiAgZnVuY3Rpb24gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKG9uZSwgdHdvKSB7XG4gICAgaWYgKCFvbmUgfHwgIXR3bykge1xuICAgICAgcmV0dXJuIDY7XG4gICAgfVxuICAgIGNvbnN0IGNoYXIxID0gb25lLmNoYXJBdChvbmUubGVuZ3RoIC0gMSk7XG4gICAgY29uc3QgY2hhcjIgPSB0d28uY2hhckF0KDApO1xuICAgIGNvbnN0IG5vbkFscGhhTnVtZXJpYzEgPSBjaGFyMS5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgIGNvbnN0IG5vbkFscGhhTnVtZXJpYzIgPSBjaGFyMi5tYXRjaChub25BbHBoYU51bWVyaWNSZWdleF8pO1xuICAgIGNvbnN0IHdoaXRlc3BhY2UxID0gbm9uQWxwaGFOdW1lcmljMSAmJiBjaGFyMS5tYXRjaCh3aGl0ZXNwYWNlUmVnZXhfKTtcbiAgICBjb25zdCB3aGl0ZXNwYWNlMiA9IG5vbkFscGhhTnVtZXJpYzIgJiYgY2hhcjIubWF0Y2god2hpdGVzcGFjZVJlZ2V4Xyk7XG4gICAgY29uc3QgbGluZUJyZWFrMSA9IHdoaXRlc3BhY2UxICYmIGNoYXIxLm1hdGNoKGxpbmVicmVha1JlZ2V4Xyk7XG4gICAgY29uc3QgbGluZUJyZWFrMiA9IHdoaXRlc3BhY2UyICYmIGNoYXIyLm1hdGNoKGxpbmVicmVha1JlZ2V4Xyk7XG4gICAgY29uc3QgYmxhbmtMaW5lMSA9IGxpbmVCcmVhazEgJiYgb25lLm1hdGNoKGJsYW5rbGluZUVuZFJlZ2V4Xyk7XG4gICAgY29uc3QgYmxhbmtMaW5lMiA9IGxpbmVCcmVhazIgJiYgdHdvLm1hdGNoKGJsYW5rbGluZVN0YXJ0UmVnZXhfKTtcbiAgICBpZiAoYmxhbmtMaW5lMSB8fCBibGFua0xpbmUyKSB7XG4gICAgICByZXR1cm4gNTtcbiAgICB9IGVsc2UgaWYgKGxpbmVCcmVhazEgfHwgbGluZUJyZWFrMikge1xuICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxICYmICF3aGl0ZXNwYWNlMSAmJiB3aGl0ZXNwYWNlMikge1xuICAgICAgcmV0dXJuIDM7XG4gICAgfSBlbHNlIGlmICh3aGl0ZXNwYWNlMSB8fCB3aGl0ZXNwYWNlMikge1xuICAgICAgcmV0dXJuIDI7XG4gICAgfSBlbHNlIGlmIChub25BbHBoYU51bWVyaWMxIHx8IG5vbkFscGhhTnVtZXJpYzIpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBsZXQgZXF1YWxpdHkxID0gZGlmZnNbcG9pbnRlciAtIDFdWzFdO1xuICAgICAgbGV0IGVkaXQgPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgIGxldCBlcXVhbGl0eTIgPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICBjb25zdCBjb21tb25PZmZzZXQgPSBkaWZmQ29tbW9uU3VmZml4KGVxdWFsaXR5MSwgZWRpdCk7XG4gICAgICBpZiAoY29tbW9uT2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IGNvbW1vblN0cmluZyA9IGVkaXQuc3Vic3RyaW5nKGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkxID0gZXF1YWxpdHkxLnN1YnN0cmluZygwLCBlcXVhbGl0eTEubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZWRpdCA9IGNvbW1vblN0cmluZyArIGVkaXQuc3Vic3RyaW5nKDAsIGVkaXQubGVuZ3RoIC0gY29tbW9uT2Zmc2V0KTtcbiAgICAgICAgZXF1YWxpdHkyID0gY29tbW9uU3RyaW5nICsgZXF1YWxpdHkyO1xuICAgICAgfVxuICAgICAgbGV0IGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICBsZXQgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgbGV0IGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICBsZXQgYmVzdFNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgIHdoaWxlIChlZGl0LmNoYXJBdCgwKSA9PT0gZXF1YWxpdHkyLmNoYXJBdCgwKSkge1xuICAgICAgICBlcXVhbGl0eTEgKz0gZWRpdC5jaGFyQXQoMCk7XG4gICAgICAgIGVkaXQgPSBlZGl0LnN1YnN0cmluZygxKSArIGVxdWFsaXR5Mi5jaGFyQXQoMCk7XG4gICAgICAgIGVxdWFsaXR5MiA9IGVxdWFsaXR5Mi5zdWJzdHJpbmcoMSk7XG4gICAgICAgIGNvbnN0IHNjb3JlID0gZGlmZkNsZWFudXBTZW1hbnRpY1Njb3JlKGVxdWFsaXR5MSwgZWRpdCkgKyBkaWZmQ2xlYW51cFNlbWFudGljU2NvcmUoZWRpdCwgZXF1YWxpdHkyKTtcbiAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSkge1xuICAgICAgICAgIGJlc3RTY29yZSA9IHNjb3JlO1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTEgPSBlcXVhbGl0eTE7XG4gICAgICAgICAgYmVzdEVkaXQgPSBlZGl0O1xuICAgICAgICAgIGJlc3RFcXVhbGl0eTIgPSBlcXVhbGl0eTI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMV0gIT09IGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgaWYgKGJlc3RFcXVhbGl0eTEpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gPSBiZXN0RXF1YWxpdHkxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyIC0gMSwgMSk7XG4gICAgICAgICAgcG9pbnRlci0tO1xuICAgICAgICB9XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gYmVzdEVkaXQ7XG4gICAgICAgIGlmIChiZXN0RXF1YWxpdHkyKSB7XG4gICAgICAgICAgZGlmZnNbcG9pbnRlciArIDFdWzFdID0gYmVzdEVxdWFsaXR5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICAgIHBvaW50ZXItLTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpZmZDbGVhbnVwRWZmaWNpZW5jeShkaWZmcywgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBkaWZmRWRpdENvc3QgPSBkZWZhdWx0T3B0aW9ucy5kaWZmRWRpdENvc3RcbiAgfSA9IG9wdGlvbnM7XG4gIGxldCBjaGFuZ2VzID0gZmFsc2U7XG4gIGNvbnN0IGVxdWFsaXRpZXMgPSBbXTtcbiAgbGV0IGVxdWFsaXRpZXNMZW5ndGggPSAwO1xuICBsZXQgbGFzdEVxdWFsaXR5ID0gbnVsbDtcbiAgbGV0IHBvaW50ZXIgPSAwO1xuICBsZXQgcHJlX2lucyA9IGZhbHNlO1xuICBsZXQgcHJlX2RlbCA9IGZhbHNlO1xuICBsZXQgcG9zdF9pbnMgPSBmYWxzZTtcbiAgbGV0IHBvc3RfZGVsID0gZmFsc2U7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoKSB7XG4gICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIDwgZGlmZkVkaXRDb3N0ICYmIChwb3N0X2lucyB8fCBwb3N0X2RlbCkpIHtcbiAgICAgICAgZXF1YWxpdGllc1tlcXVhbGl0aWVzTGVuZ3RoKytdID0gcG9pbnRlcjtcbiAgICAgICAgcHJlX2lucyA9IHBvc3RfaW5zO1xuICAgICAgICBwcmVfZGVsID0gcG9zdF9kZWw7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IGRpZmZzW3BvaW50ZXJdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIGxhc3RFcXVhbGl0eSA9IG51bGw7XG4gICAgICB9XG4gICAgICBwb3N0X2lucyA9IHBvc3RfZGVsID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBib29sZWFuQ291bnQgPSBmdW5jdGlvbiguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBhcmdzLmZpbHRlcihCb29sZWFuKS5sZW5ndGg7XG4gICAgICB9O1xuICAgICAgaWYgKGRpZmZzW3BvaW50ZXJdWzBdID09PSBESUZGX0RFTEVURSlcbiAgICAgICAgcG9zdF9kZWwgPSB0cnVlO1xuICAgICAgZWxzZVxuICAgICAgICBwb3N0X2lucyA9IHRydWU7XG4gICAgICBpZiAobGFzdEVxdWFsaXR5ICYmIChwcmVfaW5zICYmIHByZV9kZWwgJiYgcG9zdF9pbnMgJiYgcG9zdF9kZWwgfHwgbGFzdEVxdWFsaXR5Lmxlbmd0aCA8IGRpZmZFZGl0Q29zdCAvIDIgJiYgYm9vbGVhbkNvdW50KHByZV9pbnMsIHByZV9kZWwsIHBvc3RfaW5zLCBwb3N0X2RlbCkgPT09IDMpKSB7XG4gICAgICAgIGRpZmZzLnNwbGljZShlcXVhbGl0aWVzW2VxdWFsaXRpZXNMZW5ndGggLSAxXSwgMCwgY3JlYXRlRGlmZihESUZGX0RFTEVURSwgbGFzdEVxdWFsaXR5KSk7XG4gICAgICAgIGRpZmZzW2VxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdICsgMV1bMF0gPSBESUZGX0lOU0VSVDtcbiAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICBsYXN0RXF1YWxpdHkgPSBudWxsO1xuICAgICAgICBpZiAocHJlX2lucyAmJiBwcmVfZGVsKSB7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IHRydWU7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aCA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXF1YWxpdGllc0xlbmd0aC0tO1xuICAgICAgICAgIHBvaW50ZXIgPSBlcXVhbGl0aWVzTGVuZ3RoID4gMCA/IGVxdWFsaXRpZXNbZXF1YWxpdGllc0xlbmd0aCAtIDFdIDogLTE7XG4gICAgICAgICAgcG9zdF9pbnMgPSBwb3N0X2RlbCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5nZXMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBwb2ludGVyKys7XG4gIH1cbiAgaWYgKGNoYW5nZXMpXG4gICAgZGlmZkNsZWFudXBNZXJnZShkaWZmcyk7XG59XG5mdW5jdGlvbiBkaWZmQ2xlYW51cE1lcmdlKGRpZmZzKSB7XG4gIGRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBcIlwiKSk7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgbGV0IGNvdW50X2RlbGV0ZSA9IDA7XG4gIGxldCBjb3VudF9pbnNlcnQgPSAwO1xuICBsZXQgdGV4dF9kZWxldGUgPSBcIlwiO1xuICBsZXQgdGV4dF9pbnNlcnQgPSBcIlwiO1xuICBsZXQgY29tbW9ubGVuZ3RoO1xuICB3aGlsZSAocG9pbnRlciA8IGRpZmZzLmxlbmd0aCkge1xuICAgIHN3aXRjaCAoZGlmZnNbcG9pbnRlcl1bMF0pIHtcbiAgICAgIGNhc2UgRElGRl9JTlNFUlQ6XG4gICAgICAgIGNvdW50X2luc2VydCsrO1xuICAgICAgICB0ZXh0X2luc2VydCArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGNvdW50X2RlbGV0ZSsrO1xuICAgICAgICB0ZXh0X2RlbGV0ZSArPSBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9FUVVBTDpcbiAgICAgICAgaWYgKGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCA+IDEpIHtcbiAgICAgICAgICBpZiAoY291bnRfZGVsZXRlICE9PSAwICYmIGNvdW50X2luc2VydCAhPT0gMCkge1xuICAgICAgICAgICAgY29tbW9ubGVuZ3RoID0gZGlmZkNvbW1vblByZWZpeCh0ZXh0X2luc2VydCwgdGV4dF9kZWxldGUpO1xuICAgICAgICAgICAgaWYgKGNvbW1vbmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAocG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCA+IDAgJiYgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICAgICAgICAgICAgZGlmZnNbcG9pbnRlciAtIGNvdW50X2RlbGV0ZSAtIGNvdW50X2luc2VydCAtIDFdWzFdICs9IHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpZmZzLnNwbGljZSgwLCAwLCBjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHRleHRfaW5zZXJ0LnN1YnN0cmluZygwLCBjb21tb25sZW5ndGgpKSk7XG4gICAgICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRleHRfaW5zZXJ0ID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICAgIHRleHRfZGVsZXRlID0gdGV4dF9kZWxldGUuc3Vic3RyaW5nKGNvbW1vbmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21tb25sZW5ndGggPSBkaWZmQ29tbW9uU3VmZml4KHRleHRfaW5zZXJ0LCB0ZXh0X2RlbGV0ZSk7XG4gICAgICAgICAgICBpZiAoY29tbW9ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gdGV4dF9pbnNlcnQuc3Vic3RyaW5nKHRleHRfaW5zZXJ0Lmxlbmd0aCAtIGNvbW1vbmxlbmd0aCkgKyBkaWZmc1twb2ludGVyXVsxXTtcbiAgICAgICAgICAgICAgdGV4dF9pbnNlcnQgPSB0ZXh0X2luc2VydC5zdWJzdHJpbmcoMCwgdGV4dF9pbnNlcnQubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgdGV4dF9kZWxldGUgPSB0ZXh0X2RlbGV0ZS5zdWJzdHJpbmcoMCwgdGV4dF9kZWxldGUubGVuZ3RoIC0gY29tbW9ubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcG9pbnRlciAtPSBjb3VudF9kZWxldGUgKyBjb3VudF9pbnNlcnQ7XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIGNvdW50X2RlbGV0ZSArIGNvdW50X2luc2VydCk7XG4gICAgICAgICAgaWYgKHRleHRfZGVsZXRlLmxlbmd0aCkge1xuICAgICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDAsIGNyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHRfZGVsZXRlKSk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0ZXh0X2luc2VydC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRpZmZzLnNwbGljZShwb2ludGVyLCAwLCBjcmVhdGVEaWZmKERJRkZfSU5TRVJULCB0ZXh0X2luc2VydCkpO1xuICAgICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgIH0gZWxzZSBpZiAocG9pbnRlciAhPT0gMCAmJiBkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwpIHtcbiAgICAgICAgICBkaWZmc1twb2ludGVyIC0gMV1bMV0gKz0gZGlmZnNbcG9pbnRlcl1bMV07XG4gICAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfVxuICAgICAgICBjb3VudF9pbnNlcnQgPSAwO1xuICAgICAgICBjb3VudF9kZWxldGUgPSAwO1xuICAgICAgICB0ZXh0X2RlbGV0ZSA9IFwiXCI7XG4gICAgICAgIHRleHRfaW5zZXJ0ID0gXCJcIjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIGlmIChkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXSA9PT0gXCJcIilcbiAgICBkaWZmcy5wb3AoKTtcbiAgbGV0IGNoYW5nZXMgPSBmYWxzZTtcbiAgcG9pbnRlciA9IDE7XG4gIHdoaWxlIChwb2ludGVyIDwgZGlmZnMubGVuZ3RoIC0gMSkge1xuICAgIGlmIChkaWZmc1twb2ludGVyIC0gMV1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZnNbcG9pbnRlciArIDFdWzBdID09PSBESUZGX0VRVUFMKSB7XG4gICAgICBpZiAoZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXJdWzFdLmxlbmd0aCAtIGRpZmZzW3BvaW50ZXIgLSAxXVsxXS5sZW5ndGgpID09PSBkaWZmc1twb2ludGVyIC0gMV1bMV0pIHtcbiAgICAgICAgZGlmZnNbcG9pbnRlcl1bMV0gPSBkaWZmc1twb2ludGVyIC0gMV1bMV0gKyBkaWZmc1twb2ludGVyXVsxXS5zdWJzdHJpbmcoMCwgZGlmZnNbcG9pbnRlcl1bMV0ubGVuZ3RoIC0gZGlmZnNbcG9pbnRlciAtIDFdWzFdLmxlbmd0aCk7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgKyAxXVsxXSA9IGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArIGRpZmZzW3BvaW50ZXIgKyAxXVsxXTtcbiAgICAgICAgZGlmZnMuc3BsaWNlKHBvaW50ZXIgLSAxLCAxKTtcbiAgICAgICAgY2hhbmdlcyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRpZmZzW3BvaW50ZXJdWzFdLnN1YnN0cmluZygwLCBkaWZmc1twb2ludGVyICsgMV1bMV0ubGVuZ3RoKSA9PT0gZGlmZnNbcG9pbnRlciArIDFdWzFdKSB7XG4gICAgICAgIGRpZmZzW3BvaW50ZXIgLSAxXVsxXSArPSBkaWZmc1twb2ludGVyICsgMV1bMV07XG4gICAgICAgIGRpZmZzW3BvaW50ZXJdWzFdID0gZGlmZnNbcG9pbnRlcl1bMV0uc3Vic3RyaW5nKGRpZmZzW3BvaW50ZXIgKyAxXVsxXS5sZW5ndGgpICsgZGlmZnNbcG9pbnRlciArIDFdWzFdO1xuICAgICAgICBkaWZmcy5zcGxpY2UocG9pbnRlciArIDEsIDEpO1xuICAgICAgICBjaGFuZ2VzID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcG9pbnRlcisrO1xuICB9XG4gIGlmIChjaGFuZ2VzKVxuICAgIGRpZmZDbGVhbnVwTWVyZ2UoZGlmZnMpO1xufVxuZnVuY3Rpb24gZGlmZlhJbmRleChkaWZmcywgbG9jKSB7XG4gIGxldCBjaGFyczEgPSAwO1xuICBsZXQgY2hhcnMyID0gMDtcbiAgbGV0IGxhc3RfY2hhcnMxID0gMDtcbiAgbGV0IGxhc3RfY2hhcnMyID0gMDtcbiAgbGV0IHg7XG4gIGZvciAoeCA9IDA7IHggPCBkaWZmcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9JTlNFUlQpIHtcbiAgICAgIGNoYXJzMSArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChkaWZmc1t4XVswXSAhPT0gRElGRl9ERUxFVEUpIHtcbiAgICAgIGNoYXJzMiArPSBkaWZmc1t4XVsxXS5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChjaGFyczEgPiBsb2MpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBsYXN0X2NoYXJzMSA9IGNoYXJzMTtcbiAgICBsYXN0X2NoYXJzMiA9IGNoYXJzMjtcbiAgfVxuICBpZiAoZGlmZnMubGVuZ3RoICE9PSB4ICYmIGRpZmZzW3hdWzBdID09PSBESUZGX0RFTEVURSlcbiAgICByZXR1cm4gbGFzdF9jaGFyczI7XG4gIHJldHVybiBsYXN0X2NoYXJzMiArIChsb2MgLSBsYXN0X2NoYXJzMSk7XG59XG5mdW5jdGlvbiBkaWZmUHJldHR5SHRtbChkaWZmcykge1xuICBjb25zdCBodG1sID0gW107XG4gIGNvbnN0IHBhdHRlcm5fYW1wID0gLyYvZztcbiAgY29uc3QgcGF0dGVybl9sdCA9IC88L2c7XG4gIGNvbnN0IHBhdHRlcm5fZ3QgPSAvPi9nO1xuICBjb25zdCBwYXR0ZXJuX3BhcmEgPSAvXFxuL2c7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBjb25zdCB0ZXh0ID0gZGF0YS5yZXBsYWNlKHBhdHRlcm5fYW1wLCBcIiZhbXA7XCIpLnJlcGxhY2UocGF0dGVybl9sdCwgXCImbHQ7XCIpLnJlcGxhY2UocGF0dGVybl9ndCwgXCImZ3Q7XCIpLnJlcGxhY2UocGF0dGVybl9wYXJhLCBcIiZwYXJhOzxicj5cIik7XG4gICAgc3dpdGNoIChvcCkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgaHRtbFt4XSA9IGA8aW5zIHN0eWxlPVwiYmFja2dyb3VuZDojZTZmZmU2O1wiPiR7dGV4dH08L2lucz5gO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGh0bWxbeF0gPSBgPGRlbCBzdHlsZT1cImJhY2tncm91bmQ6I2ZmZTZlNjtcIj4ke3RleHR9PC9kZWw+YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGh0bWxbeF0gPSBgPHNwYW4+JHt0ZXh0fTwvc3Bhbj5gO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGh0bWwuam9pbihcIlwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZUZXh0MShkaWZmcykge1xuICBjb25zdCB0ZXh0ID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBpZiAoZGlmZnNbeF1bMF0gIT09IERJRkZfSU5TRVJUKVxuICAgICAgdGV4dFt4XSA9IGRpZmZzW3hdWzFdO1xuICB9XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBkaWZmVGV4dDIoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgaWYgKGRpZmZzW3hdWzBdICE9PSBESUZGX0RFTEVURSlcbiAgICAgIHRleHRbeF0gPSBkaWZmc1t4XVsxXTtcbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gZGlmZkxldmVuc2h0ZWluKGRpZmZzKSB7XG4gIGxldCBsZXZlbnNodGVpbiA9IDA7XG4gIGxldCBpbnNlcnRpb25zID0gMDtcbiAgbGV0IGRlbGV0aW9ucyA9IDA7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBvcCA9IGRpZmZzW3hdWzBdO1xuICAgIGNvbnN0IGRhdGEgPSBkaWZmc1t4XVsxXTtcbiAgICBzd2l0Y2ggKG9wKSB7XG4gICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICBpbnNlcnRpb25zICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgIGRlbGV0aW9ucyArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGxldmVuc2h0ZWluICs9IE1hdGgubWF4KGluc2VydGlvbnMsIGRlbGV0aW9ucyk7XG4gICAgICAgIGluc2VydGlvbnMgPSAwO1xuICAgICAgICBkZWxldGlvbnMgPSAwO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgbGV2ZW5zaHRlaW4gKz0gTWF0aC5tYXgoaW5zZXJ0aW9ucywgZGVsZXRpb25zKTtcbiAgcmV0dXJuIGxldmVuc2h0ZWluO1xufVxuZnVuY3Rpb24gZGlmZlRvRGVsdGEoZGlmZnMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgc3dpdGNoIChkaWZmc1t4XVswXSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgdGV4dFt4XSA9IGArJHtlbmNvZGVVUkkoZGlmZnNbeF1bMV0pfWA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBESUZGX0RFTEVURTpcbiAgICAgICAgdGV4dFt4XSA9IGAtJHtkaWZmc1t4XVsxXS5sZW5ndGh9YDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIHRleHRbeF0gPSBgPSR7ZGlmZnNbeF1bMV0ubGVuZ3RofWA7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGV4dC5qb2luKFwiXHRcIikucmVwbGFjZSgvJTIwL2csIFwiIFwiKTtcbn1cbmZ1bmN0aW9uIGRpZmZGcm9tRGVsdGEodGV4dDEsIGRlbHRhKSB7XG4gIGNvbnN0IGRpZmZzID0gW107XG4gIGxldCBkaWZmc0xlbmd0aCA9IDA7XG4gIGxldCBwb2ludGVyID0gMDtcbiAgY29uc3QgdG9rZW5zID0gZGVsdGEuc3BsaXQoL1xcdC9nKTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCB0b2tlbnMubGVuZ3RoOyB4KyspIHtcbiAgICBjb25zdCBwYXJhbSA9IHRva2Vuc1t4XS5zdWJzdHJpbmcoMSk7XG4gICAgc3dpdGNoICh0b2tlbnNbeF0uY2hhckF0KDApKSB7XG4gICAgICBjYXNlIFwiK1wiOlxuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpZmZzW2RpZmZzTGVuZ3RoKytdID0gY3JlYXRlRGlmZihESUZGX0lOU0VSVCwgZGVjb2RlVVJJKHBhcmFtKSk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIGVzY2FwZSBpbiBkaWZmX2Zyb21EZWx0YTogJHtwYXJhbX1gKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCItXCI6XG4gICAgICBjYXNlIFwiPVwiOiB7XG4gICAgICAgIGNvbnN0IG4gPSBOdW1iZXIucGFyc2VJbnQocGFyYW0sIDEwKTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihuKSB8fCBuIDwgMClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbnVtYmVyIGluIGRpZmZfZnJvbURlbHRhOiAke3BhcmFtfWApO1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dDEuc3Vic3RyaW5nKHBvaW50ZXIsIHBvaW50ZXIgKz0gbik7XG4gICAgICAgIGlmICh0b2tlbnNbeF0uY2hhckF0KDApID09PSBcIj1cIilcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgdGV4dCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBkaWZmc1tkaWZmc0xlbmd0aCsrXSA9IGNyZWF0ZURpZmYoRElGRl9ERUxFVEUsIHRleHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmICh0b2tlbnNbeF0pXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGRpZmYgb3BlcmF0aW9uIGluIGRpZmZfZnJvbURlbHRhOiAke3Rva2Vuc1t4XX1gKTtcbiAgICB9XG4gIH1cbiAgaWYgKHBvaW50ZXIgIT09IHRleHQxLmxlbmd0aClcbiAgICB0aHJvdyBuZXcgRXJyb3IoYERlbHRhIGxlbmd0aCAoJHtwb2ludGVyfSkgZG9lcyBub3QgZXF1YWwgc291cmNlIHRleHQgbGVuZ3RoICgke3RleHQxLmxlbmd0aH0pLmApO1xuICByZXR1cm4gZGlmZnM7XG59XG5cbmZ1bmN0aW9uIG1hdGNoTWFpbih0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpIHtcbiAgaWYgKHRleHQgPT0gbnVsbCB8fCBwYXR0ZXJuID09IG51bGwgfHwgbG9jID09IG51bGwpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTnVsbCBpbnB1dC4gKG1hdGNoX21haW4pXCIpO1xuICBsb2MgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihsb2MsIHRleHQubGVuZ3RoKSk7XG4gIGlmICh0ZXh0ID09PSBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoIXRleHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKHRleHQuc3Vic3RyaW5nKGxvYywgbG9jICsgcGF0dGVybi5sZW5ndGgpID09PSBwYXR0ZXJuKSB7XG4gICAgcmV0dXJuIGxvYztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbWF0Y2hCaXRhcCh0ZXh0LCBwYXR0ZXJuLCBsb2MsIG9wdGlvbnMpO1xuICB9XG59XG5mdW5jdGlvbiBtYXRjaEJpdGFwKHRleHQsIHBhdHRlcm4sIGxvYywgb3B0aW9ucykge1xuICBjb25zdCByZXNvbHZlZCA9IHJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAocGF0dGVybi5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMpXG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUGF0dGVybiB0b28gbG9uZyBmb3IgdGhpcyBicm93c2VyLlwiKTtcbiAgY29uc3QgcyA9IG1hdGNoQWxwaGFiZXQocGF0dGVybik7XG4gIGZ1bmN0aW9uIG1hdGNoQml0YXBTY29yZShlLCB4KSB7XG4gICAgY29uc3QgYWNjdXJhY3kgPSBlIC8gcGF0dGVybi5sZW5ndGg7XG4gICAgY29uc3QgcHJveGltaXR5ID0gTWF0aC5hYnMobG9jIC0geCk7XG4gICAgaWYgKCFyZXNvbHZlZC5tYXRjaERpc3RhbmNlKSB7XG4gICAgICByZXR1cm4gcHJveGltaXR5ID8gMSA6IGFjY3VyYWN5O1xuICAgIH1cbiAgICByZXR1cm4gYWNjdXJhY3kgKyBwcm94aW1pdHkgLyByZXNvbHZlZC5tYXRjaERpc3RhbmNlO1xuICB9XG4gIGxldCBzY29yZV90aHJlc2hvbGQgPSByZXNvbHZlZC5tYXRjaFRocmVzaG9sZDtcbiAgbGV0IGJlc3RfbG9jID0gdGV4dC5pbmRleE9mKHBhdHRlcm4sIGxvYyk7XG4gIGlmIChiZXN0X2xvYyAhPT0gLTEpIHtcbiAgICBzY29yZV90aHJlc2hvbGQgPSBNYXRoLm1pbihtYXRjaEJpdGFwU2NvcmUoMCwgYmVzdF9sb2MpLCBzY29yZV90aHJlc2hvbGQpO1xuICAgIGJlc3RfbG9jID0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuLCBsb2MgKyBwYXR0ZXJuLmxlbmd0aCk7XG4gICAgaWYgKGJlc3RfbG9jICE9PSAtMSlcbiAgICAgIHNjb3JlX3RocmVzaG9sZCA9IE1hdGgubWluKG1hdGNoQml0YXBTY29yZSgwLCBiZXN0X2xvYyksIHNjb3JlX3RocmVzaG9sZCk7XG4gIH1cbiAgY29uc3QgbWF0Y2htYXNrID0gMSA8PCBwYXR0ZXJuLmxlbmd0aCAtIDE7XG4gIGJlc3RfbG9jID0gLTE7XG4gIGxldCBiaW5fbWluLCBiaW5fbWlkO1xuICBsZXQgYmluX21heCA9IHBhdHRlcm4ubGVuZ3RoICsgdGV4dC5sZW5ndGg7XG4gIGxldCBsYXN0X3JkID0gW107XG4gIGZvciAobGV0IGQgPSAwOyBkIDwgcGF0dGVybi5sZW5ndGg7IGQrKykge1xuICAgIGJpbl9taW4gPSAwO1xuICAgIGJpbl9taWQgPSBiaW5fbWF4O1xuICAgIHdoaWxlIChiaW5fbWluIDwgYmluX21pZCkge1xuICAgICAgaWYgKG1hdGNoQml0YXBTY29yZShkLCBsb2MgKyBiaW5fbWlkKSA8PSBzY29yZV90aHJlc2hvbGQpXG4gICAgICAgIGJpbl9taW4gPSBiaW5fbWlkO1xuICAgICAgZWxzZVxuICAgICAgICBiaW5fbWF4ID0gYmluX21pZDtcbiAgICAgIGJpbl9taWQgPSBNYXRoLmZsb29yKChiaW5fbWF4IC0gYmluX21pbikgLyAyICsgYmluX21pbik7XG4gICAgfVxuICAgIGJpbl9tYXggPSBiaW5fbWlkO1xuICAgIGxldCBzdGFydCA9IE1hdGgubWF4KDEsIGxvYyAtIGJpbl9taWQgKyAxKTtcbiAgICBjb25zdCBmaW5pc2ggPSBNYXRoLm1pbihsb2MgKyBiaW5fbWlkLCB0ZXh0Lmxlbmd0aCkgKyBwYXR0ZXJuLmxlbmd0aDtcbiAgICBjb25zdCByZCA9IEFycmF5KGZpbmlzaCArIDIpO1xuICAgIHJkW2ZpbmlzaCArIDFdID0gKDEgPDwgZCkgLSAxO1xuICAgIGZvciAobGV0IGogPSBmaW5pc2g7IGogPj0gc3RhcnQ7IGotLSkge1xuICAgICAgY29uc3QgY2hhck1hdGNoID0gc1t0ZXh0LmNoYXJBdChqIC0gMSldO1xuICAgICAgaWYgKGQgPT09IDApIHtcbiAgICAgICAgcmRbal0gPSAocmRbaiArIDFdIDw8IDEgfCAxKSAmIGNoYXJNYXRjaDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJkW2pdID0gKHJkW2ogKyAxXSA8PCAxIHwgMSkgJiBjaGFyTWF0Y2ggfCAoKGxhc3RfcmRbaiArIDFdIHwgbGFzdF9yZFtqXSkgPDwgMSB8IDEpIHwgbGFzdF9yZFtqICsgMV07XG4gICAgICB9XG4gICAgICBpZiAocmRbal0gJiBtYXRjaG1hc2spIHtcbiAgICAgICAgY29uc3Qgc2NvcmUgPSBtYXRjaEJpdGFwU2NvcmUoZCwgaiAtIDEpO1xuICAgICAgICBpZiAoc2NvcmUgPD0gc2NvcmVfdGhyZXNob2xkKSB7XG4gICAgICAgICAgc2NvcmVfdGhyZXNob2xkID0gc2NvcmU7XG4gICAgICAgICAgYmVzdF9sb2MgPSBqIC0gMTtcbiAgICAgICAgICBpZiAoYmVzdF9sb2MgPiBsb2MpIHtcbiAgICAgICAgICAgIHN0YXJ0ID0gTWF0aC5tYXgoMSwgMiAqIGxvYyAtIGJlc3RfbG9jKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtYXRjaEJpdGFwU2NvcmUoZCArIDEsIGxvYykgPiBzY29yZV90aHJlc2hvbGQpXG4gICAgICBicmVhaztcbiAgICBsYXN0X3JkID0gcmQ7XG4gIH1cbiAgcmV0dXJuIGJlc3RfbG9jO1xufVxuZnVuY3Rpb24gbWF0Y2hBbHBoYWJldChwYXR0ZXJuKSB7XG4gIGNvbnN0IHMgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXR0ZXJuLmxlbmd0aDsgaSsrKVxuICAgIHNbcGF0dGVybi5jaGFyQXQoaSldIHw9IDEgPDwgcGF0dGVybi5sZW5ndGggLSBpIC0gMTtcbiAgcmV0dXJuIHM7XG59XG5cbmZ1bmN0aW9uIHBhdGNoQWRkQ29udGV4dChwYXRjaCwgdGV4dCwgb3B0aW9ucykge1xuICBpZiAodGV4dC5sZW5ndGggPT09IDApXG4gICAgcmV0dXJuO1xuICBpZiAocGF0Y2guc3RhcnQyID09PSBudWxsKVxuICAgIHRocm93IG5ldyBFcnJvcihcInBhdGNoIG5vdCBpbml0aWFsaXplZFwiKTtcbiAgY29uc3Qge1xuICAgIG1hdGNoTWF4Qml0cyA9IGRlZmF1bHRPcHRpb25zLm1hdGNoTWF4Qml0cyxcbiAgICBwYXRjaE1hcmdpbiA9IGRlZmF1bHRPcHRpb25zLnBhdGNoTWFyZ2luXG4gIH0gPSBvcHRpb25zO1xuICBsZXQgcGF0dGVybiA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiwgcGF0Y2guc3RhcnQyICsgcGF0Y2gubGVuZ3RoMSk7XG4gIGxldCBwYWRkaW5nID0gMDtcbiAgd2hpbGUgKHRleHQuaW5kZXhPZihwYXR0ZXJuKSAhPT0gdGV4dC5sYXN0SW5kZXhPZihwYXR0ZXJuKSAmJiBwYXR0ZXJuLmxlbmd0aCA8IG1hdGNoTWF4Qml0cyAtIHBhdGNoTWFyZ2luIC0gcGF0Y2hNYXJnaW4pIHtcbiAgICBwYWRkaW5nICs9IHBhdGNoTWFyZ2luO1xuICAgIHBhdHRlcm4gPSB0ZXh0LnN1YnN0cmluZyhwYXRjaC5zdGFydDIgLSBwYWRkaW5nLCBwYXRjaC5zdGFydDIgKyBwYXRjaC5sZW5ndGgxICsgcGFkZGluZyk7XG4gIH1cbiAgcGFkZGluZyArPSBwYXRjaE1hcmdpbjtcbiAgY29uc3QgcHJlZml4ID0gdGV4dC5zdWJzdHJpbmcocGF0Y2guc3RhcnQyIC0gcGFkZGluZywgcGF0Y2guc3RhcnQyKTtcbiAgaWYgKHByZWZpeClcbiAgICBwYXRjaC5kaWZmcy51bnNoaWZ0KGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgcHJlZml4KSk7XG4gIGNvbnN0IHN1ZmZpeCA9IHRleHQuc3Vic3RyaW5nKHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEsIHBhdGNoLnN0YXJ0MiArIHBhdGNoLmxlbmd0aDEgKyBwYWRkaW5nKTtcbiAgaWYgKHN1ZmZpeClcbiAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgc3VmZml4KSk7XG4gIHBhdGNoLnN0YXJ0MSAtPSBwcmVmaXgubGVuZ3RoO1xuICBwYXRjaC5zdGFydDIgLT0gcHJlZml4Lmxlbmd0aDtcbiAgcGF0Y2gubGVuZ3RoMSArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbiAgcGF0Y2gubGVuZ3RoMiArPSBwcmVmaXgubGVuZ3RoICsgc3VmZml4Lmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHBhdGNoTWFrZShhLCBvcHRfYiwgb3B0X2MsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCByZXNvbHZlZCA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICAuLi5vcHRpb25zXG4gIH07XG4gIGxldCB0ZXh0MSwgZGlmZnM7XG4gIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvcHRfYiA9PSBcInN0cmluZ1wiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGV4dDEgPSBhO1xuICAgIGRpZmZzID0gZGlmZk1haW4odGV4dDEsIG9wdF9iLCByZXNvbHZlZCwgdHJ1ZSk7XG4gICAgaWYgKGRpZmZzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGRpZmZDbGVhbnVwU2VtYW50aWMoZGlmZnMpO1xuICAgICAgZGlmZkNsZWFudXBFZmZpY2llbmN5KGRpZmZzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYSAmJiB0eXBlb2YgYSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvcHRfYiA9PSBcInVuZGVmaW5lZFwiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgZGlmZnMgPSAvKiogQHR5cGUge0RpZmZbXX0gKi9cbiAgICBhO1xuICAgIHRleHQxID0gZGlmZlRleHQxKGRpZmZzKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgYSA9PSBcInN0cmluZ1wiICYmIG9wdF9iICYmIHR5cGVvZiBvcHRfYiA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvcHRfYyA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGV4dDEgPSAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICBhO1xuICAgIGRpZmZzID0gLyoqIEB0eXBlIHtEaWZmW119ICovXG4gICAgb3B0X2I7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGEgPT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Ygb3B0X2IgPT0gXCJzdHJpbmdcIiAmJiBvcHRfYyAmJiB0eXBlb2Ygb3B0X2MgPT0gXCJvYmplY3RcIikge1xuICAgIHRleHQxID0gLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgYTtcbiAgICBkaWZmcyA9IC8qKiBAdHlwZSB7RGlmZltdfSAqL1xuICAgIG9wdF9jO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2FsbCBmb3JtYXQgdG8gcGF0Y2hfbWFrZS5cIik7XG4gIH1cbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMClcbiAgICByZXR1cm4gW107XG4gIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgbGV0IHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgbGV0IHBhdGNoRGlmZkxlbmd0aCA9IDA7XG4gIGxldCBjaGFyX2NvdW50MSA9IDA7XG4gIGxldCBjaGFyX2NvdW50MiA9IDA7XG4gIGxldCBwcmVwYXRjaF90ZXh0ID0gdGV4dDE7XG4gIGxldCBwb3N0cGF0Y2hfdGV4dCA9IHRleHQxO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IGRpZmZzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgZGlmZl90eXBlID0gZGlmZnNbeF1bMF07XG4gICAgY29uc3QgZGlmZl90ZXh0ID0gZGlmZnNbeF1bMV07XG4gICAgaWYgKCFwYXRjaERpZmZMZW5ndGggJiYgZGlmZl90eXBlICE9PSBESUZGX0VRVUFMKSB7XG4gICAgICBwYXRjaC5zdGFydDEgPSBjaGFyX2NvdW50MTtcbiAgICAgIHBhdGNoLnN0YXJ0MiA9IGNoYXJfY291bnQyO1xuICAgIH1cbiAgICBzd2l0Y2ggKGRpZmZfdHlwZSkge1xuICAgICAgY2FzZSBESUZGX0lOU0VSVDpcbiAgICAgICAgcGF0Y2guZGlmZnNbcGF0Y2hEaWZmTGVuZ3RoKytdID0gZGlmZnNbeF07XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgcG9zdHBhdGNoX3RleHQgPSBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoMCwgY2hhcl9jb3VudDIpICsgZGlmZl90ZXh0ICsgcG9zdHBhdGNoX3RleHQuc3Vic3RyaW5nKGNoYXJfY291bnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfREVMRVRFOlxuICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICBwb3N0cGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0LnN1YnN0cmluZygwLCBjaGFyX2NvdW50MikgKyBwb3N0cGF0Y2hfdGV4dC5zdWJzdHJpbmcoY2hhcl9jb3VudDIgKyBkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJRkZfRVFVQUw6XG4gICAgICAgIGlmIChkaWZmX3RleHQubGVuZ3RoIDw9IDIgKiByZXNvbHZlZC5wYXRjaE1hcmdpbiAmJiBwYXRjaERpZmZMZW5ndGggJiYgZGlmZnMubGVuZ3RoICE9PSB4ICsgMSkge1xuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoRGlmZkxlbmd0aCsrXSA9IGRpZmZzW3hdO1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90ZXh0Lmxlbmd0aCA+PSAyICogcmVzb2x2ZWQucGF0Y2hNYXJnaW4pIHtcbiAgICAgICAgICBpZiAocGF0Y2hEaWZmTGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXRjaEFkZENvbnRleHQocGF0Y2gsIHByZXBhdGNoX3RleHQsIHJlc29sdmVkKTtcbiAgICAgICAgICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gICAgICAgICAgICBwYXRjaCA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgICAgICAgICBwYXRjaERpZmZMZW5ndGggPSAwO1xuICAgICAgICAgICAgcHJlcGF0Y2hfdGV4dCA9IHBvc3RwYXRjaF90ZXh0O1xuICAgICAgICAgICAgY2hhcl9jb3VudDEgPSBjaGFyX2NvdW50MjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChkaWZmX3R5cGUgIT09IERJRkZfSU5TRVJUKVxuICAgICAgY2hhcl9jb3VudDEgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGlmZl90eXBlICE9PSBESUZGX0RFTEVURSlcbiAgICAgIGNoYXJfY291bnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gIH1cbiAgaWYgKHBhdGNoRGlmZkxlbmd0aCkge1xuICAgIHBhdGNoQWRkQ29udGV4dChwYXRjaCwgcHJlcGF0Y2hfdGV4dCwgcmVzb2x2ZWQpO1xuICAgIHBhdGNoZXMucHVzaChwYXRjaCk7XG4gIH1cbiAgcmV0dXJuIHBhdGNoZXM7XG59XG5mdW5jdGlvbiBwYXRjaERlZXBDb3B5KHBhdGNoZXMpIHtcbiAgY29uc3QgcGF0Y2hlc0NvcHkgPSBbXTtcbiAgZm9yIChsZXQgeCA9IDA7IHggPCBwYXRjaGVzLmxlbmd0aDsgeCsrKSB7XG4gICAgY29uc3QgcGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIGNvbnN0IHBhdGNoQ29weSA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgcGF0Y2hDb3B5LmRpZmZzID0gW107XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBwYXRjaC5kaWZmcy5sZW5ndGg7IHkrKykge1xuICAgICAgcGF0Y2hDb3B5LmRpZmZzW3ldID0gY3JlYXRlRGlmZihwYXRjaC5kaWZmc1t5XVswXSwgcGF0Y2guZGlmZnNbeV1bMV0pO1xuICAgIH1cbiAgICBwYXRjaENvcHkuc3RhcnQxID0gcGF0Y2guc3RhcnQxO1xuICAgIHBhdGNoQ29weS5zdGFydDIgPSBwYXRjaC5zdGFydDI7XG4gICAgcGF0Y2hDb3B5Lmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgxO1xuICAgIHBhdGNoQ29weS5sZW5ndGgyID0gcGF0Y2gubGVuZ3RoMjtcbiAgICBwYXRjaGVzQ29weVt4XSA9IHBhdGNoQ29weTtcbiAgfVxuICByZXR1cm4gcGF0Y2hlc0NvcHk7XG59XG5mdW5jdGlvbiBwYXRjaEFwcGx5KHBhdGNoZXMsIHRleHQsIG9wdGlvbnMpIHtcbiAgaWYgKHBhdGNoZXMubGVuZ3RoID09PSAwKVxuICAgIHJldHVybiBbdGV4dCwgW11dO1xuICBwYXRjaGVzID0gcGF0Y2hEZWVwQ29weShwYXRjaGVzKTtcbiAgY29uc3QgcmVzb2x2ZWQgPSByZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgbnVsbFBhZGRpbmcgPSBwYXRjaEFkZFBhZGRpbmcocGF0Y2hlcywgcmVzb2x2ZWQpO1xuICB0ZXh0ID0gbnVsbFBhZGRpbmcgKyB0ZXh0ICsgbnVsbFBhZGRpbmc7XG4gIHBhdGNoU3BsaXRNYXgocGF0Y2hlcywgcmVzb2x2ZWQpO1xuICBsZXQgZGVsdGEgPSAwO1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGNvbnN0IGV4cGVjdGVkX2xvYyA9IHBhdGNoZXNbeF0uc3RhcnQyICsgZGVsdGE7XG4gICAgY29uc3QgdGV4dDEgPSBkaWZmVGV4dDEocGF0Y2hlc1t4XS5kaWZmcyk7XG4gICAgbGV0IHN0YXJ0X2xvYztcbiAgICBsZXQgZW5kX2xvYyA9IC0xO1xuICAgIGlmICh0ZXh0MS5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMpIHtcbiAgICAgIHN0YXJ0X2xvYyA9IG1hdGNoTWFpbihcbiAgICAgICAgdGV4dCxcbiAgICAgICAgdGV4dDEuc3Vic3RyaW5nKDAsIHJlc29sdmVkLm1hdGNoTWF4Qml0cyksXG4gICAgICAgIGV4cGVjdGVkX2xvYyxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgKTtcbiAgICAgIGlmIChzdGFydF9sb2MgIT09IC0xKSB7XG4gICAgICAgIGVuZF9sb2MgPSBtYXRjaE1haW4oXG4gICAgICAgICAgdGV4dCxcbiAgICAgICAgICB0ZXh0MS5zdWJzdHJpbmcodGV4dDEubGVuZ3RoIC0gcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKSxcbiAgICAgICAgICBleHBlY3RlZF9sb2MgKyB0ZXh0MS5sZW5ndGggLSByZXNvbHZlZC5tYXRjaE1heEJpdHMsXG4gICAgICAgICAgb3B0aW9uc1xuICAgICAgICApO1xuICAgICAgICBpZiAoZW5kX2xvYyA9PT0gLTEgfHwgc3RhcnRfbG9jID49IGVuZF9sb2MpIHtcbiAgICAgICAgICBzdGFydF9sb2MgPSAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydF9sb2MgPSBtYXRjaE1haW4odGV4dCwgdGV4dDEsIGV4cGVjdGVkX2xvYywgb3B0aW9ucyk7XG4gICAgfVxuICAgIGlmIChzdGFydF9sb2MgPT09IC0xKSB7XG4gICAgICByZXN1bHRzW3hdID0gZmFsc2U7XG4gICAgICBkZWx0YSAtPSBwYXRjaGVzW3hdLmxlbmd0aDIgLSBwYXRjaGVzW3hdLmxlbmd0aDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHNbeF0gPSB0cnVlO1xuICAgICAgZGVsdGEgPSBzdGFydF9sb2MgLSBleHBlY3RlZF9sb2M7XG4gICAgICBsZXQgdGV4dDI7XG4gICAgICBpZiAoZW5kX2xvYyA9PT0gLTEpXG4gICAgICAgIHRleHQyID0gdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jLCBzdGFydF9sb2MgKyB0ZXh0MS5sZW5ndGgpO1xuICAgICAgZWxzZVxuICAgICAgICB0ZXh0MiA9IHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYywgZW5kX2xvYyArIHJlc29sdmVkLm1hdGNoTWF4Qml0cyk7XG4gICAgICBpZiAodGV4dDEgPT09IHRleHQyKSB7XG4gICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MpICsgZGlmZlRleHQyKHBhdGNoZXNbeF0uZGlmZnMpICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgdGV4dDEubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGRpZmZzID0gZGlmZk1haW4odGV4dDEsIHRleHQyLCBvcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIGlmICh0ZXh0MS5sZW5ndGggPiByZXNvbHZlZC5tYXRjaE1heEJpdHMgJiYgZGlmZkxldmVuc2h0ZWluKGRpZmZzKSAvIHRleHQxLmxlbmd0aCA+IHJlc29sdmVkLnBhdGNoRGVsZXRlVGhyZXNob2xkKSB7XG4gICAgICAgICAgcmVzdWx0c1t4XSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZDbGVhbnVwU2VtYW50aWNMb3NzbGVzcyhkaWZmcyk7XG4gICAgICAgICAgbGV0IGluZGV4MSA9IDA7XG4gICAgICAgICAgbGV0IGluZGV4MiA9IDA7XG4gICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCBwYXRjaGVzW3hdLmRpZmZzLmxlbmd0aDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCBtb2QgPSBwYXRjaGVzW3hdLmRpZmZzW3ldO1xuICAgICAgICAgICAgaWYgKG1vZFswXSAhPT0gRElGRl9FUVVBTClcbiAgICAgICAgICAgICAgaW5kZXgyID0gZGlmZlhJbmRleChkaWZmcywgaW5kZXgxKTtcbiAgICAgICAgICAgIGlmIChtb2RbMF0gPT09IERJRkZfSU5TRVJUKSB7XG4gICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydF9sb2MgKyBpbmRleDIpICsgbW9kWzFdICsgdGV4dC5zdWJzdHJpbmcoc3RhcnRfbG9jICsgaW5kZXgyKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAobW9kWzBdID09PSBESUZGX0RFTEVURSkge1xuICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgc3RhcnRfbG9jICsgaW5kZXgyKSArIHRleHQuc3Vic3RyaW5nKHN0YXJ0X2xvYyArIGRpZmZYSW5kZXgoZGlmZnMsIGluZGV4MSArIG1vZFsxXS5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RbMF0gIT09IERJRkZfREVMRVRFKVxuICAgICAgICAgICAgICBpbmRleDEgKz0gbW9kWzFdLmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKG51bGxQYWRkaW5nLmxlbmd0aCwgdGV4dC5sZW5ndGggLSBudWxsUGFkZGluZy5sZW5ndGgpO1xuICByZXR1cm4gW3RleHQsIHJlc3VsdHNdO1xufVxuZnVuY3Rpb24gcGF0Y2hBZGRQYWRkaW5nKHBhdGNoZXMsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgcGF0Y2hNYXJnaW46IHBhZGRpbmdMZW5ndGggPSBkZWZhdWx0T3B0aW9ucy5wYXRjaE1hcmdpblxuICB9ID0gb3B0aW9ucztcbiAgbGV0IG51bGxQYWRkaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgeCA9IDE7IHggPD0gcGFkZGluZ0xlbmd0aDsgeCsrKVxuICAgIG51bGxQYWRkaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoeCk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIHBhdGNoZXNbeF0uc3RhcnQxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2hlc1t4XS5zdGFydDIgKz0gcGFkZGluZ0xlbmd0aDtcbiAgfVxuICBsZXQgcGF0Y2ggPSBwYXRjaGVzWzBdO1xuICBsZXQgZGlmZnMgPSBwYXRjaC5kaWZmcztcbiAgaWYgKGRpZmZzLmxlbmd0aCA9PT0gMCB8fCBkaWZmc1swXVswXSAhPT0gRElGRl9FUVVBTCkge1xuICAgIGRpZmZzLnVuc2hpZnQoY3JlYXRlRGlmZihESUZGX0VRVUFMLCBudWxsUGFkZGluZykpO1xuICAgIHBhdGNoLnN0YXJ0MSAtPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBwYWRkaW5nTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDEgKz0gcGFkZGluZ0xlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgyICs9IHBhZGRpbmdMZW5ndGg7XG4gIH0gZWxzZSBpZiAocGFkZGluZ0xlbmd0aCA+IGRpZmZzWzBdWzFdLmxlbmd0aCkge1xuICAgIGNvbnN0IGV4dHJhTGVuZ3RoID0gcGFkZGluZ0xlbmd0aCAtIGRpZmZzWzBdWzFdLmxlbmd0aDtcbiAgICBkaWZmc1swXVsxXSA9IG51bGxQYWRkaW5nLnN1YnN0cmluZyhkaWZmc1swXVsxXS5sZW5ndGgpICsgZGlmZnNbMF1bMV07XG4gICAgcGF0Y2guc3RhcnQxIC09IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLnN0YXJ0MiAtPSBleHRyYUxlbmd0aDtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcGF0Y2ggPSBwYXRjaGVzW3BhdGNoZXMubGVuZ3RoIC0gMV07XG4gIGRpZmZzID0gcGF0Y2guZGlmZnM7XG4gIGlmIChkaWZmcy5sZW5ndGggPT09IDAgfHwgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMF0gIT09IERJRkZfRVFVQUwpIHtcbiAgICBkaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgbnVsbFBhZGRpbmcpKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IHBhZGRpbmdMZW5ndGg7XG4gICAgcGF0Y2gubGVuZ3RoMiArPSBwYWRkaW5nTGVuZ3RoO1xuICB9IGVsc2UgaWYgKHBhZGRpbmdMZW5ndGggPiBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGgpIHtcbiAgICBjb25zdCBleHRyYUxlbmd0aCA9IHBhZGRpbmdMZW5ndGggLSBkaWZmc1tkaWZmcy5sZW5ndGggLSAxXVsxXS5sZW5ndGg7XG4gICAgZGlmZnNbZGlmZnMubGVuZ3RoIC0gMV1bMV0gKz0gbnVsbFBhZGRpbmcuc3Vic3RyaW5nKDAsIGV4dHJhTGVuZ3RoKTtcbiAgICBwYXRjaC5sZW5ndGgxICs9IGV4dHJhTGVuZ3RoO1xuICAgIHBhdGNoLmxlbmd0aDIgKz0gZXh0cmFMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG51bGxQYWRkaW5nO1xufVxuZnVuY3Rpb24gcGF0Y2hTcGxpdE1heChwYXRjaGVzLCBvcHRpb25zKSB7XG4gIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZU9wdGlvbnMob3B0aW9ucyk7XG4gIGZvciAobGV0IHggPSAwOyB4IDwgcGF0Y2hlcy5sZW5ndGg7IHgrKykge1xuICAgIGlmIChwYXRjaGVzW3hdLmxlbmd0aDEgPD0gcmVzb2x2ZWQubWF0Y2hNYXhCaXRzKVxuICAgICAgY29udGludWU7XG4gICAgY29uc3QgYmlncGF0Y2ggPSBwYXRjaGVzW3hdO1xuICAgIHBhdGNoZXMuc3BsaWNlKHgtLSwgMSk7XG4gICAgbGV0IHN0YXJ0MSA9IGJpZ3BhdGNoLnN0YXJ0MTtcbiAgICBsZXQgc3RhcnQyID0gYmlncGF0Y2guc3RhcnQyO1xuICAgIGxldCBwcmVjb250ZXh0ID0gXCJcIjtcbiAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICBjb25zdCBwYXRjaCA9IGNyZWF0ZVBhdGNoKCk7XG4gICAgICBsZXQgZW1wdHkgPSB0cnVlO1xuICAgICAgcGF0Y2guc3RhcnQxID0gc3RhcnQxIC0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICBwYXRjaC5zdGFydDIgPSBzdGFydDIgLSBwcmVjb250ZXh0Lmxlbmd0aDtcbiAgICAgIGlmIChwcmVjb250ZXh0ICE9PSBcIlwiKSB7XG4gICAgICAgIHBhdGNoLmxlbmd0aDEgPSBwYXRjaC5sZW5ndGgyID0gcHJlY29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0VRVUFMLCBwcmVjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYmlncGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmxlbmd0aDEgPCByZXNvbHZlZC5tYXRjaE1heEJpdHMgLSByZXNvbHZlZC5wYXRjaE1hcmdpbikge1xuICAgICAgICBjb25zdCBkaWZmX3R5cGUgPSBiaWdwYXRjaC5kaWZmc1swXVswXTtcbiAgICAgICAgbGV0IGRpZmZfdGV4dCA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdO1xuICAgICAgICBpZiAoZGlmZl90eXBlID09PSBESUZGX0lOU0VSVCkge1xuICAgICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBzdGFydDIgKz0gZGlmZl90ZXh0Lmxlbmd0aDtcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGJpZ3BhdGNoLmRpZmZzLnNoaWZ0KCkpO1xuICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoZGlmZl90eXBlID09PSBESUZGX0RFTEVURSAmJiBwYXRjaC5kaWZmcy5sZW5ndGggPT09IDEgJiYgcGF0Y2guZGlmZnNbMF1bMF0gPT09IERJRkZfRVFVQUwgJiYgZGlmZl90ZXh0Lmxlbmd0aCA+IDIgKiByZXNvbHZlZC5tYXRjaE1heEJpdHMpIHtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgZW1wdHkgPSBmYWxzZTtcbiAgICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoZGlmZl90eXBlLCBkaWZmX3RleHQpKTtcbiAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRpZmZfdGV4dCA9IGRpZmZfdGV4dC5zdWJzdHJpbmcoMCwgcmVzb2x2ZWQubWF0Y2hNYXhCaXRzIC0gcGF0Y2gubGVuZ3RoMSAtIHJlc29sdmVkLnBhdGNoTWFyZ2luKTtcbiAgICAgICAgICBwYXRjaC5sZW5ndGgxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgc3RhcnQxICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgaWYgKGRpZmZfdHlwZSA9PT0gRElGRl9FUVVBTCkge1xuICAgICAgICAgICAgcGF0Y2gubGVuZ3RoMiArPSBkaWZmX3RleHQubGVuZ3RoO1xuICAgICAgICAgICAgc3RhcnQyICs9IGRpZmZfdGV4dC5sZW5ndGg7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihkaWZmX3R5cGUsIGRpZmZfdGV4dCkpO1xuICAgICAgICAgIGlmIChkaWZmX3RleHQgPT09IGJpZ3BhdGNoLmRpZmZzWzBdWzFdKSB7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmcy5zaGlmdCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiaWdwYXRjaC5kaWZmc1swXVsxXSA9IGJpZ3BhdGNoLmRpZmZzWzBdWzFdLnN1YnN0cmluZyhkaWZmX3RleHQubGVuZ3RoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByZWNvbnRleHQgPSBkaWZmVGV4dDIocGF0Y2guZGlmZnMpO1xuICAgICAgcHJlY29udGV4dCA9IHByZWNvbnRleHQuc3Vic3RyaW5nKHByZWNvbnRleHQubGVuZ3RoIC0gcmVzb2x2ZWQucGF0Y2hNYXJnaW4pO1xuICAgICAgY29uc3QgcG9zdGNvbnRleHQgPSBkaWZmVGV4dDEoYmlncGF0Y2guZGlmZnMpLnN1YnN0cmluZygwLCByZXNvbHZlZC5wYXRjaE1hcmdpbik7XG4gICAgICBpZiAocG9zdGNvbnRleHQgIT09IFwiXCIpIHtcbiAgICAgICAgcGF0Y2gubGVuZ3RoMSArPSBwb3N0Y29udGV4dC5sZW5ndGg7XG4gICAgICAgIHBhdGNoLmxlbmd0aDIgKz0gcG9zdGNvbnRleHQubGVuZ3RoO1xuICAgICAgICBpZiAocGF0Y2guZGlmZnMubGVuZ3RoICE9PSAwICYmIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzBdID09PSBESUZGX0VRVUFMKVxuICAgICAgICAgIHBhdGNoLmRpZmZzW3BhdGNoLmRpZmZzLmxlbmd0aCAtIDFdWzFdICs9IHBvc3Rjb250ZXh0O1xuICAgICAgICBlbHNlXG4gICAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfRVFVQUwsIHBvc3Rjb250ZXh0KSk7XG4gICAgICB9XG4gICAgICBpZiAoIWVtcHR5KVxuICAgICAgICBwYXRjaGVzLnNwbGljZSgrK3gsIDAsIHBhdGNoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBhdGNoVG9UZXh0KHBhdGNoZXMpIHtcbiAgY29uc3QgdGV4dCA9IFtdO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8IHBhdGNoZXMubGVuZ3RoOyB4KyspXG4gICAgdGV4dFt4XSA9IHBhdGNoZXNbeF07XG4gIHJldHVybiB0ZXh0LmpvaW4oXCJcIik7XG59XG5mdW5jdGlvbiBwYXRjaEZyb21UZXh0KHRleHRsaW5lKSB7XG4gIGNvbnN0IHBhdGNoZXMgPSBbXTtcbiAgaWYgKCF0ZXh0bGluZSlcbiAgICByZXR1cm4gcGF0Y2hlcztcbiAgY29uc3QgdGV4dCA9IHRleHRsaW5lLnNwbGl0KFwiXFxuXCIpO1xuICBsZXQgdGV4dFBvaW50ZXIgPSAwO1xuICBjb25zdCBwYXRjaEhlYWRlciA9IC9eQEAgLShcXGQrKSw/KFxcZCopIFxcKyhcXGQrKSw/KFxcZCopIEBAJC87XG4gIHdoaWxlICh0ZXh0UG9pbnRlciA8IHRleHQubGVuZ3RoKSB7XG4gICAgY29uc3QgbSA9IHRleHRbdGV4dFBvaW50ZXJdLm1hdGNoKHBhdGNoSGVhZGVyKTtcbiAgICBpZiAoIW0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGF0Y2ggc3RyaW5nOiAke3RleHRbdGV4dFBvaW50ZXJdfWApO1xuICAgIGNvbnN0IHBhdGNoID0gY3JlYXRlUGF0Y2goKTtcbiAgICBwYXRjaGVzLnB1c2gocGF0Y2gpO1xuICAgIHBhdGNoLnN0YXJ0MSA9IE51bWJlci5wYXJzZUludChtWzFdLCAxMCk7XG4gICAgaWYgKG1bMl0gPT09IFwiXCIpIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzJdID09PSBcIjBcIikge1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0MS0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMSA9IE51bWJlci5wYXJzZUludChtWzJdLCAxMCk7XG4gICAgfVxuICAgIHBhdGNoLnN0YXJ0MiA9IE51bWJlci5wYXJzZUludChtWzNdLCAxMCk7XG4gICAgaWYgKG1bNF0gPT09IFwiXCIpIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDE7XG4gICAgfSBlbHNlIGlmIChtWzRdID09PSBcIjBcIikge1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGNoLnN0YXJ0Mi0tO1xuICAgICAgcGF0Y2gubGVuZ3RoMiA9IE51bWJlci5wYXJzZUludChtWzRdLCAxMCk7XG4gICAgfVxuICAgIHRleHRQb2ludGVyKys7XG4gICAgd2hpbGUgKHRleHRQb2ludGVyIDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHNpZ24gPSB0ZXh0W3RleHRQb2ludGVyXS5jaGFyQXQoMCk7XG4gICAgICBsZXQgbGluZSA9IFwiXCI7XG4gICAgICB0cnkge1xuICAgICAgICBsaW5lID0gZGVjb2RlVVJJKHRleHRbdGV4dFBvaW50ZXJdLnN1YnN0cmluZygxKSk7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYElsbGVnYWwgZXNjYXBlIGluIHBhdGNoX2Zyb21UZXh0OiAke2xpbmV9YCk7XG4gICAgICB9XG4gICAgICBpZiAoc2lnbiA9PT0gXCItXCIpIHtcbiAgICAgICAgcGF0Y2guZGlmZnMucHVzaChjcmVhdGVEaWZmKERJRkZfREVMRVRFLCBsaW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKHNpZ24gPT09IFwiK1wiKSB7XG4gICAgICAgIHBhdGNoLmRpZmZzLnB1c2goY3JlYXRlRGlmZihESUZGX0lOU0VSVCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIiBcIikge1xuICAgICAgICBwYXRjaC5kaWZmcy5wdXNoKGNyZWF0ZURpZmYoRElGRl9FUVVBTCwgbGluZSkpO1xuICAgICAgfSBlbHNlIGlmIChzaWduID09PSBcIkBcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoc2lnbiA9PT0gXCJcIikgOyBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHBhdGNoIG1vZGUgXCIke3NpZ259XCIgaW46ICR7bGluZX1gKTtcbiAgICAgIH1cbiAgICAgIHRleHRQb2ludGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBwYXRjaGVzO1xufVxuZnVuY3Rpb24gY3JlYXRlUGF0Y2goKSB7XG4gIGNvbnN0IHBhdGNoID0ge1xuICAgIGRpZmZzOiBbXSxcbiAgICBzdGFydDE6IG51bGwsXG4gICAgc3RhcnQyOiBudWxsLFxuICAgIGxlbmd0aDE6IDAsXG4gICAgbGVuZ3RoMjogMFxuICB9O1xuICBwYXRjaC50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGxldCBjb29yZHMxLCBjb29yZHMyO1xuICAgIGlmICh0aGlzLmxlbmd0aDEgPT09IDApXG4gICAgICBjb29yZHMxID0gYCR7dGhpcy5zdGFydDF9LDBgO1xuICAgIGVsc2UgaWYgKHRoaXMubGVuZ3RoMSA9PT0gMSlcbiAgICAgIGNvb3JkczEgPSB0aGlzLnN0YXJ0MSArIDE7XG4gICAgZWxzZVxuICAgICAgY29vcmRzMSA9IGAke3RoaXMuc3RhcnQxICsgMX0sJHt0aGlzLmxlbmd0aDF9YDtcbiAgICBpZiAodGhpcy5sZW5ndGgyID09PSAwKVxuICAgICAgY29vcmRzMiA9IGAke3RoaXMuc3RhcnQyfSwwYDtcbiAgICBlbHNlIGlmICh0aGlzLmxlbmd0aDIgPT09IDEpXG4gICAgICBjb29yZHMyID0gdGhpcy5zdGFydDIgKyAxO1xuICAgIGVsc2VcbiAgICAgIGNvb3JkczIgPSBgJHt0aGlzLnN0YXJ0MiArIDF9LCR7dGhpcy5sZW5ndGgyfWA7XG4gICAgY29uc3QgdGV4dCA9IFtgQEAgLSR7Y29vcmRzMX0gKyR7Y29vcmRzMn0gQEBcbmBdO1xuICAgIGxldCBvcDtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMuZGlmZnMubGVuZ3RoOyB4KyspIHtcbiAgICAgIHN3aXRjaCAodGhpcy5kaWZmc1t4XVswXSkge1xuICAgICAgICBjYXNlIERJRkZfSU5TRVJUOlxuICAgICAgICAgIG9wID0gXCIrXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgRElGRl9ERUxFVEU6XG4gICAgICAgICAgb3AgPSBcIi1cIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBESUZGX0VRVUFMOlxuICAgICAgICAgIG9wID0gXCIgXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0ZXh0W3ggKyAxXSA9IGAke29wICsgZW5jb2RlVVJJKHRoaXMuZGlmZnNbeF1bMV0pfVxuYDtcbiAgICB9XG4gICAgcmV0dXJuIHRleHQuam9pbihcIlwiKS5yZXBsYWNlKC8lMjAvZywgXCIgXCIpO1xuICB9O1xuICByZXR1cm4gcGF0Y2g7XG59XG5cbmV4cG9ydCB7IERJRkZfREVMRVRFLCBESUZGX0VRVUFMLCBESUZGX0lOU0VSVCwgZGVmYXVsdE9wdGlvbnMsIGRpZmZNYWluIGFzIGRpZmYsIGRpZmZDbGVhbnVwRWZmaWNpZW5jeSwgZGlmZkNsZWFudXBNZXJnZSwgZGlmZkNsZWFudXBTZW1hbnRpYywgZGlmZkNsZWFudXBTZW1hbnRpY0xvc3NsZXNzLCBkaWZmQ29tbW9uUHJlZml4LCBkaWZmQ29tbW9uU3VmZml4LCBkaWZmRnJvbURlbHRhLCBkaWZmTGV2ZW5zaHRlaW4sIGRpZmZNYWluLCBkaWZmUHJldHR5SHRtbCwgZGlmZlRleHQxLCBkaWZmVGV4dDIsIGRpZmZUb0RlbHRhLCBkaWZmWEluZGV4LCBtYXRjaE1haW4gYXMgbWF0Y2gsIG1hdGNoQWxwaGFiZXQsIG1hdGNoQml0YXAsIG1hdGNoTWFpbiwgcGF0Y2hNYWtlIGFzIHBhdGNoLCBwYXRjaEFkZFBhZGRpbmcsIHBhdGNoQXBwbHksIHBhdGNoRGVlcENvcHksIHBhdGNoRnJvbVRleHQsIHBhdGNoTWFrZSwgcGF0Y2hTcGxpdE1heCwgcGF0Y2hUb1RleHQsIHJlc29sdmVPcHRpb25zIH07XG4iLCAiaW1wb3J0ICogYXMgdGltZSBmcm9tICdsaWIwL3RpbWUnXG5pbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudCdcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gJy4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRm9sZGVyJ1xuXG50eXBlIENsaWVudE1lc3NhZ2UgPSB7XG4gIHR5cGU6IFwiYWRkXCIgfCBcInJlbW92ZVwiIHwgXCJmdWxsXCIsXG4gIGRvY3M6IEFycmF5PHN0cmluZz5cbn1cblxudHlwZSBTZXJ2ZXJNZXNzYWdlID0ge1xuICB0eXBlOiBcImFkZFwiIHwgXCJmdWxsXCIsXG4gIGRvY3M6IEFycmF5PHN0cmluZz5cbn1cblxudHlwZSBFdmVudHMgPSB7XG4gIFwiY29ubmVjdGlvbi1lcnJvclwiOiAoZXZlbnQ6IEV2ZW50LCBjbGllbnQ6IEFjdGl2ZVN0cmVhbUNsaWVudCkgPT4gdm9pZCxcbiAgXCJjb25uZWN0aW9uLWNsb3NlXCI6IChldmVudDogRXZlbnQsIGNsaWVudDogQWN0aXZlU3RyZWFtQ2xpZW50KSA9PiB2b2lkLFxuICBzdGF0dXM6IChzdGF0dXM6IHsgc3RhdHVzOiBzdHJpbmcgfSkgPT4gdm9pZFxufVxuXG5jb25zdCBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA9IDMwMDAwXG5cbmNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZGF0YTogc3RyaW5nKSA9PiB7XG4gIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGRhdGEpIGFzIFNlcnZlck1lc3NhZ2VcbiAgZm9yIChjb25zdCBpZCBvZiBtZXNzYWdlLmRvY3MpIHtcbiAgICBTaGFyZWREb2N1bWVudC5maW5kQnlJZChpZCk/LnN0YXJ0V2ViUlRDU3luYygpXG4gICAgU2hhcmVkRm9sZGVyLmZpbmRCeUlkKGlkKT8uc3RhcnRXZWJSVENTeW5jKClcbiAgfVxufVxuXG5jb25zdCBzZXR1cFdTID0gKGNsaWVudDogQWN0aXZlU3RyZWFtQ2xpZW50KSA9PiB7XG4gIGlmIChjbGllbnQuc2hvdWxkQ29ubmVjdCAmJiBjbGllbnQud3MgPT09IG51bGwpIHtcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KGNsaWVudC51cmwpXG4gICAgY2xpZW50LndzID0gd2Vic29ja2V0XG4gICAgY2xpZW50LndzY29ubmVjdGluZyA9IHRydWVcbiAgICBjbGllbnQud3Njb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgY2xpZW50LndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgaGFuZGxlTWVzc2FnZShldmVudC5kYXRhKVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICBjbGllbnQuZW1pdCgnY29ubmVjdGlvbi1lcnJvcicsIFtldmVudCwgY2xpZW50XSlcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25jbG9zZSA9IChldmVudCkgPT4ge1xuICAgICAgY2xpZW50LmVtaXQoJ2Nvbm5lY3Rpb24tY2xvc2UnLCBbZXZlbnQsIGNsaWVudF0pXG4gICAgICBjbGllbnQud3MgPSBudWxsXG4gICAgICBjbGllbnQud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICAgIGlmIChjbGllbnQud3Njb25uZWN0ZWQpIHtcbiAgICAgICAgY2xpZW50LndzY29ubmVjdGVkID0gZmFsc2VcblxuICAgICAgICBjbGllbnQuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbGllbnQud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIC8vIFN0YXJ0IHdpdGggbm8gcmVjb25uZWN0IHRpbWVvdXQgYW5kIGluY3JlYXNlIHRpbWVvdXQgYnlcbiAgICAgIC8vIHVzaW5nIGV4cG9uZW50aWFsIGJhY2tvZmYgc3RhcnRpbmcgd2l0aCAxMDBtc1xuICAgICAgc2V0VGltZW91dChcbiAgICAgICAgc2V0dXBXUyxcbiAgICAgICAgbWF0aC5taW4oXG4gICAgICAgICAgbWF0aC5wb3coMiwgY2xpZW50LndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykgKiAxMDAsXG4gICAgICAgICAgY2xpZW50Lm1heEJhY2tvZmZUaW1lXG4gICAgICAgICksXG4gICAgICAgIGNsaWVudFxuICAgICAgKVxuICAgIH1cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gKCkgPT4ge1xuICAgICAgY2xpZW50LndzTGFzdE1lc3NhZ2VSZWNlaXZlZCA9IHRpbWUuZ2V0VW5peFRpbWUoKVxuICAgICAgY2xpZW50LndzY29ubmVjdGluZyA9IGZhbHNlXG4gICAgICBjbGllbnQud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBjbGllbnQud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzID0gMFxuICAgICAgY2xpZW50LmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICAgIHN0YXR1czogJ2Nvbm5lY3RlZCdcbiAgICAgIH1dKVxuXG4gICAgICBjbGllbnQuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHR5cGU6IFwiZnVsbFwiLFxuICAgICAgICBkb2NzOiBBcnJheS5mcm9tKGNsaWVudC5kb2NJZHMpXG4gICAgICB9IHNhdGlzZmllcyBDbGllbnRNZXNzYWdlKSlcblxuICAgIH1cbiAgICBjbGllbnQuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgIHN0YXR1czogJ2Nvbm5lY3RpbmcnXG4gICAgfV0pXG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFjdGl2ZVN0cmVhbUNsaWVudCBleHRlbmRzIE9ic2VydmFibGVWMjxFdmVudHM+IHtcblxuICBtYXhCYWNrb2ZmVGltZTogbnVtYmVyXG4gIHVybDogc3RyaW5nXG4gIHdzY29ubmVjdGVkOiBib29sZWFuXG4gIHdzY29ubmVjdGluZzogYm9vbGVhblxuICB3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHM6IG51bWJlclxuICB3czogV2ViU29ja2V0IHwgbnVsbFxuICB3c0xhc3RNZXNzYWdlUmVjZWl2ZWQ6IG51bWJlclxuICBzaG91bGRDb25uZWN0OiBib29sZWFuXG4gIF9yZXN5bmNJbnRlcnZhbDogbnVtYmVyXG5cbiAgZG9jSWRzOiBTZXQ8c3RyaW5nPlxuXG4gIGNvbnN0cnVjdG9yKHVybDogc3RyaW5nLCBvcHRzOiB7XG4gICAgY29ubmVjdDogYm9vbGVhbixcbiAgICByZXN5bmNJbnRlcnZhbDogbnVtYmVyLFxuICAgIG1heEJhY2tvZmZUaW1lOiBudW1iZXIsXG4gIH0gPSB7XG4gICAgICBjb25uZWN0OiB0cnVlLFxuICAgICAgcmVzeW5jSW50ZXJ2YWw6IC0xLFxuICAgICAgbWF4QmFja29mZlRpbWU6IDI1MDBcbiAgICB9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMubWF4QmFja29mZlRpbWUgPSBvcHRzLm1heEJhY2tvZmZUaW1lXG4gICAgdGhpcy51cmwgPSB1cmxcblxuICAgIHRoaXMud3Njb25uZWN0ZWQgPSBmYWxzZVxuICAgIHRoaXMud3Njb25uZWN0aW5nID0gZmFsc2VcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcblxuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gb3B0cy5jb25uZWN0XG4gICAgdGhpcy5fcmVzeW5jSW50ZXJ2YWwgPSAwXG5cbiAgICB0aGlzLmRvY0lkcyA9IG5ldyBTZXQ8c3RyaW5nPigpXG5cbiAgICBpZiAob3B0cy5yZXN5bmNJbnRlcnZhbCA+IDApIHtcbiAgICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gKHdpbmRvdy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLndzICYmIHRoaXMud3MucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgICAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgdHlwZTogXCJmdWxsXCIsXG4gICAgICAgICAgICBkb2NzOiBBcnJheS5mcm9tKHRoaXMuZG9jSWRzKVxuICAgICAgICAgIH0gc2F0aXNmaWVzIENsaWVudE1lc3NhZ2UpKVxuICAgICAgICB9XG4gICAgICB9LCBvcHRzLnJlc3luY0ludGVydmFsKSlcbiAgICB9XG5cbiAgICBpZiAob3B0cy5jb25uZWN0KSB7XG4gICAgICB0aGlzLmNvbm5lY3QoKVxuICAgIH1cbiAgfVxuXG4gIHNlbmQoZGF0YTogc3RyaW5nKSB7XG4gICAgaWYgKHRoaXMud3MgJiYgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLkNPTk5FQ1RJTkcgJiYgdGhpcy53cy5yZWFkeVN0YXRlICE9PSB0aGlzLndzLk9QRU4pIHtcbiAgICAgIHRoaXMud3MuY2xvc2UoKVxuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy53cz8uc2VuZChkYXRhKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMud3M/LmNsb3NlKClcbiAgICB9XG4gIH1cblxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKHRoaXMuX3Jlc3luY0ludGVydmFsICE9PSAwKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3Jlc3luY0ludGVydmFsKVxuICAgIH1cbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIGlmICh0aGlzLndzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgIH1cbiAgfVxuXG4gIGFkZChpZHM6IEFycmF5PHN0cmluZz4pIHtcbiAgICBmb3IgKGNvbnN0IGlkIG9mIGlkcykge1xuICAgICAgdGhpcy5kb2NJZHMuYWRkKGlkKVxuICAgIH1cbiAgICB0aGlzLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgdHlwZTogXCJhZGRcIixcbiAgICAgIGRvY3M6IGlkc1xuICAgIH0gc2F0aXNmaWVzIENsaWVudE1lc3NhZ2UpKVxuICB9XG5cbiAgcmVtb3ZlKGlkczogQXJyYXk8c3RyaW5nPikge1xuICAgIGZvciAoY29uc3QgaWQgb2YgaWRzKSB7XG4gICAgICB0aGlzLmRvY0lkcy5kZWxldGUoaWQpXG4gICAgfVxuICAgIHRoaXMuc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiBcInJlbW92ZVwiLFxuICAgICAgZG9jczogaWRzXG4gICAgfSBzYXRpc2ZpZXMgQ2xpZW50TWVzc2FnZSkpXG4gIH1cbn1cbiIsICJpbXBvcnQgeyBQbGF0Zm9ybSwgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBzZXNzaW9uIH0gZnJvbSAnQGVsZWN0cm9uL3JlbW90ZSc7XG5pbXBvcnQgUGVlcmRyYWZ0UGx1Z2luIGZyb20gXCIuL21haW5cIjtcblxuZXhwb3J0IGNvbnN0IHByZXBhcmVDb21tdW5pY2F0aW9uID0gYXN5bmMgKHBsdWdpbjogUGVlcmRyYWZ0UGx1Z2luKSA9PiB7XG5cbiAgaWYgKFBsYXRmb3JtLmlzRGVza3RvcEFwcCkgeyAgICBcbiAgICBhd2FpdCBzZXNzaW9uLmRlZmF1bHRTZXNzaW9uLmNvb2tpZXMuc2V0KHsgdXJsOiBcImh0dHBzOi8vd3d3LnBlZXJkcmFmdC5hcHBcIiwgXCJuYW1lXCI6IFwib2lkXCIsIFwidmFsdWVcIjogcGx1Z2luLnNldHRpbmdzLm9pZCwgXCJkb21haW5cIjogXCJ3d3cucGVlcmRyYWZ0LmFwcFwiLCBcInBhdGhcIjogXCIvXCIsIFwic2VjdXJlXCI6IHRydWUsIFwiaHR0cE9ubHlcIjogdHJ1ZSwgXCJzYW1lU2l0ZVwiOiBcIm5vX3Jlc3RyaWN0aW9uXCIgfSlcbiAgICBhd2FpdCBzZXNzaW9uLmRlZmF1bHRTZXNzaW9uLmNvb2tpZXMuc2V0KHsgdXJsOiBcImh0dHA6Ly9sb2NhbGhvc3Q6NTE3M1wiLCBcIm5hbWVcIjogXCJvaWRcIiwgXCJ2YWx1ZVwiOiBwbHVnaW4uc2V0dGluZ3Mub2lkLCBcImRvbWFpblwiOiBcImxvY2FsaG9zdFwiLCBcInBhdGhcIjogXCIvXCIsIFwic2VjdXJlXCI6IHRydWUsIFwiaHR0cE9ubHlcIjogdHJ1ZSwgXCJzYW1lU2l0ZVwiOiBcIm5vX3Jlc3RyaWN0aW9uXCIgfSlcbiAgfVxuICBlbHNlIGlmIChQbGF0Zm9ybS5pc01vYmlsZUFwcCkge1xuICAgIGNvbnN0IHNpZ25hbGluZ1VSTCA9IG5ldyBVUkwocGx1Z2luLnNldHRpbmdzLnNpZ25hbGluZylcbiAgICBzaWduYWxpbmdVUkwuc2VhcmNoUGFyYW1zLmFwcGVuZCgnb2lkJywgcGx1Z2luLnNldHRpbmdzLm9pZClcbiAgICBwbHVnaW4uc2V0dGluZ3Muc2lnbmFsaW5nID0gc2lnbmFsaW5nVVJMLnRvU3RyaW5nKClcbiAgfVxufSIsICJpbXBvcnQgeyByZXF1ZXN0VXJsIH0gZnJvbSBcIm9ic2lkaWFuXCJcbmltcG9ydCB7IHNob3dOb3RpY2UgfSBmcm9tIFwiLi91aVwiXG5cbmV4cG9ydCBjbGFzcyBTZXJ2ZXJBUEkge1xuXG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBvcHRzOiB7XG4gICAgICBvaWQ6IHN0cmluZyxcbiAgICAgIHBlcm1hbmVudFNlc3Npb25Vcmw6IHN0cmluZ1xuICAgIH1cbiAgKXt9XG5cbiAgYXN5bmMgY3JlYXRlUGVybWFuZW50U2Vzc2lvbiAoKSB7XG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcXVlc3RVcmwoe1xuICAgICAgdXJsOiB0aGlzLm9wdHMucGVybWFuZW50U2Vzc2lvblVybCxcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgY29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBvaWQ6IHRoaXMub3B0cy5vaWRcbiAgICAgIH0pXG4gICAgfSkuanNvblxuICBcbiAgICBpZiAoIWRhdGEgfHwgIWRhdGEuaWQpIHtcbiAgICAgIHNob3dOb3RpY2UoXCJFcnJvciBjcmVhdGluZyBzaGFyZWQgZmlsZVwiKVxuICAgICAgcmV0dXJuIFxuICAgIH1cbiAgICByZXR1cm4gZGF0YSBhcyB7aWQ6IHN0cmluZ31cbiAgfVxuXG4gIGFzeW5jIGlzU2Vzc2lvblBlcm1hbmVudCAoaWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXF1ZXN0VXJsKHtcbiAgICAgIHVybDogdGhpcy5vcHRzLnBlcm1hbmVudFNlc3Npb25VcmwgKyBcIi9cIiArIGlkLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICB9KS5qc29uXG4gIFxuICAgIGlmICghZGF0YSkge1xuICAgICAgc2hvd05vdGljZShcIkVycm9yIGNyZWF0aW5nIHNoYXJlZCBmaWxlXCIpXG4gICAgICByZXR1cm4gXG4gICAgfVxuICAgIHJldHVybiAhIWRhdGEucGVybWFuZW50XG4gIH1cbn1cbiIsICJpbXBvcnQgUGVlcmRyYWZ0UGx1Z2luIGZyb20gXCJzcmMvcGVlcmRyYWZ0UGx1Z2luXCI7XG5pbXBvcnQgeyBTaGFyZWRFbnRpdHkgfSBmcm9tIFwiLi9zaGFyZWRFbnRpdHlcIjtcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSBcIi4vc2hhcmVkRG9jdW1lbnRcIjtcbmltcG9ydCB7IFNoYXJlZEZvbGRlciB9IGZyb20gXCIuL3NoYXJlZEZvbGRlclwiO1xuXG5leHBvcnQgY29uc3QgZnJvbVNoYXJlVVJMID0gYXN5bmMgKHVybDogc3RyaW5nLCBwbHVnaW46IFBlZXJkcmFmdFBsdWdpbik6IFByb21pc2U8U2hhcmVkRW50aXR5IHwgdm9pZD4gPT4ge1xuICBjb25zdCBzcGxpdHRlZFVybCA9IHVybC5zcGxpdCgnLycpXG4gIGlmIChzcGxpdHRlZFVybD8uY29udGFpbnMoJ2NtJykpIHtcbiAgICByZXR1cm4gU2hhcmVkRG9jdW1lbnQuZnJvbVNoYXJlVVJMKHVybCwgcGx1Z2luKVxuICB9XG4gIGlmIChzcGxpdHRlZFVybD8uY29udGFpbnMoJ3RlYW0nKSkge1xuICAgIHJldHVybiBTaGFyZWRGb2xkZXIuZnJvbVNoYXJlVVJMKHVybCwgcGx1Z2luKVxuICB9XG59IiwgIlxuaW1wb3J0IHsgQXBwLCBNb2RhbCwgU2V0dGluZyB9IGZyb20gXCJvYnNpZGlhblwiXG5cbmNsYXNzIENob29zZVNlc3Npb25UeXBlTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG5cbiAgY2I6IChyZXN1bHQ6IHtwZXJtYW5lbnQ6IGJvb2xlYW59KSA9PiBhbnlcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgY2I6IChyZXN1bHQ6IHtwZXJtYW5lbnQ6IGJvb2xlYW59KSA9PiBhbnkpIHtcbiAgICBzdXBlcihhcHApXG4gICAgdGhpcy5jYiA9IGNiXG4gIH1cblxuICBhc3luYyBvbk9wZW4oKSB7XG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLnNldE5hbWUoXCJTdGFydCB3b3JraW5nIHRvZ2V0aGVyXCIpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLmFkZEJ1dHRvbihidXR0b24gPT4ge1xuICAgICAgYnV0dG9uLnNldEJ1dHRvblRleHQoXCJTdGFydCBmbGVldGluZyBzZXNzaW9uXCIpXG4gICAgICBidXR0b24uc2V0Q3RhKClcbiAgICAgIGJ1dHRvbi5vbkNsaWNrKCgpID0+IHtcbiAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgIHRoaXMuY2Ioe1xuICAgICAgICAgIHBlcm1hbmVudDogZmFsc2VcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSkuc2V0RGVzYyhcIkEgZmxlZXRpbmcgc2Vzc2lvbiBhdXRvbWF0aWNhbGx5IGNsb3NlcyB3aGVuIHlvdSBjbG9zZSB0aGUgZG9jdW1lbnQgb3IgZGlzY29ubmVjdC5cIilcblxuICAgIG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKS5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiU2hhcmUgcGVybWFuZW50bHlcIilcbiAgICAgIGJ1dHRvbi5zZXRDdGEoKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih7XG4gICAgICAgICAgcGVybWFuZW50OiB0cnVlXG4gICAgICAgIH0pXG4gICAgICB9KVxuICAgIH0pLnNldERlc2MoXCJUaGUgZG9jdW1lbnQgd2lsbCBiZSBzaGFyZWQgcGVybWFuZW50bHkgdW50aWwgeW91IGV4cGxpY2l0ZWx5IHN0b3Agc2hhcmluZy4gVGhpcyBpcyBwZXJzaXN0ZWQgZXZlbiBpZiB5b3UgZGlzY29ubmVjdCBvciBjbG9zZSBPYnNpZGlhbi5cIilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yU2Vzc2lvblR5cGUgPSAoYXBwOiBBcHApID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlPHtwZXJtYW5lbnQ6IGJvb2xlYW59IHwgdm9pZD4oKHJlc29sdmUpID0+IHtcbiAgICBuZXcgQ2hvb3NlU2Vzc2lvblR5cGVNb2RhbChhcHAsIChyZXN1bHQpID0+IHtcbiAgICAgIHJlc29sdmUocmVzdWx0KVxuICAgIH0pLm9wZW4oKVxuICB9KVxufSIsICJcbmltcG9ydCB7IEFwcCwgTW9kYWwsIFNldHRpbmcgfSBmcm9tIFwib2JzaWRpYW5cIlxuXG50eXBlIE9QVFMgPSB7XG4gIGhlYWRlcjogc3RyaW5nLFxuICBkZXNjcmlwdGlvbjogc3RyaW5nLFxuICBpbml0aWFsOiBSRVNVTFRcbn1cblxudHlwZSBSRVNVTFQgPSB7XG4gIHRleHQ6IHN0cmluZ1xufVxuXG5jbGFzcyBFbnRlclRleHRNb2RhbCBleHRlbmRzIE1vZGFsIHtcblxuICBjYjogKHJlc3VsdDogeyB0ZXh0OiBzdHJpbmcgfSkgPT4gYW55XG4gIG9wdHM6IE9QVFNcbiAgcmVzdWx0OiBSRVNVTFRcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgb3B0czogT1BUUywgY2I6IChyZXN1bHQ6IFJFU1VMVCkgPT4gYW55KSB7XG4gICAgc3VwZXIoYXBwKVxuICAgIHRoaXMuY2IgPSBjYlxuICAgIHRoaXMucmVzdWx0ID0gb3B0cy5pbml0aWFsXG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKS5zZXROYW1lKHRoaXMub3B0cy5oZWFkZXIpLnNldEhlYWRpbmcoKVxuXG4gICAgbmV3IFNldHRpbmcodGhpcy5jb250ZW50RWwpLmFkZFRleHQodGV4dCA9PiB7XG4gICAgICB0ZXh0LnNldFZhbHVlKHRoaXMucmVzdWx0LnRleHQpLFxuICAgICAgICB0ZXh0Lm9uQ2hhbmdlKCh2YWx1ZSkgPT4ge1xuICAgICAgICAgIHRoaXMucmVzdWx0LnRleHQgPSB2YWx1ZVxuICAgICAgICB9KVxuICAgICAgdGV4dC5pbnB1dEVsLm9ua2V5ZG93biA9IChldikgPT4ge1xuICAgICAgICBpZiAoZXYua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICAgICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pLnNldERlc2ModGhpcy5vcHRzLmRlc2NyaXB0aW9uKVxuXG4gICAgY29uc3QgYnV0dG9ucyA9IG5ldyBTZXR0aW5nKHRoaXMuY29udGVudEVsKVxuXG4gICAgYnV0dG9ucy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiQ2FuY2VsXCIpXG4gICAgICBidXR0b24ub25DbGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xvc2UoKVxuICAgICAgfSlcbiAgICB9KVxuXG4gICAgYnV0dG9ucy5hZGRCdXR0b24oYnV0dG9uID0+IHtcbiAgICAgIGJ1dHRvbi5zZXRCdXR0b25UZXh0KFwiT0tcIilcbiAgICAgIGJ1dHRvbi5zZXRDdGEoKVxuICAgICAgYnV0dG9uLm9uQ2xpY2soKCkgPT4ge1xuICAgICAgICB0aGlzLmNsb3NlKClcbiAgICAgICAgdGhpcy5jYih0aGlzLnJlc3VsdClcbiAgICAgIH0pXG4gICAgfSlcblxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwcm9tcHRGb3JUZXh0ID0gKGFwcDogQXBwLCBvcHRzOiBPUFRTKSA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZTxSRVNVTFQgfCB2b2lkPigocmVzb2x2ZSkgPT4ge1xuICAgIG5ldyBFbnRlclRleHRNb2RhbChhcHAsIG9wdHMsIChjYikgPT4ge1xuICAgICAgcmVzb2x2ZShjYilcbiAgICB9KS5vcGVuKClcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHByb21wdEZvclVSTCA9IChhcHA6IEFwcCkgPT4ge1xuICByZXR1cm4gcHJvbXB0Rm9yVGV4dChhcHAsIHtcbiAgICBkZXNjcmlwdGlvbjogXCJFbnRlciB0aGUgVVJMIHlvdSByZWNlaXZlZCB0byBzdGFydCB3b3JraW5nIHRvZ2V0aGVyLlwiLFxuICAgIGhlYWRlcjogXCJFbnRlciB5b3VyIFBlZXJkcmFmdCBVUkxcIixcbiAgICBpbml0aWFsOiB7XG4gICAgICB0ZXh0OiBcIlwiXG4gICAgfVxuICB9KVxufVxuXG5leHBvcnQgY29uc3QgcHJvbXB0Rm9yTmFtZSA9IChhcHA6IEFwcCkgPT4ge1xuICByZXR1cm4gcHJvbXB0Rm9yVGV4dChhcHAsIHtcbiAgICBkZXNjcmlwdGlvbjogXCJUaGlzIG5hbWUgd2lsbCBiZSBzaG93biB0byB5b3VyIGNvbGxhYm9yYXRvcnNcIixcbiAgICBoZWFkZXI6IFwiV2hhdCdzIHlvdXIgbmFtZT9cIixcbiAgICBpbml0aWFsOiB7XG4gICAgICB0ZXh0OiBcIlwiXG4gICAgfVxuICB9KVxufSIsICJpbXBvcnQgKiBhcyBZIGZyb20gJ3lqcydcbmltcG9ydCAqIGFzIHRpbWUgZnJvbSAnbGliMC90aW1lJ1xuaW1wb3J0ICogYXMgZW5jb2RpbmcgZnJvbSAnbGliMC9lbmNvZGluZydcbmltcG9ydCAqIGFzIGRlY29kaW5nIGZyb20gJ2xpYjAvZGVjb2RpbmcnXG5pbXBvcnQgeyBPYnNlcnZhYmxlVjIgfSBmcm9tICdsaWIwL29ic2VydmFibGUnXG5pbXBvcnQgKiBhcyBtYXRoIGZyb20gJ2xpYjAvbWF0aCdcbmltcG9ydCB7IFNoYXJlZERvY3VtZW50IH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWREb2N1bWVudCdcbmltcG9ydCB7IFNoYXJlZEVudGl0eSB9IGZyb20gJy4vc2hhcmVkRW50aXRpZXMvc2hhcmVkRW50aXR5J1xuaW1wb3J0IHsgU2hhcmVkRm9sZGVyIH0gZnJvbSAnLi9zaGFyZWRFbnRpdGllcy9zaGFyZWRGb2xkZXInXG5pbXBvcnQgeyBjYWxjdWxhdGVIYXNoLCBzZXJpYWxpemUgfSBmcm9tICcuL3Rvb2xzJ1xuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9TWU5DID0gMFxuZXhwb3J0IGNvbnN0IE1FU1NBR0VfUVVFUllfQVdBUkVORVNTID0gM1xuZXhwb3J0IGNvbnN0IE1FU1NBR0VfQVdBUkVORVNTID0gMVxuZXhwb3J0IGNvbnN0IE1FU1NBR0VfQVVUSCA9IDJcblxuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQyA9IDRcblxuZXhwb3J0IGNvbnN0IFNZTkNfU1RFUF8xID0gMFxuZXhwb3J0IGNvbnN0IFNZTkNfU1RFUF8yID0gMVxuZXhwb3J0IGNvbnN0IFVQREFURSA9IDNcbmV4cG9ydCBjb25zdCBORVdfRE9DVU1FTlQgPSA0XG5leHBvcnQgY29uc3QgTkVXX0RPQ1VNRU5UX0NPTkZJUk1FRCA9IDVcbmV4cG9ydCBjb25zdCBHRVRfRE9DVU1FTlRfQVNfVVBEQVRFID0gNlxuZXhwb3J0IGNvbnN0IFNFTkRfRE9DVU1FTlRfQVNfVVBEQVRFID0gN1xuXG5leHBvcnQgY29uc3QgTUVTU0FHRV9BVVRIRU5USUNBVElPTl9SRVFVRVNUID0gNVxuZXhwb3J0IGNvbnN0IE1FU1NBR0VfQVVUSEVOVElDQVRJT05fUkVTUE9OU0UgPSA2XG5cbmNvbnN0IG1lc3NhZ2VSZWNvbm5lY3RUaW1lb3V0ID0gMzAwMDBcblxuXG5cbmNvbnN0IHNldHVwV1MgPSAocHJvdmlkZXI6IFBlZXJkcmFmdFdlYnNvY2tldFByb3ZpZGVyKSA9PiB7XG4gIGlmIChwcm92aWRlci5zaG91bGRDb25uZWN0ICYmIHByb3ZpZGVyLndzID09PSBudWxsKSB7XG4gICAgY29uc3Qgd2Vic29ja2V0ID0gbmV3IFdlYlNvY2tldChwcm92aWRlci51cmwpXG4gICAgd2Vic29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInXG4gICAgcHJvdmlkZXIud3MgPSB3ZWJzb2NrZXRcbiAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSB0cnVlXG4gICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSBmYWxzZVxuXG4gICAgd2Vic29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBjb25zdCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoZXZlbnQuZGF0YSlcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PSAwKSByZXR1cm5cbiAgICAgIGNvbnN0IGRlY29kZXIgPSBkZWNvZGluZy5jcmVhdGVEZWNvZGVyKGRhdGEpXG4gICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50KGRlY29kZXIpXG4gICAgICBpZiAobWVzc2FnZVR5cGUgPT09IE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpIHtcbiAgICAgICAgY29uc3Qgc3luY01lc3NhZ2VUeXBlID0gZGVjb2RpbmcucmVhZFZhclVpbnQoZGVjb2RlcilcbiAgICAgICAgc3dpdGNoIChzeW5jTWVzc2FnZVR5cGUpIHtcbiAgICAgICAgICBjYXNlIE5FV19ET0NVTUVOVF9DT05GSVJNRUQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNvbnN0IHRlbXBJZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgICAgY29uc3QgaWQgPSBkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpXG4gICAgICAgICAgICAgIGNvbnN0IGNoZWNrc3VtID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgICBwcm92aWRlci5lbWl0KCduZXctZG9jLWNvbmZpcm1lZCcsIFt0ZW1wSWQsIGlkLCBjaGVja3N1bV0pXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNZTkNfU1RFUF8xOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHZlY3RvciA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoaWQpID8/IFNoYXJlZEZvbGRlci5maW5kQnlJZChpZClcbiAgICAgICAgICAgIGlmIChkb2MgJiYgaGFzaCAhPSBkb2MuY2FsY3VsYXRlSGFzaCgpKSB7XG4gICAgICAgICAgICAgIHByb3ZpZGVyLnNlbmRTeW5jU3RlcDIoZG9jLCB2ZWN0b3IpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBicmVhaztcbiAgICAgICAgICBjYXNlIFNZTkNfU1RFUF8yOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBoYXNoID0gZGVjb2RpbmcucmVhZFZhclN0cmluZyhkZWNvZGVyKVxuICAgICAgICAgICAgY29uc3QgZG9jID0gU2hhcmVkRG9jdW1lbnQuZmluZEJ5SWQoaWQpID8/IFNoYXJlZEZvbGRlci5maW5kQnlJZChpZClcbiAgICAgICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgICAgWS5hcHBseVVwZGF0ZShkb2MueURvYywgdXBkYXRlLCBwcm92aWRlcilcbiAgICAgICAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3luY2VkJywgW2lkLCBoYXNoXSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFNFTkRfRE9DVU1FTlRfQVNfVVBEQVRFOiB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZSA9IGRlY29kaW5nLnJlYWRWYXJVaW50OEFycmF5KGRlY29kZXIpXG4gICAgICAgICAgICBjb25zdCBjaGVja3N1bSA9IGRlY29kaW5nLnJlYWRWYXJTdHJpbmcoZGVjb2RlcilcbiAgICAgICAgICAgIHByb3ZpZGVyLmVtaXQoXCJkb2N1bWVudC1yZWNlaXZlZFwiLCBbaWQsIHVwZGF0ZSwgY2hlY2tzdW1dKVxuICAgICAgICAgIH0gYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5yZWFjaGFibGVcIilcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChtZXNzYWdlVHlwZSA9PT0gTUVTU0FHRV9BVVRIRU5USUNBVElPTl9SRVNQT05TRSkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShkZWNvZGluZy5yZWFkVmFyU3RyaW5nKGRlY29kZXIpKVxuICAgICAgICBwcm92aWRlci5hdXRoZW50aWNhdGVkID0gdHJ1ZVxuICAgICAgICBwcm92aWRlci5lbWl0KCdhdXRoZW50aWNhdGVkJywgW2RhdGFdKVxuICAgICAgfVxuICAgIH1cblxuICAgIHdlYnNvY2tldC5vbmVycm9yID0gKGV2ZW50KSA9PiB7XG4gICAgICBwcm92aWRlci5lbWl0KCdjb25uZWN0aW9uLWVycm9yJywgW2V2ZW50LCBwcm92aWRlcl0pXG4gICAgfVxuXG4gICAgd2Vic29ja2V0Lm9uY2xvc2UgPSAoZXZlbnQpID0+IHtcbiAgICAgIHByb3ZpZGVyLmVtaXQoJ2Nvbm5lY3Rpb24tY2xvc2UnLCBbZXZlbnQsIHByb3ZpZGVyXSlcbiAgICAgIGlmIChwcm92aWRlci5hdXRoZW50aWNhdGVkKSB7XG4gICAgICAgIHByb3ZpZGVyLmF1dGhlbnRpY2F0ZWQgPSBmYWxzZVxuICAgICAgfVxuICAgICAgcHJvdmlkZXIud3MgPSBudWxsXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgaWYgKHByb3ZpZGVyLndzY29ubmVjdGVkKSB7XG4gICAgICAgIHByb3ZpZGVyLndzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgcHJvdmlkZXIuZW1pdCgnc3RhdHVzJywgW3tcbiAgICAgICAgICBzdGF0dXM6ICdkaXNjb25uZWN0ZWQnXG4gICAgICAgIH1dKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvdmlkZXIud3NVbnN1Y2Nlc3NmdWxSZWNvbm5lY3RzKytcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgIHNldHVwV1MsXG4gICAgICAgIG1hdGgubWluKFxuICAgICAgICAgIG1hdGgucG93KDIsIHByb3ZpZGVyLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cykgKiAxMDAsXG4gICAgICAgICAgcHJvdmlkZXIubWF4QmFja29mZlRpbWVcbiAgICAgICAgKSxcbiAgICAgICAgcHJvdmlkZXJcbiAgICAgIClcbiAgICB9XG5cbiAgICB3ZWJzb2NrZXQub25vcGVuID0gYXN5bmMgKCkgPT4ge1xuICAgICAgcHJvdmlkZXIud3NMYXN0TWVzc2FnZVJlY2VpdmVkID0gdGltZS5nZXRVbml4VGltZSgpXG4gICAgICBwcm92aWRlci53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgICAgcHJvdmlkZXIud3Njb25uZWN0ZWQgPSB0cnVlXG4gICAgICBwcm92aWRlci53c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHMgPSAwXG4gICAgICBwcm92aWRlci5lbWl0KCdzdGF0dXMnLCBbe1xuICAgICAgICBzdGF0dXM6ICdjb25uZWN0ZWQnXG4gICAgICB9XSlcblxuICAgICAgaWYgKHByb3ZpZGVyLmp3dCkge1xuICAgICAgICBwcm92aWRlci5hdXRoZW50aWNhdGUocHJvdmlkZXIuand0KVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZvbGRlciBvZiBTaGFyZWRGb2xkZXIuZ2V0QWxsKCkpIHtcbiAgICAgICAgaWYgKGZvbGRlci5pbmRleGVkREJQcm92aWRlcikge1xuICAgICAgICAgIGlmICghZm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyLnN5bmNlZCkgYXdhaXQgZm9sZGVyLmluZGV4ZWREQlByb3ZpZGVyLndoZW5TeW5jZWRcbiAgICAgICAgICBmb2xkZXIuc3luY1dpdGhTZXJ2ZXIoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgZG9jIG9mIFNoYXJlZERvY3VtZW50LmdldEFsbCgpKSB7XG4gICAgICAgIGlmIChkb2MuaXNQZXJtYW5lbnQgJiYgZG9jLmluZGV4ZWREQlByb3ZpZGVyKSB7XG4gICAgICAgICAgaWYgKCFkb2MuaW5kZXhlZERCUHJvdmlkZXIuc3luY2VkKSBhd2FpdCBkb2MuaW5kZXhlZERCUHJvdmlkZXIud2hlblN5bmNlZFxuICAgICAgICAgIGRvYy5zeW5jV2l0aFNlcnZlcigpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH1cblxuICAgIHByb3ZpZGVyLmVtaXQoJ3N0YXR1cycsIFt7XG4gICAgICBzdGF0dXM6ICdjb25uZWN0aW5nJ1xuICAgIH1dKVxuICB9XG59XG5cbmludGVyZmFjZSBBdXRoUmVzcG9uc2VEYXRhIHtcbiAgcGxhbjoge1xuICAgIHR5cGU6IFwiaG9iYnlcIiB8IFwicHJvZmVzc2lvbmFsXCIgfCBcInRlYW1cIlxuICB9XG59XG5cbnR5cGUgRXZlbnRzID0ge1xuICBzeW5jZWQ6IChpZDogc3RyaW5nLCBoYXNoOiBzdHJpbmcpID0+IHZvaWRcbiAgLy8gc3luYzogKHN0YXRlOiBib29sZWFuKSA9PiB2b2lkXG4gIFwiY29ubmVjdGlvbi1lcnJvclwiOiAoZXZlbnQ6IEV2ZW50LCBwcm92aWRlcjogUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIpID0+IHZvaWRcbiAgXCJjb25uZWN0aW9uLWNsb3NlXCI6IChldmVudDogRXZlbnQsIHByb3ZpZGVyOiBQZWVyZHJhZnRXZWJzb2NrZXRQcm92aWRlcikgPT4gdm9pZFxuICBzdGF0dXM6IChzdGF0dXM6IHsgc3RhdHVzOiBzdHJpbmcgfSkgPT4gdm9pZFxuICAnZG9jdW1lbnQtcmVjZWl2ZWQnOiAoaWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gIC8vICdzeW5jLWNvbmZpcm1lZCc6IChpZDogc3RyaW5nLCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gICduZXctZG9jLWNvbmZpcm1lZCc6ICh0ZW1wSWQ6IHN0cmluZywgaWQ6IHN0cmluZywgY2hlY2tzdW06IHN0cmluZykgPT4gdm9pZFxuICAvLyAnbXktdXBkYXRlLXNlbnQnOiAoaWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSA9PiB2b2lkXG4gIC8vICdvdGhlci1kb2N1bWVudC1yZWNlaXZlZC1pZi1jaGVja3N1bS1kaWZmZXJzJzogKGlkOiBzdHJpbmcsIG15Q2hlY2tzdW06IHN0cmluZywgeW91ckNoZWNrc3VtOiBzdHJpbmcsIHVwZGF0ZT86IFVpbnQ4QXJyYXkpID0+IHZvaWRcbiAgJ2F1dGhlbnRpY2F0ZWQnOiAoZGF0YTogQXV0aFJlc3BvbnNlRGF0YSkgPT4gdm9pZFxufVxuXG5leHBvcnQgY2xhc3MgUGVlcmRyYWZ0V2Vic29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBPYnNlcnZhYmxlVjI8RXZlbnRzPiB7XG5cbiAgcGFyYW1zPzogeyBbczogc3RyaW5nXTogc3RyaW5nIH07XG4gIFdlYlNvY2tldFBvbHlmaWxsPzogdHlwZW9mIFdlYlNvY2tldDtcbiAgcmVzeW5jSW50ZXJ2YWw/OiBudW1iZXI7XG4gIG1heEJhY2tvZmZUaW1lOiBudW1iZXI7XG4gIHVybDogc3RyaW5nXG4gIHdzY29ubmVjdGVkOiBib29sZWFuXG4gIHdzY29ubmVjdGluZzogYm9vbGVhblxuICB3c1Vuc3VjY2Vzc2Z1bFJlY29ubmVjdHM6IG51bWJlclxuICBfc3luY2VkOiBib29sZWFuXG4gIHdzOiBXZWJTb2NrZXQgfCBudWxsXG4gIHdzTGFzdE1lc3NhZ2VSZWNlaXZlZDogbnVtYmVyXG4gIHNob3VsZENvbm5lY3Q6IGJvb2xlYW5cbiAgX3Jlc3luY0ludGVydmFsOiBudW1iZXJcbiAgX3VwZGF0ZUhhbmRsZXI6ICh1cGRhdGU6IFVpbnQ4QXJyYXksIG9yaWdpbjogYW55KSA9PiB2b2lkXG4gIF9hd2FyZW5lc3NVcGRhdGVIYW5kbGVyOiAoeyBhZGRlZCwgdXBkYXRlZCwgcmVtb3ZlZCB9OiBhbnksIF9vcmlnaW46IGFueSkgPT4gdm9pZFxuICBfZXhpdEhhbmRsZXI6ICgpID0+IHZvaWRcbiAgX2NoZWNrSW50ZXJ2YWw6IG51bWJlclxuICBhdXRoZW50aWNhdGVkOiBib29sZWFuXG4gIGp3dDogc3RyaW5nIHwgdW5kZWZpbmVkXG5cbiAgY29uc3RydWN0b3Ioc2VydmVyVXJsOiBzdHJpbmcsIHtcbiAgICBjb25uZWN0ID0gdHJ1ZSxcbiAgICByZXN5bmNJbnRlcnZhbCA9IC0xLFxuICAgIG1heEJhY2tvZmZUaW1lID0gMjUwMCxcbiAgICBqd3QgPSB1bmRlZmluZWRcbiAgfTogeyBqd3Q/OiBzdHJpbmcsIGNvbm5lY3Q/OiBib29sZWFuOyBwYXJhbXM/OiB7IFtzOiBzdHJpbmddOiBzdHJpbmcgfTsgV2ViU29ja2V0UG9seWZpbGw/OiB0eXBlb2YgV2ViU29ja2V0OyByZXN5bmNJbnRlcnZhbD86IG51bWJlcjsgbWF4QmFja29mZlRpbWU/OiBudW1iZXI7IGRpc2FibGVCYz86IGJvb2xlYW4gfSA9IHt9KSB7XG4gICAgc3VwZXIoKVxuICAgIHRoaXMudXJsID0gc2VydmVyVXJsXG4gICAgdGhpcy5tYXhCYWNrb2ZmVGltZSA9IG1heEJhY2tvZmZUaW1lXG4gICAgdGhpcy53c2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgdGhpcy53c2Nvbm5lY3RpbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gcmVzeW5jSW50ZXJ2YWxcbiAgICB0aGlzLndzVW5zdWNjZXNzZnVsUmVjb25uZWN0cyA9IDBcbiAgICB0aGlzLl9zeW5jZWQgPSBmYWxzZVxuICAgIHRoaXMud3MgPSBudWxsXG4gICAgdGhpcy53c0xhc3RNZXNzYWdlUmVjZWl2ZWQgPSAwXG4gICAgdGhpcy5zaG91bGRDb25uZWN0ID0gY29ubmVjdFxuICAgIHRoaXMuX3Jlc3luY0ludGVydmFsID0gMFxuICAgIHRoaXMuYXV0aGVudGljYXRlZCA9IGZhbHNlXG4gICAgdGhpcy5qd3QgPSBqd3RcblxuICAgIHRoaXMuX2NoZWNrSW50ZXJ2YWwgPSAod2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy53c2Nvbm5lY3RlZCAmJlxuICAgICAgICBtZXNzYWdlUmVjb25uZWN0VGltZW91dCA8XG4gICAgICAgIHRpbWUuZ2V0VW5peFRpbWUoKSAtIHRoaXMud3NMYXN0TWVzc2FnZVJlY2VpdmVkXG4gICAgICApIHtcbiAgICAgICAgKHRoaXMud3MhKS5jbG9zZSgpXG4gICAgICB9XG4gICAgfSwgbWVzc2FnZVJlY29ubmVjdFRpbWVvdXQgLyAxMCkpXG4gICAgaWYgKGNvbm5lY3QpIHtcbiAgICAgIHRoaXMuY29ubmVjdCgpXG4gICAgfVxuICB9XG5cbiAgc2VuZFN5bmNTdGVwMShkb2M6IFNoYXJlZEVudGl0eSkge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgU1lOQ19TVEVQXzEpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLnNoYXJlSWQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVWZWN0b3IoZG9jLnlEb2MpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5jYWxjdWxhdGVIYXNoKCkpXG4gICAgdGhpcy5zZW5kTWVzc2FnZShlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH1cblxuICBzZW5kU3luY1N0ZXAyKGRvYzogU2hhcmVkRW50aXR5LCB2ZWN0b3I/OiBVaW50OEFycmF5KSB7XG4gICAgY29uc3QgZW5jb2RlciA9IGVuY29kaW5nLmNyZWF0ZUVuY29kZXIoKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBNRVNTQUdFX01VTFRJUExFWF9TWU5DKVxuICAgIGVuY29kaW5nLndyaXRlVmFyVWludChlbmNvZGVyLCBTWU5DX1NURVBfMilcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2Muc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYy55RG9jLCB2ZWN0b3IpKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5jYWxjdWxhdGVIYXNoKCkpXG4gICAgdGhpcy5zZW5kTWVzc2FnZShlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH1cblxuICBzZW5kVXBkYXRlKGRvYzogU2hhcmVkRW50aXR5LCB1cGRhdGU6IFVpbnQ4QXJyYXkpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIFVQREFURSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBkb2Muc2hhcmVJZClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQ4QXJyYXkoZW5jb2RlciwgdXBkYXRlKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGRvYy5jYWxjdWxhdGVIYXNoKCkpXG4gICAgdGhpcy5zZW5kTWVzc2FnZShlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH1cblxuICBzZW5kVXBkYXRlTWVzc2FnZShzaGFyZUlkOiBzdHJpbmcsIHVwZGF0ZTogVWludDhBcnJheSwgY2hlY2tzdW06IHN0cmluZykge1xuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9NVUxUSVBMRVhfU1lOQylcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgVVBEQVRFKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIHNoYXJlSWQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIHVwZGF0ZSlcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCBjaGVja3N1bSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmROZXdEb2N1bWVudChkb2M6IFNoYXJlZEVudGl0eSwgdGVtcElkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE5FV19ET0NVTUVOVClcbiAgICBlbmNvZGluZy53cml0ZVZhclN0cmluZyhlbmNvZGVyLCB0ZW1wSWQpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50OEFycmF5KGVuY29kZXIsIFkuZW5jb2RlU3RhdGVBc1VwZGF0ZShkb2MueURvYykpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgZG9jLmNhbGN1bGF0ZUhhc2goKSlcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIHNlbmRHZXREb2N1bWVudEFzVXBkYXRlKGlkOiBzdHJpbmcpIHtcbiAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RpbmcuY3JlYXRlRW5jb2RlcigpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIE1FU1NBR0VfTVVMVElQTEVYX1NZTkMpXG4gICAgZW5jb2Rpbmcud3JpdGVWYXJVaW50KGVuY29kZXIsIEdFVF9ET0NVTUVOVF9BU19VUERBVEUpLFxuICAgICAgZW5jb2Rpbmcud3JpdGVWYXJTdHJpbmcoZW5jb2RlciwgaWQpXG4gICAgdGhpcy5zZW5kTWVzc2FnZShlbmNvZGluZy50b1VpbnQ4QXJyYXkoZW5jb2RlcikpXG4gIH1cblxuICBzZW5kQXV0aGVuaWNhdGlvblJlcXVlc3Qoand0OiBzdHJpbmcpIHtcbiAgICB0aGlzLmp3dCA9IGp3dFxuICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGluZy5jcmVhdGVFbmNvZGVyKClcbiAgICBlbmNvZGluZy53cml0ZVZhclVpbnQoZW5jb2RlciwgTUVTU0FHRV9BVVRIRU5USUNBVElPTl9SRVFVRVNUKVxuICAgIGVuY29kaW5nLndyaXRlVmFyU3RyaW5nKGVuY29kZXIsIGp3dClcbiAgICB0aGlzLnNlbmRNZXNzYWdlKGVuY29kaW5nLnRvVWludDhBcnJheShlbmNvZGVyKSlcbiAgfVxuXG4gIGF1dGhlbnRpY2F0ZShqd3Q6IHN0cmluZykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZTxBdXRoUmVzcG9uc2VEYXRhPihyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSBhc3luYyAoZGF0YTogQXV0aFJlc3BvbnNlRGF0YSkgPT4ge1xuICAgICAgICB0aGlzLm9mZignYXV0aGVudGljYXRlZCcsIGhhbmRsZXIpXG4gICAgICAgIHJlc29sdmUoZGF0YSlcbiAgICAgIH1cbiAgICAgIHRoaXMub24oJ2F1dGhlbnRpY2F0ZWQnLCBoYW5kbGVyKVxuICAgICAgdGhpcy5zZW5kQXV0aGVuaWNhdGlvblJlcXVlc3Qoand0KVxuICAgIH0pXG4gIH1cblxuICBzZW5kTWVzc2FnZShidWY6IEFycmF5QnVmZmVyKSB7XG4gICAgaWYgKHRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyAmJiB0aGlzLndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICB0aGlzLndzLnNlbmQoYnVmKVxuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3REb2N1bWVudChkb2NJZDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlPFkuRG9jPihyZXNvbHZlID0+IHtcbiAgICAgIGNvbnN0IGhhbmRsZXIgPSAoc2VydmVySWQ6IHN0cmluZywgdXBkYXRlOiBVaW50OEFycmF5LCBjaGVja3N1bTogc3RyaW5nKSA9PiB7XG4gICAgICAgIGlmIChkb2NJZCA9PT0gc2VydmVySWQpIHtcbiAgICAgICAgICB0aGlzLm9mZignZG9jdW1lbnQtcmVjZWl2ZWQnLCBoYW5kbGVyKVxuICAgICAgICAgIGNvbnN0IGRvYyA9IG5ldyBZLkRvYygpXG4gICAgICAgICAgWS5hcHBseVVwZGF0ZShkb2MsIHVwZGF0ZSlcblxuICAgICAgICAgIC8vIGNvcnJlY3QgaGFzaCBmb3IgZm9sZGVyc1xuICAgICAgICAgIGNvbnN0IGRvY3MgPSBBcnJheS5mcm9tKGRvYy5nZXRNYXAoXCJkb2N1bWVudHNcIikpXG4gICAgICAgICAgaWYgKGRvY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHNlcmlhbGl6ZShBcnJheS5mcm9tKGRvY3MpKVxuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZEhhc2ggPSBjYWxjdWxhdGVIYXNoKHNlcmlhbGl6ZWQpXG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZEhhc2ggIT0gY2hlY2tzdW0pIHtcbiAgICAgICAgICAgICAgdGhpcy5zZW5kVXBkYXRlTWVzc2FnZShkb2NJZCwgWS5lbmNvZGVTdGF0ZUFzVXBkYXRlKGRvYyksIGNhbGN1bGF0ZWRIYXNoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKGRvYylcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vbignZG9jdW1lbnQtcmVjZWl2ZWQnLCBoYW5kbGVyKVxuICAgICAgdGhpcy5zZW5kR2V0RG9jdW1lbnRBc1VwZGF0ZShkb2NJZClcbiAgICB9KVxuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5fcmVzeW5jSW50ZXJ2YWwgIT09IDApIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcmVzeW5jSW50ZXJ2YWwpXG4gICAgfVxuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fY2hlY2tJbnRlcnZhbClcbiAgICB0aGlzLmRpc2Nvbm5lY3QoKVxuICAgIHN1cGVyLmRlc3Ryb3koKVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnNob3VsZENvbm5lY3QgPSBmYWxzZVxuICAgIGlmICh0aGlzLndzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLndzLmNsb3NlKClcbiAgICB9XG4gIH1cblxuICBjb25uZWN0KCkge1xuICAgIHRoaXMuc2hvdWxkQ29ubmVjdCA9IHRydWVcbiAgICBpZiAoIXRoaXMud3Njb25uZWN0ZWQgJiYgdGhpcy53cyA9PT0gbnVsbCkge1xuICAgICAgc2V0dXBXUyh0aGlzKVxuICAgIH1cbiAgfVxufVxuIl0s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QUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sV0FBVyxNQUFJLENBQUM7QUFBQSxVQUNyRTtBQUNELGVBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFBQSxRQUNyRSxPQUFPO0FBQ04sY0FBSTtBQUNKLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBTztBQUNQLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBTztBQUNQLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBTztBQUNQLGtCQUFRO0FBQUEsWUFDTCxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sR0FBRztBQUFBLFlBQ3pDLEtBQUssT0FBTyxNQUFJLENBQUMsS0FBSyxJQUFLLEtBQUssT0FBTyxNQUFJLENBQUM7QUFBQSxZQUM1QyxLQUFLLE9BQU8sTUFBSSxDQUFDLEtBQUssSUFBSyxLQUFLLE9BQU8sTUFBSSxDQUFDO0FBQUEsWUFDNUMsS0FBSyxPQUFPLE1BQUksQ0FBQyxLQUFLLElBQUssS0FBSyxPQUFPLE1BQUksQ0FBQztBQUFBLFVBQy9DO0FBQ0QsZUFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUFBLFFBQ3JFO0FBRUEsYUFBSyxLQUFLLEtBQUs7QUFDZixhQUFLLFVBQVU7QUFDZixZQUFJO0FBQVUsZUFBSyxTQUFTO0FBQUEsTUFDN0I7QUFFQSxVQUFJLEtBQUssT0FBTyxJQUNoQjtBQUNDLFlBQUksUUFBUSxPQUFPO0FBRW5CLFdBQ0E7QUFDQyxjQUFJLFVBQVU7QUFDYixnQkFBSTtBQUNKLG9CQUFRO0FBQUEsY0FDTCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsQ0FBQztBQUFBLGNBQy9DLE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxJQUFFLENBQUM7QUFBQSxjQUNsRCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsY0FDbEQsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLElBQUUsQ0FBQztBQUFBLFlBQ3JEO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFDcEUsaUJBQUs7QUFDTCxvQkFBUTtBQUFBLGNBQ0wsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLENBQUM7QUFBQSxjQUMvQyxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsY0FDbEQsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLElBQUUsQ0FBQztBQUFBLGNBQ2xELE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxJQUFFLENBQUM7QUFBQSxZQUNyRDtBQUNELGlCQUFLLEdBQUcsSUFBSyxNQUFNLFNBQVMsU0FBUyxDQUFFLEVBQUUsS0FBSyxFQUFFLEVBQUUsU0FBUyxTQUFTO0FBQ3BFLGlCQUFLO0FBQ0wsb0JBQVE7QUFBQSxjQUNMLE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxDQUFDO0FBQUEsY0FDL0MsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLElBQUUsQ0FBQztBQUFBLGNBQ2xELE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxJQUFFLENBQUM7QUFBQSxjQUNsRCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsWUFDckQ7QUFDRCxpQkFBSyxHQUFHLElBQUssTUFBTSxTQUFTLFNBQVMsQ0FBRSxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUztBQUNwRSxpQkFBSztBQUNMLG9CQUFRO0FBQUEsY0FDTCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsQ0FBQztBQUFBLGNBQy9DLE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxJQUFFLENBQUM7QUFBQSxjQUNsRCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsY0FDbEQsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLElBQUUsQ0FBQztBQUFBLFlBQ3JEO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFBQSxVQUNyRSxPQUFPO0FBQ04sZ0JBQUk7QUFDSixvQkFBUTtBQUFBLGNBQ0wsTUFBTSxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sQ0FBQztBQUFBLGNBQ3pCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQy9CO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFDcEUsaUJBQUs7QUFDTCxvQkFBUTtBQUFBLGNBQ0wsTUFBTSxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sQ0FBQztBQUFBLGNBQ3pCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQy9CO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFDcEUsaUJBQUs7QUFDTCxvQkFBUTtBQUFBLGNBQ0wsTUFBTSxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sQ0FBQztBQUFBLGNBQ3pCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQy9CO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFDcEUsaUJBQUs7QUFDTCxvQkFBUTtBQUFBLGNBQ0wsTUFBTSxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sQ0FBQztBQUFBLGNBQ3pCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLGNBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQy9CO0FBQ0QsaUJBQUssR0FBRyxJQUFLLE1BQU0sU0FBUyxTQUFTLENBQUUsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVM7QUFBQSxVQUNyRTtBQUNBLGVBQUs7QUFBQSxRQUNOLFNBQVMsS0FBSztBQUFBLE1BQ2Y7QUFFQSxVQUFJLElBQUksTUFDUjtBQUVDLFlBQUksVUFBVTtBQUNiLGVBQUssVUFBVSxNQUFNLE1BQU0sQ0FBQztBQUFBLFFBQzdCLFdBQVcsZUFBZTtBQUN6QixlQUFLLE9BQU8sSUFBSyxNQUFNLFNBQVMsR0FBRyxJQUFJLEdBQUcsS0FBSyxPQUFRO0FBQUEsUUFDeEQsT0FBTztBQUNOLGdCQUFNLEtBQU0sS0FBSyxRQUFRLEtBQUssU0FBUyxHQUFHLElBQUs7QUFBQSxRQUNoRDtBQUVBLGFBQUssVUFBVSxPQUFPO0FBQUEsTUFDdkI7QUFFQSxhQUFPO0FBQUEsSUFDUjtBQU9BLFVBQU0sVUFBVSxTQUFTLFdBQVk7QUFDcEMsVUFBSSxRQUFRLEtBQUs7QUFDakIsVUFBSSxXQUFXLE9BQU8sU0FBUztBQUMvQixVQUFJLElBQUk7QUFDUixVQUFJLE9BQU8sS0FBSztBQUNoQixVQUFJLEtBQUs7QUFDVCxVQUFJLElBQUksSUFBSTtBQUVaLFVBQUksS0FBSyxhQUFhLElBQ3RCO0FBQ0MsY0FBTSxLQUFLLEdBQUcsTUFBTSxFQUFFLEtBQUssQ0FBQztBQUM1QixZQUFJLElBQUssS0FBSyxHQUFHLE1BQU0sRUFBRSxLQUFLLENBQUMsQ0FBRTtBQUNqQyxZQUFJLElBQUssS0FBSyxHQUFHLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBRTtBQUNsQyxZQUFJLElBQUssS0FBSyxHQUFHLE1BQU0sRUFBRSxLQUFLLEVBQUUsQ0FBRTtBQUVsQyxZQUFJLElBQUssS0FBSyxHQUFHLFNBQVMsU0FBUyxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUyxDQUFFO0FBQ2xFLFlBQUksU0FBUyxTQUFTLEVBQUUsSUFBSSxTQUFTO0FBRXJDLFlBQUksSUFBSyxLQUFLLEdBQUcsU0FBUyxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsU0FBUyxTQUFTLENBQUU7QUFDbEUsWUFBSSxTQUFTLFNBQVMsRUFBRSxJQUFJLFNBQVM7QUFFckMsWUFBSSxJQUFLLEtBQUssR0FBRyxTQUFTLFNBQVMsRUFBRSxLQUFLLEVBQUUsRUFBRSxTQUFTLFNBQVMsQ0FBRTtBQUNsRSxZQUFJLFNBQVMsU0FBUyxFQUFFLElBQUksU0FBUztBQUVyQyxZQUFJLElBQUssS0FBSyxHQUFHLFNBQVMsU0FBUyxFQUFFLEtBQUssRUFBRSxFQUFFLFNBQVMsU0FBUyxDQUFFO0FBQ2xFLFlBQUksU0FBUyxTQUFTLEVBQUUsSUFBSSxTQUFTO0FBQUEsTUFDdEMsT0FFQTtBQUNDLGNBQU8sS0FBSyxLQUFLLE1BQU0sRUFBRSxJQUFLLFNBQVU7QUFBQSxNQUN6QztBQUVBLFVBQUksSUFBSyxFQUFFLFdBQVcsS0FBSyxTQUFTLENBQUU7QUFFdEMsYUFBTyxLQUFLLE9BQU8sR0FDbkI7QUFDQyxZQUFJLFVBQVU7QUFDYixZQUFFO0FBQUEsWUFDQSxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsQ0FBQztBQUFBLFlBQy9DLE1BQU0sV0FBVyxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sV0FBVyxJQUFFLENBQUM7QUFBQSxZQUNsRCxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsWUFDbEQsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLElBQUUsQ0FBQztBQUFBLFVBQ3JEO0FBQUEsUUFDRCxPQUFPO0FBQ04sWUFBRTtBQUFBLFlBQ0EsTUFBTSxJQUFFLENBQUMsS0FBSyxJQUFLLE1BQU0sQ0FBQztBQUFBLFlBQ3pCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFlBQzVCLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLElBQUUsQ0FBQztBQUFBLFVBQy9CO0FBQUEsUUFDRDtBQUNBLFVBQUUsU0FBUyxTQUFTLEVBQUUsS0FBSyxFQUFFLEVBQUUsU0FBUyxTQUFTO0FBQ2pELFlBQ0UsSUFBSSxDQUFDLEVBQ0wsS0FBSyxFQUFFLEVBQ1AsU0FBVSxTQUFVLEVBQ3BCLElBQUssU0FBVTtBQUNqQixhQUFLO0FBQUEsTUFDTjtBQUVBLFVBQUksSUFBSSxLQUFLLE1BQU07QUFDbEIsWUFBSSxVQUFVO0FBQ2IsWUFBRTtBQUFBLFlBQ0EsTUFBTSxXQUFXLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxXQUFXLENBQUM7QUFBQSxZQUMvQyxNQUFNLFdBQVcsSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLFdBQVcsSUFBRSxDQUFDO0FBQUEsWUFDbkQ7QUFBQSxZQUNBO0FBQUEsVUFDRjtBQUFBLFFBQ0QsT0FBTztBQUNOLFlBQUU7QUFBQSxZQUNBLE1BQU0sSUFBRSxDQUFDLEtBQUssSUFBSyxNQUFNLENBQUM7QUFBQSxZQUN6QixNQUFNLElBQUUsQ0FBQyxLQUFLLElBQUssTUFBTSxJQUFFLENBQUM7QUFBQSxZQUM3QjtBQUFBLFlBQ0E7QUFBQSxVQUNGO0FBQUEsUUFDRDtBQUNBLFlBQ0UsSUFBSyxFQUFFLFNBQVMsU0FBUyxDQUFFLEVBQzNCLEtBQUssRUFBRSxFQUNQLFNBQVUsU0FBVSxFQUNwQixJQUFLLFNBQVU7QUFDakIsYUFBSztBQUFBLE1BQ047QUFFQSxhQUFPLElBQUksTUFDWDtBQUNDLFVBQUUsU0FBVSxXQUFXLE1BQU0sV0FBVyxHQUFHLElBQUksTUFBTSxHQUFHLEdBQUcsR0FBRyxHQUFHLENBQUU7QUFDbkUsWUFDRSxJQUFLLEVBQUUsU0FBUyxTQUFTLENBQUUsRUFDM0IsS0FBSyxFQUFFLEVBQ1AsU0FBUyxTQUFTO0FBQUEsTUFDckI7QUFFQSxVQUFJLElBQUksTUFBTSxFQUFFLFdBQVcsRUFBRTtBQUM3QixVQUFJLElBQUksQ0FBQyxFQUFFLFNBQVMsU0FBUztBQUU3QixVQUFJLElBQUksTUFBTSxFQUFFLFdBQVcsRUFBRTtBQUM3QixVQUFJLElBQUksQ0FBQyxFQUFFLFNBQVMsU0FBUztBQUU3QixVQUFJLElBQUksTUFBTSxFQUFFLFdBQVcsRUFBRTtBQUM3QixVQUFJLElBQUksQ0FBQztBQUdULFdBQUssS0FBTSxLQUFLLElBQUs7QUFFckIsYUFBTztBQUFBLElBQ1I7QUFFQSxJQUFBQSxRQUFPLFVBQVU7QUFBQTtBQUFBOzs7QUMzYmpCO0FBQUEsZ0RBQUFDLFNBQUE7QUFBQSxJQUFBQSxRQUFPLFVBQVU7QUFBQSxNQUNoQixLQUFLO0FBQUEsTUFDSixLQUFLO0FBQUEsSUFDUDtBQUFBO0FBQUE7OztBQ0hBO0FBQUEsd0RBQUFDLFNBQUE7QUFBQSxLQUFDLFNBQVMsR0FBRTtBQUFDLFVBQUcsWUFBVSxPQUFPLFdBQVMsZUFBYSxPQUFPQTtBQUFPLFFBQUFBLFFBQU8sVUFBUSxFQUFFO0FBQUEsZUFBVSxjQUFZLE9BQU8sVUFBUSxPQUFPO0FBQUksZUFBTyxDQUFDLEdBQUUsQ0FBQztBQUFBLFdBQU07QUFBQyxZQUFJO0FBQUUsWUFBRSxlQUFhLE9BQU8sU0FBTyxlQUFhLE9BQU8sU0FBTyxlQUFhLE9BQU8sT0FBSyxPQUFLLE9BQUssU0FBTyxRQUFPLEVBQUUsYUFBVyxFQUFFO0FBQUEsTUFBQztBQUFBLElBQUMsR0FBRyxXQUFVO0FBQUMsVUFBSSxJQUFFLEtBQUssT0FBTSxJQUFFLEtBQUssS0FBSSxJQUFFLEtBQUs7QUFBSSxhQUFPLFdBQVU7QUFBQyxpQkFBUyxFQUFFLEdBQUUsR0FBRUMsSUFBRTtBQUFDLG1CQUFTQyxHQUFFLEdBQUUsR0FBRTtBQUFDLGdCQUFHLENBQUMsRUFBRSxDQUFDLEdBQUU7QUFBQyxrQkFBRyxDQUFDLEVBQUUsQ0FBQyxHQUFFO0FBQUMsb0JBQUksSUFBRSxjQUFZLE9BQU8sV0FBUztBQUFRLG9CQUFHLENBQUMsS0FBRztBQUFFLHlCQUFPLEVBQUUsR0FBRSxJQUFFO0FBQUUsb0JBQUdDO0FBQUUseUJBQU9BLEdBQUUsR0FBRSxJQUFFO0FBQUUsb0JBQUksSUFBRSxJQUFJLE1BQU0seUJBQXVCLElBQUUsR0FBRztBQUFFLHNCQUFNLEVBQUUsT0FBSyxvQkFBbUI7QUFBQSxjQUFDO0FBQUMsa0JBQUlDLEtBQUUsRUFBRSxDQUFDLElBQUUsRUFBQyxTQUFRLENBQUMsRUFBQztBQUFFLGdCQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsS0FBS0EsR0FBRSxTQUFRLFNBQVNDLElBQUU7QUFBQyxvQkFBSUYsS0FBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUVFLEVBQUM7QUFBRSx1QkFBT0gsR0FBRUMsTUFBR0UsRUFBQztBQUFBLGNBQUMsR0FBRUQsSUFBRUEsR0FBRSxTQUFRLEdBQUUsR0FBRSxHQUFFSCxFQUFDO0FBQUEsWUFBQztBQUFDLG1CQUFPLEVBQUUsQ0FBQyxFQUFFO0FBQUEsVUFBTztBQUFDLG1CQUFRRSxLQUFFLGNBQVksT0FBTyxXQUFTLFNBQVEsSUFBRSxHQUFFLElBQUVGLEdBQUUsUUFBTztBQUFJLFlBQUFDLEdBQUVELEdBQUUsQ0FBQyxDQUFDO0FBQUUsaUJBQU9DO0FBQUEsUUFBQztBQUFDLGVBQU87QUFBQSxNQUFDLEVBQUUsRUFBRSxFQUFDLEdBQUUsQ0FBQyxTQUFTLEdBQUVBLElBQUVELElBQUU7QUFBQztBQUFhLGlCQUFTRSxHQUFFRSxJQUFFO0FBQUMsY0FBSUgsS0FBRUcsR0FBRTtBQUFPLGNBQUcsSUFBRUgsS0FBRTtBQUFFLGtCQUFNLElBQUksTUFBTSxnREFBZ0Q7QUFBRSxjQUFJRCxLQUFFSSxHQUFFLFFBQVEsR0FBRztBQUFFLGlCQUFLSixPQUFJQSxLQUFFQztBQUFHLGNBQUlDLEtBQUVGLE9BQUlDLEtBQUUsSUFBRSxJQUFFRCxLQUFFO0FBQUUsaUJBQU0sQ0FBQ0EsSUFBRUUsRUFBQztBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFRSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsaUJBQU8sS0FBR0MsS0FBRUQsTUFBRyxJQUFFQTtBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFSSxJQUFFO0FBQUMsY0FBSUgsSUFBRUQsSUFBRUssS0FBRUgsR0FBRUUsRUFBQyxHQUFFRSxLQUFFRCxHQUFFLENBQUMsR0FBRUUsS0FBRUYsR0FBRSxDQUFDLEdBQUVHLEtBQUUsSUFBSSxFQUFFLEVBQUVKLElBQUVFLElBQUVDLEVBQUMsQ0FBQyxHQUFFRSxLQUFFLEdBQUVDLEtBQUUsSUFBRUgsS0FBRUQsS0FBRSxJQUFFQTtBQUFFLGVBQUlOLEtBQUUsR0FBRUEsS0FBRVUsSUFBRVYsTUFBRztBQUFFLFlBQUFDLEtBQUUsRUFBRUcsR0FBRSxXQUFXSixFQUFDLENBQUMsS0FBRyxLQUFHLEVBQUVJLEdBQUUsV0FBV0osS0FBRSxDQUFDLENBQUMsS0FBRyxLQUFHLEVBQUVJLEdBQUUsV0FBV0osS0FBRSxDQUFDLENBQUMsS0FBRyxJQUFFLEVBQUVJLEdBQUUsV0FBV0osS0FBRSxDQUFDLENBQUMsR0FBRVEsR0FBRUMsSUFBRyxJQUFFLE1BQUlSLE1BQUcsSUFBR08sR0FBRUMsSUFBRyxJQUFFLE1BQUlSLE1BQUcsR0FBRU8sR0FBRUMsSUFBRyxJQUFFLE1BQUlSO0FBQUUsaUJBQU8sTUFBSU0sT0FBSU4sS0FBRSxFQUFFRyxHQUFFLFdBQVdKLEVBQUMsQ0FBQyxLQUFHLElBQUUsRUFBRUksR0FBRSxXQUFXSixLQUFFLENBQUMsQ0FBQyxLQUFHLEdBQUVRLEdBQUVDLElBQUcsSUFBRSxNQUFJUixLQUFHLE1BQUlNLE9BQUlOLEtBQUUsRUFBRUcsR0FBRSxXQUFXSixFQUFDLENBQUMsS0FBRyxLQUFHLEVBQUVJLEdBQUUsV0FBV0osS0FBRSxDQUFDLENBQUMsS0FBRyxJQUFFLEVBQUVJLEdBQUUsV0FBV0osS0FBRSxDQUFDLENBQUMsS0FBRyxHQUFFUSxHQUFFQyxJQUFHLElBQUUsTUFBSVIsTUFBRyxHQUFFTyxHQUFFQyxJQUFHLElBQUUsTUFBSVIsS0FBR087QUFBQSxRQUFDO0FBQUMsaUJBQVMsRUFBRUosSUFBRTtBQUFDLGlCQUFPLEVBQUUsS0FBR0EsTUFBRyxFQUFFLElBQUUsRUFBRSxLQUFHQSxNQUFHLEVBQUUsSUFBRSxFQUFFLEtBQUdBLE1BQUcsQ0FBQyxJQUFFLEVBQUUsS0FBR0EsRUFBQztBQUFBLFFBQUM7QUFBQyxpQkFBUyxFQUFFQSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsbUJBQVFFLElBQUVDLEtBQUUsQ0FBQyxHQUFFRSxLQUFFSixJQUFFSSxLQUFFTCxJQUFFSyxNQUFHO0FBQUUsWUFBQUgsTUFBRyxXQUFTRSxHQUFFQyxFQUFDLEtBQUcsT0FBSyxRQUFNRCxHQUFFQyxLQUFFLENBQUMsS0FBRyxNQUFJLE1BQUlELEdBQUVDLEtBQUUsQ0FBQyxJQUFHRixHQUFFLEtBQUssRUFBRUQsRUFBQyxDQUFDO0FBQUUsaUJBQU9DLEdBQUUsS0FBSyxFQUFFO0FBQUEsUUFBQztBQUFDLGlCQUFTLEVBQUVDLElBQUU7QUFBQyxtQkFBUUgsSUFBRUQsS0FBRUksR0FBRSxRQUFPRixLQUFFRixLQUFFLEdBQUVHLEtBQUUsQ0FBQyxHQUFFRSxLQUFFLE9BQU1DLEtBQUUsR0FBRUUsS0FBRVIsS0FBRUUsSUFBRUksS0FBRUUsSUFBRUYsTUFBR0Q7QUFBRSxZQUFBRixHQUFFLEtBQUssRUFBRUMsSUFBRUUsSUFBRUEsS0FBRUQsS0FBRUcsS0FBRUEsS0FBRUYsS0FBRUQsRUFBQyxDQUFDO0FBQUUsaUJBQU8sTUFBSUgsTUFBR0QsS0FBRUcsR0FBRUosS0FBRSxDQUFDLEdBQUVHLEdBQUUsS0FBSyxFQUFFRixNQUFHLENBQUMsSUFBRSxFQUFFLEtBQUdBLE1BQUcsQ0FBQyxJQUFFLElBQUksS0FBRyxNQUFJQyxPQUFJRCxNQUFHRyxHQUFFSixLQUFFLENBQUMsS0FBRyxLQUFHSSxHQUFFSixLQUFFLENBQUMsR0FBRUcsR0FBRSxLQUFLLEVBQUVGLE1BQUcsRUFBRSxJQUFFLEVBQUUsS0FBR0EsTUFBRyxDQUFDLElBQUUsRUFBRSxLQUFHQSxNQUFHLENBQUMsSUFBRSxHQUFHLElBQUdFLEdBQUUsS0FBSyxFQUFFO0FBQUEsUUFBQztBQUFDLFFBQUFILEdBQUUsYUFBVyxTQUFTSSxJQUFFO0FBQUMsY0FBSUgsS0FBRUMsR0FBRUUsRUFBQyxHQUFFSixLQUFFQyxHQUFFLENBQUMsR0FBRUUsS0FBRUYsR0FBRSxDQUFDO0FBQUUsaUJBQU8sS0FBR0QsS0FBRUcsTUFBRyxJQUFFQTtBQUFBLFFBQUMsR0FBRUgsR0FBRSxjQUFZLEdBQUVBLEdBQUUsZ0JBQWM7QUFBRSxpQkFBUSxJQUFFLENBQUMsR0FBRSxJQUFFLENBQUMsR0FBRSxJQUFFLGVBQWEsT0FBTyxhQUFXLFFBQU0sWUFBVyxJQUFFLG9FQUFtRSxJQUFFLEdBQUUsSUFBRSxFQUFFLFFBQU8sSUFBRSxHQUFFLEVBQUU7QUFBRSxZQUFFLENBQUMsSUFBRSxFQUFFLENBQUMsR0FBRSxFQUFFLEVBQUUsV0FBVyxDQUFDLENBQUMsSUFBRTtBQUFFLFVBQUUsRUFBRSxJQUFFLElBQUcsRUFBRSxFQUFFLElBQUU7QUFBQSxNQUFFLEdBQUUsQ0FBQyxDQUFDLEdBQUUsR0FBRSxDQUFDLFdBQVU7QUFBQSxNQUFDLEdBQUUsQ0FBQyxDQUFDLEdBQUUsR0FBRSxDQUFDLFNBQVMsR0FBRUMsSUFBRUQsSUFBRTtBQUFDLFNBQUMsV0FBVTtBQUFDLFdBQUMsV0FBVTtBQUtudUU7QUFBYSxnQkFBSUMsS0FBRSxPQUFPLGNBQWEsSUFBRSxLQUFLO0FBQUkscUJBQVMsRUFBRUcsSUFBRTtBQUFDLGtCQUFHLGFBQVdBO0FBQUUsc0JBQU0sSUFBSSxXQUFXLGdCQUFlQSxLQUFFLGdDQUFtQztBQUFFLGtCQUFJSCxLQUFFLElBQUksV0FBV0csRUFBQztBQUFFLHFCQUFPSCxHQUFFLFlBQVUsRUFBRSxXQUFVQTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRyxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsa0JBQUcsWUFBVSxPQUFPSSxJQUFFO0FBQUMsb0JBQUcsWUFBVSxPQUFPSDtBQUFFLHdCQUFNLElBQUksVUFBVSxvRUFBc0U7QUFBRSx1QkFBTyxFQUFFRyxFQUFDO0FBQUEsY0FBQztBQUFDLHFCQUFPLEVBQUVBLElBQUVILElBQUVELEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGtCQUFHLFlBQVUsT0FBT0k7QUFBRSx1QkFBTyxFQUFFQSxJQUFFSCxFQUFDO0FBQUUsa0JBQUcsWUFBWSxPQUFPRyxFQUFDO0FBQUUsdUJBQU8sRUFBRUEsRUFBQztBQUFFLGtCQUFHLFFBQU1BO0FBQUUsc0JBQU0sVUFBVSxvSEFBa0gsT0FBT0EsRUFBQztBQUFFLGtCQUFHLEVBQUVBLElBQUUsV0FBVyxLQUFHQSxNQUFHLEVBQUVBLEdBQUUsUUFBTyxXQUFXO0FBQUUsdUJBQU8sRUFBRUEsSUFBRUgsSUFBRUQsRUFBQztBQUFFLGtCQUFHLFlBQVUsT0FBT0k7QUFBRSxzQkFBTSxJQUFJLFVBQVUsdUVBQXlFO0FBQUUsa0JBQUlGLEtBQUVFLEdBQUUsV0FBU0EsR0FBRSxRQUFRO0FBQUUsa0JBQUcsUUFBTUYsTUFBR0EsT0FBSUU7QUFBRSx1QkFBTyxFQUFFLEtBQUtGLElBQUVELElBQUVELEVBQUM7QUFBRSxrQkFBSSxJQUFFLEVBQUVJLEVBQUM7QUFBRSxrQkFBRztBQUFFLHVCQUFPO0FBQUUsa0JBQUcsZUFBYSxPQUFPLFVBQVEsUUFBTSxPQUFPLGVBQWEsY0FBWSxPQUFPQSxHQUFFLE9BQU8sV0FBVztBQUFFLHVCQUFPLEVBQUUsS0FBS0EsR0FBRSxPQUFPLFdBQVcsRUFBRSxRQUFRLEdBQUVILElBQUVELEVBQUM7QUFBRSxvQkFBTSxJQUFJLFVBQVUsb0hBQWtILE9BQU9JLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUEsSUFBRTtBQUFDLGtCQUFHLFlBQVUsT0FBT0E7QUFBRSxzQkFBTSxJQUFJLFVBQVUsd0NBQTBDO0FBQUEsdUJBQVUsSUFBRUE7QUFBRSxzQkFBTSxJQUFJLFdBQVcsZ0JBQWVBLEtBQUUsZ0NBQW1DO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBTyxFQUFFSSxFQUFDLEdBQUUsS0FBR0EsS0FBRSxFQUFFQSxFQUFDLElBQUUsV0FBU0gsS0FBRSxFQUFFRyxFQUFDLElBQUUsWUFBVSxPQUFPSixLQUFFLEVBQUVJLEVBQUMsRUFBRSxLQUFLSCxJQUFFRCxFQUFDLElBQUUsRUFBRUksRUFBQyxFQUFFLEtBQUtILEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRTtBQUFDLHFCQUFPLEVBQUVBLEVBQUMsR0FBRSxFQUFFLElBQUVBLEtBQUUsSUFBRSxJQUFFLEVBQUVBLEVBQUMsQ0FBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFO0FBQUMsbUJBQUksWUFBVSxPQUFPQSxNQUFHLE9BQUtBLFFBQUtBLEtBQUUsU0FBUSxDQUFDLEVBQUUsV0FBV0EsRUFBQztBQUFFLHNCQUFNLElBQUksVUFBVSx1QkFBcUJBLEVBQUM7QUFBRSxrQkFBSUQsS0FBRSxJQUFFLEVBQUVJLElBQUVILEVBQUMsR0FBRUMsS0FBRSxFQUFFRixFQUFDLEdBQUUsSUFBRUUsR0FBRSxNQUFNRSxJQUFFSCxFQUFDO0FBQUUscUJBQU8sTUFBSUQsT0FBSUUsS0FBRUEsR0FBRSxNQUFNLEdBQUUsQ0FBQyxJQUFHQTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFO0FBQUMsdUJBQVFILEtBQUUsSUFBRUcsR0FBRSxTQUFPLElBQUUsSUFBRSxFQUFFQSxHQUFFLE1BQU0sR0FBRUosS0FBRSxFQUFFQyxFQUFDLEdBQUVDLEtBQUUsR0FBRUEsS0FBRUQsSUFBRUMsTUFBRztBQUFFLGdCQUFBRixHQUFFRSxFQUFDLElBQUUsTUFBSUUsR0FBRUYsRUFBQztBQUFFLHFCQUFPRjtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFSSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsa0JBQUcsSUFBRUMsTUFBR0csR0FBRSxhQUFXSDtBQUFFLHNCQUFNLElBQUksV0FBVyxzQ0FBd0M7QUFBRSxrQkFBR0csR0FBRSxhQUFXSCxNQUFHRCxNQUFHO0FBQUcsc0JBQU0sSUFBSSxXQUFXLHNDQUF3QztBQUFFLGtCQUFJRTtBQUFFLHFCQUFPQSxLQUFFLFdBQVNELE1BQUcsV0FBU0QsS0FBRSxJQUFJLFdBQVdJLEVBQUMsSUFBRSxXQUFTSixLQUFFLElBQUksV0FBV0ksSUFBRUgsRUFBQyxJQUFFLElBQUksV0FBV0csSUFBRUgsSUFBRUQsRUFBQyxHQUFFRSxHQUFFLFlBQVUsRUFBRSxXQUFVQTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFO0FBQUMsa0JBQUcsRUFBRSxTQUFTQSxFQUFDLEdBQUU7QUFBQyxvQkFBSUgsS0FBRSxJQUFFLEVBQUVHLEdBQUUsTUFBTSxHQUFFSixLQUFFLEVBQUVDLEVBQUM7QUFBRSx1QkFBTyxNQUFJRCxHQUFFLFNBQU9BLE1BQUdJLEdBQUUsS0FBS0osSUFBRSxHQUFFLEdBQUVDLEVBQUMsR0FBRUQ7QUFBQSxjQUFFO0FBQUMscUJBQU8sV0FBU0ksR0FBRSxTQUFPLGFBQVdBLEdBQUUsUUFBTSxNQUFNLFFBQVFBLEdBQUUsSUFBSSxJQUFFLEVBQUVBLEdBQUUsSUFBSSxJQUFFLFNBQU8sWUFBVSxPQUFPQSxHQUFFLFVBQVEsRUFBRUEsR0FBRSxNQUFNLElBQUUsRUFBRSxDQUFDLElBQUUsRUFBRUEsRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMsa0JBQUdBLE1BQUc7QUFBVyxzQkFBTSxJQUFJLFdBQVcsNERBQTBELFlBQVksU0FBUyxFQUFFLElBQUUsUUFBUTtBQUFFLHFCQUFPLElBQUVBO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxrQkFBRyxFQUFFLFNBQVNHLEVBQUM7QUFBRSx1QkFBT0EsR0FBRTtBQUFPLGtCQUFHLFlBQVksT0FBT0EsRUFBQyxLQUFHLEVBQUVBLElBQUUsV0FBVztBQUFFLHVCQUFPQSxHQUFFO0FBQVcsa0JBQUcsWUFBVSxPQUFPQTtBQUFFLHNCQUFNLElBQUksVUFBVSw2RkFBNkYsT0FBT0EsRUFBQztBQUFFLGtCQUFJSixLQUFFSSxHQUFFLFFBQU9GLEtBQUUsSUFBRSxVQUFVLFVBQVEsU0FBSyxVQUFVLENBQUM7QUFBRSxrQkFBRyxDQUFDQSxNQUFHLE1BQUlGO0FBQUUsdUJBQU87QUFBRSx1QkFBUSxJQUFFO0FBQUssd0JBQU9DLElBQUU7QUFBQSxrQkFBQyxLQUFJO0FBQUEsa0JBQVEsS0FBSTtBQUFBLGtCQUFTLEtBQUk7QUFBUywyQkFBT0Q7QUFBQSxrQkFBRSxLQUFJO0FBQUEsa0JBQU8sS0FBSTtBQUFRLDJCQUFPLEVBQUVJLEVBQUMsRUFBRTtBQUFBLGtCQUFPLEtBQUk7QUFBQSxrQkFBTyxLQUFJO0FBQUEsa0JBQVEsS0FBSTtBQUFBLGtCQUFVLEtBQUk7QUFBVywyQkFBTyxJQUFFSjtBQUFBLGtCQUFFLEtBQUk7QUFBTSwyQkFBT0EsT0FBSTtBQUFBLGtCQUFFLEtBQUk7QUFBUywyQkFBTyxFQUFFSSxFQUFDLEVBQUU7QUFBQSxrQkFBTztBQUFRLHdCQUFHO0FBQUUsNkJBQU9GLEtBQUUsS0FBRyxFQUFFRSxFQUFDLEVBQUU7QUFBTyxvQkFBQUgsTUFBRyxLQUFHQSxJQUFHLFlBQVksR0FBRSxJQUFFO0FBQUEsZ0JBQUc7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUcsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGtCQUFJRSxLQUFFO0FBQUcsbUJBQUksV0FBU0QsTUFBRyxJQUFFQSxRQUFLQSxLQUFFLElBQUdBLEtBQUUsS0FBSztBQUFPLHVCQUFNO0FBQUcsbUJBQUksV0FBU0QsTUFBR0EsS0FBRSxLQUFLLFlBQVVBLEtBQUUsS0FBSyxTQUFRLEtBQUdBO0FBQUUsdUJBQU07QUFBRyxrQkFBR0EsUUFBSyxHQUFFQyxRQUFLLEdBQUVELE1BQUdDO0FBQUUsdUJBQU07QUFBRyxtQkFBSUcsT0FBSUEsS0FBRTtBQUFVLHdCQUFPQSxJQUFFO0FBQUEsa0JBQUMsS0FBSTtBQUFNLDJCQUFPLEVBQUUsTUFBS0gsSUFBRUQsRUFBQztBQUFBLGtCQUFFLEtBQUk7QUFBQSxrQkFBTyxLQUFJO0FBQVEsMkJBQU8sRUFBRSxNQUFLQyxJQUFFRCxFQUFDO0FBQUEsa0JBQUUsS0FBSTtBQUFRLDJCQUFPLEVBQUUsTUFBS0MsSUFBRUQsRUFBQztBQUFBLGtCQUFFLEtBQUk7QUFBQSxrQkFBUyxLQUFJO0FBQVMsMkJBQU8sRUFBRSxNQUFLQyxJQUFFRCxFQUFDO0FBQUEsa0JBQUUsS0FBSTtBQUFTLDJCQUFPLEVBQUUsTUFBS0MsSUFBRUQsRUFBQztBQUFBLGtCQUFFLEtBQUk7QUFBQSxrQkFBTyxLQUFJO0FBQUEsa0JBQVEsS0FBSTtBQUFBLGtCQUFVLEtBQUk7QUFBVywyQkFBTyxFQUFFLE1BQUtDLElBQUVELEVBQUM7QUFBQSxrQkFBRTtBQUFRLHdCQUFHRTtBQUFFLDRCQUFNLElBQUksVUFBVSx1QkFBcUJFLEVBQUM7QUFBRSxvQkFBQUEsTUFBR0EsS0FBRSxJQUFJLFlBQVksR0FBRUYsS0FBRTtBQUFBLGdCQUFHO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVFLElBQUVILElBQUVELElBQUU7QUFBQyxrQkFBSUUsS0FBRUUsR0FBRUgsRUFBQztBQUFFLGNBQUFHLEdBQUVILEVBQUMsSUFBRUcsR0FBRUosRUFBQyxHQUFFSSxHQUFFSixFQUFDLElBQUVFO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVFLElBQUVILElBQUVELElBQUVFLElBQUUsR0FBRTtBQUFDLGtCQUFHLE1BQUlFLEdBQUU7QUFBTyx1QkFBTTtBQUFHLGtCQUFHLFlBQVUsT0FBT0osTUFBR0UsS0FBRUYsSUFBRUEsS0FBRSxLQUFHLGFBQVdBLEtBQUVBLEtBQUUsYUFBVyxjQUFZQSxPQUFJQSxLQUFFLGNBQWFBLEtBQUUsQ0FBQ0EsSUFBRSxFQUFFQSxFQUFDLE1BQUlBLEtBQUUsSUFBRSxJQUFFSSxHQUFFLFNBQU8sSUFBRyxJQUFFSixPQUFJQSxLQUFFSSxHQUFFLFNBQU9KLEtBQUdBLE1BQUdJLEdBQUUsUUFBTztBQUFDLG9CQUFHO0FBQUUseUJBQU07QUFBRyxnQkFBQUosS0FBRUksR0FBRSxTQUFPO0FBQUEsY0FBQyxXQUFTLElBQUVKO0FBQUUsb0JBQUc7QUFBRSxrQkFBQUEsS0FBRTtBQUFBO0FBQU8seUJBQU07QUFBRyxrQkFBRyxZQUFVLE9BQU9DLE9BQUlBLEtBQUUsRUFBRSxLQUFLQSxJQUFFQyxFQUFDLElBQUcsRUFBRSxTQUFTRCxFQUFDO0FBQUUsdUJBQU8sTUFBSUEsR0FBRSxTQUFPLEtBQUcsRUFBRUcsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRSxDQUFDO0FBQUUsa0JBQUcsWUFBVSxPQUFPRDtBQUFFLHVCQUFPQSxNQUFHLEtBQUksY0FBWSxPQUFPLFdBQVcsVUFBVSxVQUFRLElBQUUsV0FBVyxVQUFVLFFBQVEsS0FBS0csSUFBRUgsSUFBRUQsRUFBQyxJQUFFLFdBQVcsVUFBVSxZQUFZLEtBQUtJLElBQUVILElBQUVELEVBQUMsSUFBRSxFQUFFSSxJQUFFLENBQUNILEVBQUMsR0FBRUQsSUFBRUUsSUFBRSxDQUFDO0FBQUUsb0JBQU0sSUFBSSxVQUFVLHNDQUFzQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFLEdBQUU7QUFBQyx1QkFBU0csR0FBRUQsSUFBRUgsSUFBRTtBQUFDLHVCQUFPLE1BQUlLLEtBQUVGLEdBQUVILEVBQUMsSUFBRUcsR0FBRSxhQUFhSCxLQUFFSyxFQUFDO0FBQUEsY0FBQztBQUFDLGtCQUFJQSxLQUFFLEdBQUVDLEtBQUVILEdBQUUsUUFBT0ksS0FBRVAsR0FBRTtBQUFPLGtCQUFHLFdBQVNDLE9BQUlBLE1BQUdBLEtBQUUsSUFBSSxZQUFZLEdBQUUsV0FBU0EsTUFBRyxZQUFVQSxNQUFHLGNBQVlBLE1BQUcsZUFBYUEsS0FBRztBQUFDLG9CQUFHLElBQUVFLEdBQUUsVUFBUSxJQUFFSCxHQUFFO0FBQU8seUJBQU07QUFBRyxnQkFBQUssS0FBRSxHQUFFQyxNQUFHLEdBQUVDLE1BQUcsR0FBRVIsTUFBRztBQUFBLGNBQUM7QUFBQyxrQkFBSVM7QUFBRSxrQkFBRyxHQUFFO0FBQUMsb0JBQUlFLEtBQUU7QUFBRyxxQkFBSUYsS0FBRVQsSUFBRVMsS0FBRUYsSUFBRUU7QUFBSSxzQkFBR0osR0FBRUQsSUFBRUssRUFBQyxNQUFJSixHQUFFSixJQUFFLE9BQUtVLEtBQUUsSUFBRUYsS0FBRUUsRUFBQztBQUFFLDJCQUFLQSxPQUFJRixNQUFHQSxLQUFFRSxLQUFHQSxLQUFFO0FBQUEsMkJBQVcsT0FBS0EsT0FBSUEsS0FBRUYsS0FBR0EsS0FBRUUsS0FBRSxNQUFJSDtBQUFFLDJCQUFPRyxLQUFFTDtBQUFBLGNBQUM7QUFBTSxxQkFBSU4sS0FBRVEsS0FBRUQsT0FBSVAsS0FBRU8sS0FBRUMsS0FBR0MsS0FBRVQsSUFBRSxLQUFHUyxJQUFFQSxNQUFJO0FBQUMsMkJBQVFHLEtBQUUsTUFBR0YsS0FBRSxHQUFFQSxLQUFFRixJQUFFRTtBQUFJLHdCQUFHTCxHQUFFRCxJQUFFSyxLQUFFQyxFQUFDLE1BQUlMLEdBQUVKLElBQUVTLEVBQUMsR0FBRTtBQUFDLHNCQUFBRSxLQUFFO0FBQUc7QUFBQSxvQkFBSztBQUFDLHNCQUFHQTtBQUFFLDJCQUFPSDtBQUFBLGdCQUFDO0FBQUMscUJBQU07QUFBQSxZQUFFO0FBQUMscUJBQVMsRUFBRUwsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRTtBQUFDLGNBQUFGLEtBQUUsQ0FBQ0EsTUFBRztBQUFFLGtCQUFJLElBQUVJLEdBQUUsU0FBT0o7QUFBRSxjQUFBRSxNQUFHQSxLQUFFLENBQUNBLElBQUVBLEtBQUUsTUFBSUEsS0FBRSxNQUFJQSxLQUFFO0FBQUUsa0JBQUlHLEtBQUVKLEdBQUU7QUFBTyxjQUFBQyxLQUFFRyxLQUFFLE1BQUlILEtBQUVHLEtBQUU7QUFBRyx1QkFBUUMsSUFBRUMsS0FBRSxHQUFFQSxLQUFFTCxJQUFFLEVBQUVLLElBQUU7QUFBQyxvQkFBR0QsS0FBRSxTQUFTTCxHQUFFLE9BQU8sSUFBRU0sSUFBRSxDQUFDLEdBQUUsRUFBRSxHQUFFLEVBQUVELEVBQUM7QUFBRSx5QkFBT0M7QUFBRSxnQkFBQUgsR0FBRUosS0FBRU8sRUFBQyxJQUFFRDtBQUFBLGNBQUM7QUFBQyxxQkFBT0M7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUgsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRTtBQUFDLHFCQUFPLEVBQUUsRUFBRUQsSUFBRUcsR0FBRSxTQUFPSixFQUFDLEdBQUVJLElBQUVKLElBQUVFLEVBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUUsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRTtBQUFDLHFCQUFPLEVBQUUsRUFBRUQsRUFBQyxHQUFFRyxJQUFFSixJQUFFRSxFQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVFLElBQUVILElBQUVELElBQUVFLElBQUU7QUFBQyxxQkFBTyxFQUFFRSxJQUFFSCxJQUFFRCxJQUFFRSxFQUFDO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVFLElBQUVILElBQUVELElBQUVFLElBQUU7QUFBQyxxQkFBTyxFQUFFLEVBQUVELEVBQUMsR0FBRUcsSUFBRUosSUFBRUUsRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFO0FBQUMscUJBQU8sRUFBRSxFQUFFRCxJQUFFRyxHQUFFLFNBQU9KLEVBQUMsR0FBRUksSUFBRUosSUFBRUUsRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU8sTUFBSUMsTUFBR0QsT0FBSUksR0FBRSxTQUFPLEVBQUUsY0FBY0EsRUFBQyxJQUFFLEVBQUUsY0FBY0EsR0FBRSxNQUFNSCxJQUFFRCxFQUFDLENBQUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGNBQUFBLEtBQUUsRUFBRUksR0FBRSxRQUFPSixFQUFDO0FBQUUsdUJBQVFFLEtBQUUsQ0FBQyxHQUFFLElBQUVELElBQUUsSUFBRUQsTUFBRztBQUFDLG9CQUFJTSxLQUFFRixHQUFFLENBQUMsR0FBRUcsS0FBRSxNQUFLQyxLQUFFLE1BQUlGLEtBQUUsSUFBRSxNQUFJQSxLQUFFLElBQUUsTUFBSUEsS0FBRSxJQUFFO0FBQUUsb0JBQUcsSUFBRUUsTUFBR1IsSUFBRTtBQUFDLHNCQUFJUyxJQUFFRSxJQUFFQyxJQUFFRjtBQUFFLHdCQUFJRixLQUFFLE1BQUlGLE9BQUlDLEtBQUVELE1BQUcsTUFBSUUsTUFBR0MsS0FBRUwsR0FBRSxJQUFFLENBQUMsR0FBRSxRQUFNLE1BQUlLLFFBQUtDLE1BQUcsS0FBR0osT0FBSSxJQUFFLEtBQUdHLElBQUUsTUFBSUMsT0FBSUgsS0FBRUcsUUFBSyxNQUFJRixNQUFHQyxLQUFFTCxHQUFFLElBQUUsQ0FBQyxHQUFFTyxLQUFFUCxHQUFFLElBQUUsQ0FBQyxHQUFFLFFBQU0sTUFBSUssT0FBSSxRQUFNLE1BQUlFLFFBQUtELE1BQUcsS0FBR0osT0FBSSxNQUFJLEtBQUdHLE9BQUksSUFBRSxLQUFHRSxJQUFFLE9BQUtELE9BQUksUUFBTUEsTUFBRyxRQUFNQSxRQUFLSCxLQUFFRyxRQUFLLE1BQUlGLE1BQUdDLEtBQUVMLEdBQUUsSUFBRSxDQUFDLEdBQUVPLEtBQUVQLEdBQUUsSUFBRSxDQUFDLEdBQUVRLEtBQUVSLEdBQUUsSUFBRSxDQUFDLEdBQUUsUUFBTSxNQUFJSyxPQUFJLFFBQU0sTUFBSUUsT0FBSSxRQUFNLE1BQUlDLFFBQUtGLE1BQUcsS0FBR0osT0FBSSxNQUFJLEtBQUdHLE9BQUksTUFBSSxLQUFHRSxPQUFJLElBQUUsS0FBR0MsSUFBRSxRQUFNRixNQUFHLFVBQVFBLE9BQUlILEtBQUVHLFFBQUs7QUFBQSxnQkFBTTtBQUFDLHlCQUFPSCxNQUFHQSxLQUFFLE9BQU1DLEtBQUUsS0FBRyxRQUFNRCxPQUFJQSxNQUFHLE9BQU1MLEdBQUUsS0FBSyxRQUFNLE9BQUtLLE9BQUksRUFBRSxHQUFFQSxLQUFFLFFBQU0sT0FBS0EsS0FBR0wsR0FBRSxLQUFLSyxFQUFDLEdBQUUsS0FBR0M7QUFBQSxjQUFDO0FBQUMscUJBQU8sRUFBRU4sRUFBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFO0FBQUMsa0JBQUlKLEtBQUVJLEdBQUU7QUFBTyxrQkFBR0osTUFBRztBQUFLLHVCQUFPQyxHQUFFLE1BQU0sUUFBT0csRUFBQztBQUFFLHVCQUFRRixLQUFFLElBQUcsSUFBRSxHQUFFLElBQUVGO0FBQUcsZ0JBQUFFLE1BQUdELEdBQUUsTUFBTSxRQUFPRyxHQUFFLE1BQU0sR0FBRSxLQUFHLElBQUksQ0FBQztBQUFFLHFCQUFPRjtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRSxJQUFFSixJQUFFRSxJQUFFO0FBQUMsa0JBQUksSUFBRTtBQUFHLGNBQUFBLEtBQUUsRUFBRUUsR0FBRSxRQUFPRixFQUFDO0FBQUUsdUJBQVFJLEtBQUVOLElBQUVNLEtBQUVKLElBQUUsRUFBRUk7QUFBRSxxQkFBR0wsR0FBRSxNQUFJRyxHQUFFRSxFQUFDLENBQUM7QUFBRSxxQkFBTztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRixJQUFFSixJQUFFRSxJQUFFO0FBQUMsa0JBQUksSUFBRTtBQUFHLGNBQUFBLEtBQUUsRUFBRUUsR0FBRSxRQUFPRixFQUFDO0FBQUUsdUJBQVFJLEtBQUVOLElBQUVNLEtBQUVKLElBQUUsRUFBRUk7QUFBRSxxQkFBR0wsR0FBRUcsR0FBRUUsRUFBQyxDQUFDO0FBQUUscUJBQU87QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUYsSUFBRUgsSUFBRUQsSUFBRTtBQUFDLGtCQUFJRSxLQUFFRSxHQUFFO0FBQU8sZUFBQyxDQUFDSCxNQUFHLElBQUVBLFFBQUtBLEtBQUUsS0FBSSxDQUFDRCxNQUFHLElBQUVBLE1BQUdBLEtBQUVFLFFBQUtGLEtBQUVFO0FBQUcsdUJBQVEsSUFBRSxJQUFHRyxLQUFFSixJQUFFSSxLQUFFTCxJQUFFLEVBQUVLO0FBQUUscUJBQUcsRUFBRUQsR0FBRUMsRUFBQyxDQUFDO0FBQUUscUJBQU87QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUQsSUFBRUosSUFBRUUsSUFBRTtBQUFDLHVCQUFRLElBQUVFLEdBQUUsTUFBTUosSUFBRUUsRUFBQyxHQUFFRyxLQUFFLElBQUdDLEtBQUUsR0FBRUEsS0FBRSxFQUFFLFFBQU9BLE1BQUc7QUFBRSxnQkFBQUQsTUFBR0osR0FBRSxFQUFFSyxFQUFDLElBQUUsTUFBSSxFQUFFQSxLQUFFLENBQUMsQ0FBQztBQUFFLHFCQUFPRDtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRCxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsa0JBQUcsS0FBR0ksS0FBRSxLQUFHLElBQUVBO0FBQUUsc0JBQU0sSUFBSSxXQUFXLG9CQUFvQjtBQUFFLGtCQUFHQSxLQUFFSCxLQUFFRDtBQUFFLHNCQUFNLElBQUksV0FBVyx1Q0FBdUM7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRUUsSUFBRSxHQUFFRyxJQUFFO0FBQUMsa0JBQUcsQ0FBQyxFQUFFLFNBQVNELEVBQUM7QUFBRSxzQkFBTSxJQUFJLFVBQVUsNkNBQStDO0FBQUUsa0JBQUdILEtBQUUsS0FBR0EsS0FBRUk7QUFBRSxzQkFBTSxJQUFJLFdBQVcsbUNBQXFDO0FBQUUsa0JBQUdMLEtBQUVFLEtBQUVFLEdBQUU7QUFBTyxzQkFBTSxJQUFJLFdBQVcsb0JBQW9CO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUVELElBQUVFLElBQUU7QUFBQyxrQkFBR0YsS0FBRUUsS0FBRUUsR0FBRTtBQUFPLHNCQUFNLElBQUksV0FBVyxvQkFBb0I7QUFBRSxrQkFBRyxJQUFFSjtBQUFFLHNCQUFNLElBQUksV0FBVyxvQkFBb0I7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRUUsSUFBRSxHQUFFO0FBQUMscUJBQU9ELEtBQUUsQ0FBQ0EsSUFBRUQsUUFBSyxHQUFFLEtBQUcsRUFBRUksSUFBRUgsSUFBRUQsSUFBRSxHQUFFLHNCQUFxQixxQkFBcUIsR0FBRSxFQUFFLE1BQU1JLElBQUVILElBQUVELElBQUVFLElBQUUsSUFBRyxDQUFDLEdBQUVGLEtBQUU7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRUgsSUFBRUQsSUFBRUUsSUFBRSxHQUFFO0FBQUMscUJBQU9ELEtBQUUsQ0FBQ0EsSUFBRUQsUUFBSyxHQUFFLEtBQUcsRUFBRUksSUFBRUgsSUFBRUQsSUFBRSxHQUFFLHVCQUFzQixzQkFBc0IsR0FBRSxFQUFFLE1BQU1JLElBQUVILElBQUVELElBQUVFLElBQUUsSUFBRyxDQUFDLEdBQUVGLEtBQUU7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUksSUFBRTtBQUFDLGtCQUFHQSxLQUFFQSxHQUFFLE1BQU0sR0FBRyxFQUFFLENBQUMsR0FBRUEsS0FBRUEsR0FBRSxLQUFLLEVBQUUsUUFBUSxHQUFFLEVBQUUsR0FBRSxJQUFFQSxHQUFFO0FBQU8sdUJBQU07QUFBRyxxQkFBSyxLQUFHQSxHQUFFLFNBQU87QUFBRyxnQkFBQUEsTUFBRztBQUFJLHFCQUFPQTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFO0FBQUMscUJBQU8sS0FBR0EsS0FBRSxNQUFJQSxHQUFFLFNBQVMsRUFBRSxJQUFFQSxHQUFFLFNBQVMsRUFBRTtBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFO0FBQUMsY0FBQUEsS0FBRUEsTUFBRyxJQUFFO0FBQUUsdUJBQVFELElBQUVFLEtBQUVFLEdBQUUsUUFBTyxJQUFFLE1BQUtDLEtBQUUsQ0FBQyxHQUFFQyxLQUFFLEdBQUVBLEtBQUVKLElBQUUsRUFBRUksSUFBRTtBQUFDLG9CQUFHTixLQUFFSSxHQUFFLFdBQVdFLEVBQUMsR0FBRSxRQUFNTixNQUFHLFFBQU1BLElBQUU7QUFBQyxzQkFBRyxDQUFDLEdBQUU7QUFBQyx3QkFBRyxRQUFNQSxJQUFFO0FBQUMsNEJBQUlDLE1BQUcsTUFBSUksR0FBRSxLQUFLLEtBQUksS0FBSSxHQUFHO0FBQUU7QUFBQSxvQkFBUSxXQUFTQyxLQUFFLE1BQUlKLElBQUU7QUFBQyw0QkFBSUQsTUFBRyxNQUFJSSxHQUFFLEtBQUssS0FBSSxLQUFJLEdBQUc7QUFBRTtBQUFBLG9CQUFRO0FBQUMsd0JBQUVMO0FBQUU7QUFBQSxrQkFBUTtBQUFDLHNCQUFHLFFBQU1BLElBQUU7QUFBQywwQkFBSUMsTUFBRyxNQUFJSSxHQUFFLEtBQUssS0FBSSxLQUFJLEdBQUcsR0FBRSxJQUFFTDtBQUFFO0FBQUEsa0JBQVE7QUFBQyxrQkFBQUEsTUFBRyxJQUFFLFNBQU8sS0FBR0EsS0FBRSxTQUFPO0FBQUEsZ0JBQUs7QUFBTSx1QkFBRyxNQUFJQyxNQUFHLE1BQUlJLEdBQUUsS0FBSyxLQUFJLEtBQUksR0FBRztBQUFFLG9CQUFHLElBQUUsTUFBSyxNQUFJTCxJQUFFO0FBQUMsc0JBQUcsS0FBR0MsTUFBRztBQUFHO0FBQU0sa0JBQUFJLEdBQUUsS0FBS0wsRUFBQztBQUFBLGdCQUFDLFdBQVMsT0FBS0EsSUFBRTtBQUFDLHNCQUFHLEtBQUdDLE1BQUc7QUFBRztBQUFNLGtCQUFBSSxHQUFFLEtBQUssTUFBSUwsTUFBRyxHQUFFLE1BQUksS0FBR0EsRUFBQztBQUFBLGdCQUFDLFdBQVMsUUFBTUEsSUFBRTtBQUFDLHNCQUFHLEtBQUdDLE1BQUc7QUFBRztBQUFNLGtCQUFBSSxHQUFFLEtBQUssTUFBSUwsTUFBRyxJQUFHLE1BQUksS0FBR0EsTUFBRyxHQUFFLE1BQUksS0FBR0EsRUFBQztBQUFBLGdCQUFDLFdBQVMsVUFBUUEsSUFBRTtBQUFDLHNCQUFHLEtBQUdDLE1BQUc7QUFBRztBQUFNLGtCQUFBSSxHQUFFLEtBQUssTUFBSUwsTUFBRyxJQUFHLE1BQUksS0FBR0EsTUFBRyxJQUFHLE1BQUksS0FBR0EsTUFBRyxHQUFFLE1BQUksS0FBR0EsRUFBQztBQUFBLGdCQUFDO0FBQU0sd0JBQU0sSUFBSSxNQUFNLG9CQUFvQjtBQUFBLGNBQUM7QUFBQyxxQkFBT0s7QUFBQSxZQUFDO0FBQUMscUJBQVMsRUFBRUQsSUFBRTtBQUFDLHVCQUFRSCxLQUFFLENBQUMsR0FBRUQsS0FBRSxHQUFFQSxLQUFFSSxHQUFFLFFBQU8sRUFBRUo7QUFBRSxnQkFBQUMsR0FBRSxLQUFLLE1BQUlHLEdBQUUsV0FBV0osRUFBQyxDQUFDO0FBQUUscUJBQU9DO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVHLElBQUVILElBQUU7QUFBQyx1QkFBUUQsSUFBRUUsSUFBRSxHQUFFRyxLQUFFLENBQUMsR0FBRUMsS0FBRSxHQUFFQSxLQUFFRixHQUFFLFVBQVEsRUFBRSxLQUFHSCxNQUFHLEtBQUksRUFBRUs7QUFBRSxnQkFBQU4sS0FBRUksR0FBRSxXQUFXRSxFQUFDLEdBQUVKLEtBQUVGLE1BQUcsR0FBRSxJQUFFQSxLQUFFLEtBQUlLLEdBQUUsS0FBSyxDQUFDLEdBQUVBLEdBQUUsS0FBS0gsRUFBQztBQUFFLHFCQUFPRztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFRCxJQUFFO0FBQUMscUJBQU8sRUFBRSxZQUFZLEVBQUVBLEVBQUMsQ0FBQztBQUFBLFlBQUM7QUFBQyxxQkFBUyxFQUFFQSxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFO0FBQUMsdUJBQVEsSUFBRSxHQUFFLElBQUVBLE1BQUcsRUFBRSxJQUFFRixNQUFHQyxHQUFFLFVBQVEsS0FBR0csR0FBRSxTQUFRLEVBQUU7QUFBRSxnQkFBQUgsR0FBRSxJQUFFRCxFQUFDLElBQUVJLEdBQUUsQ0FBQztBQUFFLHFCQUFPO0FBQUEsWUFBQztBQUFDLHFCQUFTLEVBQUVBLElBQUVILElBQUU7QUFBQyxxQkFBT0csY0FBYUgsTUFBRyxRQUFNRyxNQUFHLFFBQU1BLEdBQUUsZUFBYSxRQUFNQSxHQUFFLFlBQVksUUFBTUEsR0FBRSxZQUFZLFNBQU9ILEdBQUU7QUFBQSxZQUFJO0FBQUMscUJBQVMsRUFBRUcsSUFBRTtBQUFDLHFCQUFPQSxPQUFJQTtBQUFBLFlBQUM7QUFBQyxnQkFBSSxJQUFFLEVBQUUsV0FBVyxHQUFFLElBQUUsRUFBRSxTQUFTO0FBQUUsWUFBQUosR0FBRSxTQUFPLEdBQUVBLEdBQUUsYUFBVyxTQUFTSSxJQUFFO0FBQUMscUJBQU0sQ0FBQ0EsTUFBR0EsT0FBSUEsS0FBRSxJQUFHLEVBQUUsTUFBTSxDQUFDQSxFQUFDO0FBQUEsWUFBQyxHQUFFSixHQUFFLG9CQUFrQjtBQUFHLFlBQUFBLEdBQUUsYUFBVyxZQUFXLEVBQUUsc0JBQW9CLFdBQVU7QUFBQyxrQkFBRztBQUFDLG9CQUFJSSxLQUFFLElBQUksV0FBVyxDQUFDO0FBQUUsdUJBQU9BLEdBQUUsWUFBVSxFQUFDLFdBQVUsV0FBVyxXQUFVLEtBQUksV0FBVTtBQUFDLHlCQUFPO0FBQUEsZ0JBQUUsRUFBQyxHQUFFLE9BQUtBLEdBQUUsSUFBSTtBQUFBLGNBQUMsU0FBT0gsSUFBTjtBQUFTLHVCQUFNO0FBQUEsY0FBRTtBQUFBLFlBQUMsRUFBRSxHQUFFLEVBQUUsdUJBQXFCLGVBQWEsT0FBTyxXQUFTLGNBQVksT0FBTyxRQUFRLFNBQU8sUUFBUSxNQUFNLCtJQUErSSxHQUFFLE9BQU8sZUFBZSxFQUFFLFdBQVUsVUFBUyxFQUFDLFlBQVcsTUFBRyxLQUFJLFdBQVU7QUFBQyxxQkFBTyxFQUFFLFNBQVMsSUFBSSxJQUFFLEtBQUssU0FBTztBQUFBLFlBQU0sRUFBQyxDQUFDLEdBQUUsT0FBTyxlQUFlLEVBQUUsV0FBVSxVQUFTLEVBQUMsWUFBVyxNQUFHLEtBQUksV0FBVTtBQUFDLHFCQUFPLEVBQUUsU0FBUyxJQUFJLElBQUUsS0FBSyxhQUFXO0FBQUEsWUFBTSxFQUFDLENBQUMsR0FBRSxlQUFhLE9BQU8sVUFBUSxRQUFNLE9BQU8sV0FBUyxFQUFFLE9BQU8sT0FBTyxNQUFJLEtBQUcsT0FBTyxlQUFlLEdBQUUsT0FBTyxTQUFRLEVBQUMsT0FBTSxNQUFLLGNBQWEsTUFBRyxZQUFXLE9BQUcsVUFBUyxNQUFFLENBQUMsR0FBRSxFQUFFLFdBQVMsTUFBSyxFQUFFLE9BQUssU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLEVBQUVJLElBQUVILElBQUVELEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLFlBQVUsV0FBVyxXQUFVLEVBQUUsWUFBVSxZQUFXLEVBQUUsUUFBTSxTQUFTSSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU8sRUFBRUksSUFBRUgsSUFBRUQsRUFBQztBQUFBLFlBQUMsR0FBRSxFQUFFLGNBQVksU0FBU0ksSUFBRTtBQUFDLHFCQUFPLEVBQUVBLEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxrQkFBZ0IsU0FBU0EsSUFBRTtBQUFDLHFCQUFPLEVBQUVBLEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxXQUFTLFNBQVNBLElBQUU7QUFBQyxxQkFBTyxRQUFNQSxNQUFHLFNBQUtBLEdBQUUsYUFBV0EsT0FBSSxFQUFFO0FBQUEsWUFBUyxHQUFFLEVBQUUsVUFBUSxTQUFTQSxJQUFFSCxJQUFFO0FBQUMsa0JBQUcsRUFBRUcsSUFBRSxVQUFVLE1BQUlBLEtBQUUsRUFBRSxLQUFLQSxJQUFFQSxHQUFFLFFBQU9BLEdBQUUsVUFBVSxJQUFHLEVBQUVILElBQUUsVUFBVSxNQUFJQSxLQUFFLEVBQUUsS0FBS0EsSUFBRUEsR0FBRSxRQUFPQSxHQUFFLFVBQVUsSUFBRyxDQUFDLEVBQUUsU0FBU0csRUFBQyxLQUFHLENBQUMsRUFBRSxTQUFTSCxFQUFDO0FBQUUsc0JBQU0sSUFBSSxVQUFVLHVFQUEyRTtBQUFFLGtCQUFHRyxPQUFJSDtBQUFFLHVCQUFPO0FBQUUsdUJBQVFELEtBQUVJLEdBQUUsUUFBT0YsS0FBRUQsR0FBRSxRQUFPSyxLQUFFLEdBQUVFLEtBQUUsRUFBRVIsSUFBRUUsRUFBQyxHQUFFSSxLQUFFRSxJQUFFLEVBQUVGO0FBQUUsb0JBQUdGLEdBQUVFLEVBQUMsTUFBSUwsR0FBRUssRUFBQyxHQUFFO0FBQUMsa0JBQUFOLEtBQUVJLEdBQUVFLEVBQUMsR0FBRUosS0FBRUQsR0FBRUssRUFBQztBQUFFO0FBQUEsZ0JBQUs7QUFBQyxxQkFBT04sS0FBRUUsS0FBRSxLQUFHQSxLQUFFRixLQUFFLElBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxhQUFXLFNBQVNJLElBQUU7QUFBQyx1QkFBUUEsS0FBRSxJQUFJLFlBQVksR0FBRTtBQUFBLGdCQUFDLEtBQUk7QUFBQSxnQkFBTSxLQUFJO0FBQUEsZ0JBQU8sS0FBSTtBQUFBLGdCQUFRLEtBQUk7QUFBQSxnQkFBUSxLQUFJO0FBQUEsZ0JBQVMsS0FBSTtBQUFBLGdCQUFTLEtBQUk7QUFBQSxnQkFBUyxLQUFJO0FBQUEsZ0JBQU8sS0FBSTtBQUFBLGdCQUFRLEtBQUk7QUFBQSxnQkFBVSxLQUFJO0FBQVcseUJBQU07QUFBQSxnQkFBRztBQUFRLHlCQUFNO0FBQUEsY0FBRztBQUFBLFlBQUMsR0FBRSxFQUFFLFNBQU8sU0FBU0EsSUFBRUgsSUFBRTtBQUFDLGtCQUFHLENBQUMsTUFBTSxRQUFRRyxFQUFDO0FBQUUsc0JBQU0sSUFBSSxVQUFVLDZDQUErQztBQUFFLGtCQUFHLE1BQUlBLEdBQUU7QUFBTyx1QkFBTyxFQUFFLE1BQU0sQ0FBQztBQUFFLGtCQUFJSjtBQUFFLGtCQUFHQyxPQUFJO0FBQU8scUJBQUlBLEtBQUUsR0FBRUQsS0FBRSxHQUFFQSxLQUFFSSxHQUFFLFFBQU8sRUFBRUo7QUFBRSxrQkFBQUMsTUFBR0csR0FBRUosRUFBQyxFQUFFO0FBQU8sa0JBQUlFLEtBQUUsRUFBRSxZQUFZRCxFQUFDLEdBQUUsSUFBRTtBQUFFLG1CQUFJRCxLQUFFLEdBQUVBLEtBQUVJLEdBQUUsUUFBTyxFQUFFSixJQUFFO0FBQUMsb0JBQUlLLEtBQUVELEdBQUVKLEVBQUM7QUFBRSxvQkFBRyxFQUFFSyxJQUFFLFVBQVUsTUFBSUEsS0FBRSxFQUFFLEtBQUtBLEVBQUMsSUFBRyxDQUFDLEVBQUUsU0FBU0EsRUFBQztBQUFFLHdCQUFNLElBQUksVUFBVSw2Q0FBK0M7QUFBRSxnQkFBQUEsR0FBRSxLQUFLSCxJQUFFLENBQUMsR0FBRSxLQUFHRyxHQUFFO0FBQUEsY0FBTTtBQUFDLHFCQUFPSDtBQUFBLFlBQUMsR0FBRSxFQUFFLGFBQVcsR0FBRSxFQUFFLFVBQVUsWUFBVSxNQUFHLEVBQUUsVUFBVSxTQUFPLFdBQVU7QUFBQyxrQkFBSUUsS0FBRSxLQUFLO0FBQU8sa0JBQUcsS0FBR0EsS0FBRTtBQUFFLHNCQUFNLElBQUksV0FBVywyQ0FBMkM7QUFBRSx1QkFBUUgsS0FBRSxHQUFFQSxLQUFFRyxJQUFFSCxNQUFHO0FBQUUsa0JBQUUsTUFBS0EsSUFBRUEsS0FBRSxDQUFDO0FBQUUscUJBQU87QUFBQSxZQUFJLEdBQUUsRUFBRSxVQUFVLFNBQU8sV0FBVTtBQUFDLGtCQUFJRyxLQUFFLEtBQUs7QUFBTyxrQkFBRyxLQUFHQSxLQUFFO0FBQUUsc0JBQU0sSUFBSSxXQUFXLDJDQUEyQztBQUFFLHVCQUFRSCxLQUFFLEdBQUVBLEtBQUVHLElBQUVILE1BQUc7QUFBRSxrQkFBRSxNQUFLQSxJQUFFQSxLQUFFLENBQUMsR0FBRSxFQUFFLE1BQUtBLEtBQUUsR0FBRUEsS0FBRSxDQUFDO0FBQUUscUJBQU87QUFBQSxZQUFJLEdBQUUsRUFBRSxVQUFVLFNBQU8sV0FBVTtBQUFDLGtCQUFJRyxLQUFFLEtBQUs7QUFBTyxrQkFBRyxLQUFHQSxLQUFFO0FBQUUsc0JBQU0sSUFBSSxXQUFXLDJDQUEyQztBQUFFLHVCQUFRSCxLQUFFLEdBQUVBLEtBQUVHLElBQUVILE1BQUc7QUFBRSxrQkFBRSxNQUFLQSxJQUFFQSxLQUFFLENBQUMsR0FBRSxFQUFFLE1BQUtBLEtBQUUsR0FBRUEsS0FBRSxDQUFDLEdBQUUsRUFBRSxNQUFLQSxLQUFFLEdBQUVBLEtBQUUsQ0FBQyxHQUFFLEVBQUUsTUFBS0EsS0FBRSxHQUFFQSxLQUFFLENBQUM7QUFBRSxxQkFBTztBQUFBLFlBQUksR0FBRSxFQUFFLFVBQVUsV0FBUyxXQUFVO0FBQUMsa0JBQUlHLEtBQUUsS0FBSztBQUFPLHFCQUFPLE1BQUlBLEtBQUUsS0FBRyxNQUFJLFVBQVUsU0FBTyxFQUFFLE1BQUssR0FBRUEsRUFBQyxJQUFFLEVBQUUsTUFBTSxNQUFLLFNBQVM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGlCQUFlLEVBQUUsVUFBVSxVQUFTLEVBQUUsVUFBVSxTQUFPLFNBQVNBLElBQUU7QUFBQyxrQkFBRyxDQUFDLEVBQUUsU0FBU0EsRUFBQztBQUFFLHNCQUFNLElBQUksVUFBVSwyQkFBMkI7QUFBRSxxQkFBTyxTQUFPQSxNQUFHLE1BQUksRUFBRSxRQUFRLE1BQUtBLEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLFVBQVEsV0FBVTtBQUFDLGtCQUFJQSxLQUFFLElBQUdILEtBQUVELEdBQUU7QUFBa0IscUJBQU9JLEtBQUUsS0FBSyxTQUFTLE9BQU0sR0FBRUgsRUFBQyxFQUFFLFFBQVEsV0FBVSxLQUFLLEVBQUUsS0FBSyxHQUFFLEtBQUssU0FBT0EsT0FBSUcsTUFBRyxVQUFTLGFBQVdBLEtBQUU7QUFBQSxZQUFHLEdBQUUsRUFBRSxVQUFVLFVBQVEsU0FBU0EsSUFBRUgsSUFBRUQsSUFBRUUsSUFBRSxHQUFFO0FBQUMsa0JBQUcsRUFBRUUsSUFBRSxVQUFVLE1BQUlBLEtBQUUsRUFBRSxLQUFLQSxJQUFFQSxHQUFFLFFBQU9BLEdBQUUsVUFBVSxJQUFHLENBQUMsRUFBRSxTQUFTQSxFQUFDO0FBQUUsc0JBQU0sSUFBSSxVQUFVLG1GQUFtRixPQUFPQSxFQUFDO0FBQUUsa0JBQUcsV0FBU0gsT0FBSUEsS0FBRSxJQUFHLFdBQVNELE9BQUlBLEtBQUVJLEtBQUVBLEdBQUUsU0FBTyxJQUFHLFdBQVNGLE9BQUlBLEtBQUUsSUFBRyxXQUFTLE1BQUksSUFBRSxLQUFLLFNBQVEsSUFBRUQsTUFBR0QsS0FBRUksR0FBRSxVQUFRLElBQUVGLE1BQUcsSUFBRSxLQUFLO0FBQU8sc0JBQU0sSUFBSSxXQUFXLG9CQUFvQjtBQUFFLGtCQUFHQSxNQUFHLEtBQUdELE1BQUdEO0FBQUUsdUJBQU87QUFBRSxrQkFBR0UsTUFBRztBQUFFLHVCQUFNO0FBQUcsa0JBQUdELE1BQUdEO0FBQUUsdUJBQU87QUFBRSxrQkFBR0MsUUFBSyxHQUFFRCxRQUFLLEdBQUVFLFFBQUssR0FBRSxPQUFLLEdBQUUsU0FBT0U7QUFBRSx1QkFBTztBQUFFLHVCQUFRRSxLQUFFLElBQUVKLElBQUVNLEtBQUVSLEtBQUVDLElBQUVRLEtBQUUsRUFBRUgsSUFBRUUsRUFBQyxHQUFFRyxLQUFFLEtBQUssTUFBTVQsSUFBRSxDQUFDLEdBQUVVLEtBQUVSLEdBQUUsTUFBTUgsSUFBRUQsRUFBQyxHQUFFVSxLQUFFLEdBQUVBLEtBQUVELElBQUUsRUFBRUM7QUFBRSxvQkFBR0MsR0FBRUQsRUFBQyxNQUFJRSxHQUFFRixFQUFDLEdBQUU7QUFBQyxrQkFBQUosS0FBRUssR0FBRUQsRUFBQyxHQUFFRixLQUFFSSxHQUFFRixFQUFDO0FBQUU7QUFBQSxnQkFBSztBQUFDLHFCQUFPSixLQUFFRSxLQUFFLEtBQUdBLEtBQUVGLEtBQUUsSUFBRTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsV0FBUyxTQUFTRixJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU0sT0FBSyxLQUFLLFFBQVFJLElBQUVILElBQUVELEVBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLFVBQVEsU0FBU0ksSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRUQsSUFBRSxJQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxjQUFZLFNBQVNJLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBTyxFQUFFLE1BQUtJLElBQUVILElBQUVELElBQUUsS0FBRTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsUUFBTSxTQUFTSSxJQUFFSCxJQUFFRCxJQUFFRSxJQUFFO0FBQUMsa0JBQUcsV0FBU0Q7QUFBRSxnQkFBQUMsS0FBRSxRQUFPRixLQUFFLEtBQUssUUFBT0MsS0FBRTtBQUFBLHVCQUFVLFdBQVNELE1BQUcsWUFBVSxPQUFPQztBQUFFLGdCQUFBQyxLQUFFRCxJQUFFRCxLQUFFLEtBQUssUUFBT0MsS0FBRTtBQUFBLHVCQUFVLFNBQVNBLEVBQUM7QUFBRSxnQkFBQUEsUUFBSyxHQUFFLFNBQVNELEVBQUMsS0FBR0EsUUFBSyxHQUFFLFdBQVNFLE9BQUlBLEtBQUUsWUFBVUEsS0FBRUYsSUFBRUEsS0FBRTtBQUFBO0FBQWEsc0JBQU0sSUFBSSxNQUFNLHlFQUF5RTtBQUFFLGtCQUFJLElBQUUsS0FBSyxTQUFPQztBQUFFLG1CQUFJLFdBQVNELE1BQUdBLEtBQUUsT0FBS0EsS0FBRSxJQUFHLElBQUVJLEdBQUUsV0FBUyxJQUFFSixNQUFHLElBQUVDLE9BQUlBLEtBQUUsS0FBSztBQUFPLHNCQUFNLElBQUksV0FBVyx3Q0FBd0M7QUFBRSxjQUFBQyxPQUFJQSxLQUFFO0FBQVEsdUJBQVFHLEtBQUU7QUFBSyx3QkFBT0gsSUFBRTtBQUFBLGtCQUFDLEtBQUk7QUFBTSwyQkFBTyxFQUFFLE1BQUtFLElBQUVILElBQUVELEVBQUM7QUFBQSxrQkFBRSxLQUFJO0FBQUEsa0JBQU8sS0FBSTtBQUFRLDJCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRUQsRUFBQztBQUFBLGtCQUFFLEtBQUk7QUFBUSwyQkFBTyxFQUFFLE1BQUtJLElBQUVILElBQUVELEVBQUM7QUFBQSxrQkFBRSxLQUFJO0FBQUEsa0JBQVMsS0FBSTtBQUFTLDJCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRUQsRUFBQztBQUFBLGtCQUFFLEtBQUk7QUFBUywyQkFBTyxFQUFFLE1BQUtJLElBQUVILElBQUVELEVBQUM7QUFBQSxrQkFBRSxLQUFJO0FBQUEsa0JBQU8sS0FBSTtBQUFBLGtCQUFRLEtBQUk7QUFBQSxrQkFBVSxLQUFJO0FBQVcsMkJBQU8sRUFBRSxNQUFLSSxJQUFFSCxJQUFFRCxFQUFDO0FBQUEsa0JBQUU7QUFBUSx3QkFBR0s7QUFBRSw0QkFBTSxJQUFJLFVBQVUsdUJBQXFCSCxFQUFDO0FBQUUsb0JBQUFBLE1BQUcsS0FBR0EsSUFBRyxZQUFZLEdBQUVHLEtBQUU7QUFBQSxnQkFBRztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsU0FBTyxXQUFVO0FBQUMscUJBQU0sRUFBQyxNQUFLLFVBQVMsTUFBSyxNQUFNLFVBQVUsTUFBTSxLQUFLLEtBQUssUUFBTSxNQUFLLENBQUMsRUFBQztBQUFBLFlBQUM7QUFBRSxjQUFFLFVBQVUsUUFBTSxTQUFTRCxJQUFFSCxJQUFFO0FBQUMsa0JBQUlELEtBQUUsS0FBSztBQUFPLGNBQUFJLEtBQUUsQ0FBQyxDQUFDQSxJQUFFSCxLQUFFQSxPQUFJLFNBQU9ELEtBQUUsQ0FBQyxDQUFDQyxJQUFFLElBQUVHLE1BQUdBLE1BQUdKLElBQUUsSUFBRUksT0FBSUEsS0FBRSxNQUFJQSxLQUFFSixPQUFJSSxLQUFFSixLQUFHLElBQUVDLE1BQUdBLE1BQUdELElBQUUsSUFBRUMsT0FBSUEsS0FBRSxNQUFJQSxLQUFFRCxPQUFJQyxLQUFFRCxLQUFHQyxLQUFFRyxPQUFJSCxLQUFFRztBQUFHLGtCQUFJRixLQUFFLEtBQUssU0FBU0UsSUFBRUgsRUFBQztBQUFFLHFCQUFPQyxHQUFFLFlBQVUsRUFBRSxXQUFVQTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsYUFBVyxTQUFTRSxJQUFFSCxJQUFFRCxJQUFFO0FBQUMsY0FBQUksUUFBSyxHQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRUksSUFBRUgsSUFBRSxLQUFLLE1BQU07QUFBRSx1QkFBUUMsS0FBRSxLQUFLRSxFQUFDLEdBQUUsSUFBRSxHQUFFQyxLQUFFLEdBQUUsRUFBRUEsS0FBRUosT0FBSSxLQUFHO0FBQU0sZ0JBQUFDLE1BQUcsS0FBS0UsS0FBRUMsRUFBQyxJQUFFO0FBQUUscUJBQU9IO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxhQUFXLFNBQVNFLElBQUVILElBQUVELElBQUU7QUFBQyxjQUFBSSxRQUFLLEdBQUVILFFBQUssR0FBRUQsTUFBRyxFQUFFSSxJQUFFSCxJQUFFLEtBQUssTUFBTTtBQUFFLHVCQUFRQyxLQUFFLEtBQUtFLEtBQUUsRUFBRUgsRUFBQyxHQUFFLElBQUUsR0FBRSxJQUFFQSxPQUFJLEtBQUc7QUFBTSxnQkFBQUMsTUFBRyxLQUFLRSxLQUFFLEVBQUVILEVBQUMsSUFBRTtBQUFFLHFCQUFPQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsWUFBVSxTQUFTRSxJQUFFSCxJQUFFO0FBQUMscUJBQU9HLFFBQUssR0FBRUgsTUFBRyxFQUFFRyxJQUFFLEdBQUUsS0FBSyxNQUFNLEdBQUUsS0FBS0EsRUFBQztBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsZUFBYSxTQUFTQSxJQUFFSCxJQUFFO0FBQUMscUJBQU9HLFFBQUssR0FBRUgsTUFBRyxFQUFFRyxJQUFFLEdBQUUsS0FBSyxNQUFNLEdBQUUsS0FBS0EsRUFBQyxJQUFFLEtBQUtBLEtBQUUsQ0FBQyxLQUFHO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNBLElBQUVILElBQUU7QUFBQyxxQkFBT0csUUFBSyxHQUFFSCxNQUFHLEVBQUVHLElBQUUsR0FBRSxLQUFLLE1BQU0sR0FBRSxLQUFLQSxFQUFDLEtBQUcsSUFBRSxLQUFLQSxLQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0EsSUFBRUgsSUFBRTtBQUFDLHFCQUFPRyxRQUFLLEdBQUVILE1BQUcsRUFBRUcsSUFBRSxHQUFFLEtBQUssTUFBTSxJQUFHLEtBQUtBLEVBQUMsSUFBRSxLQUFLQSxLQUFFLENBQUMsS0FBRyxJQUFFLEtBQUtBLEtBQUUsQ0FBQyxLQUFHLE1BQUksV0FBUyxLQUFLQSxLQUFFLENBQUM7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0EsSUFBRUgsSUFBRTtBQUFDLHFCQUFPRyxRQUFLLEdBQUVILE1BQUcsRUFBRUcsSUFBRSxHQUFFLEtBQUssTUFBTSxHQUFFLFdBQVMsS0FBS0Es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QVNHLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsT0FBTSxNQUFNLEdBQUUsS0FBS0EsRUFBQyxJQUFFRyxPQUFJLEdBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUUsTUFBSUcsSUFBRUgsS0FBRTtBQUFBLFlBQUMsR0FBRSxFQUFFLFVBQVUsZUFBYSxTQUFTRyxJQUFFSCxJQUFFRCxJQUFFO0FBQUMscUJBQU9JLEtBQUUsQ0FBQ0EsSUFBRUgsUUFBSyxHQUFFRCxNQUFHLEVBQUUsTUFBS0ksSUFBRUgsSUFBRSxHQUFFLFlBQVcsV0FBVyxHQUFFLEtBQUtBLEVBQUMsSUFBRSxNQUFJRyxJQUFFLEtBQUtILEtBQUUsQ0FBQyxJQUFFRyxPQUFJLEdBQUUsS0FBS0gsS0FBRSxDQUFDLElBQUVHLE9BQUksSUFBRyxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxJQUFHSCxLQUFFO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNHLElBQUVILElBQUVELElBQUU7QUFBQyxxQkFBT0ksS0FBRSxDQUFDQSxJQUFFSCxRQUFLLEdBQUVELE1BQUcsRUFBRSxNQUFLSSxJQUFFSCxJQUFFLEdBQUUsWUFBVyxXQUFXLEdBQUUsSUFBRUcsT0FBSUEsS0FBRSxhQUFXQSxLQUFFLElBQUcsS0FBS0gsRUFBQyxJQUFFRyxPQUFJLElBQUcsS0FBS0gsS0FBRSxDQUFDLElBQUVHLE9BQUksSUFBRyxLQUFLSCxLQUFFLENBQUMsSUFBRUcsT0FBSSxHQUFFLEtBQUtILEtBQUUsQ0FBQyxJQUFFLE1BQUlHLElBQUVILEtBQUU7QUFBQSxZQUFDLEdBQUUsRUFBRSxVQUFVLGVBQWEsU0FBU0csSUFBRUgsSUFBRUQsSUFBRTtBQUFDLHFCQUFPLEVBQUUsTUFBS0ksSUFBRUgsSUFBRSxNQUFHRCxFQUFDO0FBQUEsWUFBQyxHQUFFLEVBQUUsVUFBVSxlQUFhLFNBQVNJLElBQUVILElBQUVELElBQUU7QUFBQyxx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QUFHLEtBQUcsS0FBRyxHQUFFLElBQUUsS0FBRyxHQUFFLElBQUUsSUFBRyxJQUFFRixLQUFFLElBQUUsSUFBRSxHQUFFLElBQUVBLEtBQUUsS0FBRyxHQUFFLElBQUVGLEdBQUVELEtBQUUsQ0FBQztBQUFFLGVBQUksS0FBRyxHQUFFLElBQUUsS0FBRyxLQUFHLENBQUMsS0FBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUcsR0FBRSxJQUFFLEdBQUUsSUFBRSxNQUFJLElBQUVDLEdBQUVELEtBQUUsQ0FBQyxHQUFFLEtBQUcsR0FBRSxLQUFHO0FBQUU7QUFBQyxlQUFJLElBQUUsS0FBRyxLQUFHLENBQUMsS0FBRyxHQUFFLE1BQUksQ0FBQyxHQUFFLEtBQUdLLElBQUUsSUFBRSxHQUFFLElBQUUsTUFBSSxJQUFFSixHQUFFRCxLQUFFLENBQUMsR0FBRSxLQUFHLEdBQUUsS0FBRztBQUFFO0FBQUMsY0FBRyxNQUFJO0FBQUUsZ0JBQUUsSUFBRTtBQUFBLGVBQU07QUFBQyxnQkFBRyxNQUFJO0FBQUUscUJBQU8sSUFBRSxPQUFLLElBQUUsS0FBRyxNQUFJLElBQUU7QUFBRyxpQkFBRyxFQUFFLEdBQUVLLEVBQUMsR0FBRSxLQUFHO0FBQUEsVUFBQztBQUFDLGtCQUFPLElBQUUsS0FBRyxLQUFHLElBQUUsRUFBRSxHQUFFLElBQUVBLEVBQUM7QUFBQSxRQUFDLEdBQUUsRUFBRSxRQUFNLFNBQVNGLElBQUVFLElBQUUsR0FBRSxHQUFFLEdBQUUsR0FBRTtBQUFDLGNBQUksR0FBRSxHQUFFLEdBQUUsSUFBRSxLQUFLLEtBQUksSUFBRSxLQUFLLEtBQUksSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLEtBQUcsS0FBRyxLQUFHLEdBQUUsSUFBRSxLQUFHLEdBQUUsSUFBRSxPQUFLLElBQUUsRUFBRSxHQUFFLEdBQUcsSUFBRSxFQUFFLEdBQUUsR0FBRyxJQUFFLEdBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxHQUFFLElBQUUsSUFBRSxJQUFFLElBQUcsSUFBRSxJQUFFQSxNQUFHLE1BQUlBLE1BQUcsSUFBRSxJQUFFQSxLQUFFLElBQUU7QUFBRSxlQUFJQSxLQUFFLEVBQUVBLEVBQUMsR0FBRSxNQUFNQSxFQUFDLEtBQUdBLE9BQUksSUFBRSxLQUFHLElBQUUsTUFBTUEsRUFBQyxJQUFFLElBQUUsR0FBRSxJQUFFLE1BQUksSUFBRSxFQUFFLEVBQUVBLEVBQUMsSUFBRSxDQUFDLEdBQUUsSUFBRUEsTUFBRyxJQUFFLEVBQUUsR0FBRSxDQUFDLENBQUMsT0FBSyxLQUFJLEtBQUcsSUFBR0EsTUFBRyxLQUFHLElBQUUsSUFBRSxJQUFFLElBQUUsSUFBRSxFQUFFLEdBQUUsSUFBRSxDQUFDLEdBQUUsS0FBR0EsS0FBRSxNQUFJLEtBQUksS0FBRyxJQUFHLElBQUUsS0FBRyxLQUFHLElBQUUsR0FBRSxJQUFFLEtBQUcsS0FBRyxJQUFFLEtBQUcsS0FBR0EsS0FBRSxJQUFFLEtBQUcsRUFBRSxHQUFFLENBQUMsR0FBRSxLQUFHLE1BQUksSUFBRUEsS0FBRSxFQUFFLEdBQUUsSUFBRSxDQUFDLElBQUUsRUFBRSxHQUFFLENBQUMsR0FBRSxJQUFFLEtBQUksS0FBRyxHQUFFRixHQUFFLElBQUUsQ0FBQyxJQUFFLE1BQUksR0FBRSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7QUFBRTtBQUFDLGVBQUksSUFBRSxLQUFHLElBQUUsR0FBRSxLQUFHLEdBQUUsSUFBRSxHQUFFQSxHQUFFLElBQUUsQ0FBQyxJQUFFLE1BQUksR0FBRSxLQUFHLEdBQUUsS0FBRyxLQUFJLEtBQUc7QUFBRTtBQUFDLFVBQUFBLEdBQUUsSUFBRSxJQUFFLENBQUMsS0FBRyxNQUFJO0FBQUEsUUFBQztBQUFBLE1BQUMsR0FBRSxDQUFDLENBQUMsR0FBRSxJQUFHLENBQUMsU0FBUyxHQUFFRixJQUFFO0FBQUMsUUFBQUEsR0FBRSxVQUFRLGNBQVksT0FBTyxPQUFPLFNBQU8sU0FBU0csSUFBRUgsSUFBRTtBQUFDLFVBQUFBLE9BQUlHLEdBQUUsU0FBT0gsSUFBRUcsR0FBRSxZQUFVLE9BQU8sT0FBT0gsR0FBRSxXQUFVLEVBQUMsYUFBWSxFQUFDLE9B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QVEsS0FBSyxNQUFNO0FBQ3RCLGFBQUssU0FBUyxPQUFPLEtBQUs7QUFDMUIscUJBQWEsS0FBSyxVQUFVLE1BQU07QUFBQSxNQUNuQztBQUFBLElBQ0Q7QUFDQSxXQUFPLGNBQWMsV0FBVztBQUFBLEVBQ2pDO0FBQUEsRUFFQSxXQUFXO0FBQ1YsbUJBQWUsT0FBTyxFQUFFLFFBQVEsQ0FBQ0EsU0FBUTtBQUN4QyxNQUFBQSxLQUFJLFFBQVE7QUFBQSxJQUNiLENBQUM7QUFDRCxpQkFBYSxPQUFPLEVBQUUsUUFBUSxZQUFVO0FBQ3ZDLGFBQU8sUUFBUTtBQUFBLElBQ2hCLENBQUM7QUFDRCxTQUFLLG1CQUFtQixRQUFRO0FBQUEsRUFDakM7QUFBQSxFQUVBLElBQUksU0FBaUI7QUFDcEIsUUFBSSxLQUFLLFNBQVMsT0FBTztBQUN4QixjQUFRLElBQUksT0FBTztBQUFBLElBQ3BCO0FBQUEsRUFDRDtBQUVEOzs7QURoWUEsSUFBTyxlQUFROyIsCiAgIm5hbWVzIjogWyJtb2R1bGUiLCAibW9kdWxlIiwgInNpemUiLCAic2VsZiIsICJtb2R1bGUiLCAiWFhIIiwgImgzMiIsICJtb2R1bGUiLCAibW9kdWxlIiwgIm1vZHVsZSIsICJuIiwgInQiLCAiciIsICJhIiwgImUiLCAibyIsICJkIiwgInMiLCAibCIsICJjIiwgImYiLCAidSIsICJwIiwgImkiLCAiaCIsICJtIiwgImciLCAiXyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNOYU4iLCAibWFwIiwgImNyZWF0ZSIsICJjcmVhdGUiLCAiYXJncyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaXNOYU4iLCAicGFyc2VJbnQiLCAia2V5cyIsICJjcmVhdGUiLCAiY3JlYXRlIiwgImNyZWF0ZSIsICJsZW5ndGgiLCAiYXJncyIsICJsZW5ndGgiLCAibGVuZ3RoIiwgImNyZWF0ZSIsICJmb3JFYWNoIiwgInRleHQiLCAiZm9yRWFjaCIsICJmcmFnbWVudCIsICJjcmVhdGUiLCAiY3JlYXRlIiwgImFyZ3MiLCAiY3JlYXRlIiwgImFyZ3MiLCAic3R5bGUiLCAiY3JlYXRlIiwgImNyZWF0ZU1vZHVsZUxvZ2dlciIsICJkZWwiLCAiaWQiLCAibGVuZ3RoIiwgImkiLCAiY3JlYXRlIiwgInJlc29sdmUiLCAiZG9jIiwgInR5cGUiLCAiaWQiLCAiYW55IiwgImkiLCAiZG9jIiwgInR5cGUiLCAidHlwZSIsICJkb2MiLCAidHlwZSIsICJjcmVhdGUiLCAiaWQiLCAiZG9jIiwgInR5cGUiLCAiY3JlYXRlIiwgInN0cnVjdCIsICJkb2MiLCAidHlwZSIsICJpIiwgImhhc0NvbnRlbnQiLCAiY3JlYXRlIiwgImtleXMiLCAicGF0aCIsICJ0eXBlIiwgInR5cGUiLCAiZG9jIiwgImNyZWF0ZSIsICJsZW5ndGgiLCAibWFwIiwgImxlbmd0aCIsICJjb3VudCIsICJkb2MiLCAidGV4dCIsICJ0eXBlIiwgImVsZW1lbnQiLCAiZnJhZ21lbnQiLCAiY3JlYXRlIiwgImtleXMiLCAiaWQiLCAiaXRlbSIsICJ0ZXh0IiwgImtleXMiLCAidGV4dCIsICJjbVZpZXciLCAiY21TdGF0ZSIsICJpbnNlcnRUZXh0IiwgImNtVmlldyIsICJjbVN0YXRlIiwgImNyZWF0ZSIsICJpZCIsICJjbVN0YXRlIiwgImNtVmlldyIsICJpbXBvcnRfc3RhdGUiLCAicGF0aCIsICJpbXBvcnRfb2JzaWRpYW4iLCAicGF0aCIsICJjcmVhdGUiLCAiZG9jIiwgImRvYyIsICJjcmVhdGUiLCAiZGF0YSIsICJjcmVhdGVNb2R1bGVMb2dnZXIiLCAiZG9jIiwgImFkZCIsICJQZWVyIiwgImVuY29kZXIiLCAiY3JlYXRlIiwgImRhdGEiLCAiaW1wb3J0X29ic2lkaWFuIiwgInBhdGgiLCAiZG9jIiwgImlkIiwgInJlc29sdmUiLCAicGF0aCIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHJhbnNhY3QiLCAiY3JlYXRlIiwgInJlc29sdmUiLCAicmVqZWN0IiwgInRyYW5zYWN0IiwgImRvYyIsICJjcmVhdGUiLCAicmVzb2x2ZSIsICJ0cmFuc2FjdCIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgInJlc29sdmUiLCAia2V5cyIsICJpc0FycmF5IiwgImFyZ3MiLCAiYXNhcCIsICJhbnkiLCAiRGV4aWVFcnJvciIsICJub3AiLCAicmVzb2x2ZSIsICJyZWplY3QiLCAidHlwZSIsICJwcm9wcyIsICJ0cmFucyIsICJQcm9taXNlIiwgImkiLCAiYWRkIiwgIlRhYmxlIiwgImNvdW50IiwgImN0eCIsICJDb2xsZWN0aW9uIiwgImNtcCIsICJsZW5ndGgiLCAiZGlyZWN0aW9uIiwgIm1pbiIsICJtYXgiLCAiYWRkUmFuZ2UiLCAicmFuZ2VzIiwgIldoZXJlQ2xhdXNlIiwgImluZGV4ZWREQiIsICJUcmFuc2FjdGlvbiIsICJwIiwgImRiIiwgInRhYmxlcyIsICJrZXlQYXRoIiwgImNvbXBvdW5kIiwgInJlc3VsdCIsICJyZXEiLCAib3BlbkN1cnNvciIsICJxdWVyeSIsICJldiIsICJoYXNHZXRBbGwiLCAiY3JlYXRlIiwgIklEQktleVJhbmdlIiwgIlZlcnNpb24iLCAiRGV4aWUiLCAiRGVidWcuZGVidWciLCAiRGVidWcuZ2V0RXJyb3JXaXRoU3RhY2siLCAic2FmYXJpMTRXb3JrYXJvdW5kIiwgInByaW1hcnlLZXkiLCAiZHhUcmFucyIsICJSYW5nZVNldCIsICJmcm9tIiwgInRhcmdldCIsICJrZXkiLCAic3Vic2NyaWJlIiwgInN0YXRlIiwgInVuc3Vic2NyaWJlIiwgIk9ic2VydmFibGUiLCAiX0RleGllIiwgIkRlYnVnLnNldERlYnVnIiwgImRvYyIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZXNvbHZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgInJlc29sdmUiLCAiZG9jIiwgImZvbGRlcnMiLCAidGV4dCIsICJkaXYiLCAiaW1wb3J0X29ic2lkaWFuIiwgImRvYyIsICJwYXRoIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgImRvY3VtZW50IiwgImZvbGRlciIsICJkb2MiLCAibG9jYXRpb24iLCAiaWQiLCAicGF0aCIsICJ0ZXh0IiwgInJlc29sdmUiLCAicmVqZWN0IiwgInRhc2siLCAidGV4dCIsICJsZW5ndGgiLCAiYXJncyIsICJ0ZXh0IiwgImxlbmd0aCIsICJkb2MiLCAiZmlsZSIsICJpZCIsICJyZXNvbHZlIiwgImxvY2F0aW9uIiwgInBhdGgiLCAiaWQiLCAic2V0dXBXUyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuIiwgImlkIiwgImltcG9ydF9vYnNpZGlhbiIsICJyZXNvbHZlIiwgImltcG9ydF9vYnNpZGlhbiIsICJ0ZXh0IiwgInJlc29sdmUiLCAibWVzc2FnZVJlY29ubmVjdFRpbWVvdXQiLCAic2V0dXBXUyIsICJpZCIsICJkb2MiLCAiZGF0YSIsICJyZXNvbHZlIiwgInBhdGgiLCAiX2EiLCAiZG9jIiwgImZpbGUiXQp9Cg==
