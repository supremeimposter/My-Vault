---
pdf: 
module: 1
lecture: "2"
date: 2024-03-17T18:18:00
version:
  - COA-24
last-revision: 2024-07-23T16:33:00
notes-taken: true
tags:
  - ComputerOrganizationAndArchitecture/Memory
  - ComputerOrganizationAndArchitecture/SystemBus
---
# Main Memory

- Main memory is equally divided into small units called **cells**.
- Each cell is uniquely identified by a binary number called **address**. Each address is an unsigned binary integer.
- Total number of uniquely identifiable locations in memory is called **address space**.
- Memory chip is also called as memory module or memory bank.
- The standard representation of main memory is,
$$
\text{Number of cells} \times \text{size of each cell (in bits)}
$$
![[Main Memory and Addressability-20240723150605629.webp]]

- The capacity of the cell is decided when manufacturing the chip.
- If there are $k$ cells (or locations or addresses) in the main memory, then minimum $\log_{2}\,k$ bits are required to uniquely identify each cell (or location or address).
- Addresses are not stored physically anywhere in the main memory. Addresses are generated by the CPU and it is decoded by an address decoder.

- A group of $n$-bits is called a **word**, where $n$ is the word length. 
- In CPU's point of view, a word is the unit of data. Word is a property of the CPU.
- Word length is the number of bits processed by the processor in one go.

| Byte Addressable                        | Word Addressable                        |
| --------------------------------------- | --------------------------------------- |
| cell size = 8 bits                      | cell size = word length of CPU          |
| Each byte has an address                | Each word has an address                |
| ![[Main Memory-20240317210126736.webp]] | ![[Main Memory-20240317210135659.webp]] |
| data is stored byte by byte             | data is stored word by word             |

> [!important] 
> - Size of Address (in bits) = Number of Address Lines = Size of MAR register
> - Word length = Number of data lines = Size of MBR register

- Address of a multi-byte object in main memory is the lowest address of all bytes it contains.
- CPU does not care whether the memory is byte or word-addressable. If a CPU is a 32-bit processor (word length is 32 bits), then it processes 32 bits in one go.

> [!NOTE] 
> Memory is byte-addressable by default and it is the best design, since successive addresses represent successive bytes in the main memory.
> When there is no information on whether the memory is word or byte-addressable, byte-addressable is considered, eventhough if there is an information on word length.

````col
```col-md
flexGrow=1.3
===
k-bit addressing means k bits are needed for specifying address of each location uniquely.

p-bit addressable means every p bits has an unique address i.e. word size = p.
```
```col-md
flexGrow=0.7
===
![[Main Memory and Addressability-20240723142017465.webp]]
```
````

> [!convention] 
> Kilo = $2^{10}$
> Mega = $2^{20}$
> Giga = $2^{30}$

## Byte Ordering

- When the memory is byte-addressable and multi-byte primitive data is stored, then byte ordering (Endian-ness) comes into play.
- Endian-ness is a property of CPU (system). The data is stored according to endian-ness only in the main memory.

> [!convention] 
> **Big Endian** - Start with the bigger end (MS byte)
> **Small Endian** - Start with the smaller end (LS byte)
>  
> According to Endian-ness, the most significant byte of the data is the bigger end of the data and the least significant byte of the data is the smaller end of the data.

![[Main Memory-20240318115331778.webp]]

![[Main Memory-20240318101822147.webp]]

- In Big-Endian architecture, the most significant byte of the data is at the lowest memory address and the least significant byte of the data is at the highest memory address in main memory.
- In Little-Endian architecture, the least significant byte of the data is at the lowest memory address and the most significant byte of the data is at the highest memory address in main memory.

> [!NOTE]
> Big-endian architecture is more friednly to human brain.

![[Main Memory-20240720220527440.webp]]

![[Main Memory and Addressability-20240723153850998.webp]]

- In Byte ordering, the data is ordered by **byte** and not by bits. There is no endian-ness in 1-byte data types such as character. They are stored as it is in a single byte.

- Endian-ness property applies only to <mark class="hltr-red">multi-byte primitive</mark> data items. 
- Endian-ness does not apply to derived data types such as strings, arrays or structs. So Endian-ness does not change the order of dervied data type. It only the changes the order of the multi-byte primitive data which are the elements inside the derived data type.

> [!example] 
> Consider an integer array $a$ consisting of 4 integers
> 
> ![[Main Memory-20240720221521455.webp]]
> 
> Consider a character array $c$ consisting of 4 characters (each of 1 byte)
> 
> ![[Main Memory-20240720221818590.webp]]
> 
> Consider a struct consisting of different multi-byte, single byte primitive data types
> 
> ![[Pasted image 20240723152253.png]]


> [!question] Which endian-ness is better[[[Endianness](https://faculty.cs.niu.edu/~hutchins/csci480/endianness.htm)|?]]

Why would we prefer one of these to the other? If we have a 4-byte number already in the CPU (in a register) and we want to add it to a 4-byte number we are fetching from memory, then it is convenient to use the *little-endian* architecture, as we can start the Add operation as soon as the least signficant byte arrives. This speeds up the Add operation by some tiny amount. (Engineers care very much about such tiny improvements.)

On the other hand, if we have a 4-byte number already in the CPU (in a register) and we want to compare it to a 4-byte number we are fetching from memory, then it is convenient to use the *big-endian* architecture, as we can start comparing as soon as the most significant byte arrives. This speeds up the Compare operation by some tiny amount.

There is no general consensus as to which is the superior style of endian-ness.

> [!question] When does Endian-ness matter to a programmer?

In most cases, programmers does not have to care as it is taken care of, but sometimes they have to care.

1. When you store a data as integer and read it later as a character, then endian-ness causes issue.
2. When decoding memory errors.
3. When you transfer data over bit-serial line, on transferring a *single byte* data, which one goes first, most significant bit or least significant bit.
4. When you share data and files between different computers, it can result in mis-interpretation.

> [!summary] 
> ![[Main Memory and Addressability-20240723152518960.webp]]

---
